// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.5.1
// - protoc             (unknown)
// source: rill/runtime/v1/api.proto

package runtimev1

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	RuntimeService_Ping_FullMethodName                    = "/rill.runtime.v1.RuntimeService/Ping"
	RuntimeService_Health_FullMethodName                  = "/rill.runtime.v1.RuntimeService/Health"
	RuntimeService_InstanceHealth_FullMethodName          = "/rill.runtime.v1.RuntimeService/InstanceHealth"
	RuntimeService_ListInstances_FullMethodName           = "/rill.runtime.v1.RuntimeService/ListInstances"
	RuntimeService_GetInstance_FullMethodName             = "/rill.runtime.v1.RuntimeService/GetInstance"
	RuntimeService_CreateInstance_FullMethodName          = "/rill.runtime.v1.RuntimeService/CreateInstance"
	RuntimeService_EditInstance_FullMethodName            = "/rill.runtime.v1.RuntimeService/EditInstance"
	RuntimeService_DeleteInstance_FullMethodName          = "/rill.runtime.v1.RuntimeService/DeleteInstance"
	RuntimeService_ReloadConfig_FullMethodName            = "/rill.runtime.v1.RuntimeService/ReloadConfig"
	RuntimeService_ListFiles_FullMethodName               = "/rill.runtime.v1.RuntimeService/ListFiles"
	RuntimeService_WatchFiles_FullMethodName              = "/rill.runtime.v1.RuntimeService/WatchFiles"
	RuntimeService_GetFile_FullMethodName                 = "/rill.runtime.v1.RuntimeService/GetFile"
	RuntimeService_PutFile_FullMethodName                 = "/rill.runtime.v1.RuntimeService/PutFile"
	RuntimeService_CreateDirectory_FullMethodName         = "/rill.runtime.v1.RuntimeService/CreateDirectory"
	RuntimeService_DeleteFile_FullMethodName              = "/rill.runtime.v1.RuntimeService/DeleteFile"
	RuntimeService_RenameFile_FullMethodName              = "/rill.runtime.v1.RuntimeService/RenameFile"
	RuntimeService_ListExamples_FullMethodName            = "/rill.runtime.v1.RuntimeService/ListExamples"
	RuntimeService_UnpackExample_FullMethodName           = "/rill.runtime.v1.RuntimeService/UnpackExample"
	RuntimeService_UnpackEmpty_FullMethodName             = "/rill.runtime.v1.RuntimeService/UnpackEmpty"
	RuntimeService_GenerateMetricsViewFile_FullMethodName = "/rill.runtime.v1.RuntimeService/GenerateMetricsViewFile"
	RuntimeService_GenerateCanvasFile_FullMethodName      = "/rill.runtime.v1.RuntimeService/GenerateCanvasFile"
	RuntimeService_GenerateResolver_FullMethodName        = "/rill.runtime.v1.RuntimeService/GenerateResolver"
	RuntimeService_GenerateRenderer_FullMethodName        = "/rill.runtime.v1.RuntimeService/GenerateRenderer"
	RuntimeService_QueryResolver_FullMethodName           = "/rill.runtime.v1.RuntimeService/QueryResolver"
	RuntimeService_GetLogs_FullMethodName                 = "/rill.runtime.v1.RuntimeService/GetLogs"
	RuntimeService_WatchLogs_FullMethodName               = "/rill.runtime.v1.RuntimeService/WatchLogs"
	RuntimeService_ListResources_FullMethodName           = "/rill.runtime.v1.RuntimeService/ListResources"
	RuntimeService_WatchResources_FullMethodName          = "/rill.runtime.v1.RuntimeService/WatchResources"
	RuntimeService_GetResource_FullMethodName             = "/rill.runtime.v1.RuntimeService/GetResource"
	RuntimeService_GetExplore_FullMethodName              = "/rill.runtime.v1.RuntimeService/GetExplore"
	RuntimeService_GetModelPartitions_FullMethodName      = "/rill.runtime.v1.RuntimeService/GetModelPartitions"
	RuntimeService_CreateTrigger_FullMethodName           = "/rill.runtime.v1.RuntimeService/CreateTrigger"
	RuntimeService_ListConnectorDrivers_FullMethodName    = "/rill.runtime.v1.RuntimeService/ListConnectorDrivers"
	RuntimeService_AnalyzeConnectors_FullMethodName       = "/rill.runtime.v1.RuntimeService/AnalyzeConnectors"
	RuntimeService_ListNotifierConnectors_FullMethodName  = "/rill.runtime.v1.RuntimeService/ListNotifierConnectors"
	RuntimeService_ListConversations_FullMethodName       = "/rill.runtime.v1.RuntimeService/ListConversations"
	RuntimeService_GetConversation_FullMethodName         = "/rill.runtime.v1.RuntimeService/GetConversation"
	RuntimeService_ShareConversation_FullMethodName       = "/rill.runtime.v1.RuntimeService/ShareConversation"
	RuntimeService_ForkConversation_FullMethodName        = "/rill.runtime.v1.RuntimeService/ForkConversation"
	RuntimeService_ListTools_FullMethodName               = "/rill.runtime.v1.RuntimeService/ListTools"
	RuntimeService_Complete_FullMethodName                = "/rill.runtime.v1.RuntimeService/Complete"
	RuntimeService_CompleteStreaming_FullMethodName       = "/rill.runtime.v1.RuntimeService/CompleteStreaming"
	RuntimeService_IssueDevJWT_FullMethodName             = "/rill.runtime.v1.RuntimeService/IssueDevJWT"
	RuntimeService_AnalyzeVariables_FullMethodName        = "/rill.runtime.v1.RuntimeService/AnalyzeVariables"
	RuntimeService_ListGitCommits_FullMethodName          = "/rill.runtime.v1.RuntimeService/ListGitCommits"
	RuntimeService_GitStatus_FullMethodName               = "/rill.runtime.v1.RuntimeService/GitStatus"
	RuntimeService_ListGitBranches_FullMethodName         = "/rill.runtime.v1.RuntimeService/ListGitBranches"
	RuntimeService_GitCommit_FullMethodName               = "/rill.runtime.v1.RuntimeService/GitCommit"
	RuntimeService_RestoreGitCommit_FullMethodName        = "/rill.runtime.v1.RuntimeService/RestoreGitCommit"
	RuntimeService_GitMergeToBranch_FullMethodName        = "/rill.runtime.v1.RuntimeService/GitMergeToBranch"
	RuntimeService_GitSwitchBranch_FullMethodName         = "/rill.runtime.v1.RuntimeService/GitSwitchBranch"
	RuntimeService_GitPull_FullMethodName                 = "/rill.runtime.v1.RuntimeService/GitPull"
	RuntimeService_GitPush_FullMethodName                 = "/rill.runtime.v1.RuntimeService/GitPush"
	RuntimeService_PullEnv_FullMethodName                 = "/rill.runtime.v1.RuntimeService/PullEnv"
	RuntimeService_PushEnv_FullMethodName                 = "/rill.runtime.v1.RuntimeService/PushEnv"
)

// RuntimeServiceClient is the client API for RuntimeService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// RuntimeService is a data infrastructure proxy and orchestrator based on Rill SQL.
// It has a concept of instances, which are fully isolated data projects, enabling optional multi-tenancy.
type RuntimeServiceClient interface {
	// Ping returns information about the runtime
	Ping(ctx context.Context, in *PingRequest, opts ...grpc.CallOption) (*PingResponse, error)
	// Health runs a health check on the runtime.
	Health(ctx context.Context, in *HealthRequest, opts ...grpc.CallOption) (*HealthResponse, error)
	// InstanceHealth runs a health check on a specific instance.
	InstanceHealth(ctx context.Context, in *InstanceHealthRequest, opts ...grpc.CallOption) (*InstanceHealthResponse, error)
	// ListInstances lists all the instances currently managed by the runtime
	ListInstances(ctx context.Context, in *ListInstancesRequest, opts ...grpc.CallOption) (*ListInstancesResponse, error)
	// GetInstance returns information about a specific instance
	GetInstance(ctx context.Context, in *GetInstanceRequest, opts ...grpc.CallOption) (*GetInstanceResponse, error)
	// CreateInstance creates a new instance
	CreateInstance(ctx context.Context, in *CreateInstanceRequest, opts ...grpc.CallOption) (*CreateInstanceResponse, error)
	// EditInstance edits an existing instance
	EditInstance(ctx context.Context, in *EditInstanceRequest, opts ...grpc.CallOption) (*EditInstanceResponse, error)
	// DeleteInstance deletes an instance
	DeleteInstance(ctx context.Context, in *DeleteInstanceRequest, opts ...grpc.CallOption) (*DeleteInstanceResponse, error)
	// ReloadConfig pulls the latest configuration from the admin service and triggers a repo pull.
	// If the instance doesn't have an admin connector, this RPC does nothing.
	ReloadConfig(ctx context.Context, in *ReloadConfigRequest, opts ...grpc.CallOption) (*ReloadConfigResponse, error)
	// ListFiles lists all the files matching a glob in a repo.
	// The files are sorted by their full path.
	ListFiles(ctx context.Context, in *ListFilesRequest, opts ...grpc.CallOption) (*ListFilesResponse, error)
	// WatchFiles streams repo file update events. It is not supported on all backends.
	WatchFiles(ctx context.Context, in *WatchFilesRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[WatchFilesResponse], error)
	// GetFile returns the contents of a specific file in a repo.
	GetFile(ctx context.Context, in *GetFileRequest, opts ...grpc.CallOption) (*GetFileResponse, error)
	// PutFile creates or updates a file in a repo
	PutFile(ctx context.Context, in *PutFileRequest, opts ...grpc.CallOption) (*PutFileResponse, error)
	// CreateDirectory create a directory for the given path
	CreateDirectory(ctx context.Context, in *CreateDirectoryRequest, opts ...grpc.CallOption) (*CreateDirectoryResponse, error)
	// DeleteFile deletes a file from a repo
	DeleteFile(ctx context.Context, in *DeleteFileRequest, opts ...grpc.CallOption) (*DeleteFileResponse, error)
	// RenameFile renames a file in a repo
	RenameFile(ctx context.Context, in *RenameFileRequest, opts ...grpc.CallOption) (*RenameFileResponse, error)
	// ListExamples lists all the examples embedded into binary
	ListExamples(ctx context.Context, in *ListExamplesRequest, opts ...grpc.CallOption) (*ListExamplesResponse, error)
	// UnpackExample unpacks an example project
	UnpackExample(ctx context.Context, in *UnpackExampleRequest, opts ...grpc.CallOption) (*UnpackExampleResponse, error)
	// UnpackEmpty unpacks an empty project
	UnpackEmpty(ctx context.Context, in *UnpackEmptyRequest, opts ...grpc.CallOption) (*UnpackEmptyResponse, error)
	// GenerateMetricsViewFile generates a metrics view YAML file from a table in an OLAP database
	GenerateMetricsViewFile(ctx context.Context, in *GenerateMetricsViewFileRequest, opts ...grpc.CallOption) (*GenerateMetricsViewFileResponse, error)
	// GenerateCanvasFile generates a canvas YAML file from a metrics view
	GenerateCanvasFile(ctx context.Context, in *GenerateCanvasFileRequest, opts ...grpc.CallOption) (*GenerateCanvasFileResponse, error)
	// GenerateResolver generates resolver and resolver properties from a table or a metrics view
	GenerateResolver(ctx context.Context, in *GenerateResolverRequest, opts ...grpc.CallOption) (*GenerateResolverResponse, error)
	// GenerateRenderer generates a component renderer and renderer properties from a resolver and resolver properties
	GenerateRenderer(ctx context.Context, in *GenerateRendererRequest, opts ...grpc.CallOption) (*GenerateRendererResponse, error)
	// QueryResolver queries a resolver with the given properties and arguments
	QueryResolver(ctx context.Context, in *QueryResolverRequest, opts ...grpc.CallOption) (*QueryResolverResponse, error)
	// GetLogs returns recent logs from a controller
	GetLogs(ctx context.Context, in *GetLogsRequest, opts ...grpc.CallOption) (*GetLogsResponse, error)
	// WatchLogs streams new logs emitted from a controller
	WatchLogs(ctx context.Context, in *WatchLogsRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[WatchLogsResponse], error)
	// ListResources lists the resources stored in the catalog
	ListResources(ctx context.Context, in *ListResourcesRequest, opts ...grpc.CallOption) (*ListResourcesResponse, error)
	// WatchResources streams updates to catalog resources (including creation and deletion events)
	WatchResources(ctx context.Context, in *WatchResourcesRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[WatchResourcesResponse], error)
	// GetResource looks up a specific catalog resource
	GetResource(ctx context.Context, in *GetResourceRequest, opts ...grpc.CallOption) (*GetResourceResponse, error)
	// GetExplore is a convenience RPC that combines looking up an Explore resource and its underlying MetricsView into one network call.
	GetExplore(ctx context.Context, in *GetExploreRequest, opts ...grpc.CallOption) (*GetExploreResponse, error)
	// GetModelPartitions returns the partitions of a model
	GetModelPartitions(ctx context.Context, in *GetModelPartitionsRequest, opts ...grpc.CallOption) (*GetModelPartitionsResponse, error)
	// CreateTrigger submits a refresh trigger, which will asynchronously refresh the specified resources.
	// Triggers are ephemeral resources that will be cleaned up by the controller.
	CreateTrigger(ctx context.Context, in *CreateTriggerRequest, opts ...grpc.CallOption) (*CreateTriggerResponse, error)
	// ListConnectorDrivers returns a description of all the connector drivers registed in the runtime,
	// including their configuration specs and the capabilities they support.
	ListConnectorDrivers(ctx context.Context, in *ListConnectorDriversRequest, opts ...grpc.CallOption) (*ListConnectorDriversResponse, error)
	// AnalyzeConnectors scans all the project files and returns information about all referenced connectors.
	AnalyzeConnectors(ctx context.Context, in *AnalyzeConnectorsRequest, opts ...grpc.CallOption) (*AnalyzeConnectorsResponse, error)
	// ListNotifierConnectors returns the names of all configured connectors that can be used as notifiers.
	// This API is much faster than AnalyzeConnectors and can be called without admin-level permissions.
	ListNotifierConnectors(ctx context.Context, in *ListNotifierConnectorsRequest, opts ...grpc.CallOption) (*ListNotifierConnectorsResponse, error)
	// ListConversations lists all AI chat conversations for an instance.
	ListConversations(ctx context.Context, in *ListConversationsRequest, opts ...grpc.CallOption) (*ListConversationsResponse, error)
	// GetConversation returns a specific AI chat conversation.
	GetConversation(ctx context.Context, in *GetConversationRequest, opts ...grpc.CallOption) (*GetConversationResponse, error)
	// ShareConversation enables sharing of the conversation by adding metadata.
	ShareConversation(ctx context.Context, in *ShareConversationRequest, opts ...grpc.CallOption) (*ShareConversationResponse, error)
	// ForkConversation creates a new conversation by copying messages from an existing one.
	// If its the owner then all messages will be copied, otherwise only messages up to the session.SharedUntilMessageID are copied.
	ForkConversation(ctx context.Context, in *ForkConversationRequest, opts ...grpc.CallOption) (*ForkConversationResponse, error)
	// ListTools lists metadata about all AI tools that calls to Complete(Streaming) may invoke.
	// Note that it covers all registered tools, but the current user may not have access to all of them.
	ListTools(ctx context.Context, in *ListToolsRequest, opts ...grpc.CallOption) (*ListToolsResponse, error)
	// Complete runs a language model completion (LLM chat) using the configured AI connector.
	Complete(ctx context.Context, in *CompleteRequest, opts ...grpc.CallOption) (*CompleteResponse, error)
	// CompleteStreaming runs an AI-powered chat completion, optionally invoking agents or tool calls available in Rill.
	CompleteStreaming(ctx context.Context, in *CompleteStreamingRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[CompleteStreamingResponse], error)
	// IssueDevJWT issues a JWT for mimicking a user in local development.
	IssueDevJWT(ctx context.Context, in *IssueDevJWTRequest, opts ...grpc.CallOption) (*IssueDevJWTResponse, error)
	// AnalyzeVariables scans `Source`, `Model` and `Connector` resources in the catalog for use of an environment variable
	AnalyzeVariables(ctx context.Context, in *AnalyzeVariablesRequest, opts ...grpc.CallOption) (*AnalyzeVariablesResponse, error)
	ListGitCommits(ctx context.Context, in *ListGitCommitsRequest, opts ...grpc.CallOption) (*ListGitCommitsResponse, error)
	// GitStatus returns the current status of the local git repo. This is equivalent to doing a `git fetch` followed by running `git status`.
	GitStatus(ctx context.Context, in *GitStatusRequest, opts ...grpc.CallOption) (*GitStatusResponse, error)
	ListGitBranches(ctx context.Context, in *ListGitBranchesRequest, opts ...grpc.CallOption) (*ListGitBranchesResponse, error)
	// GitCommit commits the local changes to the git repo equivalent to `git commit -am <message>` command.
	GitCommit(ctx context.Context, in *GitCommitRequest, opts ...grpc.CallOption) (*GitCommitResponse, error)
	// RestoreGitCommit creates a new commit that restores the state of the repo to the specified commit SHA.
	// This effectively discards all the changes made after the specified commit.
	RestoreGitCommit(ctx context.Context, in *RestoreGitCommitRequest, opts ...grpc.CallOption) (*RestoreGitCommitResponse, error)
	// GitMergeToBranch merges current branch to the specified branch.
	// Note: this is not the same as `git merge <branch>`, but rather `git checkout <branch>` followed by `git merge <current-branch>`.
	// It restores back to the original branch after the merge.
	GitMergeToBranch(ctx context.Context, in *GitMergeToBranchRequest, opts ...grpc.CallOption) (*GitMergeToBranchResponse, error)
	GitSwitchBranch(ctx context.Context, in *GitSwitchBranchRequest, opts ...grpc.CallOption) (*GitSwitchBranchResponse, error)
	// GitPull fetches the latest changes from the remote git repo equivalent to `git pull` command.
	// If there are any merge conflicts the pull is aborted.
	// Force can be set to true to force the pull and overwrite any local changes.
	GitPull(ctx context.Context, in *GitPullRequest, opts ...grpc.CallOption) (*GitPullResponse, error)
	// GitPush pushes the local changes to the remote git repo equivalent to `git push` command.
	// It only pushes the changes to the existing remote repo.
	GitPush(ctx context.Context, in *GitPushRequest, opts ...grpc.CallOption) (*GitPushResponse, error)
	// PullEnv pulls environment variables from cloud to local .env file
	PullEnv(ctx context.Context, in *PullEnvRequest, opts ...grpc.CallOption) (*PullEnvResponse, error)
	// PushEnv pushes local environment variables to cloud
	PushEnv(ctx context.Context, in *PushEnvRequest, opts ...grpc.CallOption) (*PushEnvResponse, error)
}

type runtimeServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewRuntimeServiceClient(cc grpc.ClientConnInterface) RuntimeServiceClient {
	return &runtimeServiceClient{cc}
}

func (c *runtimeServiceClient) Ping(ctx context.Context, in *PingRequest, opts ...grpc.CallOption) (*PingResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(PingResponse)
	err := c.cc.Invoke(ctx, RuntimeService_Ping_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *runtimeServiceClient) Health(ctx context.Context, in *HealthRequest, opts ...grpc.CallOption) (*HealthResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(HealthResponse)
	err := c.cc.Invoke(ctx, RuntimeService_Health_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *runtimeServiceClient) InstanceHealth(ctx context.Context, in *InstanceHealthRequest, opts ...grpc.CallOption) (*InstanceHealthResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(InstanceHealthResponse)
	err := c.cc.Invoke(ctx, RuntimeService_InstanceHealth_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *runtimeServiceClient) ListInstances(ctx context.Context, in *ListInstancesRequest, opts ...grpc.CallOption) (*ListInstancesResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListInstancesResponse)
	err := c.cc.Invoke(ctx, RuntimeService_ListInstances_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *runtimeServiceClient) GetInstance(ctx context.Context, in *GetInstanceRequest, opts ...grpc.CallOption) (*GetInstanceResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetInstanceResponse)
	err := c.cc.Invoke(ctx, RuntimeService_GetInstance_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *runtimeServiceClient) CreateInstance(ctx context.Context, in *CreateInstanceRequest, opts ...grpc.CallOption) (*CreateInstanceResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CreateInstanceResponse)
	err := c.cc.Invoke(ctx, RuntimeService_CreateInstance_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *runtimeServiceClient) EditInstance(ctx context.Context, in *EditInstanceRequest, opts ...grpc.CallOption) (*EditInstanceResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(EditInstanceResponse)
	err := c.cc.Invoke(ctx, RuntimeService_EditInstance_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *runtimeServiceClient) DeleteInstance(ctx context.Context, in *DeleteInstanceRequest, opts ...grpc.CallOption) (*DeleteInstanceResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DeleteInstanceResponse)
	err := c.cc.Invoke(ctx, RuntimeService_DeleteInstance_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *runtimeServiceClient) ReloadConfig(ctx context.Context, in *ReloadConfigRequest, opts ...grpc.CallOption) (*ReloadConfigResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ReloadConfigResponse)
	err := c.cc.Invoke(ctx, RuntimeService_ReloadConfig_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *runtimeServiceClient) ListFiles(ctx context.Context, in *ListFilesRequest, opts ...grpc.CallOption) (*ListFilesResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListFilesResponse)
	err := c.cc.Invoke(ctx, RuntimeService_ListFiles_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *runtimeServiceClient) WatchFiles(ctx context.Context, in *WatchFilesRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[WatchFilesResponse], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &RuntimeService_ServiceDesc.Streams[0], RuntimeService_WatchFiles_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[WatchFilesRequest, WatchFilesResponse]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type RuntimeService_WatchFilesClient = grpc.ServerStreamingClient[WatchFilesResponse]

func (c *runtimeServiceClient) GetFile(ctx context.Context, in *GetFileRequest, opts ...grpc.CallOption) (*GetFileResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetFileResponse)
	err := c.cc.Invoke(ctx, RuntimeService_GetFile_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *runtimeServiceClient) PutFile(ctx context.Context, in *PutFileRequest, opts ...grpc.CallOption) (*PutFileResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(PutFileResponse)
	err := c.cc.Invoke(ctx, RuntimeService_PutFile_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *runtimeServiceClient) CreateDirectory(ctx context.Context, in *CreateDirectoryRequest, opts ...grpc.CallOption) (*CreateDirectoryResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CreateDirectoryResponse)
	err := c.cc.Invoke(ctx, RuntimeService_CreateDirectory_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *runtimeServiceClient) DeleteFile(ctx context.Context, in *DeleteFileRequest, opts ...grpc.CallOption) (*DeleteFileResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DeleteFileResponse)
	err := c.cc.Invoke(ctx, RuntimeService_DeleteFile_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *runtimeServiceClient) RenameFile(ctx context.Context, in *RenameFileRequest, opts ...grpc.CallOption) (*RenameFileResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RenameFileResponse)
	err := c.cc.Invoke(ctx, RuntimeService_RenameFile_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *runtimeServiceClient) ListExamples(ctx context.Context, in *ListExamplesRequest, opts ...grpc.CallOption) (*ListExamplesResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListExamplesResponse)
	err := c.cc.Invoke(ctx, RuntimeService_ListExamples_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *runtimeServiceClient) UnpackExample(ctx context.Context, in *UnpackExampleRequest, opts ...grpc.CallOption) (*UnpackExampleResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UnpackExampleResponse)
	err := c.cc.Invoke(ctx, RuntimeService_UnpackExample_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *runtimeServiceClient) UnpackEmpty(ctx context.Context, in *UnpackEmptyRequest, opts ...grpc.CallOption) (*UnpackEmptyResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UnpackEmptyResponse)
	err := c.cc.Invoke(ctx, RuntimeService_UnpackEmpty_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *runtimeServiceClient) GenerateMetricsViewFile(ctx context.Context, in *GenerateMetricsViewFileRequest, opts ...grpc.CallOption) (*GenerateMetricsViewFileResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GenerateMetricsViewFileResponse)
	err := c.cc.Invoke(ctx, RuntimeService_GenerateMetricsViewFile_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *runtimeServiceClient) GenerateCanvasFile(ctx context.Context, in *GenerateCanvasFileRequest, opts ...grpc.CallOption) (*GenerateCanvasFileResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GenerateCanvasFileResponse)
	err := c.cc.Invoke(ctx, RuntimeService_GenerateCanvasFile_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *runtimeServiceClient) GenerateResolver(ctx context.Context, in *GenerateResolverRequest, opts ...grpc.CallOption) (*GenerateResolverResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GenerateResolverResponse)
	err := c.cc.Invoke(ctx, RuntimeService_GenerateResolver_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *runtimeServiceClient) GenerateRenderer(ctx context.Context, in *GenerateRendererRequest, opts ...grpc.CallOption) (*GenerateRendererResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GenerateRendererResponse)
	err := c.cc.Invoke(ctx, RuntimeService_GenerateRenderer_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *runtimeServiceClient) QueryResolver(ctx context.Context, in *QueryResolverRequest, opts ...grpc.CallOption) (*QueryResolverResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(QueryResolverResponse)
	err := c.cc.Invoke(ctx, RuntimeService_QueryResolver_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *runtimeServiceClient) GetLogs(ctx context.Context, in *GetLogsRequest, opts ...grpc.CallOption) (*GetLogsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetLogsResponse)
	err := c.cc.Invoke(ctx, RuntimeService_GetLogs_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *runtimeServiceClient) WatchLogs(ctx context.Context, in *WatchLogsRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[WatchLogsResponse], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &RuntimeService_ServiceDesc.Streams[1], RuntimeService_WatchLogs_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[WatchLogsRequest, WatchLogsResponse]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type RuntimeService_WatchLogsClient = grpc.ServerStreamingClient[WatchLogsResponse]

func (c *runtimeServiceClient) ListResources(ctx context.Context, in *ListResourcesRequest, opts ...grpc.CallOption) (*ListResourcesResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListResourcesResponse)
	err := c.cc.Invoke(ctx, RuntimeService_ListResources_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *runtimeServiceClient) WatchResources(ctx context.Context, in *WatchResourcesRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[WatchResourcesResponse], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &RuntimeService_ServiceDesc.Streams[2], RuntimeService_WatchResources_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[WatchResourcesRequest, WatchResourcesResponse]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type RuntimeService_WatchResourcesClient = grpc.ServerStreamingClient[WatchResourcesResponse]

func (c *runtimeServiceClient) GetResource(ctx context.Context, in *GetResourceRequest, opts ...grpc.CallOption) (*GetResourceResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetResourceResponse)
	err := c.cc.Invoke(ctx, RuntimeService_GetResource_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *runtimeServiceClient) GetExplore(ctx context.Context, in *GetExploreRequest, opts ...grpc.CallOption) (*GetExploreResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetExploreResponse)
	err := c.cc.Invoke(ctx, RuntimeService_GetExplore_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *runtimeServiceClient) GetModelPartitions(ctx context.Context, in *GetModelPartitionsRequest, opts ...grpc.CallOption) (*GetModelPartitionsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetModelPartitionsResponse)
	err := c.cc.Invoke(ctx, RuntimeService_GetModelPartitions_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *runtimeServiceClient) CreateTrigger(ctx context.Context, in *CreateTriggerRequest, opts ...grpc.CallOption) (*CreateTriggerResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CreateTriggerResponse)
	err := c.cc.Invoke(ctx, RuntimeService_CreateTrigger_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *runtimeServiceClient) ListConnectorDrivers(ctx context.Context, in *ListConnectorDriversRequest, opts ...grpc.CallOption) (*ListConnectorDriversResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListConnectorDriversResponse)
	err := c.cc.Invoke(ctx, RuntimeService_ListConnectorDrivers_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *runtimeServiceClient) AnalyzeConnectors(ctx context.Context, in *AnalyzeConnectorsRequest, opts ...grpc.CallOption) (*AnalyzeConnectorsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(AnalyzeConnectorsResponse)
	err := c.cc.Invoke(ctx, RuntimeService_AnalyzeConnectors_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *runtimeServiceClient) ListNotifierConnectors(ctx context.Context, in *ListNotifierConnectorsRequest, opts ...grpc.CallOption) (*ListNotifierConnectorsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListNotifierConnectorsResponse)
	err := c.cc.Invoke(ctx, RuntimeService_ListNotifierConnectors_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *runtimeServiceClient) ListConversations(ctx context.Context, in *ListConversationsRequest, opts ...grpc.CallOption) (*ListConversationsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListConversationsResponse)
	err := c.cc.Invoke(ctx, RuntimeService_ListConversations_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *runtimeServiceClient) GetConversation(ctx context.Context, in *GetConversationRequest, opts ...grpc.CallOption) (*GetConversationResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetConversationResponse)
	err := c.cc.Invoke(ctx, RuntimeService_GetConversation_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *runtimeServiceClient) ShareConversation(ctx context.Context, in *ShareConversationRequest, opts ...grpc.CallOption) (*ShareConversationResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ShareConversationResponse)
	err := c.cc.Invoke(ctx, RuntimeService_ShareConversation_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *runtimeServiceClient) ForkConversation(ctx context.Context, in *ForkConversationRequest, opts ...grpc.CallOption) (*ForkConversationResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ForkConversationResponse)
	err := c.cc.Invoke(ctx, RuntimeService_ForkConversation_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *runtimeServiceClient) ListTools(ctx context.Context, in *ListToolsRequest, opts ...grpc.CallOption) (*ListToolsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListToolsResponse)
	err := c.cc.Invoke(ctx, RuntimeService_ListTools_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *runtimeServiceClient) Complete(ctx context.Context, in *CompleteRequest, opts ...grpc.CallOption) (*CompleteResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CompleteResponse)
	err := c.cc.Invoke(ctx, RuntimeService_Complete_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *runtimeServiceClient) CompleteStreaming(ctx context.Context, in *CompleteStreamingRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[CompleteStreamingResponse], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &RuntimeService_ServiceDesc.Streams[3], RuntimeService_CompleteStreaming_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[CompleteStreamingRequest, CompleteStreamingResponse]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type RuntimeService_CompleteStreamingClient = grpc.ServerStreamingClient[CompleteStreamingResponse]

func (c *runtimeServiceClient) IssueDevJWT(ctx context.Context, in *IssueDevJWTRequest, opts ...grpc.CallOption) (*IssueDevJWTResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(IssueDevJWTResponse)
	err := c.cc.Invoke(ctx, RuntimeService_IssueDevJWT_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *runtimeServiceClient) AnalyzeVariables(ctx context.Context, in *AnalyzeVariablesRequest, opts ...grpc.CallOption) (*AnalyzeVariablesResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(AnalyzeVariablesResponse)
	err := c.cc.Invoke(ctx, RuntimeService_AnalyzeVariables_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *runtimeServiceClient) ListGitCommits(ctx context.Context, in *ListGitCommitsRequest, opts ...grpc.CallOption) (*ListGitCommitsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListGitCommitsResponse)
	err := c.cc.Invoke(ctx, RuntimeService_ListGitCommits_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *runtimeServiceClient) GitStatus(ctx context.Context, in *GitStatusRequest, opts ...grpc.CallOption) (*GitStatusResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GitStatusResponse)
	err := c.cc.Invoke(ctx, RuntimeService_GitStatus_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *runtimeServiceClient) ListGitBranches(ctx context.Context, in *ListGitBranchesRequest, opts ...grpc.CallOption) (*ListGitBranchesResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListGitBranchesResponse)
	err := c.cc.Invoke(ctx, RuntimeService_ListGitBranches_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *runtimeServiceClient) GitCommit(ctx context.Context, in *GitCommitRequest, opts ...grpc.CallOption) (*GitCommitResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GitCommitResponse)
	err := c.cc.Invoke(ctx, RuntimeService_GitCommit_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *runtimeServiceClient) RestoreGitCommit(ctx context.Context, in *RestoreGitCommitRequest, opts ...grpc.CallOption) (*RestoreGitCommitResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RestoreGitCommitResponse)
	err := c.cc.Invoke(ctx, RuntimeService_RestoreGitCommit_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *runtimeServiceClient) GitMergeToBranch(ctx context.Context, in *GitMergeToBranchRequest, opts ...grpc.CallOption) (*GitMergeToBranchResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GitMergeToBranchResponse)
	err := c.cc.Invoke(ctx, RuntimeService_GitMergeToBranch_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *runtimeServiceClient) GitSwitchBranch(ctx context.Context, in *GitSwitchBranchRequest, opts ...grpc.CallOption) (*GitSwitchBranchResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GitSwitchBranchResponse)
	err := c.cc.Invoke(ctx, RuntimeService_GitSwitchBranch_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *runtimeServiceClient) GitPull(ctx context.Context, in *GitPullRequest, opts ...grpc.CallOption) (*GitPullResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GitPullResponse)
	err := c.cc.Invoke(ctx, RuntimeService_GitPull_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *runtimeServiceClient) GitPush(ctx context.Context, in *GitPushRequest, opts ...grpc.CallOption) (*GitPushResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GitPushResponse)
	err := c.cc.Invoke(ctx, RuntimeService_GitPush_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *runtimeServiceClient) PullEnv(ctx context.Context, in *PullEnvRequest, opts ...grpc.CallOption) (*PullEnvResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(PullEnvResponse)
	err := c.cc.Invoke(ctx, RuntimeService_PullEnv_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *runtimeServiceClient) PushEnv(ctx context.Context, in *PushEnvRequest, opts ...grpc.CallOption) (*PushEnvResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(PushEnvResponse)
	err := c.cc.Invoke(ctx, RuntimeService_PushEnv_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// RuntimeServiceServer is the server API for RuntimeService service.
// All implementations must embed UnimplementedRuntimeServiceServer
// for forward compatibility.
//
// RuntimeService is a data infrastructure proxy and orchestrator based on Rill SQL.
// It has a concept of instances, which are fully isolated data projects, enabling optional multi-tenancy.
type RuntimeServiceServer interface {
	// Ping returns information about the runtime
	Ping(context.Context, *PingRequest) (*PingResponse, error)
	// Health runs a health check on the runtime.
	Health(context.Context, *HealthRequest) (*HealthResponse, error)
	// InstanceHealth runs a health check on a specific instance.
	InstanceHealth(context.Context, *InstanceHealthRequest) (*InstanceHealthResponse, error)
	// ListInstances lists all the instances currently managed by the runtime
	ListInstances(context.Context, *ListInstancesRequest) (*ListInstancesResponse, error)
	// GetInstance returns information about a specific instance
	GetInstance(context.Context, *GetInstanceRequest) (*GetInstanceResponse, error)
	// CreateInstance creates a new instance
	CreateInstance(context.Context, *CreateInstanceRequest) (*CreateInstanceResponse, error)
	// EditInstance edits an existing instance
	EditInstance(context.Context, *EditInstanceRequest) (*EditInstanceResponse, error)
	// DeleteInstance deletes an instance
	DeleteInstance(context.Context, *DeleteInstanceRequest) (*DeleteInstanceResponse, error)
	// ReloadConfig pulls the latest configuration from the admin service and triggers a repo pull.
	// If the instance doesn't have an admin connector, this RPC does nothing.
	ReloadConfig(context.Context, *ReloadConfigRequest) (*ReloadConfigResponse, error)
	// ListFiles lists all the files matching a glob in a repo.
	// The files are sorted by their full path.
	ListFiles(context.Context, *ListFilesRequest) (*ListFilesResponse, error)
	// WatchFiles streams repo file update events. It is not supported on all backends.
	WatchFiles(*WatchFilesRequest, grpc.ServerStreamingServer[WatchFilesResponse]) error
	// GetFile returns the contents of a specific file in a repo.
	GetFile(context.Context, *GetFileRequest) (*GetFileResponse, error)
	// PutFile creates or updates a file in a repo
	PutFile(context.Context, *PutFileRequest) (*PutFileResponse, error)
	// CreateDirectory create a directory for the given path
	CreateDirectory(context.Context, *CreateDirectoryRequest) (*CreateDirectoryResponse, error)
	// DeleteFile deletes a file from a repo
	DeleteFile(context.Context, *DeleteFileRequest) (*DeleteFileResponse, error)
	// RenameFile renames a file in a repo
	RenameFile(context.Context, *RenameFileRequest) (*RenameFileResponse, error)
	// ListExamples lists all the examples embedded into binary
	ListExamples(context.Context, *ListExamplesRequest) (*ListExamplesResponse, error)
	// UnpackExample unpacks an example project
	UnpackExample(context.Context, *UnpackExampleRequest) (*UnpackExampleResponse, error)
	// UnpackEmpty unpacks an empty project
	UnpackEmpty(context.Context, *UnpackEmptyRequest) (*UnpackEmptyResponse, error)
	// GenerateMetricsViewFile generates a metrics view YAML file from a table in an OLAP database
	GenerateMetricsViewFile(context.Context, *GenerateMetricsViewFileRequest) (*GenerateMetricsViewFileResponse, error)
	// GenerateCanvasFile generates a canvas YAML file from a metrics view
	GenerateCanvasFile(context.Context, *GenerateCanvasFileRequest) (*GenerateCanvasFileResponse, error)
	// GenerateResolver generates resolver and resolver properties from a table or a metrics view
	GenerateResolver(context.Context, *GenerateResolverRequest) (*GenerateResolverResponse, error)
	// GenerateRenderer generates a component renderer and renderer properties from a resolver and resolver properties
	GenerateRenderer(context.Context, *GenerateRendererRequest) (*GenerateRendererResponse, error)
	// QueryResolver queries a resolver with the given properties and arguments
	QueryResolver(context.Context, *QueryResolverRequest) (*QueryResolverResponse, error)
	// GetLogs returns recent logs from a controller
	GetLogs(context.Context, *GetLogsRequest) (*GetLogsResponse, error)
	// WatchLogs streams new logs emitted from a controller
	WatchLogs(*WatchLogsRequest, grpc.ServerStreamingServer[WatchLogsResponse]) error
	// ListResources lists the resources stored in the catalog
	ListResources(context.Context, *ListResourcesRequest) (*ListResourcesResponse, error)
	// WatchResources streams updates to catalog resources (including creation and deletion events)
	WatchResources(*WatchResourcesRequest, grpc.ServerStreamingServer[WatchResourcesResponse]) error
	// GetResource looks up a specific catalog resource
	GetResource(context.Context, *GetResourceRequest) (*GetResourceResponse, error)
	// GetExplore is a convenience RPC that combines looking up an Explore resource and its underlying MetricsView into one network call.
	GetExplore(context.Context, *GetExploreRequest) (*GetExploreResponse, error)
	// GetModelPartitions returns the partitions of a model
	GetModelPartitions(context.Context, *GetModelPartitionsRequest) (*GetModelPartitionsResponse, error)
	// CreateTrigger submits a refresh trigger, which will asynchronously refresh the specified resources.
	// Triggers are ephemeral resources that will be cleaned up by the controller.
	CreateTrigger(context.Context, *CreateTriggerRequest) (*CreateTriggerResponse, error)
	// ListConnectorDrivers returns a description of all the connector drivers registed in the runtime,
	// including their configuration specs and the capabilities they support.
	ListConnectorDrivers(context.Context, *ListConnectorDriversRequest) (*ListConnectorDriversResponse, error)
	// AnalyzeConnectors scans all the project files and returns information about all referenced connectors.
	AnalyzeConnectors(context.Context, *AnalyzeConnectorsRequest) (*AnalyzeConnectorsResponse, error)
	// ListNotifierConnectors returns the names of all configured connectors that can be used as notifiers.
	// This API is much faster than AnalyzeConnectors and can be called without admin-level permissions.
	ListNotifierConnectors(context.Context, *ListNotifierConnectorsRequest) (*ListNotifierConnectorsResponse, error)
	// ListConversations lists all AI chat conversations for an instance.
	ListConversations(context.Context, *ListConversationsRequest) (*ListConversationsResponse, error)
	// GetConversation returns a specific AI chat conversation.
	GetConversation(context.Context, *GetConversationRequest) (*GetConversationResponse, error)
	// ShareConversation enables sharing of the conversation by adding metadata.
	ShareConversation(context.Context, *ShareConversationRequest) (*ShareConversationResponse, error)
	// ForkConversation creates a new conversation by copying messages from an existing one.
	// If its the owner then all messages will be copied, otherwise only messages up to the session.SharedUntilMessageID are copied.
	ForkConversation(context.Context, *ForkConversationRequest) (*ForkConversationResponse, error)
	// ListTools lists metadata about all AI tools that calls to Complete(Streaming) may invoke.
	// Note that it covers all registered tools, but the current user may not have access to all of them.
	ListTools(context.Context, *ListToolsRequest) (*ListToolsResponse, error)
	// Complete runs a language model completion (LLM chat) using the configured AI connector.
	Complete(context.Context, *CompleteRequest) (*CompleteResponse, error)
	// CompleteStreaming runs an AI-powered chat completion, optionally invoking agents or tool calls available in Rill.
	CompleteStreaming(*CompleteStreamingRequest, grpc.ServerStreamingServer[CompleteStreamingResponse]) error
	// IssueDevJWT issues a JWT for mimicking a user in local development.
	IssueDevJWT(context.Context, *IssueDevJWTRequest) (*IssueDevJWTResponse, error)
	// AnalyzeVariables scans `Source`, `Model` and `Connector` resources in the catalog for use of an environment variable
	AnalyzeVariables(context.Context, *AnalyzeVariablesRequest) (*AnalyzeVariablesResponse, error)
	ListGitCommits(context.Context, *ListGitCommitsRequest) (*ListGitCommitsResponse, error)
	// GitStatus returns the current status of the local git repo. This is equivalent to doing a `git fetch` followed by running `git status`.
	GitStatus(context.Context, *GitStatusRequest) (*GitStatusResponse, error)
	ListGitBranches(context.Context, *ListGitBranchesRequest) (*ListGitBranchesResponse, error)
	// GitCommit commits the local changes to the git repo equivalent to `git commit -am <message>` command.
	GitCommit(context.Context, *GitCommitRequest) (*GitCommitResponse, error)
	// RestoreGitCommit creates a new commit that restores the state of the repo to the specified commit SHA.
	// This effectively discards all the changes made after the specified commit.
	RestoreGitCommit(context.Context, *RestoreGitCommitRequest) (*RestoreGitCommitResponse, error)
	// GitMergeToBranch merges current branch to the specified branch.
	// Note: this is not the same as `git merge <branch>`, but rather `git checkout <branch>` followed by `git merge <current-branch>`.
	// It restores back to the original branch after the merge.
	GitMergeToBranch(context.Context, *GitMergeToBranchRequest) (*GitMergeToBranchResponse, error)
	GitSwitchBranch(context.Context, *GitSwitchBranchRequest) (*GitSwitchBranchResponse, error)
	// GitPull fetches the latest changes from the remote git repo equivalent to `git pull` command.
	// If there are any merge conflicts the pull is aborted.
	// Force can be set to true to force the pull and overwrite any local changes.
	GitPull(context.Context, *GitPullRequest) (*GitPullResponse, error)
	// GitPush pushes the local changes to the remote git repo equivalent to `git push` command.
	// It only pushes the changes to the existing remote repo.
	GitPush(context.Context, *GitPushRequest) (*GitPushResponse, error)
	// PullEnv pulls environment variables from cloud to local .env file
	PullEnv(context.Context, *PullEnvRequest) (*PullEnvResponse, error)
	// PushEnv pushes local environment variables to cloud
	PushEnv(context.Context, *PushEnvRequest) (*PushEnvResponse, error)
	mustEmbedUnimplementedRuntimeServiceServer()
}

// UnimplementedRuntimeServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedRuntimeServiceServer struct{}

func (UnimplementedRuntimeServiceServer) Ping(context.Context, *PingRequest) (*PingResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Ping not implemented")
}
func (UnimplementedRuntimeServiceServer) Health(context.Context, *HealthRequest) (*HealthResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Health not implemented")
}
func (UnimplementedRuntimeServiceServer) InstanceHealth(context.Context, *InstanceHealthRequest) (*InstanceHealthResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method InstanceHealth not implemented")
}
func (UnimplementedRuntimeServiceServer) ListInstances(context.Context, *ListInstancesRequest) (*ListInstancesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListInstances not implemented")
}
func (UnimplementedRuntimeServiceServer) GetInstance(context.Context, *GetInstanceRequest) (*GetInstanceResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetInstance not implemented")
}
func (UnimplementedRuntimeServiceServer) CreateInstance(context.Context, *CreateInstanceRequest) (*CreateInstanceResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateInstance not implemented")
}
func (UnimplementedRuntimeServiceServer) EditInstance(context.Context, *EditInstanceRequest) (*EditInstanceResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method EditInstance not implemented")
}
func (UnimplementedRuntimeServiceServer) DeleteInstance(context.Context, *DeleteInstanceRequest) (*DeleteInstanceResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteInstance not implemented")
}
func (UnimplementedRuntimeServiceServer) ReloadConfig(context.Context, *ReloadConfigRequest) (*ReloadConfigResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ReloadConfig not implemented")
}
func (UnimplementedRuntimeServiceServer) ListFiles(context.Context, *ListFilesRequest) (*ListFilesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListFiles not implemented")
}
func (UnimplementedRuntimeServiceServer) WatchFiles(*WatchFilesRequest, grpc.ServerStreamingServer[WatchFilesResponse]) error {
	return status.Errorf(codes.Unimplemented, "method WatchFiles not implemented")
}
func (UnimplementedRuntimeServiceServer) GetFile(context.Context, *GetFileRequest) (*GetFileResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetFile not implemented")
}
func (UnimplementedRuntimeServiceServer) PutFile(context.Context, *PutFileRequest) (*PutFileResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PutFile not implemented")
}
func (UnimplementedRuntimeServiceServer) CreateDirectory(context.Context, *CreateDirectoryRequest) (*CreateDirectoryResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateDirectory not implemented")
}
func (UnimplementedRuntimeServiceServer) DeleteFile(context.Context, *DeleteFileRequest) (*DeleteFileResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteFile not implemented")
}
func (UnimplementedRuntimeServiceServer) RenameFile(context.Context, *RenameFileRequest) (*RenameFileResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RenameFile not implemented")
}
func (UnimplementedRuntimeServiceServer) ListExamples(context.Context, *ListExamplesRequest) (*ListExamplesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListExamples not implemented")
}
func (UnimplementedRuntimeServiceServer) UnpackExample(context.Context, *UnpackExampleRequest) (*UnpackExampleResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UnpackExample not implemented")
}
func (UnimplementedRuntimeServiceServer) UnpackEmpty(context.Context, *UnpackEmptyRequest) (*UnpackEmptyResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UnpackEmpty not implemented")
}
func (UnimplementedRuntimeServiceServer) GenerateMetricsViewFile(context.Context, *GenerateMetricsViewFileRequest) (*GenerateMetricsViewFileResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GenerateMetricsViewFile not implemented")
}
func (UnimplementedRuntimeServiceServer) GenerateCanvasFile(context.Context, *GenerateCanvasFileRequest) (*GenerateCanvasFileResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GenerateCanvasFile not implemented")
}
func (UnimplementedRuntimeServiceServer) GenerateResolver(context.Context, *GenerateResolverRequest) (*GenerateResolverResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GenerateResolver not implemented")
}
func (UnimplementedRuntimeServiceServer) GenerateRenderer(context.Context, *GenerateRendererRequest) (*GenerateRendererResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GenerateRenderer not implemented")
}
func (UnimplementedRuntimeServiceServer) QueryResolver(context.Context, *QueryResolverRequest) (*QueryResolverResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QueryResolver not implemented")
}
func (UnimplementedRuntimeServiceServer) GetLogs(context.Context, *GetLogsRequest) (*GetLogsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetLogs not implemented")
}
func (UnimplementedRuntimeServiceServer) WatchLogs(*WatchLogsRequest, grpc.ServerStreamingServer[WatchLogsResponse]) error {
	return status.Errorf(codes.Unimplemented, "method WatchLogs not implemented")
}
func (UnimplementedRuntimeServiceServer) ListResources(context.Context, *ListResourcesRequest) (*ListResourcesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListResources not implemented")
}
func (UnimplementedRuntimeServiceServer) WatchResources(*WatchResourcesRequest, grpc.ServerStreamingServer[WatchResourcesResponse]) error {
	return status.Errorf(codes.Unimplemented, "method WatchResources not implemented")
}
func (UnimplementedRuntimeServiceServer) GetResource(context.Context, *GetResourceRequest) (*GetResourceResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetResource not implemented")
}
func (UnimplementedRuntimeServiceServer) GetExplore(context.Context, *GetExploreRequest) (*GetExploreResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetExplore not implemented")
}
func (UnimplementedRuntimeServiceServer) GetModelPartitions(context.Context, *GetModelPartitionsRequest) (*GetModelPartitionsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetModelPartitions not implemented")
}
func (UnimplementedRuntimeServiceServer) CreateTrigger(context.Context, *CreateTriggerRequest) (*CreateTriggerResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateTrigger not implemented")
}
func (UnimplementedRuntimeServiceServer) ListConnectorDrivers(context.Context, *ListConnectorDriversRequest) (*ListConnectorDriversResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListConnectorDrivers not implemented")
}
func (UnimplementedRuntimeServiceServer) AnalyzeConnectors(context.Context, *AnalyzeConnectorsRequest) (*AnalyzeConnectorsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AnalyzeConnectors not implemented")
}
func (UnimplementedRuntimeServiceServer) ListNotifierConnectors(context.Context, *ListNotifierConnectorsRequest) (*ListNotifierConnectorsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListNotifierConnectors not implemented")
}
func (UnimplementedRuntimeServiceServer) ListConversations(context.Context, *ListConversationsRequest) (*ListConversationsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListConversations not implemented")
}
func (UnimplementedRuntimeServiceServer) GetConversation(context.Context, *GetConversationRequest) (*GetConversationResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetConversation not implemented")
}
func (UnimplementedRuntimeServiceServer) ShareConversation(context.Context, *ShareConversationRequest) (*ShareConversationResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ShareConversation not implemented")
}
func (UnimplementedRuntimeServiceServer) ForkConversation(context.Context, *ForkConversationRequest) (*ForkConversationResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ForkConversation not implemented")
}
func (UnimplementedRuntimeServiceServer) ListTools(context.Context, *ListToolsRequest) (*ListToolsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListTools not implemented")
}
func (UnimplementedRuntimeServiceServer) Complete(context.Context, *CompleteRequest) (*CompleteResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Complete not implemented")
}
func (UnimplementedRuntimeServiceServer) CompleteStreaming(*CompleteStreamingRequest, grpc.ServerStreamingServer[CompleteStreamingResponse]) error {
	return status.Errorf(codes.Unimplemented, "method CompleteStreaming not implemented")
}
func (UnimplementedRuntimeServiceServer) IssueDevJWT(context.Context, *IssueDevJWTRequest) (*IssueDevJWTResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method IssueDevJWT not implemented")
}
func (UnimplementedRuntimeServiceServer) AnalyzeVariables(context.Context, *AnalyzeVariablesRequest) (*AnalyzeVariablesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AnalyzeVariables not implemented")
}
func (UnimplementedRuntimeServiceServer) ListGitCommits(context.Context, *ListGitCommitsRequest) (*ListGitCommitsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListGitCommits not implemented")
}
func (UnimplementedRuntimeServiceServer) GitStatus(context.Context, *GitStatusRequest) (*GitStatusResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GitStatus not implemented")
}
func (UnimplementedRuntimeServiceServer) ListGitBranches(context.Context, *ListGitBranchesRequest) (*ListGitBranchesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListGitBranches not implemented")
}
func (UnimplementedRuntimeServiceServer) GitCommit(context.Context, *GitCommitRequest) (*GitCommitResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GitCommit not implemented")
}
func (UnimplementedRuntimeServiceServer) RestoreGitCommit(context.Context, *RestoreGitCommitRequest) (*RestoreGitCommitResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RestoreGitCommit not implemented")
}
func (UnimplementedRuntimeServiceServer) GitMergeToBranch(context.Context, *GitMergeToBranchRequest) (*GitMergeToBranchResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GitMergeToBranch not implemented")
}
func (UnimplementedRuntimeServiceServer) GitSwitchBranch(context.Context, *GitSwitchBranchRequest) (*GitSwitchBranchResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GitSwitchBranch not implemented")
}
func (UnimplementedRuntimeServiceServer) GitPull(context.Context, *GitPullRequest) (*GitPullResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GitPull not implemented")
}
func (UnimplementedRuntimeServiceServer) GitPush(context.Context, *GitPushRequest) (*GitPushResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GitPush not implemented")
}
func (UnimplementedRuntimeServiceServer) PullEnv(context.Context, *PullEnvRequest) (*PullEnvResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PullEnv not implemented")
}
func (UnimplementedRuntimeServiceServer) PushEnv(context.Context, *PushEnvRequest) (*PushEnvResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PushEnv not implemented")
}
func (UnimplementedRuntimeServiceServer) mustEmbedUnimplementedRuntimeServiceServer() {}
func (UnimplementedRuntimeServiceServer) testEmbeddedByValue()                        {}

// UnsafeRuntimeServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to RuntimeServiceServer will
// result in compilation errors.
type UnsafeRuntimeServiceServer interface {
	mustEmbedUnimplementedRuntimeServiceServer()
}

func RegisterRuntimeServiceServer(s grpc.ServiceRegistrar, srv RuntimeServiceServer) {
	// If the following call pancis, it indicates UnimplementedRuntimeServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&RuntimeService_ServiceDesc, srv)
}

func _RuntimeService_Ping_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PingRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RuntimeServiceServer).Ping(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RuntimeService_Ping_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RuntimeServiceServer).Ping(ctx, req.(*PingRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RuntimeService_Health_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(HealthRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RuntimeServiceServer).Health(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RuntimeService_Health_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RuntimeServiceServer).Health(ctx, req.(*HealthRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RuntimeService_InstanceHealth_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InstanceHealthRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RuntimeServiceServer).InstanceHealth(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RuntimeService_InstanceHealth_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RuntimeServiceServer).InstanceHealth(ctx, req.(*InstanceHealthRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RuntimeService_ListInstances_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListInstancesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RuntimeServiceServer).ListInstances(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RuntimeService_ListInstances_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RuntimeServiceServer).ListInstances(ctx, req.(*ListInstancesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RuntimeService_GetInstance_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetInstanceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RuntimeServiceServer).GetInstance(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RuntimeService_GetInstance_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RuntimeServiceServer).GetInstance(ctx, req.(*GetInstanceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RuntimeService_CreateInstance_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateInstanceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RuntimeServiceServer).CreateInstance(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RuntimeService_CreateInstance_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RuntimeServiceServer).CreateInstance(ctx, req.(*CreateInstanceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RuntimeService_EditInstance_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EditInstanceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RuntimeServiceServer).EditInstance(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RuntimeService_EditInstance_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RuntimeServiceServer).EditInstance(ctx, req.(*EditInstanceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RuntimeService_DeleteInstance_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteInstanceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RuntimeServiceServer).DeleteInstance(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RuntimeService_DeleteInstance_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RuntimeServiceServer).DeleteInstance(ctx, req.(*DeleteInstanceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RuntimeService_ReloadConfig_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReloadConfigRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RuntimeServiceServer).ReloadConfig(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RuntimeService_ReloadConfig_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RuntimeServiceServer).ReloadConfig(ctx, req.(*ReloadConfigRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RuntimeService_ListFiles_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListFilesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RuntimeServiceServer).ListFiles(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RuntimeService_ListFiles_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RuntimeServiceServer).ListFiles(ctx, req.(*ListFilesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RuntimeService_WatchFiles_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(WatchFilesRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(RuntimeServiceServer).WatchFiles(m, &grpc.GenericServerStream[WatchFilesRequest, WatchFilesResponse]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type RuntimeService_WatchFilesServer = grpc.ServerStreamingServer[WatchFilesResponse]

func _RuntimeService_GetFile_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetFileRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RuntimeServiceServer).GetFile(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RuntimeService_GetFile_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RuntimeServiceServer).GetFile(ctx, req.(*GetFileRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RuntimeService_PutFile_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PutFileRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RuntimeServiceServer).PutFile(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RuntimeService_PutFile_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RuntimeServiceServer).PutFile(ctx, req.(*PutFileRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RuntimeService_CreateDirectory_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateDirectoryRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RuntimeServiceServer).CreateDirectory(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RuntimeService_CreateDirectory_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RuntimeServiceServer).CreateDirectory(ctx, req.(*CreateDirectoryRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RuntimeService_DeleteFile_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteFileRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RuntimeServiceServer).DeleteFile(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RuntimeService_DeleteFile_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RuntimeServiceServer).DeleteFile(ctx, req.(*DeleteFileRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RuntimeService_RenameFile_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RenameFileRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RuntimeServiceServer).RenameFile(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RuntimeService_RenameFile_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RuntimeServiceServer).RenameFile(ctx, req.(*RenameFileRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RuntimeService_ListExamples_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListExamplesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RuntimeServiceServer).ListExamples(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RuntimeService_ListExamples_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RuntimeServiceServer).ListExamples(ctx, req.(*ListExamplesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RuntimeService_UnpackExample_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UnpackExampleRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RuntimeServiceServer).UnpackExample(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RuntimeService_UnpackExample_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RuntimeServiceServer).UnpackExample(ctx, req.(*UnpackExampleRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RuntimeService_UnpackEmpty_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UnpackEmptyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RuntimeServiceServer).UnpackEmpty(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RuntimeService_UnpackEmpty_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RuntimeServiceServer).UnpackEmpty(ctx, req.(*UnpackEmptyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RuntimeService_GenerateMetricsViewFile_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GenerateMetricsViewFileRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RuntimeServiceServer).GenerateMetricsViewFile(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RuntimeService_GenerateMetricsViewFile_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RuntimeServiceServer).GenerateMetricsViewFile(ctx, req.(*GenerateMetricsViewFileRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RuntimeService_GenerateCanvasFile_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GenerateCanvasFileRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RuntimeServiceServer).GenerateCanvasFile(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RuntimeService_GenerateCanvasFile_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RuntimeServiceServer).GenerateCanvasFile(ctx, req.(*GenerateCanvasFileRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RuntimeService_GenerateResolver_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GenerateResolverRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RuntimeServiceServer).GenerateResolver(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RuntimeService_GenerateResolver_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RuntimeServiceServer).GenerateResolver(ctx, req.(*GenerateResolverRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RuntimeService_GenerateRenderer_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GenerateRendererRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RuntimeServiceServer).GenerateRenderer(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RuntimeService_GenerateRenderer_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RuntimeServiceServer).GenerateRenderer(ctx, req.(*GenerateRendererRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RuntimeService_QueryResolver_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryResolverRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RuntimeServiceServer).QueryResolver(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RuntimeService_QueryResolver_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RuntimeServiceServer).QueryResolver(ctx, req.(*QueryResolverRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RuntimeService_GetLogs_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetLogsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RuntimeServiceServer).GetLogs(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RuntimeService_GetLogs_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RuntimeServiceServer).GetLogs(ctx, req.(*GetLogsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RuntimeService_WatchLogs_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(WatchLogsRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(RuntimeServiceServer).WatchLogs(m, &grpc.GenericServerStream[WatchLogsRequest, WatchLogsResponse]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type RuntimeService_WatchLogsServer = grpc.ServerStreamingServer[WatchLogsResponse]

func _RuntimeService_ListResources_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListResourcesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RuntimeServiceServer).ListResources(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RuntimeService_ListResources_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RuntimeServiceServer).ListResources(ctx, req.(*ListResourcesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RuntimeService_WatchResources_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(WatchResourcesRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(RuntimeServiceServer).WatchResources(m, &grpc.GenericServerStream[WatchResourcesRequest, WatchResourcesResponse]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type RuntimeService_WatchResourcesServer = grpc.ServerStreamingServer[WatchResourcesResponse]

func _RuntimeService_GetResource_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetResourceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RuntimeServiceServer).GetResource(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RuntimeService_GetResource_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RuntimeServiceServer).GetResource(ctx, req.(*GetResourceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RuntimeService_GetExplore_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetExploreRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RuntimeServiceServer).GetExplore(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RuntimeService_GetExplore_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RuntimeServiceServer).GetExplore(ctx, req.(*GetExploreRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RuntimeService_GetModelPartitions_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetModelPartitionsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RuntimeServiceServer).GetModelPartitions(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RuntimeService_GetModelPartitions_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RuntimeServiceServer).GetModelPartitions(ctx, req.(*GetModelPartitionsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RuntimeService_CreateTrigger_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateTriggerRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RuntimeServiceServer).CreateTrigger(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RuntimeService_CreateTrigger_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RuntimeServiceServer).CreateTrigger(ctx, req.(*CreateTriggerRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RuntimeService_ListConnectorDrivers_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListConnectorDriversRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RuntimeServiceServer).ListConnectorDrivers(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RuntimeService_ListConnectorDrivers_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RuntimeServiceServer).ListConnectorDrivers(ctx, req.(*ListConnectorDriversRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RuntimeService_AnalyzeConnectors_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AnalyzeConnectorsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RuntimeServiceServer).AnalyzeConnectors(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RuntimeService_AnalyzeConnectors_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RuntimeServiceServer).AnalyzeConnectors(ctx, req.(*AnalyzeConnectorsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RuntimeService_ListNotifierConnectors_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListNotifierConnectorsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RuntimeServiceServer).ListNotifierConnectors(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RuntimeService_ListNotifierConnectors_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RuntimeServiceServer).ListNotifierConnectors(ctx, req.(*ListNotifierConnectorsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RuntimeService_ListConversations_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListConversationsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RuntimeServiceServer).ListConversations(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RuntimeService_ListConversations_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RuntimeServiceServer).ListConversations(ctx, req.(*ListConversationsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RuntimeService_GetConversation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetConversationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RuntimeServiceServer).GetConversation(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RuntimeService_GetConversation_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RuntimeServiceServer).GetConversation(ctx, req.(*GetConversationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RuntimeService_ShareConversation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ShareConversationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RuntimeServiceServer).ShareConversation(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RuntimeService_ShareConversation_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RuntimeServiceServer).ShareConversation(ctx, req.(*ShareConversationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RuntimeService_ForkConversation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ForkConversationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RuntimeServiceServer).ForkConversation(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RuntimeService_ForkConversation_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RuntimeServiceServer).ForkConversation(ctx, req.(*ForkConversationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RuntimeService_ListTools_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListToolsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RuntimeServiceServer).ListTools(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RuntimeService_ListTools_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RuntimeServiceServer).ListTools(ctx, req.(*ListToolsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RuntimeService_Complete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CompleteRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RuntimeServiceServer).Complete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RuntimeService_Complete_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RuntimeServiceServer).Complete(ctx, req.(*CompleteRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RuntimeService_CompleteStreaming_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(CompleteStreamingRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(RuntimeServiceServer).CompleteStreaming(m, &grpc.GenericServerStream[CompleteStreamingRequest, CompleteStreamingResponse]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type RuntimeService_CompleteStreamingServer = grpc.ServerStreamingServer[CompleteStreamingResponse]

func _RuntimeService_IssueDevJWT_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IssueDevJWTRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RuntimeServiceServer).IssueDevJWT(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RuntimeService_IssueDevJWT_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RuntimeServiceServer).IssueDevJWT(ctx, req.(*IssueDevJWTRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RuntimeService_AnalyzeVariables_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AnalyzeVariablesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RuntimeServiceServer).AnalyzeVariables(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RuntimeService_AnalyzeVariables_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RuntimeServiceServer).AnalyzeVariables(ctx, req.(*AnalyzeVariablesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RuntimeService_ListGitCommits_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListGitCommitsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RuntimeServiceServer).ListGitCommits(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RuntimeService_ListGitCommits_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RuntimeServiceServer).ListGitCommits(ctx, req.(*ListGitCommitsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RuntimeService_GitStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GitStatusRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RuntimeServiceServer).GitStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RuntimeService_GitStatus_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RuntimeServiceServer).GitStatus(ctx, req.(*GitStatusRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RuntimeService_ListGitBranches_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListGitBranchesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RuntimeServiceServer).ListGitBranches(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RuntimeService_ListGitBranches_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RuntimeServiceServer).ListGitBranches(ctx, req.(*ListGitBranchesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RuntimeService_GitCommit_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GitCommitRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RuntimeServiceServer).GitCommit(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RuntimeService_GitCommit_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RuntimeServiceServer).GitCommit(ctx, req.(*GitCommitRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RuntimeService_RestoreGitCommit_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RestoreGitCommitRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RuntimeServiceServer).RestoreGitCommit(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RuntimeService_RestoreGitCommit_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RuntimeServiceServer).RestoreGitCommit(ctx, req.(*RestoreGitCommitRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RuntimeService_GitMergeToBranch_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GitMergeToBranchRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RuntimeServiceServer).GitMergeToBranch(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RuntimeService_GitMergeToBranch_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RuntimeServiceServer).GitMergeToBranch(ctx, req.(*GitMergeToBranchRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RuntimeService_GitSwitchBranch_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GitSwitchBranchRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RuntimeServiceServer).GitSwitchBranch(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RuntimeService_GitSwitchBranch_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RuntimeServiceServer).GitSwitchBranch(ctx, req.(*GitSwitchBranchRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RuntimeService_GitPull_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GitPullRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RuntimeServiceServer).GitPull(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RuntimeService_GitPull_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RuntimeServiceServer).GitPull(ctx, req.(*GitPullRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RuntimeService_GitPush_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GitPushRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RuntimeServiceServer).GitPush(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RuntimeService_GitPush_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RuntimeServiceServer).GitPush(ctx, req.(*GitPushRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RuntimeService_PullEnv_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PullEnvRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RuntimeServiceServer).PullEnv(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RuntimeService_PullEnv_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RuntimeServiceServer).PullEnv(ctx, req.(*PullEnvRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RuntimeService_PushEnv_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PushEnvRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RuntimeServiceServer).PushEnv(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RuntimeService_PushEnv_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RuntimeServiceServer).PushEnv(ctx, req.(*PushEnvRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// RuntimeService_ServiceDesc is the grpc.ServiceDesc for RuntimeService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var RuntimeService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "rill.runtime.v1.RuntimeService",
	HandlerType: (*RuntimeServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Ping",
			Handler:    _RuntimeService_Ping_Handler,
		},
		{
			MethodName: "Health",
			Handler:    _RuntimeService_Health_Handler,
		},
		{
			MethodName: "InstanceHealth",
			Handler:    _RuntimeService_InstanceHealth_Handler,
		},
		{
			MethodName: "ListInstances",
			Handler:    _RuntimeService_ListInstances_Handler,
		},
		{
			MethodName: "GetInstance",
			Handler:    _RuntimeService_GetInstance_Handler,
		},
		{
			MethodName: "CreateInstance",
			Handler:    _RuntimeService_CreateInstance_Handler,
		},
		{
			MethodName: "EditInstance",
			Handler:    _RuntimeService_EditInstance_Handler,
		},
		{
			MethodName: "DeleteInstance",
			Handler:    _RuntimeService_DeleteInstance_Handler,
		},
		{
			MethodName: "ReloadConfig",
			Handler:    _RuntimeService_ReloadConfig_Handler,
		},
		{
			MethodName: "ListFiles",
			Handler:    _RuntimeService_ListFiles_Handler,
		},
		{
			MethodName: "GetFile",
			Handler:    _RuntimeService_GetFile_Handler,
		},
		{
			MethodName: "PutFile",
			Handler:    _RuntimeService_PutFile_Handler,
		},
		{
			MethodName: "CreateDirectory",
			Handler:    _RuntimeService_CreateDirectory_Handler,
		},
		{
			MethodName: "DeleteFile",
			Handler:    _RuntimeService_DeleteFile_Handler,
		},
		{
			MethodName: "RenameFile",
			Handler:    _RuntimeService_RenameFile_Handler,
		},
		{
			MethodName: "ListExamples",
			Handler:    _RuntimeService_ListExamples_Handler,
		},
		{
			MethodName: "UnpackExample",
			Handler:    _RuntimeService_UnpackExample_Handler,
		},
		{
			MethodName: "UnpackEmpty",
			Handler:    _RuntimeService_UnpackEmpty_Handler,
		},
		{
			MethodName: "GenerateMetricsViewFile",
			Handler:    _RuntimeService_GenerateMetricsViewFile_Handler,
		},
		{
			MethodName: "GenerateCanvasFile",
			Handler:    _RuntimeService_GenerateCanvasFile_Handler,
		},
		{
			MethodName: "GenerateResolver",
			Handler:    _RuntimeService_GenerateResolver_Handler,
		},
		{
			MethodName: "GenerateRenderer",
			Handler:    _RuntimeService_GenerateRenderer_Handler,
		},
		{
			MethodName: "QueryResolver",
			Handler:    _RuntimeService_QueryResolver_Handler,
		},
		{
			MethodName: "GetLogs",
			Handler:    _RuntimeService_GetLogs_Handler,
		},
		{
			MethodName: "ListResources",
			Handler:    _RuntimeService_ListResources_Handler,
		},
		{
			MethodName: "GetResource",
			Handler:    _RuntimeService_GetResource_Handler,
		},
		{
			MethodName: "GetExplore",
			Handler:    _RuntimeService_GetExplore_Handler,
		},
		{
			MethodName: "GetModelPartitions",
			Handler:    _RuntimeService_GetModelPartitions_Handler,
		},
		{
			MethodName: "CreateTrigger",
			Handler:    _RuntimeService_CreateTrigger_Handler,
		},
		{
			MethodName: "ListConnectorDrivers",
			Handler:    _RuntimeService_ListConnectorDrivers_Handler,
		},
		{
			MethodName: "AnalyzeConnectors",
			Handler:    _RuntimeService_AnalyzeConnectors_Handler,
		},
		{
			MethodName: "ListNotifierConnectors",
			Handler:    _RuntimeService_ListNotifierConnectors_Handler,
		},
		{
			MethodName: "ListConversations",
			Handler:    _RuntimeService_ListConversations_Handler,
		},
		{
			MethodName: "GetConversation",
			Handler:    _RuntimeService_GetConversation_Handler,
		},
		{
			MethodName: "ShareConversation",
			Handler:    _RuntimeService_ShareConversation_Handler,
		},
		{
			MethodName: "ForkConversation",
			Handler:    _RuntimeService_ForkConversation_Handler,
		},
		{
			MethodName: "ListTools",
			Handler:    _RuntimeService_ListTools_Handler,
		},
		{
			MethodName: "Complete",
			Handler:    _RuntimeService_Complete_Handler,
		},
		{
			MethodName: "IssueDevJWT",
			Handler:    _RuntimeService_IssueDevJWT_Handler,
		},
		{
			MethodName: "AnalyzeVariables",
			Handler:    _RuntimeService_AnalyzeVariables_Handler,
		},
		{
			MethodName: "ListGitCommits",
			Handler:    _RuntimeService_ListGitCommits_Handler,
		},
		{
			MethodName: "GitStatus",
			Handler:    _RuntimeService_GitStatus_Handler,
		},
		{
			MethodName: "ListGitBranches",
			Handler:    _RuntimeService_ListGitBranches_Handler,
		},
		{
			MethodName: "GitCommit",
			Handler:    _RuntimeService_GitCommit_Handler,
		},
		{
			MethodName: "RestoreGitCommit",
			Handler:    _RuntimeService_RestoreGitCommit_Handler,
		},
		{
			MethodName: "GitMergeToBranch",
			Handler:    _RuntimeService_GitMergeToBranch_Handler,
		},
		{
			MethodName: "GitSwitchBranch",
			Handler:    _RuntimeService_GitSwitchBranch_Handler,
		},
		{
			MethodName: "GitPull",
			Handler:    _RuntimeService_GitPull_Handler,
		},
		{
			MethodName: "GitPush",
			Handler:    _RuntimeService_GitPush_Handler,
		},
		{
			MethodName: "PullEnv",
			Handler:    _RuntimeService_PullEnv_Handler,
		},
		{
			MethodName: "PushEnv",
			Handler:    _RuntimeService_PushEnv_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "WatchFiles",
			Handler:       _RuntimeService_WatchFiles_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "WatchLogs",
			Handler:       _RuntimeService_WatchLogs_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "WatchResources",
			Handler:       _RuntimeService_WatchResources_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "CompleteStreaming",
			Handler:       _RuntimeService_CompleteStreaming_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "rill/runtime/v1/api.proto",
}

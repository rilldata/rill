// Code generated by protoc-gen-validate. DO NOT EDIT.
// source: rill/runtime/v1/resources.proto

package runtimev1

import (
	"bytes"
	"errors"
	"fmt"
	"net"
	"net/mail"
	"net/url"
	"regexp"
	"sort"
	"strings"
	"time"
	"unicode/utf8"

	"google.golang.org/protobuf/types/known/anypb"
)

// ensure the imports are used
var (
	_ = bytes.MinRead
	_ = errors.New("")
	_ = fmt.Print
	_ = utf8.UTFMax
	_ = (*regexp.Regexp)(nil)
	_ = (*strings.Reader)(nil)
	_ = net.IPv4len
	_ = time.Duration(0)
	_ = (*url.URL)(nil)
	_ = (*mail.Address)(nil)
	_ = anypb.Any{}
	_ = sort.Sort
)

// Validate checks the field values on Resource with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Resource) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Resource with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ResourceMultiError, or nil
// if none found.
func (m *Resource) ValidateAll() error {
	return m.validate(true)
}

func (m *Resource) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetMeta()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ResourceValidationError{
					field:  "Meta",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ResourceValidationError{
					field:  "Meta",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetMeta()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ResourceValidationError{
				field:  "Meta",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	switch v := m.Resource.(type) {
	case *Resource_ProjectParser:
		if v == nil {
			err := ResourceValidationError{
				field:  "Resource",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetProjectParser()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ResourceValidationError{
						field:  "ProjectParser",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ResourceValidationError{
						field:  "ProjectParser",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetProjectParser()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ResourceValidationError{
					field:  "ProjectParser",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Resource_Source:
		if v == nil {
			err := ResourceValidationError{
				field:  "Resource",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetSource()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ResourceValidationError{
						field:  "Source",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ResourceValidationError{
						field:  "Source",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetSource()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ResourceValidationError{
					field:  "Source",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Resource_Model:
		if v == nil {
			err := ResourceValidationError{
				field:  "Resource",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetModel()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ResourceValidationError{
						field:  "Model",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ResourceValidationError{
						field:  "Model",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetModel()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ResourceValidationError{
					field:  "Model",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Resource_MetricsView:
		if v == nil {
			err := ResourceValidationError{
				field:  "Resource",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetMetricsView()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ResourceValidationError{
						field:  "MetricsView",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ResourceValidationError{
						field:  "MetricsView",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetMetricsView()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ResourceValidationError{
					field:  "MetricsView",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Resource_Explore:
		if v == nil {
			err := ResourceValidationError{
				field:  "Resource",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetExplore()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ResourceValidationError{
						field:  "Explore",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ResourceValidationError{
						field:  "Explore",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetExplore()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ResourceValidationError{
					field:  "Explore",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Resource_Migration:
		if v == nil {
			err := ResourceValidationError{
				field:  "Resource",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetMigration()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ResourceValidationError{
						field:  "Migration",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ResourceValidationError{
						field:  "Migration",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetMigration()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ResourceValidationError{
					field:  "Migration",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Resource_Report:
		if v == nil {
			err := ResourceValidationError{
				field:  "Resource",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetReport()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ResourceValidationError{
						field:  "Report",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ResourceValidationError{
						field:  "Report",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetReport()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ResourceValidationError{
					field:  "Report",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Resource_Alert:
		if v == nil {
			err := ResourceValidationError{
				field:  "Resource",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetAlert()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ResourceValidationError{
						field:  "Alert",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ResourceValidationError{
						field:  "Alert",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetAlert()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ResourceValidationError{
					field:  "Alert",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Resource_RefreshTrigger:
		if v == nil {
			err := ResourceValidationError{
				field:  "Resource",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetRefreshTrigger()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ResourceValidationError{
						field:  "RefreshTrigger",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ResourceValidationError{
						field:  "RefreshTrigger",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetRefreshTrigger()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ResourceValidationError{
					field:  "RefreshTrigger",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Resource_Theme:
		if v == nil {
			err := ResourceValidationError{
				field:  "Resource",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetTheme()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ResourceValidationError{
						field:  "Theme",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ResourceValidationError{
						field:  "Theme",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetTheme()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ResourceValidationError{
					field:  "Theme",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Resource_Component:
		if v == nil {
			err := ResourceValidationError{
				field:  "Resource",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetComponent()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ResourceValidationError{
						field:  "Component",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ResourceValidationError{
						field:  "Component",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetComponent()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ResourceValidationError{
					field:  "Component",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Resource_Canvas:
		if v == nil {
			err := ResourceValidationError{
				field:  "Resource",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetCanvas()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ResourceValidationError{
						field:  "Canvas",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ResourceValidationError{
						field:  "Canvas",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetCanvas()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ResourceValidationError{
					field:  "Canvas",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Resource_Api:
		if v == nil {
			err := ResourceValidationError{
				field:  "Resource",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetApi()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ResourceValidationError{
						field:  "Api",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ResourceValidationError{
						field:  "Api",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetApi()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ResourceValidationError{
					field:  "Api",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Resource_Connector:
		if v == nil {
			err := ResourceValidationError{
				field:  "Resource",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetConnector()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ResourceValidationError{
						field:  "Connector",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ResourceValidationError{
						field:  "Connector",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetConnector()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ResourceValidationError{
					field:  "Connector",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	default:
		_ = v // ensures v is used
	}

	if len(errors) > 0 {
		return ResourceMultiError(errors)
	}

	return nil
}

// ResourceMultiError is an error wrapping multiple validation errors returned
// by Resource.ValidateAll() if the designated constraints aren't met.
type ResourceMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ResourceMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ResourceMultiError) AllErrors() []error { return m }

// ResourceValidationError is the validation error returned by
// Resource.Validate if the designated constraints aren't met.
type ResourceValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ResourceValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ResourceValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ResourceValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ResourceValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ResourceValidationError) ErrorName() string { return "ResourceValidationError" }

// Error satisfies the builtin error interface
func (e ResourceValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sResource.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ResourceValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ResourceValidationError{}

// Validate checks the field values on ResourceMeta with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ResourceMeta) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ResourceMeta with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ResourceMetaMultiError, or
// nil if none found.
func (m *ResourceMeta) ValidateAll() error {
	return m.validate(true)
}

func (m *ResourceMeta) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetName()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ResourceMetaValidationError{
					field:  "Name",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ResourceMetaValidationError{
					field:  "Name",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetName()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ResourceMetaValidationError{
				field:  "Name",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetRefs() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ResourceMetaValidationError{
						field:  fmt.Sprintf("Refs[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ResourceMetaValidationError{
						field:  fmt.Sprintf("Refs[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ResourceMetaValidationError{
					field:  fmt.Sprintf("Refs[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for Hidden

	// no validation rules for Version

	// no validation rules for SpecVersion

	// no validation rules for StateVersion

	if all {
		switch v := interface{}(m.GetCreatedOn()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ResourceMetaValidationError{
					field:  "CreatedOn",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ResourceMetaValidationError{
					field:  "CreatedOn",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCreatedOn()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ResourceMetaValidationError{
				field:  "CreatedOn",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetSpecUpdatedOn()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ResourceMetaValidationError{
					field:  "SpecUpdatedOn",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ResourceMetaValidationError{
					field:  "SpecUpdatedOn",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSpecUpdatedOn()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ResourceMetaValidationError{
				field:  "SpecUpdatedOn",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetStateUpdatedOn()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ResourceMetaValidationError{
					field:  "StateUpdatedOn",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ResourceMetaValidationError{
					field:  "StateUpdatedOn",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetStateUpdatedOn()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ResourceMetaValidationError{
				field:  "StateUpdatedOn",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for ReconcileStatus

	// no validation rules for ReconcileError

	if all {
		switch v := interface{}(m.GetReconcileOn()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ResourceMetaValidationError{
					field:  "ReconcileOn",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ResourceMetaValidationError{
					field:  "ReconcileOn",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetReconcileOn()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ResourceMetaValidationError{
				field:  "ReconcileOn",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if m.Owner != nil {

		if all {
			switch v := interface{}(m.GetOwner()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ResourceMetaValidationError{
						field:  "Owner",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ResourceMetaValidationError{
						field:  "Owner",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetOwner()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ResourceMetaValidationError{
					field:  "Owner",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if m.DeletedOn != nil {

		if all {
			switch v := interface{}(m.GetDeletedOn()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ResourceMetaValidationError{
						field:  "DeletedOn",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ResourceMetaValidationError{
						field:  "DeletedOn",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetDeletedOn()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ResourceMetaValidationError{
					field:  "DeletedOn",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if m.RenamedFrom != nil {

		if all {
			switch v := interface{}(m.GetRenamedFrom()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ResourceMetaValidationError{
						field:  "RenamedFrom",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ResourceMetaValidationError{
						field:  "RenamedFrom",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetRenamedFrom()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ResourceMetaValidationError{
					field:  "RenamedFrom",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ResourceMetaMultiError(errors)
	}

	return nil
}

// ResourceMetaMultiError is an error wrapping multiple validation errors
// returned by ResourceMeta.ValidateAll() if the designated constraints aren't met.
type ResourceMetaMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ResourceMetaMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ResourceMetaMultiError) AllErrors() []error { return m }

// ResourceMetaValidationError is the validation error returned by
// ResourceMeta.Validate if the designated constraints aren't met.
type ResourceMetaValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ResourceMetaValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ResourceMetaValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ResourceMetaValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ResourceMetaValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ResourceMetaValidationError) ErrorName() string { return "ResourceMetaValidationError" }

// Error satisfies the builtin error interface
func (e ResourceMetaValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sResourceMeta.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ResourceMetaValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ResourceMetaValidationError{}

// Validate checks the field values on ResourceName with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ResourceName) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ResourceName with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ResourceNameMultiError, or
// nil if none found.
func (m *ResourceName) ValidateAll() error {
	return m.validate(true)
}

func (m *ResourceName) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Kind

	// no validation rules for Name

	if len(errors) > 0 {
		return ResourceNameMultiError(errors)
	}

	return nil
}

// ResourceNameMultiError is an error wrapping multiple validation errors
// returned by ResourceName.ValidateAll() if the designated constraints aren't met.
type ResourceNameMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ResourceNameMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ResourceNameMultiError) AllErrors() []error { return m }

// ResourceNameValidationError is the validation error returned by
// ResourceName.Validate if the designated constraints aren't met.
type ResourceNameValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ResourceNameValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ResourceNameValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ResourceNameValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ResourceNameValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ResourceNameValidationError) ErrorName() string { return "ResourceNameValidationError" }

// Error satisfies the builtin error interface
func (e ResourceNameValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sResourceName.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ResourceNameValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ResourceNameValidationError{}

// Validate checks the field values on ProjectParser with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ProjectParser) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ProjectParser with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ProjectParserMultiError, or
// nil if none found.
func (m *ProjectParser) ValidateAll() error {
	return m.validate(true)
}

func (m *ProjectParser) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetSpec()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ProjectParserValidationError{
					field:  "Spec",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ProjectParserValidationError{
					field:  "Spec",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSpec()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ProjectParserValidationError{
				field:  "Spec",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetState()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ProjectParserValidationError{
					field:  "State",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ProjectParserValidationError{
					field:  "State",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetState()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ProjectParserValidationError{
				field:  "State",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ProjectParserMultiError(errors)
	}

	return nil
}

// ProjectParserMultiError is an error wrapping multiple validation errors
// returned by ProjectParser.ValidateAll() if the designated constraints
// aren't met.
type ProjectParserMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ProjectParserMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ProjectParserMultiError) AllErrors() []error { return m }

// ProjectParserValidationError is the validation error returned by
// ProjectParser.Validate if the designated constraints aren't met.
type ProjectParserValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ProjectParserValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ProjectParserValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ProjectParserValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ProjectParserValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ProjectParserValidationError) ErrorName() string { return "ProjectParserValidationError" }

// Error satisfies the builtin error interface
func (e ProjectParserValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sProjectParser.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ProjectParserValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ProjectParserValidationError{}

// Validate checks the field values on ProjectParserSpec with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *ProjectParserSpec) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ProjectParserSpec with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ProjectParserSpecMultiError, or nil if none found.
func (m *ProjectParserSpec) ValidateAll() error {
	return m.validate(true)
}

func (m *ProjectParserSpec) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return ProjectParserSpecMultiError(errors)
	}

	return nil
}

// ProjectParserSpecMultiError is an error wrapping multiple validation errors
// returned by ProjectParserSpec.ValidateAll() if the designated constraints
// aren't met.
type ProjectParserSpecMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ProjectParserSpecMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ProjectParserSpecMultiError) AllErrors() []error { return m }

// ProjectParserSpecValidationError is the validation error returned by
// ProjectParserSpec.Validate if the designated constraints aren't met.
type ProjectParserSpecValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ProjectParserSpecValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ProjectParserSpecValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ProjectParserSpecValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ProjectParserSpecValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ProjectParserSpecValidationError) ErrorName() string {
	return "ProjectParserSpecValidationError"
}

// Error satisfies the builtin error interface
func (e ProjectParserSpecValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sProjectParserSpec.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ProjectParserSpecValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ProjectParserSpecValidationError{}

// Validate checks the field values on ProjectParserState with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ProjectParserState) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ProjectParserState with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ProjectParserStateMultiError, or nil if none found.
func (m *ProjectParserState) ValidateAll() error {
	return m.validate(true)
}

func (m *ProjectParserState) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetParseErrors() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ProjectParserStateValidationError{
						field:  fmt.Sprintf("ParseErrors[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ProjectParserStateValidationError{
						field:  fmt.Sprintf("ParseErrors[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ProjectParserStateValidationError{
					field:  fmt.Sprintf("ParseErrors[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for CurrentCommitSha

	if all {
		switch v := interface{}(m.GetCurrentCommitOn()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ProjectParserStateValidationError{
					field:  "CurrentCommitOn",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ProjectParserStateValidationError{
					field:  "CurrentCommitOn",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCurrentCommitOn()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ProjectParserStateValidationError{
				field:  "CurrentCommitOn",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Watching

	if len(errors) > 0 {
		return ProjectParserStateMultiError(errors)
	}

	return nil
}

// ProjectParserStateMultiError is an error wrapping multiple validation errors
// returned by ProjectParserState.ValidateAll() if the designated constraints
// aren't met.
type ProjectParserStateMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ProjectParserStateMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ProjectParserStateMultiError) AllErrors() []error { return m }

// ProjectParserStateValidationError is the validation error returned by
// ProjectParserState.Validate if the designated constraints aren't met.
type ProjectParserStateValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ProjectParserStateValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ProjectParserStateValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ProjectParserStateValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ProjectParserStateValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ProjectParserStateValidationError) ErrorName() string {
	return "ProjectParserStateValidationError"
}

// Error satisfies the builtin error interface
func (e ProjectParserStateValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sProjectParserState.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ProjectParserStateValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ProjectParserStateValidationError{}

// Validate checks the field values on Source with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Source) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Source with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in SourceMultiError, or nil if none found.
func (m *Source) ValidateAll() error {
	return m.validate(true)
}

func (m *Source) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetSpec()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, SourceValidationError{
					field:  "Spec",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, SourceValidationError{
					field:  "Spec",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSpec()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SourceValidationError{
				field:  "Spec",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetState()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, SourceValidationError{
					field:  "State",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, SourceValidationError{
					field:  "State",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetState()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SourceValidationError{
				field:  "State",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return SourceMultiError(errors)
	}

	return nil
}

// SourceMultiError is an error wrapping multiple validation errors returned by
// Source.ValidateAll() if the designated constraints aren't met.
type SourceMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SourceMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SourceMultiError) AllErrors() []error { return m }

// SourceValidationError is the validation error returned by Source.Validate if
// the designated constraints aren't met.
type SourceValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SourceValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SourceValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SourceValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SourceValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SourceValidationError) ErrorName() string { return "SourceValidationError" }

// Error satisfies the builtin error interface
func (e SourceValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSource.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SourceValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SourceValidationError{}

// Validate checks the field values on SourceSpec with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *SourceSpec) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SourceSpec with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in SourceSpecMultiError, or
// nil if none found.
func (m *SourceSpec) ValidateAll() error {
	return m.validate(true)
}

func (m *SourceSpec) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for SourceConnector

	// no validation rules for SinkConnector

	if all {
		switch v := interface{}(m.GetProperties()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, SourceSpecValidationError{
					field:  "Properties",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, SourceSpecValidationError{
					field:  "Properties",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetProperties()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SourceSpecValidationError{
				field:  "Properties",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetRefreshSchedule()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, SourceSpecValidationError{
					field:  "RefreshSchedule",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, SourceSpecValidationError{
					field:  "RefreshSchedule",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetRefreshSchedule()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SourceSpecValidationError{
				field:  "RefreshSchedule",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for TimeoutSeconds

	// no validation rules for StageChanges

	// no validation rules for StreamIngestion

	// no validation rules for Trigger

	if len(errors) > 0 {
		return SourceSpecMultiError(errors)
	}

	return nil
}

// SourceSpecMultiError is an error wrapping multiple validation errors
// returned by SourceSpec.ValidateAll() if the designated constraints aren't met.
type SourceSpecMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SourceSpecMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SourceSpecMultiError) AllErrors() []error { return m }

// SourceSpecValidationError is the validation error returned by
// SourceSpec.Validate if the designated constraints aren't met.
type SourceSpecValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SourceSpecValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SourceSpecValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SourceSpecValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SourceSpecValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SourceSpecValidationError) ErrorName() string { return "SourceSpecValidationError" }

// Error satisfies the builtin error interface
func (e SourceSpecValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSourceSpec.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SourceSpecValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SourceSpecValidationError{}

// Validate checks the field values on SourceState with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *SourceState) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SourceState with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in SourceStateMultiError, or
// nil if none found.
func (m *SourceState) ValidateAll() error {
	return m.validate(true)
}

func (m *SourceState) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Connector

	// no validation rules for Table

	// no validation rules for SpecHash

	if all {
		switch v := interface{}(m.GetRefreshedOn()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, SourceStateValidationError{
					field:  "RefreshedOn",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, SourceStateValidationError{
					field:  "RefreshedOn",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetRefreshedOn()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SourceStateValidationError{
				field:  "RefreshedOn",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return SourceStateMultiError(errors)
	}

	return nil
}

// SourceStateMultiError is an error wrapping multiple validation errors
// returned by SourceState.ValidateAll() if the designated constraints aren't met.
type SourceStateMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SourceStateMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SourceStateMultiError) AllErrors() []error { return m }

// SourceStateValidationError is the validation error returned by
// SourceState.Validate if the designated constraints aren't met.
type SourceStateValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SourceStateValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SourceStateValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SourceStateValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SourceStateValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SourceStateValidationError) ErrorName() string { return "SourceStateValidationError" }

// Error satisfies the builtin error interface
func (e SourceStateValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSourceState.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SourceStateValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SourceStateValidationError{}

// Validate checks the field values on Model with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Model) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Model with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in ModelMultiError, or nil if none found.
func (m *Model) ValidateAll() error {
	return m.validate(true)
}

func (m *Model) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetSpec()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ModelValidationError{
					field:  "Spec",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ModelValidationError{
					field:  "Spec",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSpec()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ModelValidationError{
				field:  "Spec",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetState()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ModelValidationError{
					field:  "State",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ModelValidationError{
					field:  "State",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetState()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ModelValidationError{
				field:  "State",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ModelMultiError(errors)
	}

	return nil
}

// ModelMultiError is an error wrapping multiple validation errors returned by
// Model.ValidateAll() if the designated constraints aren't met.
type ModelMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ModelMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ModelMultiError) AllErrors() []error { return m }

// ModelValidationError is the validation error returned by Model.Validate if
// the designated constraints aren't met.
type ModelValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ModelValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ModelValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ModelValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ModelValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ModelValidationError) ErrorName() string { return "ModelValidationError" }

// Error satisfies the builtin error interface
func (e ModelValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sModel.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ModelValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ModelValidationError{}

// Validate checks the field values on ModelSpec with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ModelSpec) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ModelSpec with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ModelSpecMultiError, or nil
// if none found.
func (m *ModelSpec) ValidateAll() error {
	return m.validate(true)
}

func (m *ModelSpec) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetRefreshSchedule()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ModelSpecValidationError{
					field:  "RefreshSchedule",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ModelSpecValidationError{
					field:  "RefreshSchedule",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetRefreshSchedule()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ModelSpecValidationError{
				field:  "RefreshSchedule",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for TimeoutSeconds

	// no validation rules for Incremental

	// no validation rules for IncrementalStateResolver

	if all {
		switch v := interface{}(m.GetIncrementalStateResolverProperties()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ModelSpecValidationError{
					field:  "IncrementalStateResolverProperties",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ModelSpecValidationError{
					field:  "IncrementalStateResolverProperties",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetIncrementalStateResolverProperties()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ModelSpecValidationError{
				field:  "IncrementalStateResolverProperties",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for PartitionsResolver

	if all {
		switch v := interface{}(m.GetPartitionsResolverProperties()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ModelSpecValidationError{
					field:  "PartitionsResolverProperties",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ModelSpecValidationError{
					field:  "PartitionsResolverProperties",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPartitionsResolverProperties()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ModelSpecValidationError{
				field:  "PartitionsResolverProperties",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for PartitionsWatermarkField

	// no validation rules for PartitionsConcurrencyLimit

	// no validation rules for InputConnector

	if all {
		switch v := interface{}(m.GetInputProperties()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ModelSpecValidationError{
					field:  "InputProperties",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ModelSpecValidationError{
					field:  "InputProperties",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetInputProperties()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ModelSpecValidationError{
				field:  "InputProperties",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for StageConnector

	if all {
		switch v := interface{}(m.GetStageProperties()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ModelSpecValidationError{
					field:  "StageProperties",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ModelSpecValidationError{
					field:  "StageProperties",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetStageProperties()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ModelSpecValidationError{
				field:  "StageProperties",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for OutputConnector

	if all {
		switch v := interface{}(m.GetOutputProperties()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ModelSpecValidationError{
					field:  "OutputProperties",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ModelSpecValidationError{
					field:  "OutputProperties",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetOutputProperties()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ModelSpecValidationError{
				field:  "OutputProperties",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for ChangeMode

	// no validation rules for Trigger

	// no validation rules for TriggerFull

	// no validation rules for DefinedAsSource

	if len(errors) > 0 {
		return ModelSpecMultiError(errors)
	}

	return nil
}

// ModelSpecMultiError is an error wrapping multiple validation errors returned
// by ModelSpec.ValidateAll() if the designated constraints aren't met.
type ModelSpecMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ModelSpecMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ModelSpecMultiError) AllErrors() []error { return m }

// ModelSpecValidationError is the validation error returned by
// ModelSpec.Validate if the designated constraints aren't met.
type ModelSpecValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ModelSpecValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ModelSpecValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ModelSpecValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ModelSpecValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ModelSpecValidationError) ErrorName() string { return "ModelSpecValidationError" }

// Error satisfies the builtin error interface
func (e ModelSpecValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sModelSpec.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ModelSpecValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ModelSpecValidationError{}

// Validate checks the field values on ModelState with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ModelState) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ModelState with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ModelStateMultiError, or
// nil if none found.
func (m *ModelState) ValidateAll() error {
	return m.validate(true)
}

func (m *ModelState) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ExecutorConnector

	// no validation rules for ResultConnector

	if all {
		switch v := interface{}(m.GetResultProperties()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ModelStateValidationError{
					field:  "ResultProperties",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ModelStateValidationError{
					field:  "ResultProperties",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetResultProperties()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ModelStateValidationError{
				field:  "ResultProperties",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for ResultTable

	// no validation rules for SpecHash

	// no validation rules for RefsHash

	if all {
		switch v := interface{}(m.GetRefreshedOn()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ModelStateValidationError{
					field:  "RefreshedOn",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ModelStateValidationError{
					field:  "RefreshedOn",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetRefreshedOn()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ModelStateValidationError{
				field:  "RefreshedOn",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetIncrementalState()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ModelStateValidationError{
					field:  "IncrementalState",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ModelStateValidationError{
					field:  "IncrementalState",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetIncrementalState()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ModelStateValidationError{
				field:  "IncrementalState",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetIncrementalStateSchema()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ModelStateValidationError{
					field:  "IncrementalStateSchema",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ModelStateValidationError{
					field:  "IncrementalStateSchema",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetIncrementalStateSchema()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ModelStateValidationError{
				field:  "IncrementalStateSchema",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for PartitionsModelId

	// no validation rules for PartitionsHaveErrors

	// no validation rules for TotalExecutionDurationMs

	// no validation rules for LatestExecutionDurationMs

	if len(errors) > 0 {
		return ModelStateMultiError(errors)
	}

	return nil
}

// ModelStateMultiError is an error wrapping multiple validation errors
// returned by ModelState.ValidateAll() if the designated constraints aren't met.
type ModelStateMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ModelStateMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ModelStateMultiError) AllErrors() []error { return m }

// ModelStateValidationError is the validation error returned by
// ModelState.Validate if the designated constraints aren't met.
type ModelStateValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ModelStateValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ModelStateValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ModelStateValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ModelStateValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ModelStateValidationError) ErrorName() string { return "ModelStateValidationError" }

// Error satisfies the builtin error interface
func (e ModelStateValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sModelState.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ModelStateValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ModelStateValidationError{}

// Validate checks the field values on MetricsView with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *MetricsView) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on MetricsView with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in MetricsViewMultiError, or
// nil if none found.
func (m *MetricsView) ValidateAll() error {
	return m.validate(true)
}

func (m *MetricsView) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetSpec()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, MetricsViewValidationError{
					field:  "Spec",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, MetricsViewValidationError{
					field:  "Spec",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSpec()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return MetricsViewValidationError{
				field:  "Spec",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetState()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, MetricsViewValidationError{
					field:  "State",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, MetricsViewValidationError{
					field:  "State",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetState()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return MetricsViewValidationError{
				field:  "State",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return MetricsViewMultiError(errors)
	}

	return nil
}

// MetricsViewMultiError is an error wrapping multiple validation errors
// returned by MetricsView.ValidateAll() if the designated constraints aren't met.
type MetricsViewMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MetricsViewMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MetricsViewMultiError) AllErrors() []error { return m }

// MetricsViewValidationError is the validation error returned by
// MetricsView.Validate if the designated constraints aren't met.
type MetricsViewValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MetricsViewValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MetricsViewValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MetricsViewValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MetricsViewValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MetricsViewValidationError) ErrorName() string { return "MetricsViewValidationError" }

// Error satisfies the builtin error interface
func (e MetricsViewValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMetricsView.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MetricsViewValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MetricsViewValidationError{}

// Validate checks the field values on MetricsViewSpec with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *MetricsViewSpec) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on MetricsViewSpec with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// MetricsViewSpecMultiError, or nil if none found.
func (m *MetricsViewSpec) ValidateAll() error {
	return m.validate(true)
}

func (m *MetricsViewSpec) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Connector

	// no validation rules for Database

	// no validation rules for DatabaseSchema

	// no validation rules for Table

	// no validation rules for Model

	// no validation rules for DisplayName

	// no validation rules for Description

	// no validation rules for AiInstructions

	// no validation rules for TimeDimension

	// no validation rules for SmallestTimeGrain

	// no validation rules for WatermarkExpression

	for idx, item := range m.GetDimensions() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, MetricsViewSpecValidationError{
						field:  fmt.Sprintf("Dimensions[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, MetricsViewSpecValidationError{
						field:  fmt.Sprintf("Dimensions[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return MetricsViewSpecValidationError{
					field:  fmt.Sprintf("Dimensions[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetMeasures() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, MetricsViewSpecValidationError{
						field:  fmt.Sprintf("Measures[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, MetricsViewSpecValidationError{
						field:  fmt.Sprintf("Measures[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return MetricsViewSpecValidationError{
					field:  fmt.Sprintf("Measures[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetSecurityRules() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, MetricsViewSpecValidationError{
						field:  fmt.Sprintf("SecurityRules[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, MetricsViewSpecValidationError{
						field:  fmt.Sprintf("SecurityRules[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return MetricsViewSpecValidationError{
					field:  fmt.Sprintf("SecurityRules[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for FirstDayOfWeek

	// no validation rules for FirstMonthOfYear

	// no validation rules for CacheKeySql

	// no validation rules for CacheKeyTtlSeconds

	if m.CacheEnabled != nil {
		// no validation rules for CacheEnabled
	}

	if len(errors) > 0 {
		return MetricsViewSpecMultiError(errors)
	}

	return nil
}

// MetricsViewSpecMultiError is an error wrapping multiple validation errors
// returned by MetricsViewSpec.ValidateAll() if the designated constraints
// aren't met.
type MetricsViewSpecMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MetricsViewSpecMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MetricsViewSpecMultiError) AllErrors() []error { return m }

// MetricsViewSpecValidationError is the validation error returned by
// MetricsViewSpec.Validate if the designated constraints aren't met.
type MetricsViewSpecValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MetricsViewSpecValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MetricsViewSpecValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MetricsViewSpecValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MetricsViewSpecValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MetricsViewSpecValidationError) ErrorName() string { return "MetricsViewSpecValidationError" }

// Error satisfies the builtin error interface
func (e MetricsViewSpecValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMetricsViewSpec.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MetricsViewSpecValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MetricsViewSpecValidationError{}

// Validate checks the field values on SecurityRule with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *SecurityRule) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SecurityRule with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in SecurityRuleMultiError, or
// nil if none found.
func (m *SecurityRule) ValidateAll() error {
	return m.validate(true)
}

func (m *SecurityRule) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	switch v := m.Rule.(type) {
	case *SecurityRule_Access:
		if v == nil {
			err := SecurityRuleValidationError{
				field:  "Rule",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetAccess()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, SecurityRuleValidationError{
						field:  "Access",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, SecurityRuleValidationError{
						field:  "Access",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetAccess()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return SecurityRuleValidationError{
					field:  "Access",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *SecurityRule_FieldAccess:
		if v == nil {
			err := SecurityRuleValidationError{
				field:  "Rule",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetFieldAccess()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, SecurityRuleValidationError{
						field:  "FieldAccess",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, SecurityRuleValidationError{
						field:  "FieldAccess",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetFieldAccess()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return SecurityRuleValidationError{
					field:  "FieldAccess",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *SecurityRule_RowFilter:
		if v == nil {
			err := SecurityRuleValidationError{
				field:  "Rule",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetRowFilter()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, SecurityRuleValidationError{
						field:  "RowFilter",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, SecurityRuleValidationError{
						field:  "RowFilter",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetRowFilter()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return SecurityRuleValidationError{
					field:  "RowFilter",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	default:
		_ = v // ensures v is used
	}

	if len(errors) > 0 {
		return SecurityRuleMultiError(errors)
	}

	return nil
}

// SecurityRuleMultiError is an error wrapping multiple validation errors
// returned by SecurityRule.ValidateAll() if the designated constraints aren't met.
type SecurityRuleMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SecurityRuleMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SecurityRuleMultiError) AllErrors() []error { return m }

// SecurityRuleValidationError is the validation error returned by
// SecurityRule.Validate if the designated constraints aren't met.
type SecurityRuleValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SecurityRuleValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SecurityRuleValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SecurityRuleValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SecurityRuleValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SecurityRuleValidationError) ErrorName() string { return "SecurityRuleValidationError" }

// Error satisfies the builtin error interface
func (e SecurityRuleValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSecurityRule.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SecurityRuleValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SecurityRuleValidationError{}

// Validate checks the field values on SecurityRuleAccess with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *SecurityRuleAccess) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SecurityRuleAccess with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// SecurityRuleAccessMultiError, or nil if none found.
func (m *SecurityRuleAccess) ValidateAll() error {
	return m.validate(true)
}

func (m *SecurityRuleAccess) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Condition

	// no validation rules for Allow

	if len(errors) > 0 {
		return SecurityRuleAccessMultiError(errors)
	}

	return nil
}

// SecurityRuleAccessMultiError is an error wrapping multiple validation errors
// returned by SecurityRuleAccess.ValidateAll() if the designated constraints
// aren't met.
type SecurityRuleAccessMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SecurityRuleAccessMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SecurityRuleAccessMultiError) AllErrors() []error { return m }

// SecurityRuleAccessValidationError is the validation error returned by
// SecurityRuleAccess.Validate if the designated constraints aren't met.
type SecurityRuleAccessValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SecurityRuleAccessValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SecurityRuleAccessValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SecurityRuleAccessValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SecurityRuleAccessValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SecurityRuleAccessValidationError) ErrorName() string {
	return "SecurityRuleAccessValidationError"
}

// Error satisfies the builtin error interface
func (e SecurityRuleAccessValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSecurityRuleAccess.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SecurityRuleAccessValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SecurityRuleAccessValidationError{}

// Validate checks the field values on SecurityRuleFieldAccess with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *SecurityRuleFieldAccess) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SecurityRuleFieldAccess with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// SecurityRuleFieldAccessMultiError, or nil if none found.
func (m *SecurityRuleFieldAccess) ValidateAll() error {
	return m.validate(true)
}

func (m *SecurityRuleFieldAccess) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Condition

	// no validation rules for Allow

	// no validation rules for AllFields

	if len(errors) > 0 {
		return SecurityRuleFieldAccessMultiError(errors)
	}

	return nil
}

// SecurityRuleFieldAccessMultiError is an error wrapping multiple validation
// errors returned by SecurityRuleFieldAccess.ValidateAll() if the designated
// constraints aren't met.
type SecurityRuleFieldAccessMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SecurityRuleFieldAccessMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SecurityRuleFieldAccessMultiError) AllErrors() []error { return m }

// SecurityRuleFieldAccessValidationError is the validation error returned by
// SecurityRuleFieldAccess.Validate if the designated constraints aren't met.
type SecurityRuleFieldAccessValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SecurityRuleFieldAccessValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SecurityRuleFieldAccessValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SecurityRuleFieldAccessValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SecurityRuleFieldAccessValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SecurityRuleFieldAccessValidationError) ErrorName() string {
	return "SecurityRuleFieldAccessValidationError"
}

// Error satisfies the builtin error interface
func (e SecurityRuleFieldAccessValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSecurityRuleFieldAccess.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SecurityRuleFieldAccessValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SecurityRuleFieldAccessValidationError{}

// Validate checks the field values on SecurityRuleRowFilter with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *SecurityRuleRowFilter) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SecurityRuleRowFilter with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// SecurityRuleRowFilterMultiError, or nil if none found.
func (m *SecurityRuleRowFilter) ValidateAll() error {
	return m.validate(true)
}

func (m *SecurityRuleRowFilter) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Condition

	// no validation rules for Sql

	if all {
		switch v := interface{}(m.GetExpression()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, SecurityRuleRowFilterValidationError{
					field:  "Expression",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, SecurityRuleRowFilterValidationError{
					field:  "Expression",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetExpression()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SecurityRuleRowFilterValidationError{
				field:  "Expression",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return SecurityRuleRowFilterMultiError(errors)
	}

	return nil
}

// SecurityRuleRowFilterMultiError is an error wrapping multiple validation
// errors returned by SecurityRuleRowFilter.ValidateAll() if the designated
// constraints aren't met.
type SecurityRuleRowFilterMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SecurityRuleRowFilterMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SecurityRuleRowFilterMultiError) AllErrors() []error { return m }

// SecurityRuleRowFilterValidationError is the validation error returned by
// SecurityRuleRowFilter.Validate if the designated constraints aren't met.
type SecurityRuleRowFilterValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SecurityRuleRowFilterValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SecurityRuleRowFilterValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SecurityRuleRowFilterValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SecurityRuleRowFilterValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SecurityRuleRowFilterValidationError) ErrorName() string {
	return "SecurityRuleRowFilterValidationError"
}

// Error satisfies the builtin error interface
func (e SecurityRuleRowFilterValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSecurityRuleRowFilter.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SecurityRuleRowFilterValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SecurityRuleRowFilterValidationError{}

// Validate checks the field values on MetricsViewState with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *MetricsViewState) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on MetricsViewState with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// MetricsViewStateMultiError, or nil if none found.
func (m *MetricsViewState) ValidateAll() error {
	return m.validate(true)
}

func (m *MetricsViewState) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetValidSpec()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, MetricsViewStateValidationError{
					field:  "ValidSpec",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, MetricsViewStateValidationError{
					field:  "ValidSpec",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetValidSpec()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return MetricsViewStateValidationError{
				field:  "ValidSpec",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Streaming

	if all {
		switch v := interface{}(m.GetDataRefreshedOn()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, MetricsViewStateValidationError{
					field:  "DataRefreshedOn",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, MetricsViewStateValidationError{
					field:  "DataRefreshedOn",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDataRefreshedOn()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return MetricsViewStateValidationError{
				field:  "DataRefreshedOn",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return MetricsViewStateMultiError(errors)
	}

	return nil
}

// MetricsViewStateMultiError is an error wrapping multiple validation errors
// returned by MetricsViewState.ValidateAll() if the designated constraints
// aren't met.
type MetricsViewStateMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MetricsViewStateMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MetricsViewStateMultiError) AllErrors() []error { return m }

// MetricsViewStateValidationError is the validation error returned by
// MetricsViewState.Validate if the designated constraints aren't met.
type MetricsViewStateValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MetricsViewStateValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MetricsViewStateValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MetricsViewStateValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MetricsViewStateValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MetricsViewStateValidationError) ErrorName() string { return "MetricsViewStateValidationError" }

// Error satisfies the builtin error interface
func (e MetricsViewStateValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMetricsViewState.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MetricsViewStateValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MetricsViewStateValidationError{}

// Validate checks the field values on Explore with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Explore) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Explore with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in ExploreMultiError, or nil if none found.
func (m *Explore) ValidateAll() error {
	return m.validate(true)
}

func (m *Explore) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetSpec()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ExploreValidationError{
					field:  "Spec",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ExploreValidationError{
					field:  "Spec",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSpec()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ExploreValidationError{
				field:  "Spec",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetState()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ExploreValidationError{
					field:  "State",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ExploreValidationError{
					field:  "State",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetState()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ExploreValidationError{
				field:  "State",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ExploreMultiError(errors)
	}

	return nil
}

// ExploreMultiError is an error wrapping multiple validation errors returned
// by Explore.ValidateAll() if the designated constraints aren't met.
type ExploreMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ExploreMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ExploreMultiError) AllErrors() []error { return m }

// ExploreValidationError is the validation error returned by Explore.Validate
// if the designated constraints aren't met.
type ExploreValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ExploreValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ExploreValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ExploreValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ExploreValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ExploreValidationError) ErrorName() string { return "ExploreValidationError" }

// Error satisfies the builtin error interface
func (e ExploreValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sExplore.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ExploreValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ExploreValidationError{}

// Validate checks the field values on ExploreSpec with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ExploreSpec) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ExploreSpec with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ExploreSpecMultiError, or
// nil if none found.
func (m *ExploreSpec) ValidateAll() error {
	return m.validate(true)
}

func (m *ExploreSpec) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for DisplayName

	// no validation rules for Description

	// no validation rules for MetricsView

	if all {
		switch v := interface{}(m.GetDimensionsSelector()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ExploreSpecValidationError{
					field:  "DimensionsSelector",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ExploreSpecValidationError{
					field:  "DimensionsSelector",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDimensionsSelector()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ExploreSpecValidationError{
				field:  "DimensionsSelector",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetMeasuresSelector()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ExploreSpecValidationError{
					field:  "MeasuresSelector",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ExploreSpecValidationError{
					field:  "MeasuresSelector",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetMeasuresSelector()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ExploreSpecValidationError{
				field:  "MeasuresSelector",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Theme

	if all {
		switch v := interface{}(m.GetEmbeddedTheme()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ExploreSpecValidationError{
					field:  "EmbeddedTheme",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ExploreSpecValidationError{
					field:  "EmbeddedTheme",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetEmbeddedTheme()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ExploreSpecValidationError{
				field:  "EmbeddedTheme",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetTimeRanges() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ExploreSpecValidationError{
						field:  fmt.Sprintf("TimeRanges[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ExploreSpecValidationError{
						field:  fmt.Sprintf("TimeRanges[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ExploreSpecValidationError{
					field:  fmt.Sprintf("TimeRanges[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if all {
		switch v := interface{}(m.GetDefaultPreset()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ExploreSpecValidationError{
					field:  "DefaultPreset",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ExploreSpecValidationError{
					field:  "DefaultPreset",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDefaultPreset()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ExploreSpecValidationError{
				field:  "DefaultPreset",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for EmbedsHidePivot

	for idx, item := range m.GetSecurityRules() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ExploreSpecValidationError{
						field:  fmt.Sprintf("SecurityRules[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ExploreSpecValidationError{
						field:  fmt.Sprintf("SecurityRules[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ExploreSpecValidationError{
					field:  fmt.Sprintf("SecurityRules[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for Banner

	// no validation rules for LockTimeZone

	// no validation rules for AllowCustomTimeRange

	// no validation rules for DefinedInMetricsView

	if len(errors) > 0 {
		return ExploreSpecMultiError(errors)
	}

	return nil
}

// ExploreSpecMultiError is an error wrapping multiple validation errors
// returned by ExploreSpec.ValidateAll() if the designated constraints aren't met.
type ExploreSpecMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ExploreSpecMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ExploreSpecMultiError) AllErrors() []error { return m }

// ExploreSpecValidationError is the validation error returned by
// ExploreSpec.Validate if the designated constraints aren't met.
type ExploreSpecValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ExploreSpecValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ExploreSpecValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ExploreSpecValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ExploreSpecValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ExploreSpecValidationError) ErrorName() string { return "ExploreSpecValidationError" }

// Error satisfies the builtin error interface
func (e ExploreSpecValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sExploreSpec.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ExploreSpecValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ExploreSpecValidationError{}

// Validate checks the field values on ExploreState with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ExploreState) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ExploreState with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ExploreStateMultiError, or
// nil if none found.
func (m *ExploreState) ValidateAll() error {
	return m.validate(true)
}

func (m *ExploreState) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetValidSpec()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ExploreStateValidationError{
					field:  "ValidSpec",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ExploreStateValidationError{
					field:  "ValidSpec",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetValidSpec()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ExploreStateValidationError{
				field:  "ValidSpec",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetDataRefreshedOn()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ExploreStateValidationError{
					field:  "DataRefreshedOn",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ExploreStateValidationError{
					field:  "DataRefreshedOn",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDataRefreshedOn()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ExploreStateValidationError{
				field:  "DataRefreshedOn",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ExploreStateMultiError(errors)
	}

	return nil
}

// ExploreStateMultiError is an error wrapping multiple validation errors
// returned by ExploreState.ValidateAll() if the designated constraints aren't met.
type ExploreStateMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ExploreStateMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ExploreStateMultiError) AllErrors() []error { return m }

// ExploreStateValidationError is the validation error returned by
// ExploreState.Validate if the designated constraints aren't met.
type ExploreStateValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ExploreStateValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ExploreStateValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ExploreStateValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ExploreStateValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ExploreStateValidationError) ErrorName() string { return "ExploreStateValidationError" }

// Error satisfies the builtin error interface
func (e ExploreStateValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sExploreState.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ExploreStateValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ExploreStateValidationError{}

// Validate checks the field values on ExploreTimeRange with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *ExploreTimeRange) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ExploreTimeRange with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ExploreTimeRangeMultiError, or nil if none found.
func (m *ExploreTimeRange) ValidateAll() error {
	return m.validate(true)
}

func (m *ExploreTimeRange) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Range

	for idx, item := range m.GetComparisonTimeRanges() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ExploreTimeRangeValidationError{
						field:  fmt.Sprintf("ComparisonTimeRanges[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ExploreTimeRangeValidationError{
						field:  fmt.Sprintf("ComparisonTimeRanges[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ExploreTimeRangeValidationError{
					field:  fmt.Sprintf("ComparisonTimeRanges[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ExploreTimeRangeMultiError(errors)
	}

	return nil
}

// ExploreTimeRangeMultiError is an error wrapping multiple validation errors
// returned by ExploreTimeRange.ValidateAll() if the designated constraints
// aren't met.
type ExploreTimeRangeMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ExploreTimeRangeMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ExploreTimeRangeMultiError) AllErrors() []error { return m }

// ExploreTimeRangeValidationError is the validation error returned by
// ExploreTimeRange.Validate if the designated constraints aren't met.
type ExploreTimeRangeValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ExploreTimeRangeValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ExploreTimeRangeValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ExploreTimeRangeValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ExploreTimeRangeValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ExploreTimeRangeValidationError) ErrorName() string { return "ExploreTimeRangeValidationError" }

// Error satisfies the builtin error interface
func (e ExploreTimeRangeValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sExploreTimeRange.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ExploreTimeRangeValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ExploreTimeRangeValidationError{}

// Validate checks the field values on ExploreComparisonTimeRange with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ExploreComparisonTimeRange) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ExploreComparisonTimeRange with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ExploreComparisonTimeRangeMultiError, or nil if none found.
func (m *ExploreComparisonTimeRange) ValidateAll() error {
	return m.validate(true)
}

func (m *ExploreComparisonTimeRange) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Offset

	// no validation rules for Range

	if len(errors) > 0 {
		return ExploreComparisonTimeRangeMultiError(errors)
	}

	return nil
}

// ExploreComparisonTimeRangeMultiError is an error wrapping multiple
// validation errors returned by ExploreComparisonTimeRange.ValidateAll() if
// the designated constraints aren't met.
type ExploreComparisonTimeRangeMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ExploreComparisonTimeRangeMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ExploreComparisonTimeRangeMultiError) AllErrors() []error { return m }

// ExploreComparisonTimeRangeValidationError is the validation error returned
// by ExploreComparisonTimeRange.Validate if the designated constraints aren't met.
type ExploreComparisonTimeRangeValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ExploreComparisonTimeRangeValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ExploreComparisonTimeRangeValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ExploreComparisonTimeRangeValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ExploreComparisonTimeRangeValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ExploreComparisonTimeRangeValidationError) ErrorName() string {
	return "ExploreComparisonTimeRangeValidationError"
}

// Error satisfies the builtin error interface
func (e ExploreComparisonTimeRangeValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sExploreComparisonTimeRange.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ExploreComparisonTimeRangeValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ExploreComparisonTimeRangeValidationError{}

// Validate checks the field values on ExplorePreset with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ExplorePreset) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ExplorePreset with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ExplorePresetMultiError, or
// nil if none found.
func (m *ExplorePreset) ValidateAll() error {
	return m.validate(true)
}

func (m *ExplorePreset) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetDimensionsSelector()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ExplorePresetValidationError{
					field:  "DimensionsSelector",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ExplorePresetValidationError{
					field:  "DimensionsSelector",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDimensionsSelector()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ExplorePresetValidationError{
				field:  "DimensionsSelector",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetMeasuresSelector()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ExplorePresetValidationError{
					field:  "MeasuresSelector",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ExplorePresetValidationError{
					field:  "MeasuresSelector",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetMeasuresSelector()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ExplorePresetValidationError{
				field:  "MeasuresSelector",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for ComparisonMode

	if m.Where != nil {

		if all {
			switch v := interface{}(m.GetWhere()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ExplorePresetValidationError{
						field:  "Where",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ExplorePresetValidationError{
						field:  "Where",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetWhere()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ExplorePresetValidationError{
					field:  "Where",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if m.TimeRange != nil {
		// no validation rules for TimeRange
	}

	if m.Timezone != nil {
		// no validation rules for Timezone
	}

	if m.TimeGrain != nil {
		// no validation rules for TimeGrain
	}

	if m.SelectTimeRange != nil {
		// no validation rules for SelectTimeRange
	}

	if m.CompareTimeRange != nil {
		// no validation rules for CompareTimeRange
	}

	if m.ComparisonDimension != nil {
		// no validation rules for ComparisonDimension
	}

	if m.View != nil {
		// no validation rules for View
	}

	if m.ExploreSortBy != nil {
		// no validation rules for ExploreSortBy
	}

	if m.ExploreSortAsc != nil {
		// no validation rules for ExploreSortAsc
	}

	if m.ExploreSortType != nil {
		// no validation rules for ExploreSortType
	}

	if m.ExploreExpandedDimension != nil {
		// no validation rules for ExploreExpandedDimension
	}

	if m.ExploreLeaderboardMeasureCount != nil {
		// no validation rules for ExploreLeaderboardMeasureCount
	}

	if m.ExploreLeaderboardShowContextForAllMeasures != nil {
		// no validation rules for ExploreLeaderboardShowContextForAllMeasures
	}

	if m.TimeDimensionMeasure != nil {
		// no validation rules for TimeDimensionMeasure
	}

	if m.TimeDimensionChartType != nil {
		// no validation rules for TimeDimensionChartType
	}

	if m.TimeDimensionPin != nil {
		// no validation rules for TimeDimensionPin
	}

	if m.PivotSortBy != nil {
		// no validation rules for PivotSortBy
	}

	if m.PivotSortAsc != nil {
		// no validation rules for PivotSortAsc
	}

	if m.PivotTableMode != nil {
		// no validation rules for PivotTableMode
	}

	if len(errors) > 0 {
		return ExplorePresetMultiError(errors)
	}

	return nil
}

// ExplorePresetMultiError is an error wrapping multiple validation errors
// returned by ExplorePreset.ValidateAll() if the designated constraints
// aren't met.
type ExplorePresetMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ExplorePresetMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ExplorePresetMultiError) AllErrors() []error { return m }

// ExplorePresetValidationError is the validation error returned by
// ExplorePreset.Validate if the designated constraints aren't met.
type ExplorePresetValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ExplorePresetValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ExplorePresetValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ExplorePresetValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ExplorePresetValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ExplorePresetValidationError) ErrorName() string { return "ExplorePresetValidationError" }

// Error satisfies the builtin error interface
func (e ExplorePresetValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sExplorePreset.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ExplorePresetValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ExplorePresetValidationError{}

// Validate checks the field values on FieldSelector with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *FieldSelector) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on FieldSelector with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in FieldSelectorMultiError, or
// nil if none found.
func (m *FieldSelector) ValidateAll() error {
	return m.validate(true)
}

func (m *FieldSelector) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Invert

	switch v := m.Selector.(type) {
	case *FieldSelector_All:
		if v == nil {
			err := FieldSelectorValidationError{
				field:  "Selector",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		// no validation rules for All
	case *FieldSelector_Fields:
		if v == nil {
			err := FieldSelectorValidationError{
				field:  "Selector",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetFields()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, FieldSelectorValidationError{
						field:  "Fields",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, FieldSelectorValidationError{
						field:  "Fields",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetFields()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return FieldSelectorValidationError{
					field:  "Fields",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *FieldSelector_Regex:
		if v == nil {
			err := FieldSelectorValidationError{
				field:  "Selector",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		// no validation rules for Regex
	case *FieldSelector_DuckdbExpression:
		if v == nil {
			err := FieldSelectorValidationError{
				field:  "Selector",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		// no validation rules for DuckdbExpression
	default:
		_ = v // ensures v is used
	}

	if len(errors) > 0 {
		return FieldSelectorMultiError(errors)
	}

	return nil
}

// FieldSelectorMultiError is an error wrapping multiple validation errors
// returned by FieldSelector.ValidateAll() if the designated constraints
// aren't met.
type FieldSelectorMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m FieldSelectorMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m FieldSelectorMultiError) AllErrors() []error { return m }

// FieldSelectorValidationError is the validation error returned by
// FieldSelector.Validate if the designated constraints aren't met.
type FieldSelectorValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e FieldSelectorValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e FieldSelectorValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e FieldSelectorValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e FieldSelectorValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e FieldSelectorValidationError) ErrorName() string { return "FieldSelectorValidationError" }

// Error satisfies the builtin error interface
func (e FieldSelectorValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sFieldSelector.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = FieldSelectorValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = FieldSelectorValidationError{}

// Validate checks the field values on StringListValue with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *StringListValue) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on StringListValue with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// StringListValueMultiError, or nil if none found.
func (m *StringListValue) ValidateAll() error {
	return m.validate(true)
}

func (m *StringListValue) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return StringListValueMultiError(errors)
	}

	return nil
}

// StringListValueMultiError is an error wrapping multiple validation errors
// returned by StringListValue.ValidateAll() if the designated constraints
// aren't met.
type StringListValueMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m StringListValueMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m StringListValueMultiError) AllErrors() []error { return m }

// StringListValueValidationError is the validation error returned by
// StringListValue.Validate if the designated constraints aren't met.
type StringListValueValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e StringListValueValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e StringListValueValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e StringListValueValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e StringListValueValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e StringListValueValidationError) ErrorName() string { return "StringListValueValidationError" }

// Error satisfies the builtin error interface
func (e StringListValueValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sStringListValue.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = StringListValueValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = StringListValueValidationError{}

// Validate checks the field values on Migration with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Migration) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Migration with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in MigrationMultiError, or nil
// if none found.
func (m *Migration) ValidateAll() error {
	return m.validate(true)
}

func (m *Migration) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetSpec()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, MigrationValidationError{
					field:  "Spec",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, MigrationValidationError{
					field:  "Spec",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSpec()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return MigrationValidationError{
				field:  "Spec",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetState()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, MigrationValidationError{
					field:  "State",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, MigrationValidationError{
					field:  "State",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetState()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return MigrationValidationError{
				field:  "State",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return MigrationMultiError(errors)
	}

	return nil
}

// MigrationMultiError is an error wrapping multiple validation errors returned
// by Migration.ValidateAll() if the designated constraints aren't met.
type MigrationMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MigrationMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MigrationMultiError) AllErrors() []error { return m }

// MigrationValidationError is the validation error returned by
// Migration.Validate if the designated constraints aren't met.
type MigrationValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MigrationValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MigrationValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MigrationValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MigrationValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MigrationValidationError) ErrorName() string { return "MigrationValidationError" }

// Error satisfies the builtin error interface
func (e MigrationValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMigration.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MigrationValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MigrationValidationError{}

// Validate checks the field values on MigrationSpec with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *MigrationSpec) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on MigrationSpec with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in MigrationSpecMultiError, or
// nil if none found.
func (m *MigrationSpec) ValidateAll() error {
	return m.validate(true)
}

func (m *MigrationSpec) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Connector

	// no validation rules for Sql

	// no validation rules for Version

	if len(errors) > 0 {
		return MigrationSpecMultiError(errors)
	}

	return nil
}

// MigrationSpecMultiError is an error wrapping multiple validation errors
// returned by MigrationSpec.ValidateAll() if the designated constraints
// aren't met.
type MigrationSpecMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MigrationSpecMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MigrationSpecMultiError) AllErrors() []error { return m }

// MigrationSpecValidationError is the validation error returned by
// MigrationSpec.Validate if the designated constraints aren't met.
type MigrationSpecValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MigrationSpecValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MigrationSpecValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MigrationSpecValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MigrationSpecValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MigrationSpecValidationError) ErrorName() string { return "MigrationSpecValidationError" }

// Error satisfies the builtin error interface
func (e MigrationSpecValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMigrationSpec.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MigrationSpecValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MigrationSpecValidationError{}

// Validate checks the field values on MigrationState with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *MigrationState) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on MigrationState with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in MigrationStateMultiError,
// or nil if none found.
func (m *MigrationState) ValidateAll() error {
	return m.validate(true)
}

func (m *MigrationState) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Version

	if len(errors) > 0 {
		return MigrationStateMultiError(errors)
	}

	return nil
}

// MigrationStateMultiError is an error wrapping multiple validation errors
// returned by MigrationState.ValidateAll() if the designated constraints
// aren't met.
type MigrationStateMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MigrationStateMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MigrationStateMultiError) AllErrors() []error { return m }

// MigrationStateValidationError is the validation error returned by
// MigrationState.Validate if the designated constraints aren't met.
type MigrationStateValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MigrationStateValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MigrationStateValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MigrationStateValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MigrationStateValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MigrationStateValidationError) ErrorName() string { return "MigrationStateValidationError" }

// Error satisfies the builtin error interface
func (e MigrationStateValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMigrationState.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MigrationStateValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MigrationStateValidationError{}

// Validate checks the field values on Report with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Report) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Report with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in ReportMultiError, or nil if none found.
func (m *Report) ValidateAll() error {
	return m.validate(true)
}

func (m *Report) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetSpec()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ReportValidationError{
					field:  "Spec",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ReportValidationError{
					field:  "Spec",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSpec()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ReportValidationError{
				field:  "Spec",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetState()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ReportValidationError{
					field:  "State",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ReportValidationError{
					field:  "State",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetState()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ReportValidationError{
				field:  "State",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ReportMultiError(errors)
	}

	return nil
}

// ReportMultiError is an error wrapping multiple validation errors returned by
// Report.ValidateAll() if the designated constraints aren't met.
type ReportMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ReportMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ReportMultiError) AllErrors() []error { return m }

// ReportValidationError is the validation error returned by Report.Validate if
// the designated constraints aren't met.
type ReportValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ReportValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ReportValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ReportValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ReportValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ReportValidationError) ErrorName() string { return "ReportValidationError" }

// Error satisfies the builtin error interface
func (e ReportValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sReport.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ReportValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ReportValidationError{}

// Validate checks the field values on ReportSpec with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ReportSpec) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ReportSpec with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ReportSpecMultiError, or
// nil if none found.
func (m *ReportSpec) ValidateAll() error {
	return m.validate(true)
}

func (m *ReportSpec) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for DisplayName

	// no validation rules for Trigger

	if all {
		switch v := interface{}(m.GetRefreshSchedule()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ReportSpecValidationError{
					field:  "RefreshSchedule",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ReportSpecValidationError{
					field:  "RefreshSchedule",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetRefreshSchedule()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ReportSpecValidationError{
				field:  "RefreshSchedule",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for TimeoutSeconds

	// no validation rules for QueryName

	// no validation rules for QueryArgsJson

	// no validation rules for ExportLimit

	// no validation rules for ExportFormat

	// no validation rules for ExportIncludeHeader

	for idx, item := range m.GetNotifiers() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ReportSpecValidationError{
						field:  fmt.Sprintf("Notifiers[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ReportSpecValidationError{
						field:  fmt.Sprintf("Notifiers[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ReportSpecValidationError{
					field:  fmt.Sprintf("Notifiers[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for Annotations

	// no validation rules for WatermarkInherit

	// no validation rules for IntervalsIsoDuration

	// no validation rules for IntervalsLimit

	// no validation rules for IntervalsCheckUnclosed

	if len(errors) > 0 {
		return ReportSpecMultiError(errors)
	}

	return nil
}

// ReportSpecMultiError is an error wrapping multiple validation errors
// returned by ReportSpec.ValidateAll() if the designated constraints aren't met.
type ReportSpecMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ReportSpecMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ReportSpecMultiError) AllErrors() []error { return m }

// ReportSpecValidationError is the validation error returned by
// ReportSpec.Validate if the designated constraints aren't met.
type ReportSpecValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ReportSpecValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ReportSpecValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ReportSpecValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ReportSpecValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ReportSpecValidationError) ErrorName() string { return "ReportSpecValidationError" }

// Error satisfies the builtin error interface
func (e ReportSpecValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sReportSpec.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ReportSpecValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ReportSpecValidationError{}

// Validate checks the field values on ReportState with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ReportState) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ReportState with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ReportStateMultiError, or
// nil if none found.
func (m *ReportState) ValidateAll() error {
	return m.validate(true)
}

func (m *ReportState) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetNextRunOn()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ReportStateValidationError{
					field:  "NextRunOn",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ReportStateValidationError{
					field:  "NextRunOn",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetNextRunOn()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ReportStateValidationError{
				field:  "NextRunOn",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetCurrentExecution()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ReportStateValidationError{
					field:  "CurrentExecution",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ReportStateValidationError{
					field:  "CurrentExecution",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCurrentExecution()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ReportStateValidationError{
				field:  "CurrentExecution",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetExecutionHistory() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ReportStateValidationError{
						field:  fmt.Sprintf("ExecutionHistory[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ReportStateValidationError{
						field:  fmt.Sprintf("ExecutionHistory[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ReportStateValidationError{
					field:  fmt.Sprintf("ExecutionHistory[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for ExecutionCount

	if len(errors) > 0 {
		return ReportStateMultiError(errors)
	}

	return nil
}

// ReportStateMultiError is an error wrapping multiple validation errors
// returned by ReportState.ValidateAll() if the designated constraints aren't met.
type ReportStateMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ReportStateMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ReportStateMultiError) AllErrors() []error { return m }

// ReportStateValidationError is the validation error returned by
// ReportState.Validate if the designated constraints aren't met.
type ReportStateValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ReportStateValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ReportStateValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ReportStateValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ReportStateValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ReportStateValidationError) ErrorName() string { return "ReportStateValidationError" }

// Error satisfies the builtin error interface
func (e ReportStateValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sReportState.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ReportStateValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ReportStateValidationError{}

// Validate checks the field values on ReportExecution with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *ReportExecution) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ReportExecution with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ReportExecutionMultiError, or nil if none found.
func (m *ReportExecution) ValidateAll() error {
	return m.validate(true)
}

func (m *ReportExecution) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Adhoc

	// no validation rules for ErrorMessage

	if all {
		switch v := interface{}(m.GetReportTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ReportExecutionValidationError{
					field:  "ReportTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ReportExecutionValidationError{
					field:  "ReportTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetReportTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ReportExecutionValidationError{
				field:  "ReportTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetStartedOn()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ReportExecutionValidationError{
					field:  "StartedOn",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ReportExecutionValidationError{
					field:  "StartedOn",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetStartedOn()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ReportExecutionValidationError{
				field:  "StartedOn",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetFinishedOn()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ReportExecutionValidationError{
					field:  "FinishedOn",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ReportExecutionValidationError{
					field:  "FinishedOn",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetFinishedOn()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ReportExecutionValidationError{
				field:  "FinishedOn",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ReportExecutionMultiError(errors)
	}

	return nil
}

// ReportExecutionMultiError is an error wrapping multiple validation errors
// returned by ReportExecution.ValidateAll() if the designated constraints
// aren't met.
type ReportExecutionMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ReportExecutionMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ReportExecutionMultiError) AllErrors() []error { return m }

// ReportExecutionValidationError is the validation error returned by
// ReportExecution.Validate if the designated constraints aren't met.
type ReportExecutionValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ReportExecutionValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ReportExecutionValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ReportExecutionValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ReportExecutionValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ReportExecutionValidationError) ErrorName() string { return "ReportExecutionValidationError" }

// Error satisfies the builtin error interface
func (e ReportExecutionValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sReportExecution.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ReportExecutionValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ReportExecutionValidationError{}

// Validate checks the field values on Alert with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Alert) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Alert with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in AlertMultiError, or nil if none found.
func (m *Alert) ValidateAll() error {
	return m.validate(true)
}

func (m *Alert) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetSpec()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, AlertValidationError{
					field:  "Spec",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, AlertValidationError{
					field:  "Spec",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSpec()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return AlertValidationError{
				field:  "Spec",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetState()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, AlertValidationError{
					field:  "State",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, AlertValidationError{
					field:  "State",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetState()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return AlertValidationError{
				field:  "State",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return AlertMultiError(errors)
	}

	return nil
}

// AlertMultiError is an error wrapping multiple validation errors returned by
// Alert.ValidateAll() if the designated constraints aren't met.
type AlertMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AlertMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AlertMultiError) AllErrors() []error { return m }

// AlertValidationError is the validation error returned by Alert.Validate if
// the designated constraints aren't met.
type AlertValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AlertValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AlertValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AlertValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AlertValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AlertValidationError) ErrorName() string { return "AlertValidationError" }

// Error satisfies the builtin error interface
func (e AlertValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAlert.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AlertValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AlertValidationError{}

// Validate checks the field values on AlertSpec with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *AlertSpec) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on AlertSpec with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in AlertSpecMultiError, or nil
// if none found.
func (m *AlertSpec) ValidateAll() error {
	return m.validate(true)
}

func (m *AlertSpec) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for DisplayName

	// no validation rules for Trigger

	if all {
		switch v := interface{}(m.GetRefreshSchedule()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, AlertSpecValidationError{
					field:  "RefreshSchedule",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, AlertSpecValidationError{
					field:  "RefreshSchedule",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetRefreshSchedule()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return AlertSpecValidationError{
				field:  "RefreshSchedule",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for WatermarkInherit

	// no validation rules for IntervalsIsoDuration

	// no validation rules for IntervalsLimit

	// no validation rules for IntervalsCheckUnclosed

	// no validation rules for TimeoutSeconds

	// no validation rules for QueryName

	// no validation rules for QueryArgsJson

	// no validation rules for Resolver

	if all {
		switch v := interface{}(m.GetResolverProperties()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, AlertSpecValidationError{
					field:  "ResolverProperties",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, AlertSpecValidationError{
					field:  "ResolverProperties",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetResolverProperties()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return AlertSpecValidationError{
				field:  "ResolverProperties",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for NotifyOnRecover

	// no validation rules for NotifyOnFail

	// no validation rules for NotifyOnError

	// no validation rules for Renotify

	// no validation rules for RenotifyAfterSeconds

	for idx, item := range m.GetNotifiers() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, AlertSpecValidationError{
						field:  fmt.Sprintf("Notifiers[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, AlertSpecValidationError{
						field:  fmt.Sprintf("Notifiers[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return AlertSpecValidationError{
					field:  fmt.Sprintf("Notifiers[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for Annotations

	switch v := m.QueryFor.(type) {
	case *AlertSpec_QueryForUserId:
		if v == nil {
			err := AlertSpecValidationError{
				field:  "QueryFor",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		// no validation rules for QueryForUserId
	case *AlertSpec_QueryForUserEmail:
		if v == nil {
			err := AlertSpecValidationError{
				field:  "QueryFor",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		// no validation rules for QueryForUserEmail
	case *AlertSpec_QueryForAttributes:
		if v == nil {
			err := AlertSpecValidationError{
				field:  "QueryFor",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetQueryForAttributes()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, AlertSpecValidationError{
						field:  "QueryForAttributes",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, AlertSpecValidationError{
						field:  "QueryForAttributes",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetQueryForAttributes()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return AlertSpecValidationError{
					field:  "QueryForAttributes",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	default:
		_ = v // ensures v is used
	}

	if len(errors) > 0 {
		return AlertSpecMultiError(errors)
	}

	return nil
}

// AlertSpecMultiError is an error wrapping multiple validation errors returned
// by AlertSpec.ValidateAll() if the designated constraints aren't met.
type AlertSpecMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AlertSpecMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AlertSpecMultiError) AllErrors() []error { return m }

// AlertSpecValidationError is the validation error returned by
// AlertSpec.Validate if the designated constraints aren't met.
type AlertSpecValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AlertSpecValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AlertSpecValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AlertSpecValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AlertSpecValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AlertSpecValidationError) ErrorName() string { return "AlertSpecValidationError" }

// Error satisfies the builtin error interface
func (e AlertSpecValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAlertSpec.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AlertSpecValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AlertSpecValidationError{}

// Validate checks the field values on Notifier with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Notifier) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Notifier with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in NotifierMultiError, or nil
// if none found.
func (m *Notifier) ValidateAll() error {
	return m.validate(true)
}

func (m *Notifier) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Connector

	if all {
		switch v := interface{}(m.GetProperties()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, NotifierValidationError{
					field:  "Properties",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, NotifierValidationError{
					field:  "Properties",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetProperties()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return NotifierValidationError{
				field:  "Properties",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return NotifierMultiError(errors)
	}

	return nil
}

// NotifierMultiError is an error wrapping multiple validation errors returned
// by Notifier.ValidateAll() if the designated constraints aren't met.
type NotifierMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m NotifierMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m NotifierMultiError) AllErrors() []error { return m }

// NotifierValidationError is the validation error returned by
// Notifier.Validate if the designated constraints aren't met.
type NotifierValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e NotifierValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e NotifierValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e NotifierValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e NotifierValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e NotifierValidationError) ErrorName() string { return "NotifierValidationError" }

// Error satisfies the builtin error interface
func (e NotifierValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sNotifier.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = NotifierValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = NotifierValidationError{}

// Validate checks the field values on AlertState with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *AlertState) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on AlertState with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in AlertStateMultiError, or
// nil if none found.
func (m *AlertState) ValidateAll() error {
	return m.validate(true)
}

func (m *AlertState) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for SpecHash

	// no validation rules for RefsHash

	if all {
		switch v := interface{}(m.GetNextRunOn()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, AlertStateValidationError{
					field:  "NextRunOn",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, AlertStateValidationError{
					field:  "NextRunOn",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetNextRunOn()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return AlertStateValidationError{
				field:  "NextRunOn",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetCurrentExecution()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, AlertStateValidationError{
					field:  "CurrentExecution",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, AlertStateValidationError{
					field:  "CurrentExecution",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCurrentExecution()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return AlertStateValidationError{
				field:  "CurrentExecution",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetExecutionHistory() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, AlertStateValidationError{
						field:  fmt.Sprintf("ExecutionHistory[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, AlertStateValidationError{
						field:  fmt.Sprintf("ExecutionHistory[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return AlertStateValidationError{
					field:  fmt.Sprintf("ExecutionHistory[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for ExecutionCount

	if len(errors) > 0 {
		return AlertStateMultiError(errors)
	}

	return nil
}

// AlertStateMultiError is an error wrapping multiple validation errors
// returned by AlertState.ValidateAll() if the designated constraints aren't met.
type AlertStateMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AlertStateMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AlertStateMultiError) AllErrors() []error { return m }

// AlertStateValidationError is the validation error returned by
// AlertState.Validate if the designated constraints aren't met.
type AlertStateValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AlertStateValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AlertStateValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AlertStateValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AlertStateValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AlertStateValidationError) ErrorName() string { return "AlertStateValidationError" }

// Error satisfies the builtin error interface
func (e AlertStateValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAlertState.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AlertStateValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AlertStateValidationError{}

// Validate checks the field values on AlertExecution with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *AlertExecution) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on AlertExecution with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in AlertExecutionMultiError,
// or nil if none found.
func (m *AlertExecution) ValidateAll() error {
	return m.validate(true)
}

func (m *AlertExecution) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Adhoc

	if all {
		switch v := interface{}(m.GetResult()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, AlertExecutionValidationError{
					field:  "Result",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, AlertExecutionValidationError{
					field:  "Result",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetResult()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return AlertExecutionValidationError{
				field:  "Result",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for SentNotifications

	if all {
		switch v := interface{}(m.GetExecutionTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, AlertExecutionValidationError{
					field:  "ExecutionTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, AlertExecutionValidationError{
					field:  "ExecutionTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetExecutionTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return AlertExecutionValidationError{
				field:  "ExecutionTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetStartedOn()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, AlertExecutionValidationError{
					field:  "StartedOn",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, AlertExecutionValidationError{
					field:  "StartedOn",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetStartedOn()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return AlertExecutionValidationError{
				field:  "StartedOn",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetFinishedOn()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, AlertExecutionValidationError{
					field:  "FinishedOn",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, AlertExecutionValidationError{
					field:  "FinishedOn",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetFinishedOn()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return AlertExecutionValidationError{
				field:  "FinishedOn",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetSuppressedSince()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, AlertExecutionValidationError{
					field:  "SuppressedSince",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, AlertExecutionValidationError{
					field:  "SuppressedSince",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSuppressedSince()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return AlertExecutionValidationError{
				field:  "SuppressedSince",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return AlertExecutionMultiError(errors)
	}

	return nil
}

// AlertExecutionMultiError is an error wrapping multiple validation errors
// returned by AlertExecution.ValidateAll() if the designated constraints
// aren't met.
type AlertExecutionMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AlertExecutionMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AlertExecutionMultiError) AllErrors() []error { return m }

// AlertExecutionValidationError is the validation error returned by
// AlertExecution.Validate if the designated constraints aren't met.
type AlertExecutionValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AlertExecutionValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AlertExecutionValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AlertExecutionValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AlertExecutionValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AlertExecutionValidationError) ErrorName() string { return "AlertExecutionValidationError" }

// Error satisfies the builtin error interface
func (e AlertExecutionValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAlertExecution.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AlertExecutionValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AlertExecutionValidationError{}

// Validate checks the field values on AssertionResult with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *AssertionResult) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on AssertionResult with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// AssertionResultMultiError, or nil if none found.
func (m *AssertionResult) ValidateAll() error {
	return m.validate(true)
}

func (m *AssertionResult) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Status

	if all {
		switch v := interface{}(m.GetFailRow()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, AssertionResultValidationError{
					field:  "FailRow",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, AssertionResultValidationError{
					field:  "FailRow",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetFailRow()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return AssertionResultValidationError{
				field:  "FailRow",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for ErrorMessage

	if len(errors) > 0 {
		return AssertionResultMultiError(errors)
	}

	return nil
}

// AssertionResultMultiError is an error wrapping multiple validation errors
// returned by AssertionResult.ValidateAll() if the designated constraints
// aren't met.
type AssertionResultMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AssertionResultMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AssertionResultMultiError) AllErrors() []error { return m }

// AssertionResultValidationError is the validation error returned by
// AssertionResult.Validate if the designated constraints aren't met.
type AssertionResultValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AssertionResultValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AssertionResultValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AssertionResultValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AssertionResultValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AssertionResultValidationError) ErrorName() string { return "AssertionResultValidationError" }

// Error satisfies the builtin error interface
func (e AssertionResultValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAssertionResult.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AssertionResultValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AssertionResultValidationError{}

// Validate checks the field values on RefreshTrigger with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *RefreshTrigger) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RefreshTrigger with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in RefreshTriggerMultiError,
// or nil if none found.
func (m *RefreshTrigger) ValidateAll() error {
	return m.validate(true)
}

func (m *RefreshTrigger) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetSpec()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, RefreshTriggerValidationError{
					field:  "Spec",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, RefreshTriggerValidationError{
					field:  "Spec",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSpec()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return RefreshTriggerValidationError{
				field:  "Spec",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetState()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, RefreshTriggerValidationError{
					field:  "State",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, RefreshTriggerValidationError{
					field:  "State",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetState()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return RefreshTriggerValidationError{
				field:  "State",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return RefreshTriggerMultiError(errors)
	}

	return nil
}

// RefreshTriggerMultiError is an error wrapping multiple validation errors
// returned by RefreshTrigger.ValidateAll() if the designated constraints
// aren't met.
type RefreshTriggerMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RefreshTriggerMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RefreshTriggerMultiError) AllErrors() []error { return m }

// RefreshTriggerValidationError is the validation error returned by
// RefreshTrigger.Validate if the designated constraints aren't met.
type RefreshTriggerValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RefreshTriggerValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RefreshTriggerValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RefreshTriggerValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RefreshTriggerValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RefreshTriggerValidationError) ErrorName() string { return "RefreshTriggerValidationError" }

// Error satisfies the builtin error interface
func (e RefreshTriggerValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRefreshTrigger.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RefreshTriggerValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RefreshTriggerValidationError{}

// Validate checks the field values on RefreshTriggerSpec with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *RefreshTriggerSpec) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RefreshTriggerSpec with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// RefreshTriggerSpecMultiError, or nil if none found.
func (m *RefreshTriggerSpec) ValidateAll() error {
	return m.validate(true)
}

func (m *RefreshTriggerSpec) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetResources() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, RefreshTriggerSpecValidationError{
						field:  fmt.Sprintf("Resources[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, RefreshTriggerSpecValidationError{
						field:  fmt.Sprintf("Resources[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return RefreshTriggerSpecValidationError{
					field:  fmt.Sprintf("Resources[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetModels() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, RefreshTriggerSpecValidationError{
						field:  fmt.Sprintf("Models[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, RefreshTriggerSpecValidationError{
						field:  fmt.Sprintf("Models[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return RefreshTriggerSpecValidationError{
					field:  fmt.Sprintf("Models[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return RefreshTriggerSpecMultiError(errors)
	}

	return nil
}

// RefreshTriggerSpecMultiError is an error wrapping multiple validation errors
// returned by RefreshTriggerSpec.ValidateAll() if the designated constraints
// aren't met.
type RefreshTriggerSpecMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RefreshTriggerSpecMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RefreshTriggerSpecMultiError) AllErrors() []error { return m }

// RefreshTriggerSpecValidationError is the validation error returned by
// RefreshTriggerSpec.Validate if the designated constraints aren't met.
type RefreshTriggerSpecValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RefreshTriggerSpecValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RefreshTriggerSpecValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RefreshTriggerSpecValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RefreshTriggerSpecValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RefreshTriggerSpecValidationError) ErrorName() string {
	return "RefreshTriggerSpecValidationError"
}

// Error satisfies the builtin error interface
func (e RefreshTriggerSpecValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRefreshTriggerSpec.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RefreshTriggerSpecValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RefreshTriggerSpecValidationError{}

// Validate checks the field values on RefreshTriggerState with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *RefreshTriggerState) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RefreshTriggerState with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// RefreshTriggerStateMultiError, or nil if none found.
func (m *RefreshTriggerState) ValidateAll() error {
	return m.validate(true)
}

func (m *RefreshTriggerState) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return RefreshTriggerStateMultiError(errors)
	}

	return nil
}

// RefreshTriggerStateMultiError is an error wrapping multiple validation
// errors returned by RefreshTriggerState.ValidateAll() if the designated
// constraints aren't met.
type RefreshTriggerStateMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RefreshTriggerStateMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RefreshTriggerStateMultiError) AllErrors() []error { return m }

// RefreshTriggerStateValidationError is the validation error returned by
// RefreshTriggerState.Validate if the designated constraints aren't met.
type RefreshTriggerStateValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RefreshTriggerStateValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RefreshTriggerStateValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RefreshTriggerStateValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RefreshTriggerStateValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RefreshTriggerStateValidationError) ErrorName() string {
	return "RefreshTriggerStateValidationError"
}

// Error satisfies the builtin error interface
func (e RefreshTriggerStateValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRefreshTriggerState.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RefreshTriggerStateValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RefreshTriggerStateValidationError{}

// Validate checks the field values on RefreshModelTrigger with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *RefreshModelTrigger) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RefreshModelTrigger with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// RefreshModelTriggerMultiError, or nil if none found.
func (m *RefreshModelTrigger) ValidateAll() error {
	return m.validate(true)
}

func (m *RefreshModelTrigger) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Model

	// no validation rules for Full

	// no validation rules for AllErroredPartitions

	if len(errors) > 0 {
		return RefreshModelTriggerMultiError(errors)
	}

	return nil
}

// RefreshModelTriggerMultiError is an error wrapping multiple validation
// errors returned by RefreshModelTrigger.ValidateAll() if the designated
// constraints aren't met.
type RefreshModelTriggerMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RefreshModelTriggerMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RefreshModelTriggerMultiError) AllErrors() []error { return m }

// RefreshModelTriggerValidationError is the validation error returned by
// RefreshModelTrigger.Validate if the designated constraints aren't met.
type RefreshModelTriggerValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RefreshModelTriggerValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RefreshModelTriggerValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RefreshModelTriggerValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RefreshModelTriggerValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RefreshModelTriggerValidationError) ErrorName() string {
	return "RefreshModelTriggerValidationError"
}

// Error satisfies the builtin error interface
func (e RefreshModelTriggerValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRefreshModelTrigger.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RefreshModelTriggerValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RefreshModelTriggerValidationError{}

// Validate checks the field values on Theme with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Theme) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Theme with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in ThemeMultiError, or nil if none found.
func (m *Theme) ValidateAll() error {
	return m.validate(true)
}

func (m *Theme) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetSpec()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ThemeValidationError{
					field:  "Spec",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ThemeValidationError{
					field:  "Spec",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSpec()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ThemeValidationError{
				field:  "Spec",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetState()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ThemeValidationError{
					field:  "State",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ThemeValidationError{
					field:  "State",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetState()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ThemeValidationError{
				field:  "State",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ThemeMultiError(errors)
	}

	return nil
}

// ThemeMultiError is an error wrapping multiple validation errors returned by
// Theme.ValidateAll() if the designated constraints aren't met.
type ThemeMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ThemeMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ThemeMultiError) AllErrors() []error { return m }

// ThemeValidationError is the validation error returned by Theme.Validate if
// the designated constraints aren't met.
type ThemeValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ThemeValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ThemeValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ThemeValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ThemeValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ThemeValidationError) ErrorName() string { return "ThemeValidationError" }

// Error satisfies the builtin error interface
func (e ThemeValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTheme.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ThemeValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ThemeValidationError{}

// Validate checks the field values on ThemeSpec with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ThemeSpec) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ThemeSpec with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ThemeSpecMultiError, or nil
// if none found.
func (m *ThemeSpec) ValidateAll() error {
	return m.validate(true)
}

func (m *ThemeSpec) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for PrimaryColorRaw

	// no validation rules for SecondaryColorRaw

	if m.PrimaryColor != nil {

		if all {
			switch v := interface{}(m.GetPrimaryColor()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ThemeSpecValidationError{
						field:  "PrimaryColor",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ThemeSpecValidationError{
						field:  "PrimaryColor",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetPrimaryColor()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ThemeSpecValidationError{
					field:  "PrimaryColor",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if m.SecondaryColor != nil {

		if all {
			switch v := interface{}(m.GetSecondaryColor()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ThemeSpecValidationError{
						field:  "SecondaryColor",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ThemeSpecValidationError{
						field:  "SecondaryColor",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetSecondaryColor()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ThemeSpecValidationError{
					field:  "SecondaryColor",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ThemeSpecMultiError(errors)
	}

	return nil
}

// ThemeSpecMultiError is an error wrapping multiple validation errors returned
// by ThemeSpec.ValidateAll() if the designated constraints aren't met.
type ThemeSpecMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ThemeSpecMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ThemeSpecMultiError) AllErrors() []error { return m }

// ThemeSpecValidationError is the validation error returned by
// ThemeSpec.Validate if the designated constraints aren't met.
type ThemeSpecValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ThemeSpecValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ThemeSpecValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ThemeSpecValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ThemeSpecValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ThemeSpecValidationError) ErrorName() string { return "ThemeSpecValidationError" }

// Error satisfies the builtin error interface
func (e ThemeSpecValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sThemeSpec.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ThemeSpecValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ThemeSpecValidationError{}

// Validate checks the field values on ThemeState with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ThemeState) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ThemeState with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ThemeStateMultiError, or
// nil if none found.
func (m *ThemeState) ValidateAll() error {
	return m.validate(true)
}

func (m *ThemeState) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return ThemeStateMultiError(errors)
	}

	return nil
}

// ThemeStateMultiError is an error wrapping multiple validation errors
// returned by ThemeState.ValidateAll() if the designated constraints aren't met.
type ThemeStateMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ThemeStateMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ThemeStateMultiError) AllErrors() []error { return m }

// ThemeStateValidationError is the validation error returned by
// ThemeState.Validate if the designated constraints aren't met.
type ThemeStateValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ThemeStateValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ThemeStateValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ThemeStateValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ThemeStateValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ThemeStateValidationError) ErrorName() string { return "ThemeStateValidationError" }

// Error satisfies the builtin error interface
func (e ThemeStateValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sThemeState.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ThemeStateValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ThemeStateValidationError{}

// Validate checks the field values on Component with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Component) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Component with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ComponentMultiError, or nil
// if none found.
func (m *Component) ValidateAll() error {
	return m.validate(true)
}

func (m *Component) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetSpec()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ComponentValidationError{
					field:  "Spec",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ComponentValidationError{
					field:  "Spec",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSpec()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ComponentValidationError{
				field:  "Spec",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetState()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ComponentValidationError{
					field:  "State",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ComponentValidationError{
					field:  "State",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetState()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ComponentValidationError{
				field:  "State",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ComponentMultiError(errors)
	}

	return nil
}

// ComponentMultiError is an error wrapping multiple validation errors returned
// by Component.ValidateAll() if the designated constraints aren't met.
type ComponentMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ComponentMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ComponentMultiError) AllErrors() []error { return m }

// ComponentValidationError is the validation error returned by
// Component.Validate if the designated constraints aren't met.
type ComponentValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ComponentValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ComponentValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ComponentValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ComponentValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ComponentValidationError) ErrorName() string { return "ComponentValidationError" }

// Error satisfies the builtin error interface
func (e ComponentValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sComponent.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ComponentValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ComponentValidationError{}

// Validate checks the field values on ComponentSpec with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ComponentSpec) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ComponentSpec with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ComponentSpecMultiError, or
// nil if none found.
func (m *ComponentSpec) ValidateAll() error {
	return m.validate(true)
}

func (m *ComponentSpec) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for DisplayName

	// no validation rules for Description

	// no validation rules for Renderer

	if all {
		switch v := interface{}(m.GetRendererProperties()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ComponentSpecValidationError{
					field:  "RendererProperties",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ComponentSpecValidationError{
					field:  "RendererProperties",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetRendererProperties()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ComponentSpecValidationError{
				field:  "RendererProperties",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetInput() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ComponentSpecValidationError{
						field:  fmt.Sprintf("Input[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ComponentSpecValidationError{
						field:  fmt.Sprintf("Input[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ComponentSpecValidationError{
					field:  fmt.Sprintf("Input[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if all {
		switch v := interface{}(m.GetOutput()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ComponentSpecValidationError{
					field:  "Output",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ComponentSpecValidationError{
					field:  "Output",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetOutput()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ComponentSpecValidationError{
				field:  "Output",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for DefinedInCanvas

	if len(errors) > 0 {
		return ComponentSpecMultiError(errors)
	}

	return nil
}

// ComponentSpecMultiError is an error wrapping multiple validation errors
// returned by ComponentSpec.ValidateAll() if the designated constraints
// aren't met.
type ComponentSpecMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ComponentSpecMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ComponentSpecMultiError) AllErrors() []error { return m }

// ComponentSpecValidationError is the validation error returned by
// ComponentSpec.Validate if the designated constraints aren't met.
type ComponentSpecValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ComponentSpecValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ComponentSpecValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ComponentSpecValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ComponentSpecValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ComponentSpecValidationError) ErrorName() string { return "ComponentSpecValidationError" }

// Error satisfies the builtin error interface
func (e ComponentSpecValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sComponentSpec.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ComponentSpecValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ComponentSpecValidationError{}

// Validate checks the field values on ComponentState with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ComponentState) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ComponentState with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ComponentStateMultiError,
// or nil if none found.
func (m *ComponentState) ValidateAll() error {
	return m.validate(true)
}

func (m *ComponentState) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetValidSpec()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ComponentStateValidationError{
					field:  "ValidSpec",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ComponentStateValidationError{
					field:  "ValidSpec",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetValidSpec()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ComponentStateValidationError{
				field:  "ValidSpec",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetDataRefreshedOn()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ComponentStateValidationError{
					field:  "DataRefreshedOn",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ComponentStateValidationError{
					field:  "DataRefreshedOn",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDataRefreshedOn()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ComponentStateValidationError{
				field:  "DataRefreshedOn",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ComponentStateMultiError(errors)
	}

	return nil
}

// ComponentStateMultiError is an error wrapping multiple validation errors
// returned by ComponentState.ValidateAll() if the designated constraints
// aren't met.
type ComponentStateMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ComponentStateMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ComponentStateMultiError) AllErrors() []error { return m }

// ComponentStateValidationError is the validation error returned by
// ComponentState.Validate if the designated constraints aren't met.
type ComponentStateValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ComponentStateValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ComponentStateValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ComponentStateValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ComponentStateValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ComponentStateValidationError) ErrorName() string { return "ComponentStateValidationError" }

// Error satisfies the builtin error interface
func (e ComponentStateValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sComponentState.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ComponentStateValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ComponentStateValidationError{}

// Validate checks the field values on ComponentVariable with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *ComponentVariable) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ComponentVariable with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ComponentVariableMultiError, or nil if none found.
func (m *ComponentVariable) ValidateAll() error {
	return m.validate(true)
}

func (m *ComponentVariable) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Name

	// no validation rules for Type

	if all {
		switch v := interface{}(m.GetDefaultValue()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ComponentVariableValidationError{
					field:  "DefaultValue",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ComponentVariableValidationError{
					field:  "DefaultValue",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDefaultValue()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ComponentVariableValidationError{
				field:  "DefaultValue",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ComponentVariableMultiError(errors)
	}

	return nil
}

// ComponentVariableMultiError is an error wrapping multiple validation errors
// returned by ComponentVariable.ValidateAll() if the designated constraints
// aren't met.
type ComponentVariableMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ComponentVariableMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ComponentVariableMultiError) AllErrors() []error { return m }

// ComponentVariableValidationError is the validation error returned by
// ComponentVariable.Validate if the designated constraints aren't met.
type ComponentVariableValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ComponentVariableValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ComponentVariableValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ComponentVariableValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ComponentVariableValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ComponentVariableValidationError) ErrorName() string {
	return "ComponentVariableValidationError"
}

// Error satisfies the builtin error interface
func (e ComponentVariableValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sComponentVariable.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ComponentVariableValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ComponentVariableValidationError{}

// Validate checks the field values on Canvas with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Canvas) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Canvas with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in CanvasMultiError, or nil if none found.
func (m *Canvas) ValidateAll() error {
	return m.validate(true)
}

func (m *Canvas) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetSpec()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CanvasValidationError{
					field:  "Spec",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CanvasValidationError{
					field:  "Spec",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSpec()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CanvasValidationError{
				field:  "Spec",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetState()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CanvasValidationError{
					field:  "State",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CanvasValidationError{
					field:  "State",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetState()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CanvasValidationError{
				field:  "State",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CanvasMultiError(errors)
	}

	return nil
}

// CanvasMultiError is an error wrapping multiple validation errors returned by
// Canvas.ValidateAll() if the designated constraints aren't met.
type CanvasMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CanvasMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CanvasMultiError) AllErrors() []error { return m }

// CanvasValidationError is the validation error returned by Canvas.Validate if
// the designated constraints aren't met.
type CanvasValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CanvasValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CanvasValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CanvasValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CanvasValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CanvasValidationError) ErrorName() string { return "CanvasValidationError" }

// Error satisfies the builtin error interface
func (e CanvasValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCanvas.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CanvasValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CanvasValidationError{}

// Validate checks the field values on CanvasSpec with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *CanvasSpec) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CanvasSpec with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in CanvasSpecMultiError, or
// nil if none found.
func (m *CanvasSpec) ValidateAll() error {
	return m.validate(true)
}

func (m *CanvasSpec) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for DisplayName

	// no validation rules for Banner

	// no validation rules for MaxWidth

	// no validation rules for GapX

	// no validation rules for GapY

	// no validation rules for Theme

	if all {
		switch v := interface{}(m.GetEmbeddedTheme()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CanvasSpecValidationError{
					field:  "EmbeddedTheme",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CanvasSpecValidationError{
					field:  "EmbeddedTheme",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetEmbeddedTheme()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CanvasSpecValidationError{
				field:  "EmbeddedTheme",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetTimeRanges() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, CanvasSpecValidationError{
						field:  fmt.Sprintf("TimeRanges[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, CanvasSpecValidationError{
						field:  fmt.Sprintf("TimeRanges[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return CanvasSpecValidationError{
					field:  fmt.Sprintf("TimeRanges[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for AllowCustomTimeRange

	// no validation rules for FiltersEnabled

	if all {
		switch v := interface{}(m.GetDefaultPreset()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CanvasSpecValidationError{
					field:  "DefaultPreset",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CanvasSpecValidationError{
					field:  "DefaultPreset",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDefaultPreset()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CanvasSpecValidationError{
				field:  "DefaultPreset",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetVariables() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, CanvasSpecValidationError{
						field:  fmt.Sprintf("Variables[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, CanvasSpecValidationError{
						field:  fmt.Sprintf("Variables[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return CanvasSpecValidationError{
					field:  fmt.Sprintf("Variables[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetRows() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, CanvasSpecValidationError{
						field:  fmt.Sprintf("Rows[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, CanvasSpecValidationError{
						field:  fmt.Sprintf("Rows[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return CanvasSpecValidationError{
					field:  fmt.Sprintf("Rows[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetSecurityRules() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, CanvasSpecValidationError{
						field:  fmt.Sprintf("SecurityRules[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, CanvasSpecValidationError{
						field:  fmt.Sprintf("SecurityRules[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return CanvasSpecValidationError{
					field:  fmt.Sprintf("SecurityRules[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return CanvasSpecMultiError(errors)
	}

	return nil
}

// CanvasSpecMultiError is an error wrapping multiple validation errors
// returned by CanvasSpec.ValidateAll() if the designated constraints aren't met.
type CanvasSpecMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CanvasSpecMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CanvasSpecMultiError) AllErrors() []error { return m }

// CanvasSpecValidationError is the validation error returned by
// CanvasSpec.Validate if the designated constraints aren't met.
type CanvasSpecValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CanvasSpecValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CanvasSpecValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CanvasSpecValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CanvasSpecValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CanvasSpecValidationError) ErrorName() string { return "CanvasSpecValidationError" }

// Error satisfies the builtin error interface
func (e CanvasSpecValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCanvasSpec.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CanvasSpecValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CanvasSpecValidationError{}

// Validate checks the field values on CanvasState with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *CanvasState) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CanvasState with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in CanvasStateMultiError, or
// nil if none found.
func (m *CanvasState) ValidateAll() error {
	return m.validate(true)
}

func (m *CanvasState) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetValidSpec()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CanvasStateValidationError{
					field:  "ValidSpec",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CanvasStateValidationError{
					field:  "ValidSpec",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetValidSpec()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CanvasStateValidationError{
				field:  "ValidSpec",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetDataRefreshedOn()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CanvasStateValidationError{
					field:  "DataRefreshedOn",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CanvasStateValidationError{
					field:  "DataRefreshedOn",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDataRefreshedOn()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CanvasStateValidationError{
				field:  "DataRefreshedOn",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CanvasStateMultiError(errors)
	}

	return nil
}

// CanvasStateMultiError is an error wrapping multiple validation errors
// returned by CanvasState.ValidateAll() if the designated constraints aren't met.
type CanvasStateMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CanvasStateMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CanvasStateMultiError) AllErrors() []error { return m }

// CanvasStateValidationError is the validation error returned by
// CanvasState.Validate if the designated constraints aren't met.
type CanvasStateValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CanvasStateValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CanvasStateValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CanvasStateValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CanvasStateValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CanvasStateValidationError) ErrorName() string { return "CanvasStateValidationError" }

// Error satisfies the builtin error interface
func (e CanvasStateValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCanvasState.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CanvasStateValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CanvasStateValidationError{}

// Validate checks the field values on CanvasRow with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *CanvasRow) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CanvasRow with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in CanvasRowMultiError, or nil
// if none found.
func (m *CanvasRow) ValidateAll() error {
	return m.validate(true)
}

func (m *CanvasRow) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for HeightUnit

	for idx, item := range m.GetItems() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, CanvasRowValidationError{
						field:  fmt.Sprintf("Items[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, CanvasRowValidationError{
						field:  fmt.Sprintf("Items[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return CanvasRowValidationError{
					field:  fmt.Sprintf("Items[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if m.Height != nil {
		// no validation rules for Height
	}

	if len(errors) > 0 {
		return CanvasRowMultiError(errors)
	}

	return nil
}

// CanvasRowMultiError is an error wrapping multiple validation errors returned
// by CanvasRow.ValidateAll() if the designated constraints aren't met.
type CanvasRowMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CanvasRowMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CanvasRowMultiError) AllErrors() []error { return m }

// CanvasRowValidationError is the validation error returned by
// CanvasRow.Validate if the designated constraints aren't met.
type CanvasRowValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CanvasRowValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CanvasRowValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CanvasRowValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CanvasRowValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CanvasRowValidationError) ErrorName() string { return "CanvasRowValidationError" }

// Error satisfies the builtin error interface
func (e CanvasRowValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCanvasRow.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CanvasRowValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CanvasRowValidationError{}

// Validate checks the field values on CanvasItem with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *CanvasItem) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CanvasItem with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in CanvasItemMultiError, or
// nil if none found.
func (m *CanvasItem) ValidateAll() error {
	return m.validate(true)
}

func (m *CanvasItem) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Component

	// no validation rules for DefinedInCanvas

	// no validation rules for WidthUnit

	if m.Width != nil {
		// no validation rules for Width
	}

	if len(errors) > 0 {
		return CanvasItemMultiError(errors)
	}

	return nil
}

// CanvasItemMultiError is an error wrapping multiple validation errors
// returned by CanvasItem.ValidateAll() if the designated constraints aren't met.
type CanvasItemMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CanvasItemMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CanvasItemMultiError) AllErrors() []error { return m }

// CanvasItemValidationError is the validation error returned by
// CanvasItem.Validate if the designated constraints aren't met.
type CanvasItemValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CanvasItemValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CanvasItemValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CanvasItemValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CanvasItemValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CanvasItemValidationError) ErrorName() string { return "CanvasItemValidationError" }

// Error satisfies the builtin error interface
func (e CanvasItemValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCanvasItem.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CanvasItemValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CanvasItemValidationError{}

// Validate checks the field values on CanvasPreset with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *CanvasPreset) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CanvasPreset with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in CanvasPresetMultiError, or
// nil if none found.
func (m *CanvasPreset) ValidateAll() error {
	return m.validate(true)
}

func (m *CanvasPreset) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ComparisonMode

	if m.TimeRange != nil {
		// no validation rules for TimeRange
	}

	if m.ComparisonDimension != nil {
		// no validation rules for ComparisonDimension
	}

	if len(errors) > 0 {
		return CanvasPresetMultiError(errors)
	}

	return nil
}

// CanvasPresetMultiError is an error wrapping multiple validation errors
// returned by CanvasPreset.ValidateAll() if the designated constraints aren't met.
type CanvasPresetMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CanvasPresetMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CanvasPresetMultiError) AllErrors() []error { return m }

// CanvasPresetValidationError is the validation error returned by
// CanvasPreset.Validate if the designated constraints aren't met.
type CanvasPresetValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CanvasPresetValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CanvasPresetValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CanvasPresetValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CanvasPresetValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CanvasPresetValidationError) ErrorName() string { return "CanvasPresetValidationError" }

// Error satisfies the builtin error interface
func (e CanvasPresetValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCanvasPreset.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CanvasPresetValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CanvasPresetValidationError{}

// Validate checks the field values on API with the rules defined in the proto
// definition for this message. If any rules are violated, the first error
// encountered is returned, or nil if there are no violations.
func (m *API) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on API with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in APIMultiError, or nil if none found.
func (m *API) ValidateAll() error {
	return m.validate(true)
}

func (m *API) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetSpec()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, APIValidationError{
					field:  "Spec",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, APIValidationError{
					field:  "Spec",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSpec()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return APIValidationError{
				field:  "Spec",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetState()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, APIValidationError{
					field:  "State",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, APIValidationError{
					field:  "State",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetState()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return APIValidationError{
				field:  "State",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return APIMultiError(errors)
	}

	return nil
}

// APIMultiError is an error wrapping multiple validation errors returned by
// API.ValidateAll() if the designated constraints aren't met.
type APIMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m APIMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m APIMultiError) AllErrors() []error { return m }

// APIValidationError is the validation error returned by API.Validate if the
// designated constraints aren't met.
type APIValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e APIValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e APIValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e APIValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e APIValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e APIValidationError) ErrorName() string { return "APIValidationError" }

// Error satisfies the builtin error interface
func (e APIValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAPI.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = APIValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = APIValidationError{}

// Validate checks the field values on APISpec with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *APISpec) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on APISpec with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in APISpecMultiError, or nil if none found.
func (m *APISpec) ValidateAll() error {
	return m.validate(true)
}

func (m *APISpec) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Resolver

	if all {
		switch v := interface{}(m.GetResolverProperties()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, APISpecValidationError{
					field:  "ResolverProperties",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, APISpecValidationError{
					field:  "ResolverProperties",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetResolverProperties()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return APISpecValidationError{
				field:  "ResolverProperties",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for OpenapiSummary

	// no validation rules for OpenapiParametersJson

	// no validation rules for OpenapiRequestSchemaJson

	// no validation rules for OpenapiResponseSchemaJson

	// no validation rules for OpenapiDefsPrefix

	for idx, item := range m.GetSecurityRules() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, APISpecValidationError{
						field:  fmt.Sprintf("SecurityRules[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, APISpecValidationError{
						field:  fmt.Sprintf("SecurityRules[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return APISpecValidationError{
					field:  fmt.Sprintf("SecurityRules[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for SkipNestedSecurity

	if len(errors) > 0 {
		return APISpecMultiError(errors)
	}

	return nil
}

// APISpecMultiError is an error wrapping multiple validation errors returned
// by APISpec.ValidateAll() if the designated constraints aren't met.
type APISpecMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m APISpecMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m APISpecMultiError) AllErrors() []error { return m }

// APISpecValidationError is the validation error returned by APISpec.Validate
// if the designated constraints aren't met.
type APISpecValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e APISpecValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e APISpecValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e APISpecValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e APISpecValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e APISpecValidationError) ErrorName() string { return "APISpecValidationError" }

// Error satisfies the builtin error interface
func (e APISpecValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAPISpec.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = APISpecValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = APISpecValidationError{}

// Validate checks the field values on APIState with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *APIState) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on APIState with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in APIStateMultiError, or nil
// if none found.
func (m *APIState) ValidateAll() error {
	return m.validate(true)
}

func (m *APIState) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return APIStateMultiError(errors)
	}

	return nil
}

// APIStateMultiError is an error wrapping multiple validation errors returned
// by APIState.ValidateAll() if the designated constraints aren't met.
type APIStateMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m APIStateMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m APIStateMultiError) AllErrors() []error { return m }

// APIStateValidationError is the validation error returned by
// APIState.Validate if the designated constraints aren't met.
type APIStateValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e APIStateValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e APIStateValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e APIStateValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e APIStateValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e APIStateValidationError) ErrorName() string { return "APIStateValidationError" }

// Error satisfies the builtin error interface
func (e APIStateValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAPIState.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = APIStateValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = APIStateValidationError{}

// Validate checks the field values on Schedule with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Schedule) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Schedule with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ScheduleMultiError, or nil
// if none found.
func (m *Schedule) ValidateAll() error {
	return m.validate(true)
}

func (m *Schedule) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for RefUpdate

	// no validation rules for Disable

	// no validation rules for Cron

	// no validation rules for TickerSeconds

	// no validation rules for TimeZone

	if len(errors) > 0 {
		return ScheduleMultiError(errors)
	}

	return nil
}

// ScheduleMultiError is an error wrapping multiple validation errors returned
// by Schedule.ValidateAll() if the designated constraints aren't met.
type ScheduleMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ScheduleMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ScheduleMultiError) AllErrors() []error { return m }

// ScheduleValidationError is the validation error returned by
// Schedule.Validate if the designated constraints aren't met.
type ScheduleValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ScheduleValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ScheduleValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ScheduleValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ScheduleValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ScheduleValidationError) ErrorName() string { return "ScheduleValidationError" }

// Error satisfies the builtin error interface
func (e ScheduleValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSchedule.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ScheduleValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ScheduleValidationError{}

// Validate checks the field values on ParseError with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ParseError) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ParseError with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ParseErrorMultiError, or
// nil if none found.
func (m *ParseError) ValidateAll() error {
	return m.validate(true)
}

func (m *ParseError) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Message

	// no validation rules for FilePath

	if all {
		switch v := interface{}(m.GetStartLocation()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ParseErrorValidationError{
					field:  "StartLocation",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ParseErrorValidationError{
					field:  "StartLocation",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetStartLocation()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ParseErrorValidationError{
				field:  "StartLocation",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for External

	if len(errors) > 0 {
		return ParseErrorMultiError(errors)
	}

	return nil
}

// ParseErrorMultiError is an error wrapping multiple validation errors
// returned by ParseError.ValidateAll() if the designated constraints aren't met.
type ParseErrorMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ParseErrorMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ParseErrorMultiError) AllErrors() []error { return m }

// ParseErrorValidationError is the validation error returned by
// ParseError.Validate if the designated constraints aren't met.
type ParseErrorValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ParseErrorValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ParseErrorValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ParseErrorValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ParseErrorValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ParseErrorValidationError) ErrorName() string { return "ParseErrorValidationError" }

// Error satisfies the builtin error interface
func (e ParseErrorValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sParseError.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ParseErrorValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ParseErrorValidationError{}

// Validate checks the field values on ValidationError with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *ValidationError) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ValidationError with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ValidationErrorMultiError, or nil if none found.
func (m *ValidationError) ValidateAll() error {
	return m.validate(true)
}

func (m *ValidationError) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Message

	if len(errors) > 0 {
		return ValidationErrorMultiError(errors)
	}

	return nil
}

// ValidationErrorMultiError is an error wrapping multiple validation errors
// returned by ValidationError.ValidateAll() if the designated constraints
// aren't met.
type ValidationErrorMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ValidationErrorMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ValidationErrorMultiError) AllErrors() []error { return m }

// ValidationErrorValidationError is the validation error returned by
// ValidationError.Validate if the designated constraints aren't met.
type ValidationErrorValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ValidationErrorValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ValidationErrorValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ValidationErrorValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ValidationErrorValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ValidationErrorValidationError) ErrorName() string { return "ValidationErrorValidationError" }

// Error satisfies the builtin error interface
func (e ValidationErrorValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sValidationError.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ValidationErrorValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ValidationErrorValidationError{}

// Validate checks the field values on DependencyError with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *DependencyError) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DependencyError with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DependencyErrorMultiError, or nil if none found.
func (m *DependencyError) ValidateAll() error {
	return m.validate(true)
}

func (m *DependencyError) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Message

	// no validation rules for Dependency

	if len(errors) > 0 {
		return DependencyErrorMultiError(errors)
	}

	return nil
}

// DependencyErrorMultiError is an error wrapping multiple validation errors
// returned by DependencyError.ValidateAll() if the designated constraints
// aren't met.
type DependencyErrorMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DependencyErrorMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DependencyErrorMultiError) AllErrors() []error { return m }

// DependencyErrorValidationError is the validation error returned by
// DependencyError.Validate if the designated constraints aren't met.
type DependencyErrorValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DependencyErrorValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DependencyErrorValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DependencyErrorValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DependencyErrorValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DependencyErrorValidationError) ErrorName() string { return "DependencyErrorValidationError" }

// Error satisfies the builtin error interface
func (e DependencyErrorValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDependencyError.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DependencyErrorValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DependencyErrorValidationError{}

// Validate checks the field values on ExecutionError with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ExecutionError) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ExecutionError with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ExecutionErrorMultiError,
// or nil if none found.
func (m *ExecutionError) ValidateAll() error {
	return m.validate(true)
}

func (m *ExecutionError) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Message

	if len(errors) > 0 {
		return ExecutionErrorMultiError(errors)
	}

	return nil
}

// ExecutionErrorMultiError is an error wrapping multiple validation errors
// returned by ExecutionError.ValidateAll() if the designated constraints
// aren't met.
type ExecutionErrorMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ExecutionErrorMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ExecutionErrorMultiError) AllErrors() []error { return m }

// ExecutionErrorValidationError is the validation error returned by
// ExecutionError.Validate if the designated constraints aren't met.
type ExecutionErrorValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ExecutionErrorValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ExecutionErrorValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ExecutionErrorValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ExecutionErrorValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ExecutionErrorValidationError) ErrorName() string { return "ExecutionErrorValidationError" }

// Error satisfies the builtin error interface
func (e ExecutionErrorValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sExecutionError.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ExecutionErrorValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ExecutionErrorValidationError{}

// Validate checks the field values on CharLocation with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *CharLocation) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CharLocation with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in CharLocationMultiError, or
// nil if none found.
func (m *CharLocation) ValidateAll() error {
	return m.validate(true)
}

func (m *CharLocation) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Line

	if len(errors) > 0 {
		return CharLocationMultiError(errors)
	}

	return nil
}

// CharLocationMultiError is an error wrapping multiple validation errors
// returned by CharLocation.ValidateAll() if the designated constraints aren't met.
type CharLocationMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CharLocationMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CharLocationMultiError) AllErrors() []error { return m }

// CharLocationValidationError is the validation error returned by
// CharLocation.Validate if the designated constraints aren't met.
type CharLocationValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CharLocationValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CharLocationValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CharLocationValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CharLocationValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CharLocationValidationError) ErrorName() string { return "CharLocationValidationError" }

// Error satisfies the builtin error interface
func (e CharLocationValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCharLocation.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CharLocationValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CharLocationValidationError{}

// Validate checks the field values on ConnectorV2 with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ConnectorV2) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ConnectorV2 with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ConnectorV2MultiError, or
// nil if none found.
func (m *ConnectorV2) ValidateAll() error {
	return m.validate(true)
}

func (m *ConnectorV2) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetSpec()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ConnectorV2ValidationError{
					field:  "Spec",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ConnectorV2ValidationError{
					field:  "Spec",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSpec()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ConnectorV2ValidationError{
				field:  "Spec",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetState()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ConnectorV2ValidationError{
					field:  "State",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ConnectorV2ValidationError{
					field:  "State",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetState()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ConnectorV2ValidationError{
				field:  "State",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ConnectorV2MultiError(errors)
	}

	return nil
}

// ConnectorV2MultiError is an error wrapping multiple validation errors
// returned by ConnectorV2.ValidateAll() if the designated constraints aren't met.
type ConnectorV2MultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ConnectorV2MultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ConnectorV2MultiError) AllErrors() []error { return m }

// ConnectorV2ValidationError is the validation error returned by
// ConnectorV2.Validate if the designated constraints aren't met.
type ConnectorV2ValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ConnectorV2ValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ConnectorV2ValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ConnectorV2ValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ConnectorV2ValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ConnectorV2ValidationError) ErrorName() string { return "ConnectorV2ValidationError" }

// Error satisfies the builtin error interface
func (e ConnectorV2ValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sConnectorV2.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ConnectorV2ValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ConnectorV2ValidationError{}

// Validate checks the field values on ConnectorSpec with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ConnectorSpec) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ConnectorSpec with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ConnectorSpecMultiError, or
// nil if none found.
func (m *ConnectorSpec) ValidateAll() error {
	return m.validate(true)
}

func (m *ConnectorSpec) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Driver

	// no validation rules for Properties

	// no validation rules for Provision

	if all {
		switch v := interface{}(m.GetProvisionArgs()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ConnectorSpecValidationError{
					field:  "ProvisionArgs",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ConnectorSpecValidationError{
					field:  "ProvisionArgs",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetProvisionArgs()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ConnectorSpecValidationError{
				field:  "ProvisionArgs",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ConnectorSpecMultiError(errors)
	}

	return nil
}

// ConnectorSpecMultiError is an error wrapping multiple validation errors
// returned by ConnectorSpec.ValidateAll() if the designated constraints
// aren't met.
type ConnectorSpecMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ConnectorSpecMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ConnectorSpecMultiError) AllErrors() []error { return m }

// ConnectorSpecValidationError is the validation error returned by
// ConnectorSpec.Validate if the designated constraints aren't met.
type ConnectorSpecValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ConnectorSpecValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ConnectorSpecValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ConnectorSpecValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ConnectorSpecValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ConnectorSpecValidationError) ErrorName() string { return "ConnectorSpecValidationError" }

// Error satisfies the builtin error interface
func (e ConnectorSpecValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sConnectorSpec.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ConnectorSpecValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ConnectorSpecValidationError{}

// Validate checks the field values on ConnectorState with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ConnectorState) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ConnectorState with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ConnectorStateMultiError,
// or nil if none found.
func (m *ConnectorState) ValidateAll() error {
	return m.validate(true)
}

func (m *ConnectorState) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for SpecHash

	if len(errors) > 0 {
		return ConnectorStateMultiError(errors)
	}

	return nil
}

// ConnectorStateMultiError is an error wrapping multiple validation errors
// returned by ConnectorState.ValidateAll() if the designated constraints
// aren't met.
type ConnectorStateMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ConnectorStateMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ConnectorStateMultiError) AllErrors() []error { return m }

// ConnectorStateValidationError is the validation error returned by
// ConnectorState.Validate if the designated constraints aren't met.
type ConnectorStateValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ConnectorStateValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ConnectorStateValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ConnectorStateValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ConnectorStateValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ConnectorStateValidationError) ErrorName() string { return "ConnectorStateValidationError" }

// Error satisfies the builtin error interface
func (e ConnectorStateValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sConnectorState.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ConnectorStateValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ConnectorStateValidationError{}

// Validate checks the field values on MetricsViewSpec_Dimension with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *MetricsViewSpec_Dimension) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on MetricsViewSpec_Dimension with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// MetricsViewSpec_DimensionMultiError, or nil if none found.
func (m *MetricsViewSpec_Dimension) ValidateAll() error {
	return m.validate(true)
}

func (m *MetricsViewSpec_Dimension) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Name

	// no validation rules for DisplayName

	// no validation rules for Description

	// no validation rules for Column

	// no validation rules for Expression

	// no validation rules for Unnest

	// no validation rules for Uri

	// no validation rules for LookupTable

	// no validation rules for LookupKeyColumn

	// no validation rules for LookupValueColumn

	// no validation rules for LookupDefaultExpression

	if all {
		switch v := interface{}(m.GetDataType()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, MetricsViewSpec_DimensionValidationError{
					field:  "DataType",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, MetricsViewSpec_DimensionValidationError{
					field:  "DataType",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDataType()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return MetricsViewSpec_DimensionValidationError{
				field:  "DataType",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return MetricsViewSpec_DimensionMultiError(errors)
	}

	return nil
}

// MetricsViewSpec_DimensionMultiError is an error wrapping multiple validation
// errors returned by MetricsViewSpec_Dimension.ValidateAll() if the
// designated constraints aren't met.
type MetricsViewSpec_DimensionMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MetricsViewSpec_DimensionMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MetricsViewSpec_DimensionMultiError) AllErrors() []error { return m }

// MetricsViewSpec_DimensionValidationError is the validation error returned by
// MetricsViewSpec_Dimension.Validate if the designated constraints aren't met.
type MetricsViewSpec_DimensionValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MetricsViewSpec_DimensionValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MetricsViewSpec_DimensionValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MetricsViewSpec_DimensionValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MetricsViewSpec_DimensionValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MetricsViewSpec_DimensionValidationError) ErrorName() string {
	return "MetricsViewSpec_DimensionValidationError"
}

// Error satisfies the builtin error interface
func (e MetricsViewSpec_DimensionValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMetricsViewSpec_Dimension.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MetricsViewSpec_DimensionValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MetricsViewSpec_DimensionValidationError{}

// Validate checks the field values on MetricsViewSpec_DimensionSelector with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *MetricsViewSpec_DimensionSelector) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on MetricsViewSpec_DimensionSelector
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// MetricsViewSpec_DimensionSelectorMultiError, or nil if none found.
func (m *MetricsViewSpec_DimensionSelector) ValidateAll() error {
	return m.validate(true)
}

func (m *MetricsViewSpec_DimensionSelector) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Name

	// no validation rules for TimeGrain

	// no validation rules for Desc

	if len(errors) > 0 {
		return MetricsViewSpec_DimensionSelectorMultiError(errors)
	}

	return nil
}

// MetricsViewSpec_DimensionSelectorMultiError is an error wrapping multiple
// validation errors returned by
// MetricsViewSpec_DimensionSelector.ValidateAll() if the designated
// constraints aren't met.
type MetricsViewSpec_DimensionSelectorMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MetricsViewSpec_DimensionSelectorMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MetricsViewSpec_DimensionSelectorMultiError) AllErrors() []error { return m }

// MetricsViewSpec_DimensionSelectorValidationError is the validation error
// returned by MetricsViewSpec_DimensionSelector.Validate if the designated
// constraints aren't met.
type MetricsViewSpec_DimensionSelectorValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MetricsViewSpec_DimensionSelectorValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MetricsViewSpec_DimensionSelectorValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MetricsViewSpec_DimensionSelectorValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MetricsViewSpec_DimensionSelectorValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MetricsViewSpec_DimensionSelectorValidationError) ErrorName() string {
	return "MetricsViewSpec_DimensionSelectorValidationError"
}

// Error satisfies the builtin error interface
func (e MetricsViewSpec_DimensionSelectorValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMetricsViewSpec_DimensionSelector.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MetricsViewSpec_DimensionSelectorValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MetricsViewSpec_DimensionSelectorValidationError{}

// Validate checks the field values on MetricsViewSpec_MeasureWindow with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *MetricsViewSpec_MeasureWindow) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on MetricsViewSpec_MeasureWindow with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// MetricsViewSpec_MeasureWindowMultiError, or nil if none found.
func (m *MetricsViewSpec_MeasureWindow) ValidateAll() error {
	return m.validate(true)
}

func (m *MetricsViewSpec_MeasureWindow) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Partition

	for idx, item := range m.GetOrderBy() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, MetricsViewSpec_MeasureWindowValidationError{
						field:  fmt.Sprintf("OrderBy[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, MetricsViewSpec_MeasureWindowValidationError{
						field:  fmt.Sprintf("OrderBy[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return MetricsViewSpec_MeasureWindowValidationError{
					field:  fmt.Sprintf("OrderBy[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for FrameExpression

	if len(errors) > 0 {
		return MetricsViewSpec_MeasureWindowMultiError(errors)
	}

	return nil
}

// MetricsViewSpec_MeasureWindowMultiError is an error wrapping multiple
// validation errors returned by MetricsViewSpec_MeasureWindow.ValidateAll()
// if the designated constraints aren't met.
type MetricsViewSpec_MeasureWindowMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MetricsViewSpec_MeasureWindowMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MetricsViewSpec_MeasureWindowMultiError) AllErrors() []error { return m }

// MetricsViewSpec_MeasureWindowValidationError is the validation error
// returned by MetricsViewSpec_MeasureWindow.Validate if the designated
// constraints aren't met.
type MetricsViewSpec_MeasureWindowValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MetricsViewSpec_MeasureWindowValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MetricsViewSpec_MeasureWindowValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MetricsViewSpec_MeasureWindowValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MetricsViewSpec_MeasureWindowValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MetricsViewSpec_MeasureWindowValidationError) ErrorName() string {
	return "MetricsViewSpec_MeasureWindowValidationError"
}

// Error satisfies the builtin error interface
func (e MetricsViewSpec_MeasureWindowValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMetricsViewSpec_MeasureWindow.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MetricsViewSpec_MeasureWindowValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MetricsViewSpec_MeasureWindowValidationError{}

// Validate checks the field values on MetricsViewSpec_Measure with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *MetricsViewSpec_Measure) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on MetricsViewSpec_Measure with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// MetricsViewSpec_MeasureMultiError, or nil if none found.
func (m *MetricsViewSpec_Measure) ValidateAll() error {
	return m.validate(true)
}

func (m *MetricsViewSpec_Measure) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Name

	// no validation rules for DisplayName

	// no validation rules for Description

	// no validation rules for Expression

	// no validation rules for Type

	if all {
		switch v := interface{}(m.GetWindow()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, MetricsViewSpec_MeasureValidationError{
					field:  "Window",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, MetricsViewSpec_MeasureValidationError{
					field:  "Window",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetWindow()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return MetricsViewSpec_MeasureValidationError{
				field:  "Window",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetPerDimensions() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, MetricsViewSpec_MeasureValidationError{
						field:  fmt.Sprintf("PerDimensions[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, MetricsViewSpec_MeasureValidationError{
						field:  fmt.Sprintf("PerDimensions[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return MetricsViewSpec_MeasureValidationError{
					field:  fmt.Sprintf("PerDimensions[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetRequiredDimensions() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, MetricsViewSpec_MeasureValidationError{
						field:  fmt.Sprintf("RequiredDimensions[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, MetricsViewSpec_MeasureValidationError{
						field:  fmt.Sprintf("RequiredDimensions[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return MetricsViewSpec_MeasureValidationError{
					field:  fmt.Sprintf("RequiredDimensions[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for FormatPreset

	// no validation rules for FormatD3

	if all {
		switch v := interface{}(m.GetFormatD3Locale()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, MetricsViewSpec_MeasureValidationError{
					field:  "FormatD3Locale",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, MetricsViewSpec_MeasureValidationError{
					field:  "FormatD3Locale",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetFormatD3Locale()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return MetricsViewSpec_MeasureValidationError{
				field:  "FormatD3Locale",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for ValidPercentOfTotal

	// no validation rules for TreatNullsAs

	if all {
		switch v := interface{}(m.GetDataType()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, MetricsViewSpec_MeasureValidationError{
					field:  "DataType",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, MetricsViewSpec_MeasureValidationError{
					field:  "DataType",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDataType()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return MetricsViewSpec_MeasureValidationError{
				field:  "DataType",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return MetricsViewSpec_MeasureMultiError(errors)
	}

	return nil
}

// MetricsViewSpec_MeasureMultiError is an error wrapping multiple validation
// errors returned by MetricsViewSpec_Measure.ValidateAll() if the designated
// constraints aren't met.
type MetricsViewSpec_MeasureMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MetricsViewSpec_MeasureMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MetricsViewSpec_MeasureMultiError) AllErrors() []error { return m }

// MetricsViewSpec_MeasureValidationError is the validation error returned by
// MetricsViewSpec_Measure.Validate if the designated constraints aren't met.
type MetricsViewSpec_MeasureValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MetricsViewSpec_MeasureValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MetricsViewSpec_MeasureValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MetricsViewSpec_MeasureValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MetricsViewSpec_MeasureValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MetricsViewSpec_MeasureValidationError) ErrorName() string {
	return "MetricsViewSpec_MeasureValidationError"
}

// Error satisfies the builtin error interface
func (e MetricsViewSpec_MeasureValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMetricsViewSpec_Measure.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MetricsViewSpec_MeasureValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MetricsViewSpec_MeasureValidationError{}

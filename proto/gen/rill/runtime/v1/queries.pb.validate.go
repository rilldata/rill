// Code generated by protoc-gen-validate. DO NOT EDIT.
// source: rill/runtime/v1/queries.proto

package runtimev1

import (
	"bytes"
	"errors"
	"fmt"
	"net"
	"net/mail"
	"net/url"
	"regexp"
	"sort"
	"strings"
	"time"
	"unicode/utf8"

	"google.golang.org/protobuf/types/known/anypb"
)

// ensure the imports are used
var (
	_ = bytes.MinRead
	_ = errors.New("")
	_ = fmt.Print
	_ = utf8.UTFMax
	_ = (*regexp.Regexp)(nil)
	_ = (*strings.Reader)(nil)
	_ = net.IPv4len
	_ = time.Duration(0)
	_ = (*url.URL)(nil)
	_ = (*mail.Address)(nil)
	_ = anypb.Any{}
	_ = sort.Sort
)

// Validate checks the field values on QueryRequest with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *QueryRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on QueryRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in QueryRequestMultiError, or
// nil if none found.
func (m *QueryRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *QueryRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if !_QueryRequest_InstanceId_Pattern.MatchString(m.GetInstanceId()) {
		err := QueryRequestValidationError{
			field:  "InstanceId",
			reason: "value does not match regex pattern \"^[_\\\\-a-zA-Z0-9]+$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Connector

	// no validation rules for Sql

	for idx, item := range m.GetArgs() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, QueryRequestValidationError{
						field:  fmt.Sprintf("Args[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, QueryRequestValidationError{
						field:  fmt.Sprintf("Args[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return QueryRequestValidationError{
					field:  fmt.Sprintf("Args[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for Priority

	// no validation rules for DryRun

	if val := m.GetLimit(); val < 0 || val > 10000 {
		err := QueryRequestValidationError{
			field:  "Limit",
			reason: "value must be inside range [0, 10000]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return QueryRequestMultiError(errors)
	}

	return nil
}

// QueryRequestMultiError is an error wrapping multiple validation errors
// returned by QueryRequest.ValidateAll() if the designated constraints aren't met.
type QueryRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m QueryRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m QueryRequestMultiError) AllErrors() []error { return m }

// QueryRequestValidationError is the validation error returned by
// QueryRequest.Validate if the designated constraints aren't met.
type QueryRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e QueryRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e QueryRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e QueryRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e QueryRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e QueryRequestValidationError) ErrorName() string { return "QueryRequestValidationError" }

// Error satisfies the builtin error interface
func (e QueryRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sQueryRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = QueryRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = QueryRequestValidationError{}

var _QueryRequest_InstanceId_Pattern = regexp.MustCompile("^[_\\-a-zA-Z0-9]+$")

// Validate checks the field values on QueryResponse with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *QueryResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on QueryResponse with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in QueryResponseMultiError, or
// nil if none found.
func (m *QueryResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *QueryResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetMeta()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, QueryResponseValidationError{
					field:  "Meta",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, QueryResponseValidationError{
					field:  "Meta",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetMeta()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return QueryResponseValidationError{
				field:  "Meta",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetData() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, QueryResponseValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, QueryResponseValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return QueryResponseValidationError{
					field:  fmt.Sprintf("Data[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return QueryResponseMultiError(errors)
	}

	return nil
}

// QueryResponseMultiError is an error wrapping multiple validation errors
// returned by QueryResponse.ValidateAll() if the designated constraints
// aren't met.
type QueryResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m QueryResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m QueryResponseMultiError) AllErrors() []error { return m }

// QueryResponseValidationError is the validation error returned by
// QueryResponse.Validate if the designated constraints aren't met.
type QueryResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e QueryResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e QueryResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e QueryResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e QueryResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e QueryResponseValidationError) ErrorName() string { return "QueryResponseValidationError" }

// Error satisfies the builtin error interface
func (e QueryResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sQueryResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = QueryResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = QueryResponseValidationError{}

// Validate checks the field values on QueryBatchRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *QueryBatchRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on QueryBatchRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// QueryBatchRequestMultiError, or nil if none found.
func (m *QueryBatchRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *QueryBatchRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for InstanceId

	for idx, item := range m.GetQueries() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, QueryBatchRequestValidationError{
						field:  fmt.Sprintf("Queries[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, QueryBatchRequestValidationError{
						field:  fmt.Sprintf("Queries[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return QueryBatchRequestValidationError{
					field:  fmt.Sprintf("Queries[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return QueryBatchRequestMultiError(errors)
	}

	return nil
}

// QueryBatchRequestMultiError is an error wrapping multiple validation errors
// returned by QueryBatchRequest.ValidateAll() if the designated constraints
// aren't met.
type QueryBatchRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m QueryBatchRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m QueryBatchRequestMultiError) AllErrors() []error { return m }

// QueryBatchRequestValidationError is the validation error returned by
// QueryBatchRequest.Validate if the designated constraints aren't met.
type QueryBatchRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e QueryBatchRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e QueryBatchRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e QueryBatchRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e QueryBatchRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e QueryBatchRequestValidationError) ErrorName() string {
	return "QueryBatchRequestValidationError"
}

// Error satisfies the builtin error interface
func (e QueryBatchRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sQueryBatchRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = QueryBatchRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = QueryBatchRequestValidationError{}

// Validate checks the field values on QueryBatchResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *QueryBatchResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on QueryBatchResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// QueryBatchResponseMultiError, or nil if none found.
func (m *QueryBatchResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *QueryBatchResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Index

	if all {
		switch v := interface{}(m.GetResult()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, QueryBatchResponseValidationError{
					field:  "Result",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, QueryBatchResponseValidationError{
					field:  "Result",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetResult()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return QueryBatchResponseValidationError{
				field:  "Result",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Error

	if len(errors) > 0 {
		return QueryBatchResponseMultiError(errors)
	}

	return nil
}

// QueryBatchResponseMultiError is an error wrapping multiple validation errors
// returned by QueryBatchResponse.ValidateAll() if the designated constraints
// aren't met.
type QueryBatchResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m QueryBatchResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m QueryBatchResponseMultiError) AllErrors() []error { return m }

// QueryBatchResponseValidationError is the validation error returned by
// QueryBatchResponse.Validate if the designated constraints aren't met.
type QueryBatchResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e QueryBatchResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e QueryBatchResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e QueryBatchResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e QueryBatchResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e QueryBatchResponseValidationError) ErrorName() string {
	return "QueryBatchResponseValidationError"
}

// Error satisfies the builtin error interface
func (e QueryBatchResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sQueryBatchResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = QueryBatchResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = QueryBatchResponseValidationError{}

// Validate checks the field values on ExportRequest with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ExportRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ExportRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ExportRequestMultiError, or
// nil if none found.
func (m *ExportRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ExportRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for InstanceId

	// no validation rules for Limit

	// no validation rules for Format

	if all {
		switch v := interface{}(m.GetQuery()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ExportRequestValidationError{
					field:  "Query",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ExportRequestValidationError{
					field:  "Query",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetQuery()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ExportRequestValidationError{
				field:  "Query",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for BakedQuery

	// no validation rules for IncludeHeader

	if all {
		switch v := interface{}(m.GetOriginDashboard()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ExportRequestValidationError{
					field:  "OriginDashboard",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ExportRequestValidationError{
					field:  "OriginDashboard",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetOriginDashboard()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ExportRequestValidationError{
				field:  "OriginDashboard",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for OriginUrl

	if len(errors) > 0 {
		return ExportRequestMultiError(errors)
	}

	return nil
}

// ExportRequestMultiError is an error wrapping multiple validation errors
// returned by ExportRequest.ValidateAll() if the designated constraints
// aren't met.
type ExportRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ExportRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ExportRequestMultiError) AllErrors() []error { return m }

// ExportRequestValidationError is the validation error returned by
// ExportRequest.Validate if the designated constraints aren't met.
type ExportRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ExportRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ExportRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ExportRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ExportRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ExportRequestValidationError) ErrorName() string { return "ExportRequestValidationError" }

// Error satisfies the builtin error interface
func (e ExportRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sExportRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ExportRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ExportRequestValidationError{}

// Validate checks the field values on ExportResponse with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ExportResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ExportResponse with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ExportResponseMultiError,
// or nil if none found.
func (m *ExportResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ExportResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for DownloadUrlPath

	if len(errors) > 0 {
		return ExportResponseMultiError(errors)
	}

	return nil
}

// ExportResponseMultiError is an error wrapping multiple validation errors
// returned by ExportResponse.ValidateAll() if the designated constraints
// aren't met.
type ExportResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ExportResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ExportResponseMultiError) AllErrors() []error { return m }

// ExportResponseValidationError is the validation error returned by
// ExportResponse.Validate if the designated constraints aren't met.
type ExportResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ExportResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ExportResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ExportResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ExportResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ExportResponseValidationError) ErrorName() string { return "ExportResponseValidationError" }

// Error satisfies the builtin error interface
func (e ExportResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sExportResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ExportResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ExportResponseValidationError{}

// Validate checks the field values on ExportReportRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ExportReportRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ExportReportRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ExportReportRequestMultiError, or nil if none found.
func (m *ExportReportRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ExportReportRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for InstanceId

	// no validation rules for Report

	if all {
		switch v := interface{}(m.GetExecutionTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ExportReportRequestValidationError{
					field:  "ExecutionTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ExportReportRequestValidationError{
					field:  "ExecutionTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetExecutionTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ExportReportRequestValidationError{
				field:  "ExecutionTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for OriginBaseUrl

	if len(errors) > 0 {
		return ExportReportRequestMultiError(errors)
	}

	return nil
}

// ExportReportRequestMultiError is an error wrapping multiple validation
// errors returned by ExportReportRequest.ValidateAll() if the designated
// constraints aren't met.
type ExportReportRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ExportReportRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ExportReportRequestMultiError) AllErrors() []error { return m }

// ExportReportRequestValidationError is the validation error returned by
// ExportReportRequest.Validate if the designated constraints aren't met.
type ExportReportRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ExportReportRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ExportReportRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ExportReportRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ExportReportRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ExportReportRequestValidationError) ErrorName() string {
	return "ExportReportRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ExportReportRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sExportReportRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ExportReportRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ExportReportRequestValidationError{}

// Validate checks the field values on ExportReportResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ExportReportResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ExportReportResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ExportReportResponseMultiError, or nil if none found.
func (m *ExportReportResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ExportReportResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for DownloadUrlPath

	if len(errors) > 0 {
		return ExportReportResponseMultiError(errors)
	}

	return nil
}

// ExportReportResponseMultiError is an error wrapping multiple validation
// errors returned by ExportReportResponse.ValidateAll() if the designated
// constraints aren't met.
type ExportReportResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ExportReportResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ExportReportResponseMultiError) AllErrors() []error { return m }

// ExportReportResponseValidationError is the validation error returned by
// ExportReportResponse.Validate if the designated constraints aren't met.
type ExportReportResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ExportReportResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ExportReportResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ExportReportResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ExportReportResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ExportReportResponseValidationError) ErrorName() string {
	return "ExportReportResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ExportReportResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sExportReportResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ExportReportResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ExportReportResponseValidationError{}

// Validate checks the field values on Query with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Query) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Query with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in QueryMultiError, or nil if none found.
func (m *Query) ValidateAll() error {
	return m.validate(true)
}

func (m *Query) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	switch v := m.Query.(type) {
	case *Query_MetricsViewAggregationRequest:
		if v == nil {
			err := QueryValidationError{
				field:  "Query",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetMetricsViewAggregationRequest()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, QueryValidationError{
						field:  "MetricsViewAggregationRequest",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, QueryValidationError{
						field:  "MetricsViewAggregationRequest",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetMetricsViewAggregationRequest()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return QueryValidationError{
					field:  "MetricsViewAggregationRequest",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Query_MetricsViewToplistRequest:
		if v == nil {
			err := QueryValidationError{
				field:  "Query",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetMetricsViewToplistRequest()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, QueryValidationError{
						field:  "MetricsViewToplistRequest",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, QueryValidationError{
						field:  "MetricsViewToplistRequest",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetMetricsViewToplistRequest()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return QueryValidationError{
					field:  "MetricsViewToplistRequest",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Query_MetricsViewComparisonRequest:
		if v == nil {
			err := QueryValidationError{
				field:  "Query",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetMetricsViewComparisonRequest()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, QueryValidationError{
						field:  "MetricsViewComparisonRequest",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, QueryValidationError{
						field:  "MetricsViewComparisonRequest",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetMetricsViewComparisonRequest()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return QueryValidationError{
					field:  "MetricsViewComparisonRequest",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Query_MetricsViewTimeSeriesRequest:
		if v == nil {
			err := QueryValidationError{
				field:  "Query",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetMetricsViewTimeSeriesRequest()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, QueryValidationError{
						field:  "MetricsViewTimeSeriesRequest",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, QueryValidationError{
						field:  "MetricsViewTimeSeriesRequest",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetMetricsViewTimeSeriesRequest()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return QueryValidationError{
					field:  "MetricsViewTimeSeriesRequest",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Query_MetricsViewTotalsRequest:
		if v == nil {
			err := QueryValidationError{
				field:  "Query",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetMetricsViewTotalsRequest()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, QueryValidationError{
						field:  "MetricsViewTotalsRequest",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, QueryValidationError{
						field:  "MetricsViewTotalsRequest",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetMetricsViewTotalsRequest()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return QueryValidationError{
					field:  "MetricsViewTotalsRequest",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Query_MetricsViewRowsRequest:
		if v == nil {
			err := QueryValidationError{
				field:  "Query",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetMetricsViewRowsRequest()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, QueryValidationError{
						field:  "MetricsViewRowsRequest",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, QueryValidationError{
						field:  "MetricsViewRowsRequest",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetMetricsViewRowsRequest()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return QueryValidationError{
					field:  "MetricsViewRowsRequest",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Query_ColumnRollupIntervalRequest:
		if v == nil {
			err := QueryValidationError{
				field:  "Query",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetColumnRollupIntervalRequest()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, QueryValidationError{
						field:  "ColumnRollupIntervalRequest",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, QueryValidationError{
						field:  "ColumnRollupIntervalRequest",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetColumnRollupIntervalRequest()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return QueryValidationError{
					field:  "ColumnRollupIntervalRequest",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Query_ColumnTopKRequest:
		if v == nil {
			err := QueryValidationError{
				field:  "Query",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetColumnTopKRequest()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, QueryValidationError{
						field:  "ColumnTopKRequest",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, QueryValidationError{
						field:  "ColumnTopKRequest",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetColumnTopKRequest()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return QueryValidationError{
					field:  "ColumnTopKRequest",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Query_ColumnNullCountRequest:
		if v == nil {
			err := QueryValidationError{
				field:  "Query",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetColumnNullCountRequest()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, QueryValidationError{
						field:  "ColumnNullCountRequest",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, QueryValidationError{
						field:  "ColumnNullCountRequest",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetColumnNullCountRequest()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return QueryValidationError{
					field:  "ColumnNullCountRequest",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Query_ColumnDescriptiveStatisticsRequest:
		if v == nil {
			err := QueryValidationError{
				field:  "Query",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetColumnDescriptiveStatisticsRequest()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, QueryValidationError{
						field:  "ColumnDescriptiveStatisticsRequest",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, QueryValidationError{
						field:  "ColumnDescriptiveStatisticsRequest",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetColumnDescriptiveStatisticsRequest()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return QueryValidationError{
					field:  "ColumnDescriptiveStatisticsRequest",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Query_ColumnTimeGrainRequest:
		if v == nil {
			err := QueryValidationError{
				field:  "Query",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetColumnTimeGrainRequest()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, QueryValidationError{
						field:  "ColumnTimeGrainRequest",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, QueryValidationError{
						field:  "ColumnTimeGrainRequest",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetColumnTimeGrainRequest()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return QueryValidationError{
					field:  "ColumnTimeGrainRequest",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Query_ColumnNumericHistogramRequest:
		if v == nil {
			err := QueryValidationError{
				field:  "Query",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetColumnNumericHistogramRequest()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, QueryValidationError{
						field:  "ColumnNumericHistogramRequest",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, QueryValidationError{
						field:  "ColumnNumericHistogramRequest",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetColumnNumericHistogramRequest()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return QueryValidationError{
					field:  "ColumnNumericHistogramRequest",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Query_ColumnRugHistogramRequest:
		if v == nil {
			err := QueryValidationError{
				field:  "Query",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetColumnRugHistogramRequest()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, QueryValidationError{
						field:  "ColumnRugHistogramRequest",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, QueryValidationError{
						field:  "ColumnRugHistogramRequest",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetColumnRugHistogramRequest()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return QueryValidationError{
					field:  "ColumnRugHistogramRequest",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Query_ColumnTimeRangeRequest:
		if v == nil {
			err := QueryValidationError{
				field:  "Query",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetColumnTimeRangeRequest()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, QueryValidationError{
						field:  "ColumnTimeRangeRequest",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, QueryValidationError{
						field:  "ColumnTimeRangeRequest",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetColumnTimeRangeRequest()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return QueryValidationError{
					field:  "ColumnTimeRangeRequest",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Query_ColumnCardinalityRequest:
		if v == nil {
			err := QueryValidationError{
				field:  "Query",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetColumnCardinalityRequest()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, QueryValidationError{
						field:  "ColumnCardinalityRequest",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, QueryValidationError{
						field:  "ColumnCardinalityRequest",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetColumnCardinalityRequest()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return QueryValidationError{
					field:  "ColumnCardinalityRequest",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Query_ColumnTimeSeriesRequest:
		if v == nil {
			err := QueryValidationError{
				field:  "Query",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetColumnTimeSeriesRequest()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, QueryValidationError{
						field:  "ColumnTimeSeriesRequest",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, QueryValidationError{
						field:  "ColumnTimeSeriesRequest",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetColumnTimeSeriesRequest()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return QueryValidationError{
					field:  "ColumnTimeSeriesRequest",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Query_TableCardinalityRequest:
		if v == nil {
			err := QueryValidationError{
				field:  "Query",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetTableCardinalityRequest()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, QueryValidationError{
						field:  "TableCardinalityRequest",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, QueryValidationError{
						field:  "TableCardinalityRequest",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetTableCardinalityRequest()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return QueryValidationError{
					field:  "TableCardinalityRequest",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Query_TableColumnsRequest:
		if v == nil {
			err := QueryValidationError{
				field:  "Query",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetTableColumnsRequest()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, QueryValidationError{
						field:  "TableColumnsRequest",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, QueryValidationError{
						field:  "TableColumnsRequest",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetTableColumnsRequest()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return QueryValidationError{
					field:  "TableColumnsRequest",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Query_TableRowsRequest:
		if v == nil {
			err := QueryValidationError{
				field:  "Query",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetTableRowsRequest()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, QueryValidationError{
						field:  "TableRowsRequest",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, QueryValidationError{
						field:  "TableRowsRequest",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetTableRowsRequest()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return QueryValidationError{
					field:  "TableRowsRequest",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	default:
		_ = v // ensures v is used
	}

	if len(errors) > 0 {
		return QueryMultiError(errors)
	}

	return nil
}

// QueryMultiError is an error wrapping multiple validation errors returned by
// Query.ValidateAll() if the designated constraints aren't met.
type QueryMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m QueryMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m QueryMultiError) AllErrors() []error { return m }

// QueryValidationError is the validation error returned by Query.Validate if
// the designated constraints aren't met.
type QueryValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e QueryValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e QueryValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e QueryValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e QueryValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e QueryValidationError) ErrorName() string { return "QueryValidationError" }

// Error satisfies the builtin error interface
func (e QueryValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sQuery.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = QueryValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = QueryValidationError{}

// Validate checks the field values on QueryResult with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *QueryResult) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on QueryResult with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in QueryResultMultiError, or
// nil if none found.
func (m *QueryResult) ValidateAll() error {
	return m.validate(true)
}

func (m *QueryResult) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	switch v := m.Result.(type) {
	case *QueryResult_MetricsViewAggregationResponse:
		if v == nil {
			err := QueryResultValidationError{
				field:  "Result",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetMetricsViewAggregationResponse()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, QueryResultValidationError{
						field:  "MetricsViewAggregationResponse",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, QueryResultValidationError{
						field:  "MetricsViewAggregationResponse",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetMetricsViewAggregationResponse()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return QueryResultValidationError{
					field:  "MetricsViewAggregationResponse",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *QueryResult_MetricsViewToplistResponse:
		if v == nil {
			err := QueryResultValidationError{
				field:  "Result",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetMetricsViewToplistResponse()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, QueryResultValidationError{
						field:  "MetricsViewToplistResponse",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, QueryResultValidationError{
						field:  "MetricsViewToplistResponse",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetMetricsViewToplistResponse()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return QueryResultValidationError{
					field:  "MetricsViewToplistResponse",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *QueryResult_MetricsViewComparisonResponse:
		if v == nil {
			err := QueryResultValidationError{
				field:  "Result",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetMetricsViewComparisonResponse()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, QueryResultValidationError{
						field:  "MetricsViewComparisonResponse",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, QueryResultValidationError{
						field:  "MetricsViewComparisonResponse",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetMetricsViewComparisonResponse()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return QueryResultValidationError{
					field:  "MetricsViewComparisonResponse",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *QueryResult_MetricsViewTimeSeriesResponse:
		if v == nil {
			err := QueryResultValidationError{
				field:  "Result",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetMetricsViewTimeSeriesResponse()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, QueryResultValidationError{
						field:  "MetricsViewTimeSeriesResponse",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, QueryResultValidationError{
						field:  "MetricsViewTimeSeriesResponse",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetMetricsViewTimeSeriesResponse()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return QueryResultValidationError{
					field:  "MetricsViewTimeSeriesResponse",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *QueryResult_MetricsViewTotalsResponse:
		if v == nil {
			err := QueryResultValidationError{
				field:  "Result",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetMetricsViewTotalsResponse()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, QueryResultValidationError{
						field:  "MetricsViewTotalsResponse",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, QueryResultValidationError{
						field:  "MetricsViewTotalsResponse",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetMetricsViewTotalsResponse()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return QueryResultValidationError{
					field:  "MetricsViewTotalsResponse",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *QueryResult_MetricsViewRowsResponse:
		if v == nil {
			err := QueryResultValidationError{
				field:  "Result",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetMetricsViewRowsResponse()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, QueryResultValidationError{
						field:  "MetricsViewRowsResponse",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, QueryResultValidationError{
						field:  "MetricsViewRowsResponse",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetMetricsViewRowsResponse()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return QueryResultValidationError{
					field:  "MetricsViewRowsResponse",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *QueryResult_ColumnRollupIntervalResponse:
		if v == nil {
			err := QueryResultValidationError{
				field:  "Result",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetColumnRollupIntervalResponse()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, QueryResultValidationError{
						field:  "ColumnRollupIntervalResponse",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, QueryResultValidationError{
						field:  "ColumnRollupIntervalResponse",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetColumnRollupIntervalResponse()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return QueryResultValidationError{
					field:  "ColumnRollupIntervalResponse",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *QueryResult_ColumnTopKResponse:
		if v == nil {
			err := QueryResultValidationError{
				field:  "Result",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetColumnTopKResponse()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, QueryResultValidationError{
						field:  "ColumnTopKResponse",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, QueryResultValidationError{
						field:  "ColumnTopKResponse",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetColumnTopKResponse()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return QueryResultValidationError{
					field:  "ColumnTopKResponse",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *QueryResult_ColumnNullCountResponse:
		if v == nil {
			err := QueryResultValidationError{
				field:  "Result",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetColumnNullCountResponse()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, QueryResultValidationError{
						field:  "ColumnNullCountResponse",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, QueryResultValidationError{
						field:  "ColumnNullCountResponse",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetColumnNullCountResponse()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return QueryResultValidationError{
					field:  "ColumnNullCountResponse",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *QueryResult_ColumnDescriptiveStatisticsResponse:
		if v == nil {
			err := QueryResultValidationError{
				field:  "Result",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetColumnDescriptiveStatisticsResponse()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, QueryResultValidationError{
						field:  "ColumnDescriptiveStatisticsResponse",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, QueryResultValidationError{
						field:  "ColumnDescriptiveStatisticsResponse",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetColumnDescriptiveStatisticsResponse()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return QueryResultValidationError{
					field:  "ColumnDescriptiveStatisticsResponse",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *QueryResult_ColumnTimeGrainResponse:
		if v == nil {
			err := QueryResultValidationError{
				field:  "Result",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetColumnTimeGrainResponse()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, QueryResultValidationError{
						field:  "ColumnTimeGrainResponse",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, QueryResultValidationError{
						field:  "ColumnTimeGrainResponse",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetColumnTimeGrainResponse()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return QueryResultValidationError{
					field:  "ColumnTimeGrainResponse",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *QueryResult_ColumnNumericHistogramResponse:
		if v == nil {
			err := QueryResultValidationError{
				field:  "Result",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetColumnNumericHistogramResponse()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, QueryResultValidationError{
						field:  "ColumnNumericHistogramResponse",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, QueryResultValidationError{
						field:  "ColumnNumericHistogramResponse",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetColumnNumericHistogramResponse()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return QueryResultValidationError{
					field:  "ColumnNumericHistogramResponse",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *QueryResult_ColumnRugHistogramResponse:
		if v == nil {
			err := QueryResultValidationError{
				field:  "Result",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetColumnRugHistogramResponse()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, QueryResultValidationError{
						field:  "ColumnRugHistogramResponse",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, QueryResultValidationError{
						field:  "ColumnRugHistogramResponse",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetColumnRugHistogramResponse()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return QueryResultValidationError{
					field:  "ColumnRugHistogramResponse",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *QueryResult_ColumnTimeRangeResponse:
		if v == nil {
			err := QueryResultValidationError{
				field:  "Result",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetColumnTimeRangeResponse()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, QueryResultValidationError{
						field:  "ColumnTimeRangeResponse",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, QueryResultValidationError{
						field:  "ColumnTimeRangeResponse",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetColumnTimeRangeResponse()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return QueryResultValidationError{
					field:  "ColumnTimeRangeResponse",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *QueryResult_ColumnCardinalityResponse:
		if v == nil {
			err := QueryResultValidationError{
				field:  "Result",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetColumnCardinalityResponse()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, QueryResultValidationError{
						field:  "ColumnCardinalityResponse",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, QueryResultValidationError{
						field:  "ColumnCardinalityResponse",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetColumnCardinalityResponse()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return QueryResultValidationError{
					field:  "ColumnCardinalityResponse",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *QueryResult_ColumnTimeSeriesResponse:
		if v == nil {
			err := QueryResultValidationError{
				field:  "Result",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetColumnTimeSeriesResponse()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, QueryResultValidationError{
						field:  "ColumnTimeSeriesResponse",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, QueryResultValidationError{
						field:  "ColumnTimeSeriesResponse",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetColumnTimeSeriesResponse()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return QueryResultValidationError{
					field:  "ColumnTimeSeriesResponse",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *QueryResult_TableCardinalityResponse:
		if v == nil {
			err := QueryResultValidationError{
				field:  "Result",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetTableCardinalityResponse()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, QueryResultValidationError{
						field:  "TableCardinalityResponse",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, QueryResultValidationError{
						field:  "TableCardinalityResponse",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetTableCardinalityResponse()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return QueryResultValidationError{
					field:  "TableCardinalityResponse",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *QueryResult_TableColumnsResponse:
		if v == nil {
			err := QueryResultValidationError{
				field:  "Result",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetTableColumnsResponse()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, QueryResultValidationError{
						field:  "TableColumnsResponse",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, QueryResultValidationError{
						field:  "TableColumnsResponse",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetTableColumnsResponse()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return QueryResultValidationError{
					field:  "TableColumnsResponse",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *QueryResult_TableRowsResponse:
		if v == nil {
			err := QueryResultValidationError{
				field:  "Result",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetTableRowsResponse()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, QueryResultValidationError{
						field:  "TableRowsResponse",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, QueryResultValidationError{
						field:  "TableRowsResponse",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetTableRowsResponse()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return QueryResultValidationError{
					field:  "TableRowsResponse",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	default:
		_ = v // ensures v is used
	}

	if len(errors) > 0 {
		return QueryResultMultiError(errors)
	}

	return nil
}

// QueryResultMultiError is an error wrapping multiple validation errors
// returned by QueryResult.ValidateAll() if the designated constraints aren't met.
type QueryResultMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m QueryResultMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m QueryResultMultiError) AllErrors() []error { return m }

// QueryResultValidationError is the validation error returned by
// QueryResult.Validate if the designated constraints aren't met.
type QueryResultValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e QueryResultValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e QueryResultValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e QueryResultValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e QueryResultValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e QueryResultValidationError) ErrorName() string { return "QueryResultValidationError" }

// Error satisfies the builtin error interface
func (e QueryResultValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sQueryResult.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = QueryResultValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = QueryResultValidationError{}

// Validate checks the field values on MetricsViewAggregationRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *MetricsViewAggregationRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on MetricsViewAggregationRequest with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// MetricsViewAggregationRequestMultiError, or nil if none found.
func (m *MetricsViewAggregationRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *MetricsViewAggregationRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for InstanceId

	if utf8.RuneCountInString(m.GetMetricsView()) < 1 {
		err := MetricsViewAggregationRequestValidationError{
			field:  "MetricsView",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	for idx, item := range m.GetDimensions() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, MetricsViewAggregationRequestValidationError{
						field:  fmt.Sprintf("Dimensions[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, MetricsViewAggregationRequestValidationError{
						field:  fmt.Sprintf("Dimensions[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return MetricsViewAggregationRequestValidationError{
					field:  fmt.Sprintf("Dimensions[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetMeasures() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, MetricsViewAggregationRequestValidationError{
						field:  fmt.Sprintf("Measures[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, MetricsViewAggregationRequestValidationError{
						field:  fmt.Sprintf("Measures[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return MetricsViewAggregationRequestValidationError{
					field:  fmt.Sprintf("Measures[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetSort() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, MetricsViewAggregationRequestValidationError{
						field:  fmt.Sprintf("Sort[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, MetricsViewAggregationRequestValidationError{
						field:  fmt.Sprintf("Sort[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return MetricsViewAggregationRequestValidationError{
					field:  fmt.Sprintf("Sort[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if all {
		switch v := interface{}(m.GetTimeRange()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, MetricsViewAggregationRequestValidationError{
					field:  "TimeRange",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, MetricsViewAggregationRequestValidationError{
					field:  "TimeRange",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTimeRange()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return MetricsViewAggregationRequestValidationError{
				field:  "TimeRange",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetComparisonTimeRange()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, MetricsViewAggregationRequestValidationError{
					field:  "ComparisonTimeRange",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, MetricsViewAggregationRequestValidationError{
					field:  "ComparisonTimeRange",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetComparisonTimeRange()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return MetricsViewAggregationRequestValidationError{
				field:  "ComparisonTimeRange",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetTimeStart()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, MetricsViewAggregationRequestValidationError{
					field:  "TimeStart",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, MetricsViewAggregationRequestValidationError{
					field:  "TimeStart",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTimeStart()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return MetricsViewAggregationRequestValidationError{
				field:  "TimeStart",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetTimeEnd()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, MetricsViewAggregationRequestValidationError{
					field:  "TimeEnd",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, MetricsViewAggregationRequestValidationError{
					field:  "TimeEnd",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTimeEnd()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return MetricsViewAggregationRequestValidationError{
				field:  "TimeEnd",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetAliases() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, MetricsViewAggregationRequestValidationError{
						field:  fmt.Sprintf("Aliases[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, MetricsViewAggregationRequestValidationError{
						field:  fmt.Sprintf("Aliases[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return MetricsViewAggregationRequestValidationError{
					field:  fmt.Sprintf("Aliases[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if all {
		switch v := interface{}(m.GetWhere()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, MetricsViewAggregationRequestValidationError{
					field:  "Where",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, MetricsViewAggregationRequestValidationError{
					field:  "Where",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetWhere()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return MetricsViewAggregationRequestValidationError{
				field:  "Where",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for WhereSql

	if all {
		switch v := interface{}(m.GetHaving()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, MetricsViewAggregationRequestValidationError{
					field:  "Having",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, MetricsViewAggregationRequestValidationError{
					field:  "Having",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetHaving()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return MetricsViewAggregationRequestValidationError{
				field:  "Having",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for HavingSql

	if m.GetLimit() < 0 {
		err := MetricsViewAggregationRequestValidationError{
			field:  "Limit",
			reason: "value must be greater than or equal to 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetOffset() < 0 {
		err := MetricsViewAggregationRequestValidationError{
			field:  "Offset",
			reason: "value must be greater than or equal to 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Priority

	if all {
		switch v := interface{}(m.GetFilter()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, MetricsViewAggregationRequestValidationError{
					field:  "Filter",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, MetricsViewAggregationRequestValidationError{
					field:  "Filter",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetFilter()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return MetricsViewAggregationRequestValidationError{
				field:  "Filter",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Exact

	// no validation rules for FillMissing

	// no validation rules for Rows

	if len(errors) > 0 {
		return MetricsViewAggregationRequestMultiError(errors)
	}

	return nil
}

// MetricsViewAggregationRequestMultiError is an error wrapping multiple
// validation errors returned by MetricsViewAggregationRequest.ValidateAll()
// if the designated constraints aren't met.
type MetricsViewAggregationRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MetricsViewAggregationRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MetricsViewAggregationRequestMultiError) AllErrors() []error { return m }

// MetricsViewAggregationRequestValidationError is the validation error
// returned by MetricsViewAggregationRequest.Validate if the designated
// constraints aren't met.
type MetricsViewAggregationRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MetricsViewAggregationRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MetricsViewAggregationRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MetricsViewAggregationRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MetricsViewAggregationRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MetricsViewAggregationRequestValidationError) ErrorName() string {
	return "MetricsViewAggregationRequestValidationError"
}

// Error satisfies the builtin error interface
func (e MetricsViewAggregationRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMetricsViewAggregationRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MetricsViewAggregationRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MetricsViewAggregationRequestValidationError{}

// Validate checks the field values on MetricsViewAggregationResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *MetricsViewAggregationResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on MetricsViewAggregationResponse with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// MetricsViewAggregationResponseMultiError, or nil if none found.
func (m *MetricsViewAggregationResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *MetricsViewAggregationResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetSchema()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, MetricsViewAggregationResponseValidationError{
					field:  "Schema",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, MetricsViewAggregationResponseValidationError{
					field:  "Schema",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSchema()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return MetricsViewAggregationResponseValidationError{
				field:  "Schema",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetData() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, MetricsViewAggregationResponseValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, MetricsViewAggregationResponseValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return MetricsViewAggregationResponseValidationError{
					field:  fmt.Sprintf("Data[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return MetricsViewAggregationResponseMultiError(errors)
	}

	return nil
}

// MetricsViewAggregationResponseMultiError is an error wrapping multiple
// validation errors returned by MetricsViewAggregationResponse.ValidateAll()
// if the designated constraints aren't met.
type MetricsViewAggregationResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MetricsViewAggregationResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MetricsViewAggregationResponseMultiError) AllErrors() []error { return m }

// MetricsViewAggregationResponseValidationError is the validation error
// returned by MetricsViewAggregationResponse.Validate if the designated
// constraints aren't met.
type MetricsViewAggregationResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MetricsViewAggregationResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MetricsViewAggregationResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MetricsViewAggregationResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MetricsViewAggregationResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MetricsViewAggregationResponseValidationError) ErrorName() string {
	return "MetricsViewAggregationResponseValidationError"
}

// Error satisfies the builtin error interface
func (e MetricsViewAggregationResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMetricsViewAggregationResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MetricsViewAggregationResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MetricsViewAggregationResponseValidationError{}

// Validate checks the field values on MetricsViewAggregationDimension with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *MetricsViewAggregationDimension) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on MetricsViewAggregationDimension with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// MetricsViewAggregationDimensionMultiError, or nil if none found.
func (m *MetricsViewAggregationDimension) ValidateAll() error {
	return m.validate(true)
}

func (m *MetricsViewAggregationDimension) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Name

	// no validation rules for TimeGrain

	// no validation rules for TimeZone

	// no validation rules for Alias

	if len(errors) > 0 {
		return MetricsViewAggregationDimensionMultiError(errors)
	}

	return nil
}

// MetricsViewAggregationDimensionMultiError is an error wrapping multiple
// validation errors returned by MetricsViewAggregationDimension.ValidateAll()
// if the designated constraints aren't met.
type MetricsViewAggregationDimensionMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MetricsViewAggregationDimensionMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MetricsViewAggregationDimensionMultiError) AllErrors() []error { return m }

// MetricsViewAggregationDimensionValidationError is the validation error
// returned by MetricsViewAggregationDimension.Validate if the designated
// constraints aren't met.
type MetricsViewAggregationDimensionValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MetricsViewAggregationDimensionValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MetricsViewAggregationDimensionValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MetricsViewAggregationDimensionValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MetricsViewAggregationDimensionValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MetricsViewAggregationDimensionValidationError) ErrorName() string {
	return "MetricsViewAggregationDimensionValidationError"
}

// Error satisfies the builtin error interface
func (e MetricsViewAggregationDimensionValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMetricsViewAggregationDimension.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MetricsViewAggregationDimensionValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MetricsViewAggregationDimensionValidationError{}

// Validate checks the field values on MetricsViewAggregationMeasure with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *MetricsViewAggregationMeasure) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on MetricsViewAggregationMeasure with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// MetricsViewAggregationMeasureMultiError, or nil if none found.
func (m *MetricsViewAggregationMeasure) ValidateAll() error {
	return m.validate(true)
}

func (m *MetricsViewAggregationMeasure) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Name

	// no validation rules for BuiltinMeasure

	for idx, item := range m.GetBuiltinMeasureArgs() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, MetricsViewAggregationMeasureValidationError{
						field:  fmt.Sprintf("BuiltinMeasureArgs[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, MetricsViewAggregationMeasureValidationError{
						field:  fmt.Sprintf("BuiltinMeasureArgs[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return MetricsViewAggregationMeasureValidationError{
					field:  fmt.Sprintf("BuiltinMeasureArgs[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if all {
		switch v := interface{}(m.GetFilter()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, MetricsViewAggregationMeasureValidationError{
					field:  "Filter",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, MetricsViewAggregationMeasureValidationError{
					field:  "Filter",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetFilter()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return MetricsViewAggregationMeasureValidationError{
				field:  "Filter",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	switch v := m.Compute.(type) {
	case *MetricsViewAggregationMeasure_Count:
		if v == nil {
			err := MetricsViewAggregationMeasureValidationError{
				field:  "Compute",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetCount()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, MetricsViewAggregationMeasureValidationError{
						field:  "Count",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, MetricsViewAggregationMeasureValidationError{
						field:  "Count",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetCount()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return MetricsViewAggregationMeasureValidationError{
					field:  "Count",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *MetricsViewAggregationMeasure_CountDistinct:
		if v == nil {
			err := MetricsViewAggregationMeasureValidationError{
				field:  "Compute",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetCountDistinct()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, MetricsViewAggregationMeasureValidationError{
						field:  "CountDistinct",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, MetricsViewAggregationMeasureValidationError{
						field:  "CountDistinct",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetCountDistinct()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return MetricsViewAggregationMeasureValidationError{
					field:  "CountDistinct",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *MetricsViewAggregationMeasure_ComparisonValue:
		if v == nil {
			err := MetricsViewAggregationMeasureValidationError{
				field:  "Compute",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetComparisonValue()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, MetricsViewAggregationMeasureValidationError{
						field:  "ComparisonValue",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, MetricsViewAggregationMeasureValidationError{
						field:  "ComparisonValue",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetComparisonValue()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return MetricsViewAggregationMeasureValidationError{
					field:  "ComparisonValue",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *MetricsViewAggregationMeasure_ComparisonDelta:
		if v == nil {
			err := MetricsViewAggregationMeasureValidationError{
				field:  "Compute",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetComparisonDelta()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, MetricsViewAggregationMeasureValidationError{
						field:  "ComparisonDelta",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, MetricsViewAggregationMeasureValidationError{
						field:  "ComparisonDelta",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetComparisonDelta()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return MetricsViewAggregationMeasureValidationError{
					field:  "ComparisonDelta",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *MetricsViewAggregationMeasure_ComparisonRatio:
		if v == nil {
			err := MetricsViewAggregationMeasureValidationError{
				field:  "Compute",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetComparisonRatio()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, MetricsViewAggregationMeasureValidationError{
						field:  "ComparisonRatio",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, MetricsViewAggregationMeasureValidationError{
						field:  "ComparisonRatio",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetComparisonRatio()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return MetricsViewAggregationMeasureValidationError{
					field:  "ComparisonRatio",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *MetricsViewAggregationMeasure_PercentOfTotal:
		if v == nil {
			err := MetricsViewAggregationMeasureValidationError{
				field:  "Compute",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetPercentOfTotal()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, MetricsViewAggregationMeasureValidationError{
						field:  "PercentOfTotal",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, MetricsViewAggregationMeasureValidationError{
						field:  "PercentOfTotal",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetPercentOfTotal()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return MetricsViewAggregationMeasureValidationError{
					field:  "PercentOfTotal",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *MetricsViewAggregationMeasure_Uri:
		if v == nil {
			err := MetricsViewAggregationMeasureValidationError{
				field:  "Compute",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetUri()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, MetricsViewAggregationMeasureValidationError{
						field:  "Uri",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, MetricsViewAggregationMeasureValidationError{
						field:  "Uri",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetUri()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return MetricsViewAggregationMeasureValidationError{
					field:  "Uri",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *MetricsViewAggregationMeasure_ComparisonTime:
		if v == nil {
			err := MetricsViewAggregationMeasureValidationError{
				field:  "Compute",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetComparisonTime()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, MetricsViewAggregationMeasureValidationError{
						field:  "ComparisonTime",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, MetricsViewAggregationMeasureValidationError{
						field:  "ComparisonTime",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetComparisonTime()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return MetricsViewAggregationMeasureValidationError{
					field:  "ComparisonTime",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	default:
		_ = v // ensures v is used
	}

	if len(errors) > 0 {
		return MetricsViewAggregationMeasureMultiError(errors)
	}

	return nil
}

// MetricsViewAggregationMeasureMultiError is an error wrapping multiple
// validation errors returned by MetricsViewAggregationMeasure.ValidateAll()
// if the designated constraints aren't met.
type MetricsViewAggregationMeasureMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MetricsViewAggregationMeasureMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MetricsViewAggregationMeasureMultiError) AllErrors() []error { return m }

// MetricsViewAggregationMeasureValidationError is the validation error
// returned by MetricsViewAggregationMeasure.Validate if the designated
// constraints aren't met.
type MetricsViewAggregationMeasureValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MetricsViewAggregationMeasureValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MetricsViewAggregationMeasureValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MetricsViewAggregationMeasureValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MetricsViewAggregationMeasureValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MetricsViewAggregationMeasureValidationError) ErrorName() string {
	return "MetricsViewAggregationMeasureValidationError"
}

// Error satisfies the builtin error interface
func (e MetricsViewAggregationMeasureValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMetricsViewAggregationMeasure.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MetricsViewAggregationMeasureValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MetricsViewAggregationMeasureValidationError{}

// Validate checks the field values on
// MetricsViewAggregationMeasureComputeCount with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *MetricsViewAggregationMeasureComputeCount) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on
// MetricsViewAggregationMeasureComputeCount with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in
// MetricsViewAggregationMeasureComputeCountMultiError, or nil if none found.
func (m *MetricsViewAggregationMeasureComputeCount) ValidateAll() error {
	return m.validate(true)
}

func (m *MetricsViewAggregationMeasureComputeCount) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return MetricsViewAggregationMeasureComputeCountMultiError(errors)
	}

	return nil
}

// MetricsViewAggregationMeasureComputeCountMultiError is an error wrapping
// multiple validation errors returned by
// MetricsViewAggregationMeasureComputeCount.ValidateAll() if the designated
// constraints aren't met.
type MetricsViewAggregationMeasureComputeCountMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MetricsViewAggregationMeasureComputeCountMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MetricsViewAggregationMeasureComputeCountMultiError) AllErrors() []error { return m }

// MetricsViewAggregationMeasureComputeCountValidationError is the validation
// error returned by MetricsViewAggregationMeasureComputeCount.Validate if the
// designated constraints aren't met.
type MetricsViewAggregationMeasureComputeCountValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MetricsViewAggregationMeasureComputeCountValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MetricsViewAggregationMeasureComputeCountValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MetricsViewAggregationMeasureComputeCountValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MetricsViewAggregationMeasureComputeCountValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MetricsViewAggregationMeasureComputeCountValidationError) ErrorName() string {
	return "MetricsViewAggregationMeasureComputeCountValidationError"
}

// Error satisfies the builtin error interface
func (e MetricsViewAggregationMeasureComputeCountValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMetricsViewAggregationMeasureComputeCount.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MetricsViewAggregationMeasureComputeCountValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MetricsViewAggregationMeasureComputeCountValidationError{}

// Validate checks the field values on
// MetricsViewAggregationMeasureComputeCountDistinct with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *MetricsViewAggregationMeasureComputeCountDistinct) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on
// MetricsViewAggregationMeasureComputeCountDistinct with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in
// MetricsViewAggregationMeasureComputeCountDistinctMultiError, or nil if none found.
func (m *MetricsViewAggregationMeasureComputeCountDistinct) ValidateAll() error {
	return m.validate(true)
}

func (m *MetricsViewAggregationMeasureComputeCountDistinct) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Dimension

	if len(errors) > 0 {
		return MetricsViewAggregationMeasureComputeCountDistinctMultiError(errors)
	}

	return nil
}

// MetricsViewAggregationMeasureComputeCountDistinctMultiError is an error
// wrapping multiple validation errors returned by
// MetricsViewAggregationMeasureComputeCountDistinct.ValidateAll() if the
// designated constraints aren't met.
type MetricsViewAggregationMeasureComputeCountDistinctMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MetricsViewAggregationMeasureComputeCountDistinctMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MetricsViewAggregationMeasureComputeCountDistinctMultiError) AllErrors() []error { return m }

// MetricsViewAggregationMeasureComputeCountDistinctValidationError is the
// validation error returned by
// MetricsViewAggregationMeasureComputeCountDistinct.Validate if the
// designated constraints aren't met.
type MetricsViewAggregationMeasureComputeCountDistinctValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MetricsViewAggregationMeasureComputeCountDistinctValidationError) Field() string {
	return e.field
}

// Reason function returns reason value.
func (e MetricsViewAggregationMeasureComputeCountDistinctValidationError) Reason() string {
	return e.reason
}

// Cause function returns cause value.
func (e MetricsViewAggregationMeasureComputeCountDistinctValidationError) Cause() error {
	return e.cause
}

// Key function returns key value.
func (e MetricsViewAggregationMeasureComputeCountDistinctValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MetricsViewAggregationMeasureComputeCountDistinctValidationError) ErrorName() string {
	return "MetricsViewAggregationMeasureComputeCountDistinctValidationError"
}

// Error satisfies the builtin error interface
func (e MetricsViewAggregationMeasureComputeCountDistinctValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMetricsViewAggregationMeasureComputeCountDistinct.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MetricsViewAggregationMeasureComputeCountDistinctValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MetricsViewAggregationMeasureComputeCountDistinctValidationError{}

// Validate checks the field values on
// MetricsViewAggregationMeasureComputeComparisonValue with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *MetricsViewAggregationMeasureComputeComparisonValue) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on
// MetricsViewAggregationMeasureComputeComparisonValue with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in
// MetricsViewAggregationMeasureComputeComparisonValueMultiError, or nil if
// none found.
func (m *MetricsViewAggregationMeasureComputeComparisonValue) ValidateAll() error {
	return m.validate(true)
}

func (m *MetricsViewAggregationMeasureComputeComparisonValue) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Measure

	if len(errors) > 0 {
		return MetricsViewAggregationMeasureComputeComparisonValueMultiError(errors)
	}

	return nil
}

// MetricsViewAggregationMeasureComputeComparisonValueMultiError is an error
// wrapping multiple validation errors returned by
// MetricsViewAggregationMeasureComputeComparisonValue.ValidateAll() if the
// designated constraints aren't met.
type MetricsViewAggregationMeasureComputeComparisonValueMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MetricsViewAggregationMeasureComputeComparisonValueMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MetricsViewAggregationMeasureComputeComparisonValueMultiError) AllErrors() []error { return m }

// MetricsViewAggregationMeasureComputeComparisonValueValidationError is the
// validation error returned by
// MetricsViewAggregationMeasureComputeComparisonValue.Validate if the
// designated constraints aren't met.
type MetricsViewAggregationMeasureComputeComparisonValueValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MetricsViewAggregationMeasureComputeComparisonValueValidationError) Field() string {
	return e.field
}

// Reason function returns reason value.
func (e MetricsViewAggregationMeasureComputeComparisonValueValidationError) Reason() string {
	return e.reason
}

// Cause function returns cause value.
func (e MetricsViewAggregationMeasureComputeComparisonValueValidationError) Cause() error {
	return e.cause
}

// Key function returns key value.
func (e MetricsViewAggregationMeasureComputeComparisonValueValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MetricsViewAggregationMeasureComputeComparisonValueValidationError) ErrorName() string {
	return "MetricsViewAggregationMeasureComputeComparisonValueValidationError"
}

// Error satisfies the builtin error interface
func (e MetricsViewAggregationMeasureComputeComparisonValueValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMetricsViewAggregationMeasureComputeComparisonValue.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MetricsViewAggregationMeasureComputeComparisonValueValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MetricsViewAggregationMeasureComputeComparisonValueValidationError{}

// Validate checks the field values on
// MetricsViewAggregationMeasureComputeComparisonDelta with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *MetricsViewAggregationMeasureComputeComparisonDelta) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on
// MetricsViewAggregationMeasureComputeComparisonDelta with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in
// MetricsViewAggregationMeasureComputeComparisonDeltaMultiError, or nil if
// none found.
func (m *MetricsViewAggregationMeasureComputeComparisonDelta) ValidateAll() error {
	return m.validate(true)
}

func (m *MetricsViewAggregationMeasureComputeComparisonDelta) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Measure

	if len(errors) > 0 {
		return MetricsViewAggregationMeasureComputeComparisonDeltaMultiError(errors)
	}

	return nil
}

// MetricsViewAggregationMeasureComputeComparisonDeltaMultiError is an error
// wrapping multiple validation errors returned by
// MetricsViewAggregationMeasureComputeComparisonDelta.ValidateAll() if the
// designated constraints aren't met.
type MetricsViewAggregationMeasureComputeComparisonDeltaMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MetricsViewAggregationMeasureComputeComparisonDeltaMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MetricsViewAggregationMeasureComputeComparisonDeltaMultiError) AllErrors() []error { return m }

// MetricsViewAggregationMeasureComputeComparisonDeltaValidationError is the
// validation error returned by
// MetricsViewAggregationMeasureComputeComparisonDelta.Validate if the
// designated constraints aren't met.
type MetricsViewAggregationMeasureComputeComparisonDeltaValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MetricsViewAggregationMeasureComputeComparisonDeltaValidationError) Field() string {
	return e.field
}

// Reason function returns reason value.
func (e MetricsViewAggregationMeasureComputeComparisonDeltaValidationError) Reason() string {
	return e.reason
}

// Cause function returns cause value.
func (e MetricsViewAggregationMeasureComputeComparisonDeltaValidationError) Cause() error {
	return e.cause
}

// Key function returns key value.
func (e MetricsViewAggregationMeasureComputeComparisonDeltaValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MetricsViewAggregationMeasureComputeComparisonDeltaValidationError) ErrorName() string {
	return "MetricsViewAggregationMeasureComputeComparisonDeltaValidationError"
}

// Error satisfies the builtin error interface
func (e MetricsViewAggregationMeasureComputeComparisonDeltaValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMetricsViewAggregationMeasureComputeComparisonDelta.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MetricsViewAggregationMeasureComputeComparisonDeltaValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MetricsViewAggregationMeasureComputeComparisonDeltaValidationError{}

// Validate checks the field values on
// MetricsViewAggregationMeasureComputeComparisonRatio with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *MetricsViewAggregationMeasureComputeComparisonRatio) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on
// MetricsViewAggregationMeasureComputeComparisonRatio with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in
// MetricsViewAggregationMeasureComputeComparisonRatioMultiError, or nil if
// none found.
func (m *MetricsViewAggregationMeasureComputeComparisonRatio) ValidateAll() error {
	return m.validate(true)
}

func (m *MetricsViewAggregationMeasureComputeComparisonRatio) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Measure

	if len(errors) > 0 {
		return MetricsViewAggregationMeasureComputeComparisonRatioMultiError(errors)
	}

	return nil
}

// MetricsViewAggregationMeasureComputeComparisonRatioMultiError is an error
// wrapping multiple validation errors returned by
// MetricsViewAggregationMeasureComputeComparisonRatio.ValidateAll() if the
// designated constraints aren't met.
type MetricsViewAggregationMeasureComputeComparisonRatioMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MetricsViewAggregationMeasureComputeComparisonRatioMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MetricsViewAggregationMeasureComputeComparisonRatioMultiError) AllErrors() []error { return m }

// MetricsViewAggregationMeasureComputeComparisonRatioValidationError is the
// validation error returned by
// MetricsViewAggregationMeasureComputeComparisonRatio.Validate if the
// designated constraints aren't met.
type MetricsViewAggregationMeasureComputeComparisonRatioValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MetricsViewAggregationMeasureComputeComparisonRatioValidationError) Field() string {
	return e.field
}

// Reason function returns reason value.
func (e MetricsViewAggregationMeasureComputeComparisonRatioValidationError) Reason() string {
	return e.reason
}

// Cause function returns cause value.
func (e MetricsViewAggregationMeasureComputeComparisonRatioValidationError) Cause() error {
	return e.cause
}

// Key function returns key value.
func (e MetricsViewAggregationMeasureComputeComparisonRatioValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MetricsViewAggregationMeasureComputeComparisonRatioValidationError) ErrorName() string {
	return "MetricsViewAggregationMeasureComputeComparisonRatioValidationError"
}

// Error satisfies the builtin error interface
func (e MetricsViewAggregationMeasureComputeComparisonRatioValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMetricsViewAggregationMeasureComputeComparisonRatio.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MetricsViewAggregationMeasureComputeComparisonRatioValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MetricsViewAggregationMeasureComputeComparisonRatioValidationError{}

// Validate checks the field values on
// MetricsViewAggregationMeasureComputePercentOfTotal with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *MetricsViewAggregationMeasureComputePercentOfTotal) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on
// MetricsViewAggregationMeasureComputePercentOfTotal with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in
// MetricsViewAggregationMeasureComputePercentOfTotalMultiError, or nil if
// none found.
func (m *MetricsViewAggregationMeasureComputePercentOfTotal) ValidateAll() error {
	return m.validate(true)
}

func (m *MetricsViewAggregationMeasureComputePercentOfTotal) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Measure

	if len(errors) > 0 {
		return MetricsViewAggregationMeasureComputePercentOfTotalMultiError(errors)
	}

	return nil
}

// MetricsViewAggregationMeasureComputePercentOfTotalMultiError is an error
// wrapping multiple validation errors returned by
// MetricsViewAggregationMeasureComputePercentOfTotal.ValidateAll() if the
// designated constraints aren't met.
type MetricsViewAggregationMeasureComputePercentOfTotalMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MetricsViewAggregationMeasureComputePercentOfTotalMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MetricsViewAggregationMeasureComputePercentOfTotalMultiError) AllErrors() []error { return m }

// MetricsViewAggregationMeasureComputePercentOfTotalValidationError is the
// validation error returned by
// MetricsViewAggregationMeasureComputePercentOfTotal.Validate if the
// designated constraints aren't met.
type MetricsViewAggregationMeasureComputePercentOfTotalValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MetricsViewAggregationMeasureComputePercentOfTotalValidationError) Field() string {
	return e.field
}

// Reason function returns reason value.
func (e MetricsViewAggregationMeasureComputePercentOfTotalValidationError) Reason() string {
	return e.reason
}

// Cause function returns cause value.
func (e MetricsViewAggregationMeasureComputePercentOfTotalValidationError) Cause() error {
	return e.cause
}

// Key function returns key value.
func (e MetricsViewAggregationMeasureComputePercentOfTotalValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MetricsViewAggregationMeasureComputePercentOfTotalValidationError) ErrorName() string {
	return "MetricsViewAggregationMeasureComputePercentOfTotalValidationError"
}

// Error satisfies the builtin error interface
func (e MetricsViewAggregationMeasureComputePercentOfTotalValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMetricsViewAggregationMeasureComputePercentOfTotal.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MetricsViewAggregationMeasureComputePercentOfTotalValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MetricsViewAggregationMeasureComputePercentOfTotalValidationError{}

// Validate checks the field values on MetricsViewAggregationMeasureComputeURI
// with the rules defined in the proto definition for this message. If any
// rules are violated, the first error encountered is returned, or nil if
// there are no violations.
func (m *MetricsViewAggregationMeasureComputeURI) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on
// MetricsViewAggregationMeasureComputeURI with the rules defined in the proto
// definition for this message. If any rules are violated, the result is a
// list of violation errors wrapped in
// MetricsViewAggregationMeasureComputeURIMultiError, or nil if none found.
func (m *MetricsViewAggregationMeasureComputeURI) ValidateAll() error {
	return m.validate(true)
}

func (m *MetricsViewAggregationMeasureComputeURI) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Dimension

	if len(errors) > 0 {
		return MetricsViewAggregationMeasureComputeURIMultiError(errors)
	}

	return nil
}

// MetricsViewAggregationMeasureComputeURIMultiError is an error wrapping
// multiple validation errors returned by
// MetricsViewAggregationMeasureComputeURI.ValidateAll() if the designated
// constraints aren't met.
type MetricsViewAggregationMeasureComputeURIMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MetricsViewAggregationMeasureComputeURIMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MetricsViewAggregationMeasureComputeURIMultiError) AllErrors() []error { return m }

// MetricsViewAggregationMeasureComputeURIValidationError is the validation
// error returned by MetricsViewAggregationMeasureComputeURI.Validate if the
// designated constraints aren't met.
type MetricsViewAggregationMeasureComputeURIValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MetricsViewAggregationMeasureComputeURIValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MetricsViewAggregationMeasureComputeURIValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MetricsViewAggregationMeasureComputeURIValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MetricsViewAggregationMeasureComputeURIValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MetricsViewAggregationMeasureComputeURIValidationError) ErrorName() string {
	return "MetricsViewAggregationMeasureComputeURIValidationError"
}

// Error satisfies the builtin error interface
func (e MetricsViewAggregationMeasureComputeURIValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMetricsViewAggregationMeasureComputeURI.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MetricsViewAggregationMeasureComputeURIValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MetricsViewAggregationMeasureComputeURIValidationError{}

// Validate checks the field values on
// MetricsViewAggregationMeasureComputeComparisonTime with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *MetricsViewAggregationMeasureComputeComparisonTime) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on
// MetricsViewAggregationMeasureComputeComparisonTime with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in
// MetricsViewAggregationMeasureComputeComparisonTimeMultiError, or nil if
// none found.
func (m *MetricsViewAggregationMeasureComputeComparisonTime) ValidateAll() error {
	return m.validate(true)
}

func (m *MetricsViewAggregationMeasureComputeComparisonTime) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Dimension

	if len(errors) > 0 {
		return MetricsViewAggregationMeasureComputeComparisonTimeMultiError(errors)
	}

	return nil
}

// MetricsViewAggregationMeasureComputeComparisonTimeMultiError is an error
// wrapping multiple validation errors returned by
// MetricsViewAggregationMeasureComputeComparisonTime.ValidateAll() if the
// designated constraints aren't met.
type MetricsViewAggregationMeasureComputeComparisonTimeMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MetricsViewAggregationMeasureComputeComparisonTimeMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MetricsViewAggregationMeasureComputeComparisonTimeMultiError) AllErrors() []error { return m }

// MetricsViewAggregationMeasureComputeComparisonTimeValidationError is the
// validation error returned by
// MetricsViewAggregationMeasureComputeComparisonTime.Validate if the
// designated constraints aren't met.
type MetricsViewAggregationMeasureComputeComparisonTimeValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MetricsViewAggregationMeasureComputeComparisonTimeValidationError) Field() string {
	return e.field
}

// Reason function returns reason value.
func (e MetricsViewAggregationMeasureComputeComparisonTimeValidationError) Reason() string {
	return e.reason
}

// Cause function returns cause value.
func (e MetricsViewAggregationMeasureComputeComparisonTimeValidationError) Cause() error {
	return e.cause
}

// Key function returns key value.
func (e MetricsViewAggregationMeasureComputeComparisonTimeValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MetricsViewAggregationMeasureComputeComparisonTimeValidationError) ErrorName() string {
	return "MetricsViewAggregationMeasureComputeComparisonTimeValidationError"
}

// Error satisfies the builtin error interface
func (e MetricsViewAggregationMeasureComputeComparisonTimeValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMetricsViewAggregationMeasureComputeComparisonTime.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MetricsViewAggregationMeasureComputeComparisonTimeValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MetricsViewAggregationMeasureComputeComparisonTimeValidationError{}

// Validate checks the field values on MetricsViewAggregationSort with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *MetricsViewAggregationSort) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on MetricsViewAggregationSort with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// MetricsViewAggregationSortMultiError, or nil if none found.
func (m *MetricsViewAggregationSort) ValidateAll() error {
	return m.validate(true)
}

func (m *MetricsViewAggregationSort) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Name

	// no validation rules for Desc

	if len(errors) > 0 {
		return MetricsViewAggregationSortMultiError(errors)
	}

	return nil
}

// MetricsViewAggregationSortMultiError is an error wrapping multiple
// validation errors returned by MetricsViewAggregationSort.ValidateAll() if
// the designated constraints aren't met.
type MetricsViewAggregationSortMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MetricsViewAggregationSortMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MetricsViewAggregationSortMultiError) AllErrors() []error { return m }

// MetricsViewAggregationSortValidationError is the validation error returned
// by MetricsViewAggregationSort.Validate if the designated constraints aren't met.
type MetricsViewAggregationSortValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MetricsViewAggregationSortValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MetricsViewAggregationSortValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MetricsViewAggregationSortValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MetricsViewAggregationSortValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MetricsViewAggregationSortValidationError) ErrorName() string {
	return "MetricsViewAggregationSortValidationError"
}

// Error satisfies the builtin error interface
func (e MetricsViewAggregationSortValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMetricsViewAggregationSort.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MetricsViewAggregationSortValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MetricsViewAggregationSortValidationError{}

// Validate checks the field values on MetricsViewToplistRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *MetricsViewToplistRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on MetricsViewToplistRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// MetricsViewToplistRequestMultiError, or nil if none found.
func (m *MetricsViewToplistRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *MetricsViewToplistRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for InstanceId

	if utf8.RuneCountInString(m.GetMetricsViewName()) < 1 {
		err := MetricsViewToplistRequestValidationError{
			field:  "MetricsViewName",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetDimensionName()) < 1 {
		err := MetricsViewToplistRequestValidationError{
			field:  "DimensionName",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetTimeStart()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, MetricsViewToplistRequestValidationError{
					field:  "TimeStart",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, MetricsViewToplistRequestValidationError{
					field:  "TimeStart",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTimeStart()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return MetricsViewToplistRequestValidationError{
				field:  "TimeStart",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetTimeEnd()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, MetricsViewToplistRequestValidationError{
					field:  "TimeEnd",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, MetricsViewToplistRequestValidationError{
					field:  "TimeEnd",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTimeEnd()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return MetricsViewToplistRequestValidationError{
				field:  "TimeEnd",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if m.GetLimit() < 0 {
		err := MetricsViewToplistRequestValidationError{
			field:  "Limit",
			reason: "value must be greater than or equal to 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetOffset() < 0 {
		err := MetricsViewToplistRequestValidationError{
			field:  "Offset",
			reason: "value must be greater than or equal to 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	for idx, item := range m.GetSort() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, MetricsViewToplistRequestValidationError{
						field:  fmt.Sprintf("Sort[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, MetricsViewToplistRequestValidationError{
						field:  fmt.Sprintf("Sort[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return MetricsViewToplistRequestValidationError{
					field:  fmt.Sprintf("Sort[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if all {
		switch v := interface{}(m.GetWhere()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, MetricsViewToplistRequestValidationError{
					field:  "Where",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, MetricsViewToplistRequestValidationError{
					field:  "Where",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetWhere()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return MetricsViewToplistRequestValidationError{
				field:  "Where",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for WhereSql

	if all {
		switch v := interface{}(m.GetHaving()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, MetricsViewToplistRequestValidationError{
					field:  "Having",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, MetricsViewToplistRequestValidationError{
					field:  "Having",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetHaving()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return MetricsViewToplistRequestValidationError{
				field:  "Having",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for HavingSql

	// no validation rules for Priority

	if all {
		switch v := interface{}(m.GetFilter()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, MetricsViewToplistRequestValidationError{
					field:  "Filter",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, MetricsViewToplistRequestValidationError{
					field:  "Filter",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetFilter()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return MetricsViewToplistRequestValidationError{
				field:  "Filter",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return MetricsViewToplistRequestMultiError(errors)
	}

	return nil
}

// MetricsViewToplistRequestMultiError is an error wrapping multiple validation
// errors returned by MetricsViewToplistRequest.ValidateAll() if the
// designated constraints aren't met.
type MetricsViewToplistRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MetricsViewToplistRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MetricsViewToplistRequestMultiError) AllErrors() []error { return m }

// MetricsViewToplistRequestValidationError is the validation error returned by
// MetricsViewToplistRequest.Validate if the designated constraints aren't met.
type MetricsViewToplistRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MetricsViewToplistRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MetricsViewToplistRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MetricsViewToplistRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MetricsViewToplistRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MetricsViewToplistRequestValidationError) ErrorName() string {
	return "MetricsViewToplistRequestValidationError"
}

// Error satisfies the builtin error interface
func (e MetricsViewToplistRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMetricsViewToplistRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MetricsViewToplistRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MetricsViewToplistRequestValidationError{}

// Validate checks the field values on MetricsViewToplistResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *MetricsViewToplistResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on MetricsViewToplistResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// MetricsViewToplistResponseMultiError, or nil if none found.
func (m *MetricsViewToplistResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *MetricsViewToplistResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetMeta() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, MetricsViewToplistResponseValidationError{
						field:  fmt.Sprintf("Meta[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, MetricsViewToplistResponseValidationError{
						field:  fmt.Sprintf("Meta[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return MetricsViewToplistResponseValidationError{
					field:  fmt.Sprintf("Meta[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetData() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, MetricsViewToplistResponseValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, MetricsViewToplistResponseValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return MetricsViewToplistResponseValidationError{
					field:  fmt.Sprintf("Data[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return MetricsViewToplistResponseMultiError(errors)
	}

	return nil
}

// MetricsViewToplistResponseMultiError is an error wrapping multiple
// validation errors returned by MetricsViewToplistResponse.ValidateAll() if
// the designated constraints aren't met.
type MetricsViewToplistResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MetricsViewToplistResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MetricsViewToplistResponseMultiError) AllErrors() []error { return m }

// MetricsViewToplistResponseValidationError is the validation error returned
// by MetricsViewToplistResponse.Validate if the designated constraints aren't met.
type MetricsViewToplistResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MetricsViewToplistResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MetricsViewToplistResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MetricsViewToplistResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MetricsViewToplistResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MetricsViewToplistResponseValidationError) ErrorName() string {
	return "MetricsViewToplistResponseValidationError"
}

// Error satisfies the builtin error interface
func (e MetricsViewToplistResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMetricsViewToplistResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MetricsViewToplistResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MetricsViewToplistResponseValidationError{}

// Validate checks the field values on MetricsViewComparisonRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *MetricsViewComparisonRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on MetricsViewComparisonRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// MetricsViewComparisonRequestMultiError, or nil if none found.
func (m *MetricsViewComparisonRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *MetricsViewComparisonRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for InstanceId

	if utf8.RuneCountInString(m.GetMetricsViewName()) < 1 {
		err := MetricsViewComparisonRequestValidationError{
			field:  "MetricsViewName",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetDimension()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, MetricsViewComparisonRequestValidationError{
					field:  "Dimension",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, MetricsViewComparisonRequestValidationError{
					field:  "Dimension",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDimension()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return MetricsViewComparisonRequestValidationError{
				field:  "Dimension",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(m.GetMeasures()) < 1 {
		err := MetricsViewComparisonRequestValidationError{
			field:  "Measures",
			reason: "value must contain at least 1 item(s)",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	for idx, item := range m.GetMeasures() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, MetricsViewComparisonRequestValidationError{
						field:  fmt.Sprintf("Measures[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, MetricsViewComparisonRequestValidationError{
						field:  fmt.Sprintf("Measures[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return MetricsViewComparisonRequestValidationError{
					field:  fmt.Sprintf("Measures[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(m.GetSort()) < 1 {
		err := MetricsViewComparisonRequestValidationError{
			field:  "Sort",
			reason: "value must contain at least 1 item(s)",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	for idx, item := range m.GetSort() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, MetricsViewComparisonRequestValidationError{
						field:  fmt.Sprintf("Sort[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, MetricsViewComparisonRequestValidationError{
						field:  fmt.Sprintf("Sort[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return MetricsViewComparisonRequestValidationError{
					field:  fmt.Sprintf("Sort[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if all {
		switch v := interface{}(m.GetTimeRange()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, MetricsViewComparisonRequestValidationError{
					field:  "TimeRange",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, MetricsViewComparisonRequestValidationError{
					field:  "TimeRange",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTimeRange()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return MetricsViewComparisonRequestValidationError{
				field:  "TimeRange",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetComparisonTimeRange()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, MetricsViewComparisonRequestValidationError{
					field:  "ComparisonTimeRange",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, MetricsViewComparisonRequestValidationError{
					field:  "ComparisonTimeRange",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetComparisonTimeRange()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return MetricsViewComparisonRequestValidationError{
				field:  "ComparisonTimeRange",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetWhere()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, MetricsViewComparisonRequestValidationError{
					field:  "Where",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, MetricsViewComparisonRequestValidationError{
					field:  "Where",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetWhere()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return MetricsViewComparisonRequestValidationError{
				field:  "Where",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for WhereSql

	if all {
		switch v := interface{}(m.GetHaving()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, MetricsViewComparisonRequestValidationError{
					field:  "Having",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, MetricsViewComparisonRequestValidationError{
					field:  "Having",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetHaving()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return MetricsViewComparisonRequestValidationError{
				field:  "Having",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for HavingSql

	for idx, item := range m.GetAliases() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, MetricsViewComparisonRequestValidationError{
						field:  fmt.Sprintf("Aliases[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, MetricsViewComparisonRequestValidationError{
						field:  fmt.Sprintf("Aliases[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return MetricsViewComparisonRequestValidationError{
					field:  fmt.Sprintf("Aliases[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if m.GetLimit() < 0 {
		err := MetricsViewComparisonRequestValidationError{
			field:  "Limit",
			reason: "value must be greater than or equal to 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetOffset() < 0 {
		err := MetricsViewComparisonRequestValidationError{
			field:  "Offset",
			reason: "value must be greater than or equal to 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Priority

	// no validation rules for Exact

	if all {
		switch v := interface{}(m.GetFilter()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, MetricsViewComparisonRequestValidationError{
					field:  "Filter",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, MetricsViewComparisonRequestValidationError{
					field:  "Filter",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetFilter()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return MetricsViewComparisonRequestValidationError{
				field:  "Filter",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return MetricsViewComparisonRequestMultiError(errors)
	}

	return nil
}

// MetricsViewComparisonRequestMultiError is an error wrapping multiple
// validation errors returned by MetricsViewComparisonRequest.ValidateAll() if
// the designated constraints aren't met.
type MetricsViewComparisonRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MetricsViewComparisonRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MetricsViewComparisonRequestMultiError) AllErrors() []error { return m }

// MetricsViewComparisonRequestValidationError is the validation error returned
// by MetricsViewComparisonRequest.Validate if the designated constraints
// aren't met.
type MetricsViewComparisonRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MetricsViewComparisonRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MetricsViewComparisonRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MetricsViewComparisonRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MetricsViewComparisonRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MetricsViewComparisonRequestValidationError) ErrorName() string {
	return "MetricsViewComparisonRequestValidationError"
}

// Error satisfies the builtin error interface
func (e MetricsViewComparisonRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMetricsViewComparisonRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MetricsViewComparisonRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MetricsViewComparisonRequestValidationError{}

// Validate checks the field values on MetricsViewComparisonResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *MetricsViewComparisonResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on MetricsViewComparisonResponse with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// MetricsViewComparisonResponseMultiError, or nil if none found.
func (m *MetricsViewComparisonResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *MetricsViewComparisonResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetRows() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, MetricsViewComparisonResponseValidationError{
						field:  fmt.Sprintf("Rows[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, MetricsViewComparisonResponseValidationError{
						field:  fmt.Sprintf("Rows[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return MetricsViewComparisonResponseValidationError{
					field:  fmt.Sprintf("Rows[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return MetricsViewComparisonResponseMultiError(errors)
	}

	return nil
}

// MetricsViewComparisonResponseMultiError is an error wrapping multiple
// validation errors returned by MetricsViewComparisonResponse.ValidateAll()
// if the designated constraints aren't met.
type MetricsViewComparisonResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MetricsViewComparisonResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MetricsViewComparisonResponseMultiError) AllErrors() []error { return m }

// MetricsViewComparisonResponseValidationError is the validation error
// returned by MetricsViewComparisonResponse.Validate if the designated
// constraints aren't met.
type MetricsViewComparisonResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MetricsViewComparisonResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MetricsViewComparisonResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MetricsViewComparisonResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MetricsViewComparisonResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MetricsViewComparisonResponseValidationError) ErrorName() string {
	return "MetricsViewComparisonResponseValidationError"
}

// Error satisfies the builtin error interface
func (e MetricsViewComparisonResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMetricsViewComparisonResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MetricsViewComparisonResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MetricsViewComparisonResponseValidationError{}

// Validate checks the field values on TimeRange with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *TimeRange) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TimeRange with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in TimeRangeMultiError, or nil
// if none found.
func (m *TimeRange) ValidateAll() error {
	return m.validate(true)
}

func (m *TimeRange) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetStart()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TimeRangeValidationError{
					field:  "Start",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TimeRangeValidationError{
					field:  "Start",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetStart()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TimeRangeValidationError{
				field:  "Start",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetEnd()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TimeRangeValidationError{
					field:  "End",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TimeRangeValidationError{
					field:  "End",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetEnd()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TimeRangeValidationError{
				field:  "End",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for IsoDuration

	// no validation rules for IsoOffset

	// no validation rules for RoundToGrain

	// no validation rules for TimeZone

	// no validation rules for Expression

	// no validation rules for TimeDimension

	if len(errors) > 0 {
		return TimeRangeMultiError(errors)
	}

	return nil
}

// TimeRangeMultiError is an error wrapping multiple validation errors returned
// by TimeRange.ValidateAll() if the designated constraints aren't met.
type TimeRangeMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TimeRangeMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TimeRangeMultiError) AllErrors() []error { return m }

// TimeRangeValidationError is the validation error returned by
// TimeRange.Validate if the designated constraints aren't met.
type TimeRangeValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TimeRangeValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TimeRangeValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TimeRangeValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TimeRangeValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TimeRangeValidationError) ErrorName() string { return "TimeRangeValidationError" }

// Error satisfies the builtin error interface
func (e TimeRangeValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTimeRange.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TimeRangeValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TimeRangeValidationError{}

// Validate checks the field values on MetricsViewComparisonSort with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *MetricsViewComparisonSort) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on MetricsViewComparisonSort with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// MetricsViewComparisonSortMultiError, or nil if none found.
func (m *MetricsViewComparisonSort) ValidateAll() error {
	return m.validate(true)
}

func (m *MetricsViewComparisonSort) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetName()) < 1 {
		err := MetricsViewComparisonSortValidationError{
			field:  "Name",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Desc

	// no validation rules for Type

	// no validation rules for SortType

	if len(errors) > 0 {
		return MetricsViewComparisonSortMultiError(errors)
	}

	return nil
}

// MetricsViewComparisonSortMultiError is an error wrapping multiple validation
// errors returned by MetricsViewComparisonSort.ValidateAll() if the
// designated constraints aren't met.
type MetricsViewComparisonSortMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MetricsViewComparisonSortMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MetricsViewComparisonSortMultiError) AllErrors() []error { return m }

// MetricsViewComparisonSortValidationError is the validation error returned by
// MetricsViewComparisonSort.Validate if the designated constraints aren't met.
type MetricsViewComparisonSortValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MetricsViewComparisonSortValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MetricsViewComparisonSortValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MetricsViewComparisonSortValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MetricsViewComparisonSortValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MetricsViewComparisonSortValidationError) ErrorName() string {
	return "MetricsViewComparisonSortValidationError"
}

// Error satisfies the builtin error interface
func (e MetricsViewComparisonSortValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMetricsViewComparisonSort.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MetricsViewComparisonSortValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MetricsViewComparisonSortValidationError{}

// Validate checks the field values on MetricsViewComparisonRow with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *MetricsViewComparisonRow) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on MetricsViewComparisonRow with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// MetricsViewComparisonRowMultiError, or nil if none found.
func (m *MetricsViewComparisonRow) ValidateAll() error {
	return m.validate(true)
}

func (m *MetricsViewComparisonRow) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetDimensionValue()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, MetricsViewComparisonRowValidationError{
					field:  "DimensionValue",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, MetricsViewComparisonRowValidationError{
					field:  "DimensionValue",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDimensionValue()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return MetricsViewComparisonRowValidationError{
				field:  "DimensionValue",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetMeasureValues() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, MetricsViewComparisonRowValidationError{
						field:  fmt.Sprintf("MeasureValues[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, MetricsViewComparisonRowValidationError{
						field:  fmt.Sprintf("MeasureValues[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return MetricsViewComparisonRowValidationError{
					field:  fmt.Sprintf("MeasureValues[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return MetricsViewComparisonRowMultiError(errors)
	}

	return nil
}

// MetricsViewComparisonRowMultiError is an error wrapping multiple validation
// errors returned by MetricsViewComparisonRow.ValidateAll() if the designated
// constraints aren't met.
type MetricsViewComparisonRowMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MetricsViewComparisonRowMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MetricsViewComparisonRowMultiError) AllErrors() []error { return m }

// MetricsViewComparisonRowValidationError is the validation error returned by
// MetricsViewComparisonRow.Validate if the designated constraints aren't met.
type MetricsViewComparisonRowValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MetricsViewComparisonRowValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MetricsViewComparisonRowValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MetricsViewComparisonRowValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MetricsViewComparisonRowValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MetricsViewComparisonRowValidationError) ErrorName() string {
	return "MetricsViewComparisonRowValidationError"
}

// Error satisfies the builtin error interface
func (e MetricsViewComparisonRowValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMetricsViewComparisonRow.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MetricsViewComparisonRowValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MetricsViewComparisonRowValidationError{}

// Validate checks the field values on MetricsViewComparisonValue with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *MetricsViewComparisonValue) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on MetricsViewComparisonValue with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// MetricsViewComparisonValueMultiError, or nil if none found.
func (m *MetricsViewComparisonValue) ValidateAll() error {
	return m.validate(true)
}

func (m *MetricsViewComparisonValue) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for MeasureName

	if all {
		switch v := interface{}(m.GetBaseValue()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, MetricsViewComparisonValueValidationError{
					field:  "BaseValue",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, MetricsViewComparisonValueValidationError{
					field:  "BaseValue",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetBaseValue()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return MetricsViewComparisonValueValidationError{
				field:  "BaseValue",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetComparisonValue()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, MetricsViewComparisonValueValidationError{
					field:  "ComparisonValue",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, MetricsViewComparisonValueValidationError{
					field:  "ComparisonValue",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetComparisonValue()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return MetricsViewComparisonValueValidationError{
				field:  "ComparisonValue",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetDeltaAbs()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, MetricsViewComparisonValueValidationError{
					field:  "DeltaAbs",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, MetricsViewComparisonValueValidationError{
					field:  "DeltaAbs",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDeltaAbs()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return MetricsViewComparisonValueValidationError{
				field:  "DeltaAbs",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetDeltaRel()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, MetricsViewComparisonValueValidationError{
					field:  "DeltaRel",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, MetricsViewComparisonValueValidationError{
					field:  "DeltaRel",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDeltaRel()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return MetricsViewComparisonValueValidationError{
				field:  "DeltaRel",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return MetricsViewComparisonValueMultiError(errors)
	}

	return nil
}

// MetricsViewComparisonValueMultiError is an error wrapping multiple
// validation errors returned by MetricsViewComparisonValue.ValidateAll() if
// the designated constraints aren't met.
type MetricsViewComparisonValueMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MetricsViewComparisonValueMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MetricsViewComparisonValueMultiError) AllErrors() []error { return m }

// MetricsViewComparisonValueValidationError is the validation error returned
// by MetricsViewComparisonValue.Validate if the designated constraints aren't met.
type MetricsViewComparisonValueValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MetricsViewComparisonValueValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MetricsViewComparisonValueValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MetricsViewComparisonValueValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MetricsViewComparisonValueValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MetricsViewComparisonValueValidationError) ErrorName() string {
	return "MetricsViewComparisonValueValidationError"
}

// Error satisfies the builtin error interface
func (e MetricsViewComparisonValueValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMetricsViewComparisonValue.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MetricsViewComparisonValueValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MetricsViewComparisonValueValidationError{}

// Validate checks the field values on MetricsViewComparisonMeasureAlias with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *MetricsViewComparisonMeasureAlias) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on MetricsViewComparisonMeasureAlias
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// MetricsViewComparisonMeasureAliasMultiError, or nil if none found.
func (m *MetricsViewComparisonMeasureAlias) ValidateAll() error {
	return m.validate(true)
}

func (m *MetricsViewComparisonMeasureAlias) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Name

	// no validation rules for Type

	// no validation rules for Alias

	if len(errors) > 0 {
		return MetricsViewComparisonMeasureAliasMultiError(errors)
	}

	return nil
}

// MetricsViewComparisonMeasureAliasMultiError is an error wrapping multiple
// validation errors returned by
// MetricsViewComparisonMeasureAlias.ValidateAll() if the designated
// constraints aren't met.
type MetricsViewComparisonMeasureAliasMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MetricsViewComparisonMeasureAliasMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MetricsViewComparisonMeasureAliasMultiError) AllErrors() []error { return m }

// MetricsViewComparisonMeasureAliasValidationError is the validation error
// returned by MetricsViewComparisonMeasureAlias.Validate if the designated
// constraints aren't met.
type MetricsViewComparisonMeasureAliasValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MetricsViewComparisonMeasureAliasValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MetricsViewComparisonMeasureAliasValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MetricsViewComparisonMeasureAliasValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MetricsViewComparisonMeasureAliasValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MetricsViewComparisonMeasureAliasValidationError) ErrorName() string {
	return "MetricsViewComparisonMeasureAliasValidationError"
}

// Error satisfies the builtin error interface
func (e MetricsViewComparisonMeasureAliasValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMetricsViewComparisonMeasureAlias.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MetricsViewComparisonMeasureAliasValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MetricsViewComparisonMeasureAliasValidationError{}

// Validate checks the field values on MetricsViewTimeSeriesRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *MetricsViewTimeSeriesRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on MetricsViewTimeSeriesRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// MetricsViewTimeSeriesRequestMultiError, or nil if none found.
func (m *MetricsViewTimeSeriesRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *MetricsViewTimeSeriesRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for InstanceId

	if utf8.RuneCountInString(m.GetMetricsViewName()) < 1 {
		err := MetricsViewTimeSeriesRequestValidationError{
			field:  "MetricsViewName",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(m.GetMeasureNames()) < 1 {
		err := MetricsViewTimeSeriesRequestValidationError{
			field:  "MeasureNames",
			reason: "value must contain at least 1 item(s)",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetTimeStart()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, MetricsViewTimeSeriesRequestValidationError{
					field:  "TimeStart",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, MetricsViewTimeSeriesRequestValidationError{
					field:  "TimeStart",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTimeStart()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return MetricsViewTimeSeriesRequestValidationError{
				field:  "TimeStart",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetTimeEnd()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, MetricsViewTimeSeriesRequestValidationError{
					field:  "TimeEnd",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, MetricsViewTimeSeriesRequestValidationError{
					field:  "TimeEnd",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTimeEnd()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return MetricsViewTimeSeriesRequestValidationError{
				field:  "TimeEnd",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if _, ok := _MetricsViewTimeSeriesRequest_TimeGranularity_NotInLookup[m.GetTimeGranularity()]; ok {
		err := MetricsViewTimeSeriesRequestValidationError{
			field:  "TimeGranularity",
			reason: "value must not be in list [TIME_GRAIN_UNSPECIFIED]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetWhere()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, MetricsViewTimeSeriesRequestValidationError{
					field:  "Where",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, MetricsViewTimeSeriesRequestValidationError{
					field:  "Where",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetWhere()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return MetricsViewTimeSeriesRequestValidationError{
				field:  "Where",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for WhereSql

	if all {
		switch v := interface{}(m.GetHaving()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, MetricsViewTimeSeriesRequestValidationError{
					field:  "Having",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, MetricsViewTimeSeriesRequestValidationError{
					field:  "Having",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetHaving()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return MetricsViewTimeSeriesRequestValidationError{
				field:  "Having",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for HavingSql

	// no validation rules for TimeZone

	// no validation rules for Priority

	if all {
		switch v := interface{}(m.GetFilter()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, MetricsViewTimeSeriesRequestValidationError{
					field:  "Filter",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, MetricsViewTimeSeriesRequestValidationError{
					field:  "Filter",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetFilter()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return MetricsViewTimeSeriesRequestValidationError{
				field:  "Filter",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for TimeDimension

	if len(errors) > 0 {
		return MetricsViewTimeSeriesRequestMultiError(errors)
	}

	return nil
}

// MetricsViewTimeSeriesRequestMultiError is an error wrapping multiple
// validation errors returned by MetricsViewTimeSeriesRequest.ValidateAll() if
// the designated constraints aren't met.
type MetricsViewTimeSeriesRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MetricsViewTimeSeriesRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MetricsViewTimeSeriesRequestMultiError) AllErrors() []error { return m }

// MetricsViewTimeSeriesRequestValidationError is the validation error returned
// by MetricsViewTimeSeriesRequest.Validate if the designated constraints
// aren't met.
type MetricsViewTimeSeriesRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MetricsViewTimeSeriesRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MetricsViewTimeSeriesRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MetricsViewTimeSeriesRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MetricsViewTimeSeriesRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MetricsViewTimeSeriesRequestValidationError) ErrorName() string {
	return "MetricsViewTimeSeriesRequestValidationError"
}

// Error satisfies the builtin error interface
func (e MetricsViewTimeSeriesRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMetricsViewTimeSeriesRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MetricsViewTimeSeriesRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MetricsViewTimeSeriesRequestValidationError{}

var _MetricsViewTimeSeriesRequest_TimeGranularity_NotInLookup = map[TimeGrain]struct{}{
	0: {},
}

// Validate checks the field values on MetricsViewTimeSeriesResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *MetricsViewTimeSeriesResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on MetricsViewTimeSeriesResponse with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// MetricsViewTimeSeriesResponseMultiError, or nil if none found.
func (m *MetricsViewTimeSeriesResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *MetricsViewTimeSeriesResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetMeta() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, MetricsViewTimeSeriesResponseValidationError{
						field:  fmt.Sprintf("Meta[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, MetricsViewTimeSeriesResponseValidationError{
						field:  fmt.Sprintf("Meta[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return MetricsViewTimeSeriesResponseValidationError{
					field:  fmt.Sprintf("Meta[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetData() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, MetricsViewTimeSeriesResponseValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, MetricsViewTimeSeriesResponseValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return MetricsViewTimeSeriesResponseValidationError{
					field:  fmt.Sprintf("Data[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return MetricsViewTimeSeriesResponseMultiError(errors)
	}

	return nil
}

// MetricsViewTimeSeriesResponseMultiError is an error wrapping multiple
// validation errors returned by MetricsViewTimeSeriesResponse.ValidateAll()
// if the designated constraints aren't met.
type MetricsViewTimeSeriesResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MetricsViewTimeSeriesResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MetricsViewTimeSeriesResponseMultiError) AllErrors() []error { return m }

// MetricsViewTimeSeriesResponseValidationError is the validation error
// returned by MetricsViewTimeSeriesResponse.Validate if the designated
// constraints aren't met.
type MetricsViewTimeSeriesResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MetricsViewTimeSeriesResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MetricsViewTimeSeriesResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MetricsViewTimeSeriesResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MetricsViewTimeSeriesResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MetricsViewTimeSeriesResponseValidationError) ErrorName() string {
	return "MetricsViewTimeSeriesResponseValidationError"
}

// Error satisfies the builtin error interface
func (e MetricsViewTimeSeriesResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMetricsViewTimeSeriesResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MetricsViewTimeSeriesResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MetricsViewTimeSeriesResponseValidationError{}

// Validate checks the field values on MetricsViewTotalsRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *MetricsViewTotalsRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on MetricsViewTotalsRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// MetricsViewTotalsRequestMultiError, or nil if none found.
func (m *MetricsViewTotalsRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *MetricsViewTotalsRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for InstanceId

	if utf8.RuneCountInString(m.GetMetricsViewName()) < 1 {
		err := MetricsViewTotalsRequestValidationError{
			field:  "MetricsViewName",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(m.GetMeasureNames()) < 1 {
		err := MetricsViewTotalsRequestValidationError{
			field:  "MeasureNames",
			reason: "value must contain at least 1 item(s)",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetTimeStart()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, MetricsViewTotalsRequestValidationError{
					field:  "TimeStart",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, MetricsViewTotalsRequestValidationError{
					field:  "TimeStart",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTimeStart()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return MetricsViewTotalsRequestValidationError{
				field:  "TimeStart",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetTimeEnd()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, MetricsViewTotalsRequestValidationError{
					field:  "TimeEnd",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, MetricsViewTotalsRequestValidationError{
					field:  "TimeEnd",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTimeEnd()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return MetricsViewTotalsRequestValidationError{
				field:  "TimeEnd",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetWhere()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, MetricsViewTotalsRequestValidationError{
					field:  "Where",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, MetricsViewTotalsRequestValidationError{
					field:  "Where",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetWhere()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return MetricsViewTotalsRequestValidationError{
				field:  "Where",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for WhereSql

	// no validation rules for Priority

	if all {
		switch v := interface{}(m.GetFilter()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, MetricsViewTotalsRequestValidationError{
					field:  "Filter",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, MetricsViewTotalsRequestValidationError{
					field:  "Filter",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetFilter()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return MetricsViewTotalsRequestValidationError{
				field:  "Filter",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for TimeDimension

	if len(errors) > 0 {
		return MetricsViewTotalsRequestMultiError(errors)
	}

	return nil
}

// MetricsViewTotalsRequestMultiError is an error wrapping multiple validation
// errors returned by MetricsViewTotalsRequest.ValidateAll() if the designated
// constraints aren't met.
type MetricsViewTotalsRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MetricsViewTotalsRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MetricsViewTotalsRequestMultiError) AllErrors() []error { return m }

// MetricsViewTotalsRequestValidationError is the validation error returned by
// MetricsViewTotalsRequest.Validate if the designated constraints aren't met.
type MetricsViewTotalsRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MetricsViewTotalsRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MetricsViewTotalsRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MetricsViewTotalsRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MetricsViewTotalsRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MetricsViewTotalsRequestValidationError) ErrorName() string {
	return "MetricsViewTotalsRequestValidationError"
}

// Error satisfies the builtin error interface
func (e MetricsViewTotalsRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMetricsViewTotalsRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MetricsViewTotalsRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MetricsViewTotalsRequestValidationError{}

// Validate checks the field values on MetricsViewTotalsResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *MetricsViewTotalsResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on MetricsViewTotalsResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// MetricsViewTotalsResponseMultiError, or nil if none found.
func (m *MetricsViewTotalsResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *MetricsViewTotalsResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetMeta() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, MetricsViewTotalsResponseValidationError{
						field:  fmt.Sprintf("Meta[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, MetricsViewTotalsResponseValidationError{
						field:  fmt.Sprintf("Meta[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return MetricsViewTotalsResponseValidationError{
					field:  fmt.Sprintf("Meta[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, MetricsViewTotalsResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, MetricsViewTotalsResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return MetricsViewTotalsResponseValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return MetricsViewTotalsResponseMultiError(errors)
	}

	return nil
}

// MetricsViewTotalsResponseMultiError is an error wrapping multiple validation
// errors returned by MetricsViewTotalsResponse.ValidateAll() if the
// designated constraints aren't met.
type MetricsViewTotalsResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MetricsViewTotalsResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MetricsViewTotalsResponseMultiError) AllErrors() []error { return m }

// MetricsViewTotalsResponseValidationError is the validation error returned by
// MetricsViewTotalsResponse.Validate if the designated constraints aren't met.
type MetricsViewTotalsResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MetricsViewTotalsResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MetricsViewTotalsResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MetricsViewTotalsResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MetricsViewTotalsResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MetricsViewTotalsResponseValidationError) ErrorName() string {
	return "MetricsViewTotalsResponseValidationError"
}

// Error satisfies the builtin error interface
func (e MetricsViewTotalsResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMetricsViewTotalsResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MetricsViewTotalsResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MetricsViewTotalsResponseValidationError{}

// Validate checks the field values on MetricsViewRowsRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *MetricsViewRowsRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on MetricsViewRowsRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// MetricsViewRowsRequestMultiError, or nil if none found.
func (m *MetricsViewRowsRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *MetricsViewRowsRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for InstanceId

	if utf8.RuneCountInString(m.GetMetricsViewName()) < 1 {
		err := MetricsViewRowsRequestValidationError{
			field:  "MetricsViewName",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetTimeStart()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, MetricsViewRowsRequestValidationError{
					field:  "TimeStart",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, MetricsViewRowsRequestValidationError{
					field:  "TimeStart",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTimeStart()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return MetricsViewRowsRequestValidationError{
				field:  "TimeStart",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetTimeEnd()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, MetricsViewRowsRequestValidationError{
					field:  "TimeEnd",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, MetricsViewRowsRequestValidationError{
					field:  "TimeEnd",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTimeEnd()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return MetricsViewRowsRequestValidationError{
				field:  "TimeEnd",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for TimeGranularity

	if all {
		switch v := interface{}(m.GetWhere()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, MetricsViewRowsRequestValidationError{
					field:  "Where",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, MetricsViewRowsRequestValidationError{
					field:  "Where",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetWhere()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return MetricsViewRowsRequestValidationError{
				field:  "Where",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetSort() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, MetricsViewRowsRequestValidationError{
						field:  fmt.Sprintf("Sort[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, MetricsViewRowsRequestValidationError{
						field:  fmt.Sprintf("Sort[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return MetricsViewRowsRequestValidationError{
					field:  fmt.Sprintf("Sort[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if m.GetLimit() < 0 {
		err := MetricsViewRowsRequestValidationError{
			field:  "Limit",
			reason: "value must be greater than or equal to 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetOffset() < 0 {
		err := MetricsViewRowsRequestValidationError{
			field:  "Offset",
			reason: "value must be greater than or equal to 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Priority

	// no validation rules for TimeZone

	if all {
		switch v := interface{}(m.GetFilter()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, MetricsViewRowsRequestValidationError{
					field:  "Filter",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, MetricsViewRowsRequestValidationError{
					field:  "Filter",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetFilter()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return MetricsViewRowsRequestValidationError{
				field:  "Filter",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for TimeDimension

	if len(errors) > 0 {
		return MetricsViewRowsRequestMultiError(errors)
	}

	return nil
}

// MetricsViewRowsRequestMultiError is an error wrapping multiple validation
// errors returned by MetricsViewRowsRequest.ValidateAll() if the designated
// constraints aren't met.
type MetricsViewRowsRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MetricsViewRowsRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MetricsViewRowsRequestMultiError) AllErrors() []error { return m }

// MetricsViewRowsRequestValidationError is the validation error returned by
// MetricsViewRowsRequest.Validate if the designated constraints aren't met.
type MetricsViewRowsRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MetricsViewRowsRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MetricsViewRowsRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MetricsViewRowsRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MetricsViewRowsRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MetricsViewRowsRequestValidationError) ErrorName() string {
	return "MetricsViewRowsRequestValidationError"
}

// Error satisfies the builtin error interface
func (e MetricsViewRowsRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMetricsViewRowsRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MetricsViewRowsRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MetricsViewRowsRequestValidationError{}

// Validate checks the field values on MetricsViewRowsResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *MetricsViewRowsResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on MetricsViewRowsResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// MetricsViewRowsResponseMultiError, or nil if none found.
func (m *MetricsViewRowsResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *MetricsViewRowsResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetMeta() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, MetricsViewRowsResponseValidationError{
						field:  fmt.Sprintf("Meta[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, MetricsViewRowsResponseValidationError{
						field:  fmt.Sprintf("Meta[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return MetricsViewRowsResponseValidationError{
					field:  fmt.Sprintf("Meta[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetData() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, MetricsViewRowsResponseValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, MetricsViewRowsResponseValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return MetricsViewRowsResponseValidationError{
					field:  fmt.Sprintf("Data[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return MetricsViewRowsResponseMultiError(errors)
	}

	return nil
}

// MetricsViewRowsResponseMultiError is an error wrapping multiple validation
// errors returned by MetricsViewRowsResponse.ValidateAll() if the designated
// constraints aren't met.
type MetricsViewRowsResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MetricsViewRowsResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MetricsViewRowsResponseMultiError) AllErrors() []error { return m }

// MetricsViewRowsResponseValidationError is the validation error returned by
// MetricsViewRowsResponse.Validate if the designated constraints aren't met.
type MetricsViewRowsResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MetricsViewRowsResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MetricsViewRowsResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MetricsViewRowsResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MetricsViewRowsResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MetricsViewRowsResponseValidationError) ErrorName() string {
	return "MetricsViewRowsResponseValidationError"
}

// Error satisfies the builtin error interface
func (e MetricsViewRowsResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMetricsViewRowsResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MetricsViewRowsResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MetricsViewRowsResponseValidationError{}

// Validate checks the field values on MetricsViewSort with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *MetricsViewSort) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on MetricsViewSort with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// MetricsViewSortMultiError, or nil if none found.
func (m *MetricsViewSort) ValidateAll() error {
	return m.validate(true)
}

func (m *MetricsViewSort) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetName()) < 1 {
		err := MetricsViewSortValidationError{
			field:  "Name",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Ascending

	if len(errors) > 0 {
		return MetricsViewSortMultiError(errors)
	}

	return nil
}

// MetricsViewSortMultiError is an error wrapping multiple validation errors
// returned by MetricsViewSort.ValidateAll() if the designated constraints
// aren't met.
type MetricsViewSortMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MetricsViewSortMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MetricsViewSortMultiError) AllErrors() []error { return m }

// MetricsViewSortValidationError is the validation error returned by
// MetricsViewSort.Validate if the designated constraints aren't met.
type MetricsViewSortValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MetricsViewSortValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MetricsViewSortValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MetricsViewSortValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MetricsViewSortValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MetricsViewSortValidationError) ErrorName() string { return "MetricsViewSortValidationError" }

// Error satisfies the builtin error interface
func (e MetricsViewSortValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMetricsViewSort.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MetricsViewSortValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MetricsViewSortValidationError{}

// Validate checks the field values on MetricsViewFilter with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *MetricsViewFilter) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on MetricsViewFilter with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// MetricsViewFilterMultiError, or nil if none found.
func (m *MetricsViewFilter) ValidateAll() error {
	return m.validate(true)
}

func (m *MetricsViewFilter) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetInclude() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, MetricsViewFilterValidationError{
						field:  fmt.Sprintf("Include[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, MetricsViewFilterValidationError{
						field:  fmt.Sprintf("Include[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return MetricsViewFilterValidationError{
					field:  fmt.Sprintf("Include[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetExclude() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, MetricsViewFilterValidationError{
						field:  fmt.Sprintf("Exclude[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, MetricsViewFilterValidationError{
						field:  fmt.Sprintf("Exclude[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return MetricsViewFilterValidationError{
					field:  fmt.Sprintf("Exclude[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return MetricsViewFilterMultiError(errors)
	}

	return nil
}

// MetricsViewFilterMultiError is an error wrapping multiple validation errors
// returned by MetricsViewFilter.ValidateAll() if the designated constraints
// aren't met.
type MetricsViewFilterMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MetricsViewFilterMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MetricsViewFilterMultiError) AllErrors() []error { return m }

// MetricsViewFilterValidationError is the validation error returned by
// MetricsViewFilter.Validate if the designated constraints aren't met.
type MetricsViewFilterValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MetricsViewFilterValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MetricsViewFilterValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MetricsViewFilterValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MetricsViewFilterValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MetricsViewFilterValidationError) ErrorName() string {
	return "MetricsViewFilterValidationError"
}

// Error satisfies the builtin error interface
func (e MetricsViewFilterValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMetricsViewFilter.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MetricsViewFilterValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MetricsViewFilterValidationError{}

// Validate checks the field values on MetricsViewColumn with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *MetricsViewColumn) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on MetricsViewColumn with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// MetricsViewColumnMultiError, or nil if none found.
func (m *MetricsViewColumn) ValidateAll() error {
	return m.validate(true)
}

func (m *MetricsViewColumn) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Name

	// no validation rules for Type

	// no validation rules for Nullable

	if len(errors) > 0 {
		return MetricsViewColumnMultiError(errors)
	}

	return nil
}

// MetricsViewColumnMultiError is an error wrapping multiple validation errors
// returned by MetricsViewColumn.ValidateAll() if the designated constraints
// aren't met.
type MetricsViewColumnMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MetricsViewColumnMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MetricsViewColumnMultiError) AllErrors() []error { return m }

// MetricsViewColumnValidationError is the validation error returned by
// MetricsViewColumn.Validate if the designated constraints aren't met.
type MetricsViewColumnValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MetricsViewColumnValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MetricsViewColumnValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MetricsViewColumnValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MetricsViewColumnValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MetricsViewColumnValidationError) ErrorName() string {
	return "MetricsViewColumnValidationError"
}

// Error satisfies the builtin error interface
func (e MetricsViewColumnValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMetricsViewColumn.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MetricsViewColumnValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MetricsViewColumnValidationError{}

// Validate checks the field values on InlineMeasure with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *InlineMeasure) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on InlineMeasure with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in InlineMeasureMultiError, or
// nil if none found.
func (m *InlineMeasure) ValidateAll() error {
	return m.validate(true)
}

func (m *InlineMeasure) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetName()) < 1 {
		err := InlineMeasureValidationError{
			field:  "Name",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetExpression()) < 1 {
		err := InlineMeasureValidationError{
			field:  "Expression",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return InlineMeasureMultiError(errors)
	}

	return nil
}

// InlineMeasureMultiError is an error wrapping multiple validation errors
// returned by InlineMeasure.ValidateAll() if the designated constraints
// aren't met.
type InlineMeasureMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m InlineMeasureMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m InlineMeasureMultiError) AllErrors() []error { return m }

// InlineMeasureValidationError is the validation error returned by
// InlineMeasure.Validate if the designated constraints aren't met.
type InlineMeasureValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e InlineMeasureValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e InlineMeasureValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e InlineMeasureValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e InlineMeasureValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e InlineMeasureValidationError) ErrorName() string { return "InlineMeasureValidationError" }

// Error satisfies the builtin error interface
func (e InlineMeasureValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sInlineMeasure.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = InlineMeasureValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = InlineMeasureValidationError{}

// Validate checks the field values on MetricsViewTimeRangeRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *MetricsViewTimeRangeRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on MetricsViewTimeRangeRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// MetricsViewTimeRangeRequestMultiError, or nil if none found.
func (m *MetricsViewTimeRangeRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *MetricsViewTimeRangeRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for InstanceId

	if utf8.RuneCountInString(m.GetMetricsViewName()) < 1 {
		err := MetricsViewTimeRangeRequestValidationError{
			field:  "MetricsViewName",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Priority

	// no validation rules for TimeDimension

	if len(errors) > 0 {
		return MetricsViewTimeRangeRequestMultiError(errors)
	}

	return nil
}

// MetricsViewTimeRangeRequestMultiError is an error wrapping multiple
// validation errors returned by MetricsViewTimeRangeRequest.ValidateAll() if
// the designated constraints aren't met.
type MetricsViewTimeRangeRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MetricsViewTimeRangeRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MetricsViewTimeRangeRequestMultiError) AllErrors() []error { return m }

// MetricsViewTimeRangeRequestValidationError is the validation error returned
// by MetricsViewTimeRangeRequest.Validate if the designated constraints
// aren't met.
type MetricsViewTimeRangeRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MetricsViewTimeRangeRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MetricsViewTimeRangeRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MetricsViewTimeRangeRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MetricsViewTimeRangeRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MetricsViewTimeRangeRequestValidationError) ErrorName() string {
	return "MetricsViewTimeRangeRequestValidationError"
}

// Error satisfies the builtin error interface
func (e MetricsViewTimeRangeRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMetricsViewTimeRangeRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MetricsViewTimeRangeRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MetricsViewTimeRangeRequestValidationError{}

// Validate checks the field values on MetricsViewTimeRangeResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *MetricsViewTimeRangeResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on MetricsViewTimeRangeResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// MetricsViewTimeRangeResponseMultiError, or nil if none found.
func (m *MetricsViewTimeRangeResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *MetricsViewTimeRangeResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetTimeRangeSummary()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, MetricsViewTimeRangeResponseValidationError{
					field:  "TimeRangeSummary",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, MetricsViewTimeRangeResponseValidationError{
					field:  "TimeRangeSummary",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTimeRangeSummary()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return MetricsViewTimeRangeResponseValidationError{
				field:  "TimeRangeSummary",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return MetricsViewTimeRangeResponseMultiError(errors)
	}

	return nil
}

// MetricsViewTimeRangeResponseMultiError is an error wrapping multiple
// validation errors returned by MetricsViewTimeRangeResponse.ValidateAll() if
// the designated constraints aren't met.
type MetricsViewTimeRangeResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MetricsViewTimeRangeResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MetricsViewTimeRangeResponseMultiError) AllErrors() []error { return m }

// MetricsViewTimeRangeResponseValidationError is the validation error returned
// by MetricsViewTimeRangeResponse.Validate if the designated constraints
// aren't met.
type MetricsViewTimeRangeResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MetricsViewTimeRangeResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MetricsViewTimeRangeResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MetricsViewTimeRangeResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MetricsViewTimeRangeResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MetricsViewTimeRangeResponseValidationError) ErrorName() string {
	return "MetricsViewTimeRangeResponseValidationError"
}

// Error satisfies the builtin error interface
func (e MetricsViewTimeRangeResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMetricsViewTimeRangeResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MetricsViewTimeRangeResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MetricsViewTimeRangeResponseValidationError{}

// Validate checks the field values on MetricsViewSchemaRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *MetricsViewSchemaRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on MetricsViewSchemaRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// MetricsViewSchemaRequestMultiError, or nil if none found.
func (m *MetricsViewSchemaRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *MetricsViewSchemaRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for InstanceId

	if utf8.RuneCountInString(m.GetMetricsViewName()) < 1 {
		err := MetricsViewSchemaRequestValidationError{
			field:  "MetricsViewName",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Priority

	if len(errors) > 0 {
		return MetricsViewSchemaRequestMultiError(errors)
	}

	return nil
}

// MetricsViewSchemaRequestMultiError is an error wrapping multiple validation
// errors returned by MetricsViewSchemaRequest.ValidateAll() if the designated
// constraints aren't met.
type MetricsViewSchemaRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MetricsViewSchemaRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MetricsViewSchemaRequestMultiError) AllErrors() []error { return m }

// MetricsViewSchemaRequestValidationError is the validation error returned by
// MetricsViewSchemaRequest.Validate if the designated constraints aren't met.
type MetricsViewSchemaRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MetricsViewSchemaRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MetricsViewSchemaRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MetricsViewSchemaRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MetricsViewSchemaRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MetricsViewSchemaRequestValidationError) ErrorName() string {
	return "MetricsViewSchemaRequestValidationError"
}

// Error satisfies the builtin error interface
func (e MetricsViewSchemaRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMetricsViewSchemaRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MetricsViewSchemaRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MetricsViewSchemaRequestValidationError{}

// Validate checks the field values on MetricsViewSchemaResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *MetricsViewSchemaResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on MetricsViewSchemaResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// MetricsViewSchemaResponseMultiError, or nil if none found.
func (m *MetricsViewSchemaResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *MetricsViewSchemaResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetSchema()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, MetricsViewSchemaResponseValidationError{
					field:  "Schema",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, MetricsViewSchemaResponseValidationError{
					field:  "Schema",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSchema()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return MetricsViewSchemaResponseValidationError{
				field:  "Schema",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return MetricsViewSchemaResponseMultiError(errors)
	}

	return nil
}

// MetricsViewSchemaResponseMultiError is an error wrapping multiple validation
// errors returned by MetricsViewSchemaResponse.ValidateAll() if the
// designated constraints aren't met.
type MetricsViewSchemaResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MetricsViewSchemaResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MetricsViewSchemaResponseMultiError) AllErrors() []error { return m }

// MetricsViewSchemaResponseValidationError is the validation error returned by
// MetricsViewSchemaResponse.Validate if the designated constraints aren't met.
type MetricsViewSchemaResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MetricsViewSchemaResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MetricsViewSchemaResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MetricsViewSchemaResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MetricsViewSchemaResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MetricsViewSchemaResponseValidationError) ErrorName() string {
	return "MetricsViewSchemaResponseValidationError"
}

// Error satisfies the builtin error interface
func (e MetricsViewSchemaResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMetricsViewSchemaResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MetricsViewSchemaResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MetricsViewSchemaResponseValidationError{}

// Validate checks the field values on MetricsViewSearchRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *MetricsViewSearchRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on MetricsViewSearchRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// MetricsViewSearchRequestMultiError, or nil if none found.
func (m *MetricsViewSearchRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *MetricsViewSearchRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for InstanceId

	if utf8.RuneCountInString(m.GetMetricsViewName()) < 1 {
		err := MetricsViewSearchRequestValidationError{
			field:  "MetricsViewName",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Search

	if all {
		switch v := interface{}(m.GetTimeRange()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, MetricsViewSearchRequestValidationError{
					field:  "TimeRange",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, MetricsViewSearchRequestValidationError{
					field:  "TimeRange",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTimeRange()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return MetricsViewSearchRequestValidationError{
				field:  "TimeRange",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetWhere()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, MetricsViewSearchRequestValidationError{
					field:  "Where",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, MetricsViewSearchRequestValidationError{
					field:  "Where",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetWhere()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return MetricsViewSearchRequestValidationError{
				field:  "Where",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetHaving()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, MetricsViewSearchRequestValidationError{
					field:  "Having",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, MetricsViewSearchRequestValidationError{
					field:  "Having",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetHaving()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return MetricsViewSearchRequestValidationError{
				field:  "Having",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if m.GetLimit() < 0 {
		err := MetricsViewSearchRequestValidationError{
			field:  "Limit",
			reason: "value must be greater than or equal to 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Priority

	if len(errors) > 0 {
		return MetricsViewSearchRequestMultiError(errors)
	}

	return nil
}

// MetricsViewSearchRequestMultiError is an error wrapping multiple validation
// errors returned by MetricsViewSearchRequest.ValidateAll() if the designated
// constraints aren't met.
type MetricsViewSearchRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MetricsViewSearchRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MetricsViewSearchRequestMultiError) AllErrors() []error { return m }

// MetricsViewSearchRequestValidationError is the validation error returned by
// MetricsViewSearchRequest.Validate if the designated constraints aren't met.
type MetricsViewSearchRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MetricsViewSearchRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MetricsViewSearchRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MetricsViewSearchRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MetricsViewSearchRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MetricsViewSearchRequestValidationError) ErrorName() string {
	return "MetricsViewSearchRequestValidationError"
}

// Error satisfies the builtin error interface
func (e MetricsViewSearchRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMetricsViewSearchRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MetricsViewSearchRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MetricsViewSearchRequestValidationError{}

// Validate checks the field values on MetricsViewSearchResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *MetricsViewSearchResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on MetricsViewSearchResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// MetricsViewSearchResponseMultiError, or nil if none found.
func (m *MetricsViewSearchResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *MetricsViewSearchResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetResults() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, MetricsViewSearchResponseValidationError{
						field:  fmt.Sprintf("Results[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, MetricsViewSearchResponseValidationError{
						field:  fmt.Sprintf("Results[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return MetricsViewSearchResponseValidationError{
					field:  fmt.Sprintf("Results[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return MetricsViewSearchResponseMultiError(errors)
	}

	return nil
}

// MetricsViewSearchResponseMultiError is an error wrapping multiple validation
// errors returned by MetricsViewSearchResponse.ValidateAll() if the
// designated constraints aren't met.
type MetricsViewSearchResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MetricsViewSearchResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MetricsViewSearchResponseMultiError) AllErrors() []error { return m }

// MetricsViewSearchResponseValidationError is the validation error returned by
// MetricsViewSearchResponse.Validate if the designated constraints aren't met.
type MetricsViewSearchResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MetricsViewSearchResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MetricsViewSearchResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MetricsViewSearchResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MetricsViewSearchResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MetricsViewSearchResponseValidationError) ErrorName() string {
	return "MetricsViewSearchResponseValidationError"
}

// Error satisfies the builtin error interface
func (e MetricsViewSearchResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMetricsViewSearchResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MetricsViewSearchResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MetricsViewSearchResponseValidationError{}

// Validate checks the field values on MetricsViewTimeRangesRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *MetricsViewTimeRangesRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on MetricsViewTimeRangesRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// MetricsViewTimeRangesRequestMultiError, or nil if none found.
func (m *MetricsViewTimeRangesRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *MetricsViewTimeRangesRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for InstanceId

	if utf8.RuneCountInString(m.GetMetricsViewName()) < 1 {
		err := MetricsViewTimeRangesRequestValidationError{
			field:  "MetricsViewName",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Priority

	// no validation rules for TimeZone

	// no validation rules for TimeDimension

	if len(errors) > 0 {
		return MetricsViewTimeRangesRequestMultiError(errors)
	}

	return nil
}

// MetricsViewTimeRangesRequestMultiError is an error wrapping multiple
// validation errors returned by MetricsViewTimeRangesRequest.ValidateAll() if
// the designated constraints aren't met.
type MetricsViewTimeRangesRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MetricsViewTimeRangesRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MetricsViewTimeRangesRequestMultiError) AllErrors() []error { return m }

// MetricsViewTimeRangesRequestValidationError is the validation error returned
// by MetricsViewTimeRangesRequest.Validate if the designated constraints
// aren't met.
type MetricsViewTimeRangesRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MetricsViewTimeRangesRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MetricsViewTimeRangesRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MetricsViewTimeRangesRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MetricsViewTimeRangesRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MetricsViewTimeRangesRequestValidationError) ErrorName() string {
	return "MetricsViewTimeRangesRequestValidationError"
}

// Error satisfies the builtin error interface
func (e MetricsViewTimeRangesRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMetricsViewTimeRangesRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MetricsViewTimeRangesRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MetricsViewTimeRangesRequestValidationError{}

// Validate checks the field values on MetricsViewTimeRangesResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *MetricsViewTimeRangesResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on MetricsViewTimeRangesResponse with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// MetricsViewTimeRangesResponseMultiError, or nil if none found.
func (m *MetricsViewTimeRangesResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *MetricsViewTimeRangesResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetTimeRanges() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, MetricsViewTimeRangesResponseValidationError{
						field:  fmt.Sprintf("TimeRanges[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, MetricsViewTimeRangesResponseValidationError{
						field:  fmt.Sprintf("TimeRanges[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return MetricsViewTimeRangesResponseValidationError{
					field:  fmt.Sprintf("TimeRanges[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return MetricsViewTimeRangesResponseMultiError(errors)
	}

	return nil
}

// MetricsViewTimeRangesResponseMultiError is an error wrapping multiple
// validation errors returned by MetricsViewTimeRangesResponse.ValidateAll()
// if the designated constraints aren't met.
type MetricsViewTimeRangesResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MetricsViewTimeRangesResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MetricsViewTimeRangesResponseMultiError) AllErrors() []error { return m }

// MetricsViewTimeRangesResponseValidationError is the validation error
// returned by MetricsViewTimeRangesResponse.Validate if the designated
// constraints aren't met.
type MetricsViewTimeRangesResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MetricsViewTimeRangesResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MetricsViewTimeRangesResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MetricsViewTimeRangesResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MetricsViewTimeRangesResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MetricsViewTimeRangesResponseValidationError) ErrorName() string {
	return "MetricsViewTimeRangesResponseValidationError"
}

// Error satisfies the builtin error interface
func (e MetricsViewTimeRangesResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMetricsViewTimeRangesResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MetricsViewTimeRangesResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MetricsViewTimeRangesResponseValidationError{}

// Validate checks the field values on ResolveCanvasRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ResolveCanvasRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ResolveCanvasRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ResolveCanvasRequestMultiError, or nil if none found.
func (m *ResolveCanvasRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ResolveCanvasRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for InstanceId

	// no validation rules for Canvas

	if all {
		switch v := interface{}(m.GetArgs()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ResolveCanvasRequestValidationError{
					field:  "Args",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ResolveCanvasRequestValidationError{
					field:  "Args",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetArgs()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ResolveCanvasRequestValidationError{
				field:  "Args",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ResolveCanvasRequestMultiError(errors)
	}

	return nil
}

// ResolveCanvasRequestMultiError is an error wrapping multiple validation
// errors returned by ResolveCanvasRequest.ValidateAll() if the designated
// constraints aren't met.
type ResolveCanvasRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ResolveCanvasRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ResolveCanvasRequestMultiError) AllErrors() []error { return m }

// ResolveCanvasRequestValidationError is the validation error returned by
// ResolveCanvasRequest.Validate if the designated constraints aren't met.
type ResolveCanvasRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ResolveCanvasRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ResolveCanvasRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ResolveCanvasRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ResolveCanvasRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ResolveCanvasRequestValidationError) ErrorName() string {
	return "ResolveCanvasRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ResolveCanvasRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sResolveCanvasRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ResolveCanvasRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ResolveCanvasRequestValidationError{}

// Validate checks the field values on ResolveCanvasResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ResolveCanvasResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ResolveCanvasResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ResolveCanvasResponseMultiError, or nil if none found.
func (m *ResolveCanvasResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ResolveCanvasResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetCanvas()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ResolveCanvasResponseValidationError{
					field:  "Canvas",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ResolveCanvasResponseValidationError{
					field:  "Canvas",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCanvas()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ResolveCanvasResponseValidationError{
				field:  "Canvas",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	{
		sorted_keys := make([]string, len(m.GetResolvedComponents()))
		i := 0
		for key := range m.GetResolvedComponents() {
			sorted_keys[i] = key
			i++
		}
		sort.Slice(sorted_keys, func(i, j int) bool { return sorted_keys[i] < sorted_keys[j] })
		for _, key := range sorted_keys {
			val := m.GetResolvedComponents()[key]
			_ = val

			// no validation rules for ResolvedComponents[key]

			if all {
				switch v := interface{}(val).(type) {
				case interface{ ValidateAll() error }:
					if err := v.ValidateAll(); err != nil {
						errors = append(errors, ResolveCanvasResponseValidationError{
							field:  fmt.Sprintf("ResolvedComponents[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				case interface{ Validate() error }:
					if err := v.Validate(); err != nil {
						errors = append(errors, ResolveCanvasResponseValidationError{
							field:  fmt.Sprintf("ResolvedComponents[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				}
			} else if v, ok := interface{}(val).(interface{ Validate() error }); ok {
				if err := v.Validate(); err != nil {
					return ResolveCanvasResponseValidationError{
						field:  fmt.Sprintf("ResolvedComponents[%v]", key),
						reason: "embedded message failed validation",
						cause:  err,
					}
				}
			}

		}
	}

	{
		sorted_keys := make([]string, len(m.GetReferencedMetricsViews()))
		i := 0
		for key := range m.GetReferencedMetricsViews() {
			sorted_keys[i] = key
			i++
		}
		sort.Slice(sorted_keys, func(i, j int) bool { return sorted_keys[i] < sorted_keys[j] })
		for _, key := range sorted_keys {
			val := m.GetReferencedMetricsViews()[key]
			_ = val

			// no validation rules for ReferencedMetricsViews[key]

			if all {
				switch v := interface{}(val).(type) {
				case interface{ ValidateAll() error }:
					if err := v.ValidateAll(); err != nil {
						errors = append(errors, ResolveCanvasResponseValidationError{
							field:  fmt.Sprintf("ReferencedMetricsViews[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				case interface{ Validate() error }:
					if err := v.Validate(); err != nil {
						errors = append(errors, ResolveCanvasResponseValidationError{
							field:  fmt.Sprintf("ReferencedMetricsViews[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				}
			} else if v, ok := interface{}(val).(interface{ Validate() error }); ok {
				if err := v.Validate(); err != nil {
					return ResolveCanvasResponseValidationError{
						field:  fmt.Sprintf("ReferencedMetricsViews[%v]", key),
						reason: "embedded message failed validation",
						cause:  err,
					}
				}
			}

		}
	}

	if len(errors) > 0 {
		return ResolveCanvasResponseMultiError(errors)
	}

	return nil
}

// ResolveCanvasResponseMultiError is an error wrapping multiple validation
// errors returned by ResolveCanvasResponse.ValidateAll() if the designated
// constraints aren't met.
type ResolveCanvasResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ResolveCanvasResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ResolveCanvasResponseMultiError) AllErrors() []error { return m }

// ResolveCanvasResponseValidationError is the validation error returned by
// ResolveCanvasResponse.Validate if the designated constraints aren't met.
type ResolveCanvasResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ResolveCanvasResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ResolveCanvasResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ResolveCanvasResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ResolveCanvasResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ResolveCanvasResponseValidationError) ErrorName() string {
	return "ResolveCanvasResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ResolveCanvasResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sResolveCanvasResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ResolveCanvasResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ResolveCanvasResponseValidationError{}

// Validate checks the field values on ResolveComponentRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ResolveComponentRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ResolveComponentRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ResolveComponentRequestMultiError, or nil if none found.
func (m *ResolveComponentRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ResolveComponentRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for InstanceId

	// no validation rules for Component

	if all {
		switch v := interface{}(m.GetArgs()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ResolveComponentRequestValidationError{
					field:  "Args",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ResolveComponentRequestValidationError{
					field:  "Args",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetArgs()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ResolveComponentRequestValidationError{
				field:  "Args",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ResolveComponentRequestMultiError(errors)
	}

	return nil
}

// ResolveComponentRequestMultiError is an error wrapping multiple validation
// errors returned by ResolveComponentRequest.ValidateAll() if the designated
// constraints aren't met.
type ResolveComponentRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ResolveComponentRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ResolveComponentRequestMultiError) AllErrors() []error { return m }

// ResolveComponentRequestValidationError is the validation error returned by
// ResolveComponentRequest.Validate if the designated constraints aren't met.
type ResolveComponentRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ResolveComponentRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ResolveComponentRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ResolveComponentRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ResolveComponentRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ResolveComponentRequestValidationError) ErrorName() string {
	return "ResolveComponentRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ResolveComponentRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sResolveComponentRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ResolveComponentRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ResolveComponentRequestValidationError{}

// Validate checks the field values on ResolveComponentResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ResolveComponentResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ResolveComponentResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ResolveComponentResponseMultiError, or nil if none found.
func (m *ResolveComponentResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ResolveComponentResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetRendererProperties()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ResolveComponentResponseValidationError{
					field:  "RendererProperties",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ResolveComponentResponseValidationError{
					field:  "RendererProperties",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetRendererProperties()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ResolveComponentResponseValidationError{
				field:  "RendererProperties",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ResolveComponentResponseMultiError(errors)
	}

	return nil
}

// ResolveComponentResponseMultiError is an error wrapping multiple validation
// errors returned by ResolveComponentResponse.ValidateAll() if the designated
// constraints aren't met.
type ResolveComponentResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ResolveComponentResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ResolveComponentResponseMultiError) AllErrors() []error { return m }

// ResolveComponentResponseValidationError is the validation error returned by
// ResolveComponentResponse.Validate if the designated constraints aren't met.
type ResolveComponentResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ResolveComponentResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ResolveComponentResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ResolveComponentResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ResolveComponentResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ResolveComponentResponseValidationError) ErrorName() string {
	return "ResolveComponentResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ResolveComponentResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sResolveComponentResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ResolveComponentResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ResolveComponentResponseValidationError{}

// Validate checks the field values on ColumnRollupIntervalRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ColumnRollupIntervalRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ColumnRollupIntervalRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ColumnRollupIntervalRequestMultiError, or nil if none found.
func (m *ColumnRollupIntervalRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ColumnRollupIntervalRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for InstanceId

	// no validation rules for Connector

	// no validation rules for Database

	// no validation rules for DatabaseSchema

	if utf8.RuneCountInString(m.GetTableName()) < 1 {
		err := ColumnRollupIntervalRequestValidationError{
			field:  "TableName",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetColumnName()) < 1 {
		err := ColumnRollupIntervalRequestValidationError{
			field:  "ColumnName",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Priority

	if len(errors) > 0 {
		return ColumnRollupIntervalRequestMultiError(errors)
	}

	return nil
}

// ColumnRollupIntervalRequestMultiError is an error wrapping multiple
// validation errors returned by ColumnRollupIntervalRequest.ValidateAll() if
// the designated constraints aren't met.
type ColumnRollupIntervalRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ColumnRollupIntervalRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ColumnRollupIntervalRequestMultiError) AllErrors() []error { return m }

// ColumnRollupIntervalRequestValidationError is the validation error returned
// by ColumnRollupIntervalRequest.Validate if the designated constraints
// aren't met.
type ColumnRollupIntervalRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ColumnRollupIntervalRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ColumnRollupIntervalRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ColumnRollupIntervalRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ColumnRollupIntervalRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ColumnRollupIntervalRequestValidationError) ErrorName() string {
	return "ColumnRollupIntervalRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ColumnRollupIntervalRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sColumnRollupIntervalRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ColumnRollupIntervalRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ColumnRollupIntervalRequestValidationError{}

// Validate checks the field values on ColumnRollupIntervalResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ColumnRollupIntervalResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ColumnRollupIntervalResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ColumnRollupIntervalResponseMultiError, or nil if none found.
func (m *ColumnRollupIntervalResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ColumnRollupIntervalResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetStart()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ColumnRollupIntervalResponseValidationError{
					field:  "Start",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ColumnRollupIntervalResponseValidationError{
					field:  "Start",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetStart()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ColumnRollupIntervalResponseValidationError{
				field:  "Start",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetEnd()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ColumnRollupIntervalResponseValidationError{
					field:  "End",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ColumnRollupIntervalResponseValidationError{
					field:  "End",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetEnd()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ColumnRollupIntervalResponseValidationError{
				field:  "End",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Interval

	if len(errors) > 0 {
		return ColumnRollupIntervalResponseMultiError(errors)
	}

	return nil
}

// ColumnRollupIntervalResponseMultiError is an error wrapping multiple
// validation errors returned by ColumnRollupIntervalResponse.ValidateAll() if
// the designated constraints aren't met.
type ColumnRollupIntervalResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ColumnRollupIntervalResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ColumnRollupIntervalResponseMultiError) AllErrors() []error { return m }

// ColumnRollupIntervalResponseValidationError is the validation error returned
// by ColumnRollupIntervalResponse.Validate if the designated constraints
// aren't met.
type ColumnRollupIntervalResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ColumnRollupIntervalResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ColumnRollupIntervalResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ColumnRollupIntervalResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ColumnRollupIntervalResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ColumnRollupIntervalResponseValidationError) ErrorName() string {
	return "ColumnRollupIntervalResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ColumnRollupIntervalResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sColumnRollupIntervalResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ColumnRollupIntervalResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ColumnRollupIntervalResponseValidationError{}

// Validate checks the field values on ColumnTopKRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *ColumnTopKRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ColumnTopKRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ColumnTopKRequestMultiError, or nil if none found.
func (m *ColumnTopKRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ColumnTopKRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for InstanceId

	// no validation rules for Connector

	// no validation rules for Database

	// no validation rules for DatabaseSchema

	if utf8.RuneCountInString(m.GetTableName()) < 1 {
		err := ColumnTopKRequestValidationError{
			field:  "TableName",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetColumnName()) < 1 {
		err := ColumnTopKRequestValidationError{
			field:  "ColumnName",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Agg

	// no validation rules for K

	// no validation rules for Priority

	if len(errors) > 0 {
		return ColumnTopKRequestMultiError(errors)
	}

	return nil
}

// ColumnTopKRequestMultiError is an error wrapping multiple validation errors
// returned by ColumnTopKRequest.ValidateAll() if the designated constraints
// aren't met.
type ColumnTopKRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ColumnTopKRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ColumnTopKRequestMultiError) AllErrors() []error { return m }

// ColumnTopKRequestValidationError is the validation error returned by
// ColumnTopKRequest.Validate if the designated constraints aren't met.
type ColumnTopKRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ColumnTopKRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ColumnTopKRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ColumnTopKRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ColumnTopKRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ColumnTopKRequestValidationError) ErrorName() string {
	return "ColumnTopKRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ColumnTopKRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sColumnTopKRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ColumnTopKRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ColumnTopKRequestValidationError{}

// Validate checks the field values on ColumnTopKResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ColumnTopKResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ColumnTopKResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ColumnTopKResponseMultiError, or nil if none found.
func (m *ColumnTopKResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ColumnTopKResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetCategoricalSummary()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ColumnTopKResponseValidationError{
					field:  "CategoricalSummary",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ColumnTopKResponseValidationError{
					field:  "CategoricalSummary",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCategoricalSummary()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ColumnTopKResponseValidationError{
				field:  "CategoricalSummary",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ColumnTopKResponseMultiError(errors)
	}

	return nil
}

// ColumnTopKResponseMultiError is an error wrapping multiple validation errors
// returned by ColumnTopKResponse.ValidateAll() if the designated constraints
// aren't met.
type ColumnTopKResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ColumnTopKResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ColumnTopKResponseMultiError) AllErrors() []error { return m }

// ColumnTopKResponseValidationError is the validation error returned by
// ColumnTopKResponse.Validate if the designated constraints aren't met.
type ColumnTopKResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ColumnTopKResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ColumnTopKResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ColumnTopKResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ColumnTopKResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ColumnTopKResponseValidationError) ErrorName() string {
	return "ColumnTopKResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ColumnTopKResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sColumnTopKResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ColumnTopKResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ColumnTopKResponseValidationError{}

// Validate checks the field values on CategoricalSummary with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CategoricalSummary) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CategoricalSummary with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CategoricalSummaryMultiError, or nil if none found.
func (m *CategoricalSummary) ValidateAll() error {
	return m.validate(true)
}

func (m *CategoricalSummary) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	switch v := m.Case.(type) {
	case *CategoricalSummary_TopK:
		if v == nil {
			err := CategoricalSummaryValidationError{
				field:  "Case",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetTopK()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, CategoricalSummaryValidationError{
						field:  "TopK",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, CategoricalSummaryValidationError{
						field:  "TopK",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetTopK()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return CategoricalSummaryValidationError{
					field:  "TopK",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *CategoricalSummary_Cardinality:
		if v == nil {
			err := CategoricalSummaryValidationError{
				field:  "Case",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		// no validation rules for Cardinality
	default:
		_ = v // ensures v is used
	}

	if len(errors) > 0 {
		return CategoricalSummaryMultiError(errors)
	}

	return nil
}

// CategoricalSummaryMultiError is an error wrapping multiple validation errors
// returned by CategoricalSummary.ValidateAll() if the designated constraints
// aren't met.
type CategoricalSummaryMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CategoricalSummaryMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CategoricalSummaryMultiError) AllErrors() []error { return m }

// CategoricalSummaryValidationError is the validation error returned by
// CategoricalSummary.Validate if the designated constraints aren't met.
type CategoricalSummaryValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CategoricalSummaryValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CategoricalSummaryValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CategoricalSummaryValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CategoricalSummaryValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CategoricalSummaryValidationError) ErrorName() string {
	return "CategoricalSummaryValidationError"
}

// Error satisfies the builtin error interface
func (e CategoricalSummaryValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCategoricalSummary.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CategoricalSummaryValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CategoricalSummaryValidationError{}

// Validate checks the field values on TopK with the rules defined in the proto
// definition for this message. If any rules are violated, the first error
// encountered is returned, or nil if there are no violations.
func (m *TopK) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TopK with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in TopKMultiError, or nil if none found.
func (m *TopK) ValidateAll() error {
	return m.validate(true)
}

func (m *TopK) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetEntries() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, TopKValidationError{
						field:  fmt.Sprintf("Entries[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, TopKValidationError{
						field:  fmt.Sprintf("Entries[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return TopKValidationError{
					field:  fmt.Sprintf("Entries[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return TopKMultiError(errors)
	}

	return nil
}

// TopKMultiError is an error wrapping multiple validation errors returned by
// TopK.ValidateAll() if the designated constraints aren't met.
type TopKMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TopKMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TopKMultiError) AllErrors() []error { return m }

// TopKValidationError is the validation error returned by TopK.Validate if the
// designated constraints aren't met.
type TopKValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TopKValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TopKValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TopKValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TopKValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TopKValidationError) ErrorName() string { return "TopKValidationError" }

// Error satisfies the builtin error interface
func (e TopKValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTopK.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TopKValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TopKValidationError{}

// Validate checks the field values on ColumnNullCountRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ColumnNullCountRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ColumnNullCountRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ColumnNullCountRequestMultiError, or nil if none found.
func (m *ColumnNullCountRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ColumnNullCountRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for InstanceId

	// no validation rules for Connector

	// no validation rules for Database

	// no validation rules for DatabaseSchema

	if utf8.RuneCountInString(m.GetTableName()) < 1 {
		err := ColumnNullCountRequestValidationError{
			field:  "TableName",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetColumnName()) < 1 {
		err := ColumnNullCountRequestValidationError{
			field:  "ColumnName",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Priority

	if len(errors) > 0 {
		return ColumnNullCountRequestMultiError(errors)
	}

	return nil
}

// ColumnNullCountRequestMultiError is an error wrapping multiple validation
// errors returned by ColumnNullCountRequest.ValidateAll() if the designated
// constraints aren't met.
type ColumnNullCountRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ColumnNullCountRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ColumnNullCountRequestMultiError) AllErrors() []error { return m }

// ColumnNullCountRequestValidationError is the validation error returned by
// ColumnNullCountRequest.Validate if the designated constraints aren't met.
type ColumnNullCountRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ColumnNullCountRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ColumnNullCountRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ColumnNullCountRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ColumnNullCountRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ColumnNullCountRequestValidationError) ErrorName() string {
	return "ColumnNullCountRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ColumnNullCountRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sColumnNullCountRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ColumnNullCountRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ColumnNullCountRequestValidationError{}

// Validate checks the field values on ColumnNullCountResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ColumnNullCountResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ColumnNullCountResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ColumnNullCountResponseMultiError, or nil if none found.
func (m *ColumnNullCountResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ColumnNullCountResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Count

	if len(errors) > 0 {
		return ColumnNullCountResponseMultiError(errors)
	}

	return nil
}

// ColumnNullCountResponseMultiError is an error wrapping multiple validation
// errors returned by ColumnNullCountResponse.ValidateAll() if the designated
// constraints aren't met.
type ColumnNullCountResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ColumnNullCountResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ColumnNullCountResponseMultiError) AllErrors() []error { return m }

// ColumnNullCountResponseValidationError is the validation error returned by
// ColumnNullCountResponse.Validate if the designated constraints aren't met.
type ColumnNullCountResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ColumnNullCountResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ColumnNullCountResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ColumnNullCountResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ColumnNullCountResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ColumnNullCountResponseValidationError) ErrorName() string {
	return "ColumnNullCountResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ColumnNullCountResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sColumnNullCountResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ColumnNullCountResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ColumnNullCountResponseValidationError{}

// Validate checks the field values on ColumnDescriptiveStatisticsRequest with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *ColumnDescriptiveStatisticsRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ColumnDescriptiveStatisticsRequest
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// ColumnDescriptiveStatisticsRequestMultiError, or nil if none found.
func (m *ColumnDescriptiveStatisticsRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ColumnDescriptiveStatisticsRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for InstanceId

	// no validation rules for Connector

	// no validation rules for Database

	// no validation rules for DatabaseSchema

	if utf8.RuneCountInString(m.GetTableName()) < 1 {
		err := ColumnDescriptiveStatisticsRequestValidationError{
			field:  "TableName",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetColumnName()) < 1 {
		err := ColumnDescriptiveStatisticsRequestValidationError{
			field:  "ColumnName",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Priority

	if len(errors) > 0 {
		return ColumnDescriptiveStatisticsRequestMultiError(errors)
	}

	return nil
}

// ColumnDescriptiveStatisticsRequestMultiError is an error wrapping multiple
// validation errors returned by
// ColumnDescriptiveStatisticsRequest.ValidateAll() if the designated
// constraints aren't met.
type ColumnDescriptiveStatisticsRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ColumnDescriptiveStatisticsRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ColumnDescriptiveStatisticsRequestMultiError) AllErrors() []error { return m }

// ColumnDescriptiveStatisticsRequestValidationError is the validation error
// returned by ColumnDescriptiveStatisticsRequest.Validate if the designated
// constraints aren't met.
type ColumnDescriptiveStatisticsRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ColumnDescriptiveStatisticsRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ColumnDescriptiveStatisticsRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ColumnDescriptiveStatisticsRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ColumnDescriptiveStatisticsRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ColumnDescriptiveStatisticsRequestValidationError) ErrorName() string {
	return "ColumnDescriptiveStatisticsRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ColumnDescriptiveStatisticsRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sColumnDescriptiveStatisticsRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ColumnDescriptiveStatisticsRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ColumnDescriptiveStatisticsRequestValidationError{}

// Validate checks the field values on ColumnDescriptiveStatisticsResponse with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *ColumnDescriptiveStatisticsResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ColumnDescriptiveStatisticsResponse
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// ColumnDescriptiveStatisticsResponseMultiError, or nil if none found.
func (m *ColumnDescriptiveStatisticsResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ColumnDescriptiveStatisticsResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetNumericSummary()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ColumnDescriptiveStatisticsResponseValidationError{
					field:  "NumericSummary",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ColumnDescriptiveStatisticsResponseValidationError{
					field:  "NumericSummary",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetNumericSummary()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ColumnDescriptiveStatisticsResponseValidationError{
				field:  "NumericSummary",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ColumnDescriptiveStatisticsResponseMultiError(errors)
	}

	return nil
}

// ColumnDescriptiveStatisticsResponseMultiError is an error wrapping multiple
// validation errors returned by
// ColumnDescriptiveStatisticsResponse.ValidateAll() if the designated
// constraints aren't met.
type ColumnDescriptiveStatisticsResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ColumnDescriptiveStatisticsResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ColumnDescriptiveStatisticsResponseMultiError) AllErrors() []error { return m }

// ColumnDescriptiveStatisticsResponseValidationError is the validation error
// returned by ColumnDescriptiveStatisticsResponse.Validate if the designated
// constraints aren't met.
type ColumnDescriptiveStatisticsResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ColumnDescriptiveStatisticsResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ColumnDescriptiveStatisticsResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ColumnDescriptiveStatisticsResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ColumnDescriptiveStatisticsResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ColumnDescriptiveStatisticsResponseValidationError) ErrorName() string {
	return "ColumnDescriptiveStatisticsResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ColumnDescriptiveStatisticsResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sColumnDescriptiveStatisticsResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ColumnDescriptiveStatisticsResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ColumnDescriptiveStatisticsResponseValidationError{}

// Validate checks the field values on NumericSummary with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *NumericSummary) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on NumericSummary with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in NumericSummaryMultiError,
// or nil if none found.
func (m *NumericSummary) ValidateAll() error {
	return m.validate(true)
}

func (m *NumericSummary) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	switch v := m.Case.(type) {
	case *NumericSummary_NumericHistogramBins:
		if v == nil {
			err := NumericSummaryValidationError{
				field:  "Case",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetNumericHistogramBins()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, NumericSummaryValidationError{
						field:  "NumericHistogramBins",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, NumericSummaryValidationError{
						field:  "NumericHistogramBins",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetNumericHistogramBins()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return NumericSummaryValidationError{
					field:  "NumericHistogramBins",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *NumericSummary_NumericStatistics:
		if v == nil {
			err := NumericSummaryValidationError{
				field:  "Case",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetNumericStatistics()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, NumericSummaryValidationError{
						field:  "NumericStatistics",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, NumericSummaryValidationError{
						field:  "NumericStatistics",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetNumericStatistics()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return NumericSummaryValidationError{
					field:  "NumericStatistics",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *NumericSummary_NumericOutliers:
		if v == nil {
			err := NumericSummaryValidationError{
				field:  "Case",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetNumericOutliers()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, NumericSummaryValidationError{
						field:  "NumericOutliers",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, NumericSummaryValidationError{
						field:  "NumericOutliers",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetNumericOutliers()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return NumericSummaryValidationError{
					field:  "NumericOutliers",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	default:
		_ = v // ensures v is used
	}

	if len(errors) > 0 {
		return NumericSummaryMultiError(errors)
	}

	return nil
}

// NumericSummaryMultiError is an error wrapping multiple validation errors
// returned by NumericSummary.ValidateAll() if the designated constraints
// aren't met.
type NumericSummaryMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m NumericSummaryMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m NumericSummaryMultiError) AllErrors() []error { return m }

// NumericSummaryValidationError is the validation error returned by
// NumericSummary.Validate if the designated constraints aren't met.
type NumericSummaryValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e NumericSummaryValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e NumericSummaryValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e NumericSummaryValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e NumericSummaryValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e NumericSummaryValidationError) ErrorName() string { return "NumericSummaryValidationError" }

// Error satisfies the builtin error interface
func (e NumericSummaryValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sNumericSummary.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = NumericSummaryValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = NumericSummaryValidationError{}

// Validate checks the field values on NumericHistogramBins with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *NumericHistogramBins) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on NumericHistogramBins with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// NumericHistogramBinsMultiError, or nil if none found.
func (m *NumericHistogramBins) ValidateAll() error {
	return m.validate(true)
}

func (m *NumericHistogramBins) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetBins() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, NumericHistogramBinsValidationError{
						field:  fmt.Sprintf("Bins[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, NumericHistogramBinsValidationError{
						field:  fmt.Sprintf("Bins[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return NumericHistogramBinsValidationError{
					field:  fmt.Sprintf("Bins[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return NumericHistogramBinsMultiError(errors)
	}

	return nil
}

// NumericHistogramBinsMultiError is an error wrapping multiple validation
// errors returned by NumericHistogramBins.ValidateAll() if the designated
// constraints aren't met.
type NumericHistogramBinsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m NumericHistogramBinsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m NumericHistogramBinsMultiError) AllErrors() []error { return m }

// NumericHistogramBinsValidationError is the validation error returned by
// NumericHistogramBins.Validate if the designated constraints aren't met.
type NumericHistogramBinsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e NumericHistogramBinsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e NumericHistogramBinsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e NumericHistogramBinsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e NumericHistogramBinsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e NumericHistogramBinsValidationError) ErrorName() string {
	return "NumericHistogramBinsValidationError"
}

// Error satisfies the builtin error interface
func (e NumericHistogramBinsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sNumericHistogramBins.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = NumericHistogramBinsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = NumericHistogramBinsValidationError{}

// Validate checks the field values on NumericStatistics with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *NumericStatistics) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on NumericStatistics with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// NumericStatisticsMultiError, or nil if none found.
func (m *NumericStatistics) ValidateAll() error {
	return m.validate(true)
}

func (m *NumericStatistics) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Min

	// no validation rules for Max

	// no validation rules for Mean

	// no validation rules for Q25

	// no validation rules for Q50

	// no validation rules for Q75

	// no validation rules for Sd

	if len(errors) > 0 {
		return NumericStatisticsMultiError(errors)
	}

	return nil
}

// NumericStatisticsMultiError is an error wrapping multiple validation errors
// returned by NumericStatistics.ValidateAll() if the designated constraints
// aren't met.
type NumericStatisticsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m NumericStatisticsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m NumericStatisticsMultiError) AllErrors() []error { return m }

// NumericStatisticsValidationError is the validation error returned by
// NumericStatistics.Validate if the designated constraints aren't met.
type NumericStatisticsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e NumericStatisticsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e NumericStatisticsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e NumericStatisticsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e NumericStatisticsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e NumericStatisticsValidationError) ErrorName() string {
	return "NumericStatisticsValidationError"
}

// Error satisfies the builtin error interface
func (e NumericStatisticsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sNumericStatistics.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = NumericStatisticsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = NumericStatisticsValidationError{}

// Validate checks the field values on NumericOutliers with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *NumericOutliers) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on NumericOutliers with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// NumericOutliersMultiError, or nil if none found.
func (m *NumericOutliers) ValidateAll() error {
	return m.validate(true)
}

func (m *NumericOutliers) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetOutliers() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, NumericOutliersValidationError{
						field:  fmt.Sprintf("Outliers[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, NumericOutliersValidationError{
						field:  fmt.Sprintf("Outliers[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return NumericOutliersValidationError{
					field:  fmt.Sprintf("Outliers[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return NumericOutliersMultiError(errors)
	}

	return nil
}

// NumericOutliersMultiError is an error wrapping multiple validation errors
// returned by NumericOutliers.ValidateAll() if the designated constraints
// aren't met.
type NumericOutliersMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m NumericOutliersMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m NumericOutliersMultiError) AllErrors() []error { return m }

// NumericOutliersValidationError is the validation error returned by
// NumericOutliers.Validate if the designated constraints aren't met.
type NumericOutliersValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e NumericOutliersValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e NumericOutliersValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e NumericOutliersValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e NumericOutliersValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e NumericOutliersValidationError) ErrorName() string { return "NumericOutliersValidationError" }

// Error satisfies the builtin error interface
func (e NumericOutliersValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sNumericOutliers.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = NumericOutliersValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = NumericOutliersValidationError{}

// Validate checks the field values on ColumnTimeGrainRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ColumnTimeGrainRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ColumnTimeGrainRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ColumnTimeGrainRequestMultiError, or nil if none found.
func (m *ColumnTimeGrainRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ColumnTimeGrainRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for InstanceId

	// no validation rules for Connector

	// no validation rules for Database

	// no validation rules for DatabaseSchema

	if utf8.RuneCountInString(m.GetTableName()) < 1 {
		err := ColumnTimeGrainRequestValidationError{
			field:  "TableName",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetColumnName()) < 1 {
		err := ColumnTimeGrainRequestValidationError{
			field:  "ColumnName",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Priority

	if len(errors) > 0 {
		return ColumnTimeGrainRequestMultiError(errors)
	}

	return nil
}

// ColumnTimeGrainRequestMultiError is an error wrapping multiple validation
// errors returned by ColumnTimeGrainRequest.ValidateAll() if the designated
// constraints aren't met.
type ColumnTimeGrainRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ColumnTimeGrainRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ColumnTimeGrainRequestMultiError) AllErrors() []error { return m }

// ColumnTimeGrainRequestValidationError is the validation error returned by
// ColumnTimeGrainRequest.Validate if the designated constraints aren't met.
type ColumnTimeGrainRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ColumnTimeGrainRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ColumnTimeGrainRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ColumnTimeGrainRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ColumnTimeGrainRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ColumnTimeGrainRequestValidationError) ErrorName() string {
	return "ColumnTimeGrainRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ColumnTimeGrainRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sColumnTimeGrainRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ColumnTimeGrainRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ColumnTimeGrainRequestValidationError{}

// Validate checks the field values on ColumnTimeGrainResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ColumnTimeGrainResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ColumnTimeGrainResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ColumnTimeGrainResponseMultiError, or nil if none found.
func (m *ColumnTimeGrainResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ColumnTimeGrainResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for TimeGrain

	if len(errors) > 0 {
		return ColumnTimeGrainResponseMultiError(errors)
	}

	return nil
}

// ColumnTimeGrainResponseMultiError is an error wrapping multiple validation
// errors returned by ColumnTimeGrainResponse.ValidateAll() if the designated
// constraints aren't met.
type ColumnTimeGrainResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ColumnTimeGrainResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ColumnTimeGrainResponseMultiError) AllErrors() []error { return m }

// ColumnTimeGrainResponseValidationError is the validation error returned by
// ColumnTimeGrainResponse.Validate if the designated constraints aren't met.
type ColumnTimeGrainResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ColumnTimeGrainResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ColumnTimeGrainResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ColumnTimeGrainResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ColumnTimeGrainResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ColumnTimeGrainResponseValidationError) ErrorName() string {
	return "ColumnTimeGrainResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ColumnTimeGrainResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sColumnTimeGrainResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ColumnTimeGrainResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ColumnTimeGrainResponseValidationError{}

// Validate checks the field values on ColumnNumericHistogramRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ColumnNumericHistogramRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ColumnNumericHistogramRequest with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// ColumnNumericHistogramRequestMultiError, or nil if none found.
func (m *ColumnNumericHistogramRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ColumnNumericHistogramRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for InstanceId

	// no validation rules for Connector

	// no validation rules for Database

	// no validation rules for DatabaseSchema

	if utf8.RuneCountInString(m.GetTableName()) < 1 {
		err := ColumnNumericHistogramRequestValidationError{
			field:  "TableName",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetColumnName()) < 1 {
		err := ColumnNumericHistogramRequestValidationError{
			field:  "ColumnName",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for HistogramMethod

	// no validation rules for Priority

	if len(errors) > 0 {
		return ColumnNumericHistogramRequestMultiError(errors)
	}

	return nil
}

// ColumnNumericHistogramRequestMultiError is an error wrapping multiple
// validation errors returned by ColumnNumericHistogramRequest.ValidateAll()
// if the designated constraints aren't met.
type ColumnNumericHistogramRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ColumnNumericHistogramRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ColumnNumericHistogramRequestMultiError) AllErrors() []error { return m }

// ColumnNumericHistogramRequestValidationError is the validation error
// returned by ColumnNumericHistogramRequest.Validate if the designated
// constraints aren't met.
type ColumnNumericHistogramRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ColumnNumericHistogramRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ColumnNumericHistogramRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ColumnNumericHistogramRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ColumnNumericHistogramRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ColumnNumericHistogramRequestValidationError) ErrorName() string {
	return "ColumnNumericHistogramRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ColumnNumericHistogramRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sColumnNumericHistogramRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ColumnNumericHistogramRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ColumnNumericHistogramRequestValidationError{}

// Validate checks the field values on ColumnNumericHistogramResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ColumnNumericHistogramResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ColumnNumericHistogramResponse with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// ColumnNumericHistogramResponseMultiError, or nil if none found.
func (m *ColumnNumericHistogramResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ColumnNumericHistogramResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetNumericSummary()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ColumnNumericHistogramResponseValidationError{
					field:  "NumericSummary",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ColumnNumericHistogramResponseValidationError{
					field:  "NumericSummary",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetNumericSummary()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ColumnNumericHistogramResponseValidationError{
				field:  "NumericSummary",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ColumnNumericHistogramResponseMultiError(errors)
	}

	return nil
}

// ColumnNumericHistogramResponseMultiError is an error wrapping multiple
// validation errors returned by ColumnNumericHistogramResponse.ValidateAll()
// if the designated constraints aren't met.
type ColumnNumericHistogramResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ColumnNumericHistogramResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ColumnNumericHistogramResponseMultiError) AllErrors() []error { return m }

// ColumnNumericHistogramResponseValidationError is the validation error
// returned by ColumnNumericHistogramResponse.Validate if the designated
// constraints aren't met.
type ColumnNumericHistogramResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ColumnNumericHistogramResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ColumnNumericHistogramResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ColumnNumericHistogramResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ColumnNumericHistogramResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ColumnNumericHistogramResponseValidationError) ErrorName() string {
	return "ColumnNumericHistogramResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ColumnNumericHistogramResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sColumnNumericHistogramResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ColumnNumericHistogramResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ColumnNumericHistogramResponseValidationError{}

// Validate checks the field values on ColumnRugHistogramRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ColumnRugHistogramRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ColumnRugHistogramRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ColumnRugHistogramRequestMultiError, or nil if none found.
func (m *ColumnRugHistogramRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ColumnRugHistogramRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for InstanceId

	// no validation rules for Connector

	// no validation rules for Database

	// no validation rules for DatabaseSchema

	if utf8.RuneCountInString(m.GetTableName()) < 1 {
		err := ColumnRugHistogramRequestValidationError{
			field:  "TableName",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetColumnName()) < 1 {
		err := ColumnRugHistogramRequestValidationError{
			field:  "ColumnName",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Priority

	if len(errors) > 0 {
		return ColumnRugHistogramRequestMultiError(errors)
	}

	return nil
}

// ColumnRugHistogramRequestMultiError is an error wrapping multiple validation
// errors returned by ColumnRugHistogramRequest.ValidateAll() if the
// designated constraints aren't met.
type ColumnRugHistogramRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ColumnRugHistogramRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ColumnRugHistogramRequestMultiError) AllErrors() []error { return m }

// ColumnRugHistogramRequestValidationError is the validation error returned by
// ColumnRugHistogramRequest.Validate if the designated constraints aren't met.
type ColumnRugHistogramRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ColumnRugHistogramRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ColumnRugHistogramRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ColumnRugHistogramRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ColumnRugHistogramRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ColumnRugHistogramRequestValidationError) ErrorName() string {
	return "ColumnRugHistogramRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ColumnRugHistogramRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sColumnRugHistogramRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ColumnRugHistogramRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ColumnRugHistogramRequestValidationError{}

// Validate checks the field values on ColumnRugHistogramResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ColumnRugHistogramResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ColumnRugHistogramResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ColumnRugHistogramResponseMultiError, or nil if none found.
func (m *ColumnRugHistogramResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ColumnRugHistogramResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetNumericSummary()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ColumnRugHistogramResponseValidationError{
					field:  "NumericSummary",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ColumnRugHistogramResponseValidationError{
					field:  "NumericSummary",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetNumericSummary()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ColumnRugHistogramResponseValidationError{
				field:  "NumericSummary",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ColumnRugHistogramResponseMultiError(errors)
	}

	return nil
}

// ColumnRugHistogramResponseMultiError is an error wrapping multiple
// validation errors returned by ColumnRugHistogramResponse.ValidateAll() if
// the designated constraints aren't met.
type ColumnRugHistogramResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ColumnRugHistogramResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ColumnRugHistogramResponseMultiError) AllErrors() []error { return m }

// ColumnRugHistogramResponseValidationError is the validation error returned
// by ColumnRugHistogramResponse.Validate if the designated constraints aren't met.
type ColumnRugHistogramResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ColumnRugHistogramResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ColumnRugHistogramResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ColumnRugHistogramResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ColumnRugHistogramResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ColumnRugHistogramResponseValidationError) ErrorName() string {
	return "ColumnRugHistogramResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ColumnRugHistogramResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sColumnRugHistogramResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ColumnRugHistogramResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ColumnRugHistogramResponseValidationError{}

// Validate checks the field values on ColumnTimeRangeRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ColumnTimeRangeRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ColumnTimeRangeRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ColumnTimeRangeRequestMultiError, or nil if none found.
func (m *ColumnTimeRangeRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ColumnTimeRangeRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for InstanceId

	// no validation rules for Connector

	// no validation rules for Database

	// no validation rules for DatabaseSchema

	if utf8.RuneCountInString(m.GetTableName()) < 1 {
		err := ColumnTimeRangeRequestValidationError{
			field:  "TableName",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetColumnName()) < 1 {
		err := ColumnTimeRangeRequestValidationError{
			field:  "ColumnName",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Priority

	if len(errors) > 0 {
		return ColumnTimeRangeRequestMultiError(errors)
	}

	return nil
}

// ColumnTimeRangeRequestMultiError is an error wrapping multiple validation
// errors returned by ColumnTimeRangeRequest.ValidateAll() if the designated
// constraints aren't met.
type ColumnTimeRangeRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ColumnTimeRangeRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ColumnTimeRangeRequestMultiError) AllErrors() []error { return m }

// ColumnTimeRangeRequestValidationError is the validation error returned by
// ColumnTimeRangeRequest.Validate if the designated constraints aren't met.
type ColumnTimeRangeRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ColumnTimeRangeRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ColumnTimeRangeRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ColumnTimeRangeRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ColumnTimeRangeRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ColumnTimeRangeRequestValidationError) ErrorName() string {
	return "ColumnTimeRangeRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ColumnTimeRangeRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sColumnTimeRangeRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ColumnTimeRangeRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ColumnTimeRangeRequestValidationError{}

// Validate checks the field values on ColumnTimeRangeResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ColumnTimeRangeResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ColumnTimeRangeResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ColumnTimeRangeResponseMultiError, or nil if none found.
func (m *ColumnTimeRangeResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ColumnTimeRangeResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetTimeRangeSummary()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ColumnTimeRangeResponseValidationError{
					field:  "TimeRangeSummary",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ColumnTimeRangeResponseValidationError{
					field:  "TimeRangeSummary",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTimeRangeSummary()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ColumnTimeRangeResponseValidationError{
				field:  "TimeRangeSummary",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ColumnTimeRangeResponseMultiError(errors)
	}

	return nil
}

// ColumnTimeRangeResponseMultiError is an error wrapping multiple validation
// errors returned by ColumnTimeRangeResponse.ValidateAll() if the designated
// constraints aren't met.
type ColumnTimeRangeResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ColumnTimeRangeResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ColumnTimeRangeResponseMultiError) AllErrors() []error { return m }

// ColumnTimeRangeResponseValidationError is the validation error returned by
// ColumnTimeRangeResponse.Validate if the designated constraints aren't met.
type ColumnTimeRangeResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ColumnTimeRangeResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ColumnTimeRangeResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ColumnTimeRangeResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ColumnTimeRangeResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ColumnTimeRangeResponseValidationError) ErrorName() string {
	return "ColumnTimeRangeResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ColumnTimeRangeResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sColumnTimeRangeResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ColumnTimeRangeResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ColumnTimeRangeResponseValidationError{}

// Validate checks the field values on TimeRangeSummary with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *TimeRangeSummary) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TimeRangeSummary with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// TimeRangeSummaryMultiError, or nil if none found.
func (m *TimeRangeSummary) ValidateAll() error {
	return m.validate(true)
}

func (m *TimeRangeSummary) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetMin()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TimeRangeSummaryValidationError{
					field:  "Min",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TimeRangeSummaryValidationError{
					field:  "Min",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetMin()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TimeRangeSummaryValidationError{
				field:  "Min",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetMax()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TimeRangeSummaryValidationError{
					field:  "Max",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TimeRangeSummaryValidationError{
					field:  "Max",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetMax()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TimeRangeSummaryValidationError{
				field:  "Max",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetWatermark()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TimeRangeSummaryValidationError{
					field:  "Watermark",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TimeRangeSummaryValidationError{
					field:  "Watermark",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetWatermark()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TimeRangeSummaryValidationError{
				field:  "Watermark",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return TimeRangeSummaryMultiError(errors)
	}

	return nil
}

// TimeRangeSummaryMultiError is an error wrapping multiple validation errors
// returned by TimeRangeSummary.ValidateAll() if the designated constraints
// aren't met.
type TimeRangeSummaryMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TimeRangeSummaryMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TimeRangeSummaryMultiError) AllErrors() []error { return m }

// TimeRangeSummaryValidationError is the validation error returned by
// TimeRangeSummary.Validate if the designated constraints aren't met.
type TimeRangeSummaryValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TimeRangeSummaryValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TimeRangeSummaryValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TimeRangeSummaryValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TimeRangeSummaryValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TimeRangeSummaryValidationError) ErrorName() string { return "TimeRangeSummaryValidationError" }

// Error satisfies the builtin error interface
func (e TimeRangeSummaryValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTimeRangeSummary.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TimeRangeSummaryValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TimeRangeSummaryValidationError{}

// Validate checks the field values on ColumnCardinalityRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ColumnCardinalityRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ColumnCardinalityRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ColumnCardinalityRequestMultiError, or nil if none found.
func (m *ColumnCardinalityRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ColumnCardinalityRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for InstanceId

	// no validation rules for Connector

	// no validation rules for Database

	// no validation rules for DatabaseSchema

	if utf8.RuneCountInString(m.GetTableName()) < 1 {
		err := ColumnCardinalityRequestValidationError{
			field:  "TableName",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetColumnName()) < 1 {
		err := ColumnCardinalityRequestValidationError{
			field:  "ColumnName",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Priority

	if len(errors) > 0 {
		return ColumnCardinalityRequestMultiError(errors)
	}

	return nil
}

// ColumnCardinalityRequestMultiError is an error wrapping multiple validation
// errors returned by ColumnCardinalityRequest.ValidateAll() if the designated
// constraints aren't met.
type ColumnCardinalityRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ColumnCardinalityRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ColumnCardinalityRequestMultiError) AllErrors() []error { return m }

// ColumnCardinalityRequestValidationError is the validation error returned by
// ColumnCardinalityRequest.Validate if the designated constraints aren't met.
type ColumnCardinalityRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ColumnCardinalityRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ColumnCardinalityRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ColumnCardinalityRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ColumnCardinalityRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ColumnCardinalityRequestValidationError) ErrorName() string {
	return "ColumnCardinalityRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ColumnCardinalityRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sColumnCardinalityRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ColumnCardinalityRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ColumnCardinalityRequestValidationError{}

// Validate checks the field values on ColumnCardinalityResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ColumnCardinalityResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ColumnCardinalityResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ColumnCardinalityResponseMultiError, or nil if none found.
func (m *ColumnCardinalityResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ColumnCardinalityResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetCategoricalSummary()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ColumnCardinalityResponseValidationError{
					field:  "CategoricalSummary",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ColumnCardinalityResponseValidationError{
					field:  "CategoricalSummary",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCategoricalSummary()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ColumnCardinalityResponseValidationError{
				field:  "CategoricalSummary",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ColumnCardinalityResponseMultiError(errors)
	}

	return nil
}

// ColumnCardinalityResponseMultiError is an error wrapping multiple validation
// errors returned by ColumnCardinalityResponse.ValidateAll() if the
// designated constraints aren't met.
type ColumnCardinalityResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ColumnCardinalityResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ColumnCardinalityResponseMultiError) AllErrors() []error { return m }

// ColumnCardinalityResponseValidationError is the validation error returned by
// ColumnCardinalityResponse.Validate if the designated constraints aren't met.
type ColumnCardinalityResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ColumnCardinalityResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ColumnCardinalityResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ColumnCardinalityResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ColumnCardinalityResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ColumnCardinalityResponseValidationError) ErrorName() string {
	return "ColumnCardinalityResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ColumnCardinalityResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sColumnCardinalityResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ColumnCardinalityResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ColumnCardinalityResponseValidationError{}

// Validate checks the field values on ColumnTimeSeriesRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ColumnTimeSeriesRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ColumnTimeSeriesRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ColumnTimeSeriesRequestMultiError, or nil if none found.
func (m *ColumnTimeSeriesRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ColumnTimeSeriesRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for InstanceId

	// no validation rules for Connector

	// no validation rules for Database

	// no validation rules for DatabaseSchema

	if utf8.RuneCountInString(m.GetTableName()) < 1 {
		err := ColumnTimeSeriesRequestValidationError{
			field:  "TableName",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(m.GetMeasures()) < 1 {
		err := ColumnTimeSeriesRequestValidationError{
			field:  "Measures",
			reason: "value must contain at least 1 item(s)",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	for idx, item := range m.GetMeasures() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ColumnTimeSeriesRequestValidationError{
						field:  fmt.Sprintf("Measures[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ColumnTimeSeriesRequestValidationError{
						field:  fmt.Sprintf("Measures[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ColumnTimeSeriesRequestValidationError{
					field:  fmt.Sprintf("Measures[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if utf8.RuneCountInString(m.GetTimestampColumnName()) < 1 {
		err := ColumnTimeSeriesRequestValidationError{
			field:  "TimestampColumnName",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetTimeRange()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ColumnTimeSeriesRequestValidationError{
					field:  "TimeRange",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ColumnTimeSeriesRequestValidationError{
					field:  "TimeRange",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTimeRange()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ColumnTimeSeriesRequestValidationError{
				field:  "TimeRange",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if m.GetPixels() < 0 {
		err := ColumnTimeSeriesRequestValidationError{
			field:  "Pixels",
			reason: "value must be greater than or equal to 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetSampleSize() < 0 {
		err := ColumnTimeSeriesRequestValidationError{
			field:  "SampleSize",
			reason: "value must be greater than or equal to 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Priority

	// no validation rules for TimeZone

	if len(errors) > 0 {
		return ColumnTimeSeriesRequestMultiError(errors)
	}

	return nil
}

// ColumnTimeSeriesRequestMultiError is an error wrapping multiple validation
// errors returned by ColumnTimeSeriesRequest.ValidateAll() if the designated
// constraints aren't met.
type ColumnTimeSeriesRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ColumnTimeSeriesRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ColumnTimeSeriesRequestMultiError) AllErrors() []error { return m }

// ColumnTimeSeriesRequestValidationError is the validation error returned by
// ColumnTimeSeriesRequest.Validate if the designated constraints aren't met.
type ColumnTimeSeriesRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ColumnTimeSeriesRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ColumnTimeSeriesRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ColumnTimeSeriesRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ColumnTimeSeriesRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ColumnTimeSeriesRequestValidationError) ErrorName() string {
	return "ColumnTimeSeriesRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ColumnTimeSeriesRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sColumnTimeSeriesRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ColumnTimeSeriesRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ColumnTimeSeriesRequestValidationError{}

// Validate checks the field values on ColumnTimeSeriesResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ColumnTimeSeriesResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ColumnTimeSeriesResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ColumnTimeSeriesResponseMultiError, or nil if none found.
func (m *ColumnTimeSeriesResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ColumnTimeSeriesResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetRollup()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ColumnTimeSeriesResponseValidationError{
					field:  "Rollup",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ColumnTimeSeriesResponseValidationError{
					field:  "Rollup",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetRollup()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ColumnTimeSeriesResponseValidationError{
				field:  "Rollup",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ColumnTimeSeriesResponseMultiError(errors)
	}

	return nil
}

// ColumnTimeSeriesResponseMultiError is an error wrapping multiple validation
// errors returned by ColumnTimeSeriesResponse.ValidateAll() if the designated
// constraints aren't met.
type ColumnTimeSeriesResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ColumnTimeSeriesResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ColumnTimeSeriesResponseMultiError) AllErrors() []error { return m }

// ColumnTimeSeriesResponseValidationError is the validation error returned by
// ColumnTimeSeriesResponse.Validate if the designated constraints aren't met.
type ColumnTimeSeriesResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ColumnTimeSeriesResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ColumnTimeSeriesResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ColumnTimeSeriesResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ColumnTimeSeriesResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ColumnTimeSeriesResponseValidationError) ErrorName() string {
	return "ColumnTimeSeriesResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ColumnTimeSeriesResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sColumnTimeSeriesResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ColumnTimeSeriesResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ColumnTimeSeriesResponseValidationError{}

// Validate checks the field values on TimeSeriesTimeRange with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *TimeSeriesTimeRange) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TimeSeriesTimeRange with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// TimeSeriesTimeRangeMultiError, or nil if none found.
func (m *TimeSeriesTimeRange) ValidateAll() error {
	return m.validate(true)
}

func (m *TimeSeriesTimeRange) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetStart()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TimeSeriesTimeRangeValidationError{
					field:  "Start",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TimeSeriesTimeRangeValidationError{
					field:  "Start",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetStart()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TimeSeriesTimeRangeValidationError{
				field:  "Start",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetEnd()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TimeSeriesTimeRangeValidationError{
					field:  "End",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TimeSeriesTimeRangeValidationError{
					field:  "End",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetEnd()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TimeSeriesTimeRangeValidationError{
				field:  "End",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if _, ok := TimeGrain_name[int32(m.GetInterval())]; !ok {
		err := TimeSeriesTimeRangeValidationError{
			field:  "Interval",
			reason: "value must be one of the defined enum values",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return TimeSeriesTimeRangeMultiError(errors)
	}

	return nil
}

// TimeSeriesTimeRangeMultiError is an error wrapping multiple validation
// errors returned by TimeSeriesTimeRange.ValidateAll() if the designated
// constraints aren't met.
type TimeSeriesTimeRangeMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TimeSeriesTimeRangeMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TimeSeriesTimeRangeMultiError) AllErrors() []error { return m }

// TimeSeriesTimeRangeValidationError is the validation error returned by
// TimeSeriesTimeRange.Validate if the designated constraints aren't met.
type TimeSeriesTimeRangeValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TimeSeriesTimeRangeValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TimeSeriesTimeRangeValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TimeSeriesTimeRangeValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TimeSeriesTimeRangeValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TimeSeriesTimeRangeValidationError) ErrorName() string {
	return "TimeSeriesTimeRangeValidationError"
}

// Error satisfies the builtin error interface
func (e TimeSeriesTimeRangeValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTimeSeriesTimeRange.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TimeSeriesTimeRangeValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TimeSeriesTimeRangeValidationError{}

// Validate checks the field values on TimeSeriesResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *TimeSeriesResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TimeSeriesResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// TimeSeriesResponseMultiError, or nil if none found.
func (m *TimeSeriesResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *TimeSeriesResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetResults() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, TimeSeriesResponseValidationError{
						field:  fmt.Sprintf("Results[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, TimeSeriesResponseValidationError{
						field:  fmt.Sprintf("Results[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return TimeSeriesResponseValidationError{
					field:  fmt.Sprintf("Results[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetSpark() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, TimeSeriesResponseValidationError{
						field:  fmt.Sprintf("Spark[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, TimeSeriesResponseValidationError{
						field:  fmt.Sprintf("Spark[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return TimeSeriesResponseValidationError{
					field:  fmt.Sprintf("Spark[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for SampleSize

	if len(errors) > 0 {
		return TimeSeriesResponseMultiError(errors)
	}

	return nil
}

// TimeSeriesResponseMultiError is an error wrapping multiple validation errors
// returned by TimeSeriesResponse.ValidateAll() if the designated constraints
// aren't met.
type TimeSeriesResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TimeSeriesResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TimeSeriesResponseMultiError) AllErrors() []error { return m }

// TimeSeriesResponseValidationError is the validation error returned by
// TimeSeriesResponse.Validate if the designated constraints aren't met.
type TimeSeriesResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TimeSeriesResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TimeSeriesResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TimeSeriesResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TimeSeriesResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TimeSeriesResponseValidationError) ErrorName() string {
	return "TimeSeriesResponseValidationError"
}

// Error satisfies the builtin error interface
func (e TimeSeriesResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTimeSeriesResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TimeSeriesResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TimeSeriesResponseValidationError{}

// Validate checks the field values on TimeSeriesValue with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *TimeSeriesValue) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TimeSeriesValue with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// TimeSeriesValueMultiError, or nil if none found.
func (m *TimeSeriesValue) ValidateAll() error {
	return m.validate(true)
}

func (m *TimeSeriesValue) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetTs()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TimeSeriesValueValidationError{
					field:  "Ts",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TimeSeriesValueValidationError{
					field:  "Ts",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTs()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TimeSeriesValueValidationError{
				field:  "Ts",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Bin

	if all {
		switch v := interface{}(m.GetRecords()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TimeSeriesValueValidationError{
					field:  "Records",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TimeSeriesValueValidationError{
					field:  "Records",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetRecords()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TimeSeriesValueValidationError{
				field:  "Records",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return TimeSeriesValueMultiError(errors)
	}

	return nil
}

// TimeSeriesValueMultiError is an error wrapping multiple validation errors
// returned by TimeSeriesValue.ValidateAll() if the designated constraints
// aren't met.
type TimeSeriesValueMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TimeSeriesValueMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TimeSeriesValueMultiError) AllErrors() []error { return m }

// TimeSeriesValueValidationError is the validation error returned by
// TimeSeriesValue.Validate if the designated constraints aren't met.
type TimeSeriesValueValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TimeSeriesValueValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TimeSeriesValueValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TimeSeriesValueValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TimeSeriesValueValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TimeSeriesValueValidationError) ErrorName() string { return "TimeSeriesValueValidationError" }

// Error satisfies the builtin error interface
func (e TimeSeriesValueValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTimeSeriesValue.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TimeSeriesValueValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TimeSeriesValueValidationError{}

// Validate checks the field values on TableCardinalityRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *TableCardinalityRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TableCardinalityRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// TableCardinalityRequestMultiError, or nil if none found.
func (m *TableCardinalityRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *TableCardinalityRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for InstanceId

	// no validation rules for Connector

	// no validation rules for Database

	// no validation rules for DatabaseSchema

	if utf8.RuneCountInString(m.GetTableName()) < 1 {
		err := TableCardinalityRequestValidationError{
			field:  "TableName",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Priority

	if len(errors) > 0 {
		return TableCardinalityRequestMultiError(errors)
	}

	return nil
}

// TableCardinalityRequestMultiError is an error wrapping multiple validation
// errors returned by TableCardinalityRequest.ValidateAll() if the designated
// constraints aren't met.
type TableCardinalityRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TableCardinalityRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TableCardinalityRequestMultiError) AllErrors() []error { return m }

// TableCardinalityRequestValidationError is the validation error returned by
// TableCardinalityRequest.Validate if the designated constraints aren't met.
type TableCardinalityRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TableCardinalityRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TableCardinalityRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TableCardinalityRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TableCardinalityRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TableCardinalityRequestValidationError) ErrorName() string {
	return "TableCardinalityRequestValidationError"
}

// Error satisfies the builtin error interface
func (e TableCardinalityRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTableCardinalityRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TableCardinalityRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TableCardinalityRequestValidationError{}

// Validate checks the field values on TableCardinalityResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *TableCardinalityResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TableCardinalityResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// TableCardinalityResponseMultiError, or nil if none found.
func (m *TableCardinalityResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *TableCardinalityResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Cardinality

	if len(errors) > 0 {
		return TableCardinalityResponseMultiError(errors)
	}

	return nil
}

// TableCardinalityResponseMultiError is an error wrapping multiple validation
// errors returned by TableCardinalityResponse.ValidateAll() if the designated
// constraints aren't met.
type TableCardinalityResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TableCardinalityResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TableCardinalityResponseMultiError) AllErrors() []error { return m }

// TableCardinalityResponseValidationError is the validation error returned by
// TableCardinalityResponse.Validate if the designated constraints aren't met.
type TableCardinalityResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TableCardinalityResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TableCardinalityResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TableCardinalityResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TableCardinalityResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TableCardinalityResponseValidationError) ErrorName() string {
	return "TableCardinalityResponseValidationError"
}

// Error satisfies the builtin error interface
func (e TableCardinalityResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTableCardinalityResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TableCardinalityResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TableCardinalityResponseValidationError{}

// Validate checks the field values on TableColumnsRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *TableColumnsRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TableColumnsRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// TableColumnsRequestMultiError, or nil if none found.
func (m *TableColumnsRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *TableColumnsRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for InstanceId

	// no validation rules for Connector

	// no validation rules for Database

	// no validation rules for DatabaseSchema

	if utf8.RuneCountInString(m.GetTableName()) < 1 {
		err := TableColumnsRequestValidationError{
			field:  "TableName",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Priority

	if len(errors) > 0 {
		return TableColumnsRequestMultiError(errors)
	}

	return nil
}

// TableColumnsRequestMultiError is an error wrapping multiple validation
// errors returned by TableColumnsRequest.ValidateAll() if the designated
// constraints aren't met.
type TableColumnsRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TableColumnsRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TableColumnsRequestMultiError) AllErrors() []error { return m }

// TableColumnsRequestValidationError is the validation error returned by
// TableColumnsRequest.Validate if the designated constraints aren't met.
type TableColumnsRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TableColumnsRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TableColumnsRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TableColumnsRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TableColumnsRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TableColumnsRequestValidationError) ErrorName() string {
	return "TableColumnsRequestValidationError"
}

// Error satisfies the builtin error interface
func (e TableColumnsRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTableColumnsRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TableColumnsRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TableColumnsRequestValidationError{}

// Validate checks the field values on TableColumnsResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *TableColumnsResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TableColumnsResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// TableColumnsResponseMultiError, or nil if none found.
func (m *TableColumnsResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *TableColumnsResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetProfileColumns() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, TableColumnsResponseValidationError{
						field:  fmt.Sprintf("ProfileColumns[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, TableColumnsResponseValidationError{
						field:  fmt.Sprintf("ProfileColumns[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return TableColumnsResponseValidationError{
					field:  fmt.Sprintf("ProfileColumns[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for UnsupportedColumns

	if len(errors) > 0 {
		return TableColumnsResponseMultiError(errors)
	}

	return nil
}

// TableColumnsResponseMultiError is an error wrapping multiple validation
// errors returned by TableColumnsResponse.ValidateAll() if the designated
// constraints aren't met.
type TableColumnsResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TableColumnsResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TableColumnsResponseMultiError) AllErrors() []error { return m }

// TableColumnsResponseValidationError is the validation error returned by
// TableColumnsResponse.Validate if the designated constraints aren't met.
type TableColumnsResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TableColumnsResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TableColumnsResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TableColumnsResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TableColumnsResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TableColumnsResponseValidationError) ErrorName() string {
	return "TableColumnsResponseValidationError"
}

// Error satisfies the builtin error interface
func (e TableColumnsResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTableColumnsResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TableColumnsResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TableColumnsResponseValidationError{}

// Validate checks the field values on ProfileColumn with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ProfileColumn) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ProfileColumn with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ProfileColumnMultiError, or
// nil if none found.
func (m *ProfileColumn) ValidateAll() error {
	return m.validate(true)
}

func (m *ProfileColumn) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Name

	// no validation rules for Type

	// no validation rules for LargestStringLength

	if len(errors) > 0 {
		return ProfileColumnMultiError(errors)
	}

	return nil
}

// ProfileColumnMultiError is an error wrapping multiple validation errors
// returned by ProfileColumn.ValidateAll() if the designated constraints
// aren't met.
type ProfileColumnMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ProfileColumnMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ProfileColumnMultiError) AllErrors() []error { return m }

// ProfileColumnValidationError is the validation error returned by
// ProfileColumn.Validate if the designated constraints aren't met.
type ProfileColumnValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ProfileColumnValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ProfileColumnValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ProfileColumnValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ProfileColumnValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ProfileColumnValidationError) ErrorName() string { return "ProfileColumnValidationError" }

// Error satisfies the builtin error interface
func (e ProfileColumnValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sProfileColumn.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ProfileColumnValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ProfileColumnValidationError{}

// Validate checks the field values on TableRowsRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *TableRowsRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TableRowsRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// TableRowsRequestMultiError, or nil if none found.
func (m *TableRowsRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *TableRowsRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for InstanceId

	// no validation rules for Connector

	// no validation rules for Database

	// no validation rules for DatabaseSchema

	if utf8.RuneCountInString(m.GetTableName()) < 1 {
		err := TableRowsRequestValidationError{
			field:  "TableName",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetLimit() < 0 {
		err := TableRowsRequestValidationError{
			field:  "Limit",
			reason: "value must be greater than or equal to 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Priority

	if len(errors) > 0 {
		return TableRowsRequestMultiError(errors)
	}

	return nil
}

// TableRowsRequestMultiError is an error wrapping multiple validation errors
// returned by TableRowsRequest.ValidateAll() if the designated constraints
// aren't met.
type TableRowsRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TableRowsRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TableRowsRequestMultiError) AllErrors() []error { return m }

// TableRowsRequestValidationError is the validation error returned by
// TableRowsRequest.Validate if the designated constraints aren't met.
type TableRowsRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TableRowsRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TableRowsRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TableRowsRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TableRowsRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TableRowsRequestValidationError) ErrorName() string { return "TableRowsRequestValidationError" }

// Error satisfies the builtin error interface
func (e TableRowsRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTableRowsRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TableRowsRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TableRowsRequestValidationError{}

// Validate checks the field values on TableRowsResponse with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *TableRowsResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TableRowsResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// TableRowsResponseMultiError, or nil if none found.
func (m *TableRowsResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *TableRowsResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetData() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, TableRowsResponseValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, TableRowsResponseValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return TableRowsResponseValidationError{
					field:  fmt.Sprintf("Data[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return TableRowsResponseMultiError(errors)
	}

	return nil
}

// TableRowsResponseMultiError is an error wrapping multiple validation errors
// returned by TableRowsResponse.ValidateAll() if the designated constraints
// aren't met.
type TableRowsResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TableRowsResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TableRowsResponseMultiError) AllErrors() []error { return m }

// TableRowsResponseValidationError is the validation error returned by
// TableRowsResponse.Validate if the designated constraints aren't met.
type TableRowsResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TableRowsResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TableRowsResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TableRowsResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TableRowsResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TableRowsResponseValidationError) ErrorName() string {
	return "TableRowsResponseValidationError"
}

// Error satisfies the builtin error interface
func (e TableRowsResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTableRowsResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TableRowsResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TableRowsResponseValidationError{}

// Validate checks the field values on MetricsViewFilter_Cond with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *MetricsViewFilter_Cond) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on MetricsViewFilter_Cond with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// MetricsViewFilter_CondMultiError, or nil if none found.
func (m *MetricsViewFilter_Cond) ValidateAll() error {
	return m.validate(true)
}

func (m *MetricsViewFilter_Cond) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Name

	for idx, item := range m.GetIn() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, MetricsViewFilter_CondValidationError{
						field:  fmt.Sprintf("In[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, MetricsViewFilter_CondValidationError{
						field:  fmt.Sprintf("In[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return MetricsViewFilter_CondValidationError{
					field:  fmt.Sprintf("In[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return MetricsViewFilter_CondMultiError(errors)
	}

	return nil
}

// MetricsViewFilter_CondMultiError is an error wrapping multiple validation
// errors returned by MetricsViewFilter_Cond.ValidateAll() if the designated
// constraints aren't met.
type MetricsViewFilter_CondMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MetricsViewFilter_CondMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MetricsViewFilter_CondMultiError) AllErrors() []error { return m }

// MetricsViewFilter_CondValidationError is the validation error returned by
// MetricsViewFilter_Cond.Validate if the designated constraints aren't met.
type MetricsViewFilter_CondValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MetricsViewFilter_CondValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MetricsViewFilter_CondValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MetricsViewFilter_CondValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MetricsViewFilter_CondValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MetricsViewFilter_CondValidationError) ErrorName() string {
	return "MetricsViewFilter_CondValidationError"
}

// Error satisfies the builtin error interface
func (e MetricsViewFilter_CondValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMetricsViewFilter_Cond.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MetricsViewFilter_CondValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MetricsViewFilter_CondValidationError{}

// Validate checks the field values on MetricsViewSearchResponse_SearchResult
// with the rules defined in the proto definition for this message. If any
// rules are violated, the first error encountered is returned, or nil if
// there are no violations.
func (m *MetricsViewSearchResponse_SearchResult) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on
// MetricsViewSearchResponse_SearchResult with the rules defined in the proto
// definition for this message. If any rules are violated, the result is a
// list of violation errors wrapped in
// MetricsViewSearchResponse_SearchResultMultiError, or nil if none found.
func (m *MetricsViewSearchResponse_SearchResult) ValidateAll() error {
	return m.validate(true)
}

func (m *MetricsViewSearchResponse_SearchResult) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Dimension

	if all {
		switch v := interface{}(m.GetValue()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, MetricsViewSearchResponse_SearchResultValidationError{
					field:  "Value",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, MetricsViewSearchResponse_SearchResultValidationError{
					field:  "Value",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetValue()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return MetricsViewSearchResponse_SearchResultValidationError{
				field:  "Value",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return MetricsViewSearchResponse_SearchResultMultiError(errors)
	}

	return nil
}

// MetricsViewSearchResponse_SearchResultMultiError is an error wrapping
// multiple validation errors returned by
// MetricsViewSearchResponse_SearchResult.ValidateAll() if the designated
// constraints aren't met.
type MetricsViewSearchResponse_SearchResultMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MetricsViewSearchResponse_SearchResultMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MetricsViewSearchResponse_SearchResultMultiError) AllErrors() []error { return m }

// MetricsViewSearchResponse_SearchResultValidationError is the validation
// error returned by MetricsViewSearchResponse_SearchResult.Validate if the
// designated constraints aren't met.
type MetricsViewSearchResponse_SearchResultValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MetricsViewSearchResponse_SearchResultValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MetricsViewSearchResponse_SearchResultValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MetricsViewSearchResponse_SearchResultValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MetricsViewSearchResponse_SearchResultValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MetricsViewSearchResponse_SearchResultValidationError) ErrorName() string {
	return "MetricsViewSearchResponse_SearchResultValidationError"
}

// Error satisfies the builtin error interface
func (e MetricsViewSearchResponse_SearchResultValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMetricsViewSearchResponse_SearchResult.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MetricsViewSearchResponse_SearchResultValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MetricsViewSearchResponse_SearchResultValidationError{}

// Validate checks the field values on TopK_Entry with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *TopK_Entry) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TopK_Entry with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in TopK_EntryMultiError, or
// nil if none found.
func (m *TopK_Entry) ValidateAll() error {
	return m.validate(true)
}

func (m *TopK_Entry) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetValue()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TopK_EntryValidationError{
					field:  "Value",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TopK_EntryValidationError{
					field:  "Value",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetValue()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TopK_EntryValidationError{
				field:  "Value",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Count

	if len(errors) > 0 {
		return TopK_EntryMultiError(errors)
	}

	return nil
}

// TopK_EntryMultiError is an error wrapping multiple validation errors
// returned by TopK_Entry.ValidateAll() if the designated constraints aren't met.
type TopK_EntryMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TopK_EntryMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TopK_EntryMultiError) AllErrors() []error { return m }

// TopK_EntryValidationError is the validation error returned by
// TopK_Entry.Validate if the designated constraints aren't met.
type TopK_EntryValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TopK_EntryValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TopK_EntryValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TopK_EntryValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TopK_EntryValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TopK_EntryValidationError) ErrorName() string { return "TopK_EntryValidationError" }

// Error satisfies the builtin error interface
func (e TopK_EntryValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTopK_Entry.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TopK_EntryValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TopK_EntryValidationError{}

// Validate checks the field values on NumericHistogramBins_Bin with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *NumericHistogramBins_Bin) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on NumericHistogramBins_Bin with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// NumericHistogramBins_BinMultiError, or nil if none found.
func (m *NumericHistogramBins_Bin) ValidateAll() error {
	return m.validate(true)
}

func (m *NumericHistogramBins_Bin) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Bucket

	// no validation rules for Low

	// no validation rules for Midpoint

	// no validation rules for High

	// no validation rules for Count

	if len(errors) > 0 {
		return NumericHistogramBins_BinMultiError(errors)
	}

	return nil
}

// NumericHistogramBins_BinMultiError is an error wrapping multiple validation
// errors returned by NumericHistogramBins_Bin.ValidateAll() if the designated
// constraints aren't met.
type NumericHistogramBins_BinMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m NumericHistogramBins_BinMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m NumericHistogramBins_BinMultiError) AllErrors() []error { return m }

// NumericHistogramBins_BinValidationError is the validation error returned by
// NumericHistogramBins_Bin.Validate if the designated constraints aren't met.
type NumericHistogramBins_BinValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e NumericHistogramBins_BinValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e NumericHistogramBins_BinValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e NumericHistogramBins_BinValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e NumericHistogramBins_BinValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e NumericHistogramBins_BinValidationError) ErrorName() string {
	return "NumericHistogramBins_BinValidationError"
}

// Error satisfies the builtin error interface
func (e NumericHistogramBins_BinValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sNumericHistogramBins_Bin.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = NumericHistogramBins_BinValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = NumericHistogramBins_BinValidationError{}

// Validate checks the field values on NumericOutliers_Outlier with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *NumericOutliers_Outlier) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on NumericOutliers_Outlier with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// NumericOutliers_OutlierMultiError, or nil if none found.
func (m *NumericOutliers_Outlier) ValidateAll() error {
	return m.validate(true)
}

func (m *NumericOutliers_Outlier) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Bucket

	// no validation rules for Low

	// no validation rules for High

	// no validation rules for Present

	// no validation rules for Count

	if len(errors) > 0 {
		return NumericOutliers_OutlierMultiError(errors)
	}

	return nil
}

// NumericOutliers_OutlierMultiError is an error wrapping multiple validation
// errors returned by NumericOutliers_Outlier.ValidateAll() if the designated
// constraints aren't met.
type NumericOutliers_OutlierMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m NumericOutliers_OutlierMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m NumericOutliers_OutlierMultiError) AllErrors() []error { return m }

// NumericOutliers_OutlierValidationError is the validation error returned by
// NumericOutliers_Outlier.Validate if the designated constraints aren't met.
type NumericOutliers_OutlierValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e NumericOutliers_OutlierValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e NumericOutliers_OutlierValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e NumericOutliers_OutlierValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e NumericOutliers_OutlierValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e NumericOutliers_OutlierValidationError) ErrorName() string {
	return "NumericOutliers_OutlierValidationError"
}

// Error satisfies the builtin error interface
func (e NumericOutliers_OutlierValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sNumericOutliers_Outlier.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = NumericOutliers_OutlierValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = NumericOutliers_OutlierValidationError{}

// Validate checks the field values on ColumnTimeSeriesRequest_BasicMeasure
// with the rules defined in the proto definition for this message. If any
// rules are violated, the first error encountered is returned, or nil if
// there are no violations.
func (m *ColumnTimeSeriesRequest_BasicMeasure) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ColumnTimeSeriesRequest_BasicMeasure
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// ColumnTimeSeriesRequest_BasicMeasureMultiError, or nil if none found.
func (m *ColumnTimeSeriesRequest_BasicMeasure) ValidateAll() error {
	return m.validate(true)
}

func (m *ColumnTimeSeriesRequest_BasicMeasure) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	if utf8.RuneCountInString(m.GetExpression()) < 1 {
		err := ColumnTimeSeriesRequest_BasicMeasureValidationError{
			field:  "Expression",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for SqlName

	if len(errors) > 0 {
		return ColumnTimeSeriesRequest_BasicMeasureMultiError(errors)
	}

	return nil
}

// ColumnTimeSeriesRequest_BasicMeasureMultiError is an error wrapping multiple
// validation errors returned by
// ColumnTimeSeriesRequest_BasicMeasure.ValidateAll() if the designated
// constraints aren't met.
type ColumnTimeSeriesRequest_BasicMeasureMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ColumnTimeSeriesRequest_BasicMeasureMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ColumnTimeSeriesRequest_BasicMeasureMultiError) AllErrors() []error { return m }

// ColumnTimeSeriesRequest_BasicMeasureValidationError is the validation error
// returned by ColumnTimeSeriesRequest_BasicMeasure.Validate if the designated
// constraints aren't met.
type ColumnTimeSeriesRequest_BasicMeasureValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ColumnTimeSeriesRequest_BasicMeasureValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ColumnTimeSeriesRequest_BasicMeasureValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ColumnTimeSeriesRequest_BasicMeasureValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ColumnTimeSeriesRequest_BasicMeasureValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ColumnTimeSeriesRequest_BasicMeasureValidationError) ErrorName() string {
	return "ColumnTimeSeriesRequest_BasicMeasureValidationError"
}

// Error satisfies the builtin error interface
func (e ColumnTimeSeriesRequest_BasicMeasureValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sColumnTimeSeriesRequest_BasicMeasure.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ColumnTimeSeriesRequest_BasicMeasureValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ColumnTimeSeriesRequest_BasicMeasureValidationError{}

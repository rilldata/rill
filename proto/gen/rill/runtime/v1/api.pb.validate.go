// Code generated by protoc-gen-validate. DO NOT EDIT.
// source: rill/runtime/v1/api.proto

package runtimev1

import (
	"bytes"
	"errors"
	"fmt"
	"net"
	"net/mail"
	"net/url"
	"regexp"
	"sort"
	"strings"
	"time"
	"unicode/utf8"

	"google.golang.org/protobuf/types/known/anypb"
)

// ensure the imports are used
var (
	_ = bytes.MinRead
	_ = errors.New("")
	_ = fmt.Print
	_ = utf8.UTFMax
	_ = (*regexp.Regexp)(nil)
	_ = (*strings.Reader)(nil)
	_ = net.IPv4len
	_ = time.Duration(0)
	_ = (*url.URL)(nil)
	_ = (*mail.Address)(nil)
	_ = anypb.Any{}
	_ = sort.Sort
)

// Validate checks the field values on PingRequest with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *PingRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PingRequest with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in PingRequestMultiError, or
// nil if none found.
func (m *PingRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *PingRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return PingRequestMultiError(errors)
	}

	return nil
}

// PingRequestMultiError is an error wrapping multiple validation errors
// returned by PingRequest.ValidateAll() if the designated constraints aren't met.
type PingRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PingRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PingRequestMultiError) AllErrors() []error { return m }

// PingRequestValidationError is the validation error returned by
// PingRequest.Validate if the designated constraints aren't met.
type PingRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PingRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PingRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PingRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PingRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PingRequestValidationError) ErrorName() string { return "PingRequestValidationError" }

// Error satisfies the builtin error interface
func (e PingRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPingRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PingRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PingRequestValidationError{}

// Validate checks the field values on PingResponse with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *PingResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PingResponse with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in PingResponseMultiError, or
// nil if none found.
func (m *PingResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *PingResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Version

	if all {
		switch v := interface{}(m.GetTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, PingResponseValidationError{
					field:  "Time",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, PingResponseValidationError{
					field:  "Time",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return PingResponseValidationError{
				field:  "Time",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return PingResponseMultiError(errors)
	}

	return nil
}

// PingResponseMultiError is an error wrapping multiple validation errors
// returned by PingResponse.ValidateAll() if the designated constraints aren't met.
type PingResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PingResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PingResponseMultiError) AllErrors() []error { return m }

// PingResponseValidationError is the validation error returned by
// PingResponse.Validate if the designated constraints aren't met.
type PingResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PingResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PingResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PingResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PingResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PingResponseValidationError) ErrorName() string { return "PingResponseValidationError" }

// Error satisfies the builtin error interface
func (e PingResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPingResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PingResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PingResponseValidationError{}

// Validate checks the field values on HealthRequest with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *HealthRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on HealthRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in HealthRequestMultiError, or
// nil if none found.
func (m *HealthRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *HealthRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return HealthRequestMultiError(errors)
	}

	return nil
}

// HealthRequestMultiError is an error wrapping multiple validation errors
// returned by HealthRequest.ValidateAll() if the designated constraints
// aren't met.
type HealthRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m HealthRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m HealthRequestMultiError) AllErrors() []error { return m }

// HealthRequestValidationError is the validation error returned by
// HealthRequest.Validate if the designated constraints aren't met.
type HealthRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e HealthRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e HealthRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e HealthRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e HealthRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e HealthRequestValidationError) ErrorName() string { return "HealthRequestValidationError" }

// Error satisfies the builtin error interface
func (e HealthRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sHealthRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = HealthRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = HealthRequestValidationError{}

// Validate checks the field values on HealthResponse with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *HealthResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on HealthResponse with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in HealthResponseMultiError,
// or nil if none found.
func (m *HealthResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *HealthResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for LimiterError

	// no validation rules for ConnCacheError

	// no validation rules for MetastoreError

	// no validation rules for NetworkError

	{
		sorted_keys := make([]string, len(m.GetInstancesHealth()))
		i := 0
		for key := range m.GetInstancesHealth() {
			sorted_keys[i] = key
			i++
		}
		sort.Slice(sorted_keys, func(i, j int) bool { return sorted_keys[i] < sorted_keys[j] })
		for _, key := range sorted_keys {
			val := m.GetInstancesHealth()[key]
			_ = val

			// no validation rules for InstancesHealth[key]

			if all {
				switch v := interface{}(val).(type) {
				case interface{ ValidateAll() error }:
					if err := v.ValidateAll(); err != nil {
						errors = append(errors, HealthResponseValidationError{
							field:  fmt.Sprintf("InstancesHealth[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				case interface{ Validate() error }:
					if err := v.Validate(); err != nil {
						errors = append(errors, HealthResponseValidationError{
							field:  fmt.Sprintf("InstancesHealth[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				}
			} else if v, ok := interface{}(val).(interface{ Validate() error }); ok {
				if err := v.Validate(); err != nil {
					return HealthResponseValidationError{
						field:  fmt.Sprintf("InstancesHealth[%v]", key),
						reason: "embedded message failed validation",
						cause:  err,
					}
				}
			}

		}
	}

	if len(errors) > 0 {
		return HealthResponseMultiError(errors)
	}

	return nil
}

// HealthResponseMultiError is an error wrapping multiple validation errors
// returned by HealthResponse.ValidateAll() if the designated constraints
// aren't met.
type HealthResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m HealthResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m HealthResponseMultiError) AllErrors() []error { return m }

// HealthResponseValidationError is the validation error returned by
// HealthResponse.Validate if the designated constraints aren't met.
type HealthResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e HealthResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e HealthResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e HealthResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e HealthResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e HealthResponseValidationError) ErrorName() string { return "HealthResponseValidationError" }

// Error satisfies the builtin error interface
func (e HealthResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sHealthResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = HealthResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = HealthResponseValidationError{}

// Validate checks the field values on InstanceHealthRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *InstanceHealthRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on InstanceHealthRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// InstanceHealthRequestMultiError, or nil if none found.
func (m *InstanceHealthRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *InstanceHealthRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if !_InstanceHealthRequest_InstanceId_Pattern.MatchString(m.GetInstanceId()) {
		err := InstanceHealthRequestValidationError{
			field:  "InstanceId",
			reason: "value does not match regex pattern \"^[_\\\\-a-zA-Z0-9]+$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return InstanceHealthRequestMultiError(errors)
	}

	return nil
}

// InstanceHealthRequestMultiError is an error wrapping multiple validation
// errors returned by InstanceHealthRequest.ValidateAll() if the designated
// constraints aren't met.
type InstanceHealthRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m InstanceHealthRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m InstanceHealthRequestMultiError) AllErrors() []error { return m }

// InstanceHealthRequestValidationError is the validation error returned by
// InstanceHealthRequest.Validate if the designated constraints aren't met.
type InstanceHealthRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e InstanceHealthRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e InstanceHealthRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e InstanceHealthRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e InstanceHealthRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e InstanceHealthRequestValidationError) ErrorName() string {
	return "InstanceHealthRequestValidationError"
}

// Error satisfies the builtin error interface
func (e InstanceHealthRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sInstanceHealthRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = InstanceHealthRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = InstanceHealthRequestValidationError{}

var _InstanceHealthRequest_InstanceId_Pattern = regexp.MustCompile("^[_\\-a-zA-Z0-9]+$")

// Validate checks the field values on InstanceHealthResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *InstanceHealthResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on InstanceHealthResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// InstanceHealthResponseMultiError, or nil if none found.
func (m *InstanceHealthResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *InstanceHealthResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetInstanceHealth()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, InstanceHealthResponseValidationError{
					field:  "InstanceHealth",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, InstanceHealthResponseValidationError{
					field:  "InstanceHealth",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetInstanceHealth()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return InstanceHealthResponseValidationError{
				field:  "InstanceHealth",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return InstanceHealthResponseMultiError(errors)
	}

	return nil
}

// InstanceHealthResponseMultiError is an error wrapping multiple validation
// errors returned by InstanceHealthResponse.ValidateAll() if the designated
// constraints aren't met.
type InstanceHealthResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m InstanceHealthResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m InstanceHealthResponseMultiError) AllErrors() []error { return m }

// InstanceHealthResponseValidationError is the validation error returned by
// InstanceHealthResponse.Validate if the designated constraints aren't met.
type InstanceHealthResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e InstanceHealthResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e InstanceHealthResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e InstanceHealthResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e InstanceHealthResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e InstanceHealthResponseValidationError) ErrorName() string {
	return "InstanceHealthResponseValidationError"
}

// Error satisfies the builtin error interface
func (e InstanceHealthResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sInstanceHealthResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = InstanceHealthResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = InstanceHealthResponseValidationError{}

// Validate checks the field values on InstanceHealth with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *InstanceHealth) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on InstanceHealth with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in InstanceHealthMultiError,
// or nil if none found.
func (m *InstanceHealth) ValidateAll() error {
	return m.validate(true)
}

func (m *InstanceHealth) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ControllerError

	// no validation rules for OlapError

	// no validation rules for RepoError

	// no validation rules for MetricsViewErrors

	// no validation rules for ParseErrorCount

	// no validation rules for ReconcileErrorCount

	if len(errors) > 0 {
		return InstanceHealthMultiError(errors)
	}

	return nil
}

// InstanceHealthMultiError is an error wrapping multiple validation errors
// returned by InstanceHealth.ValidateAll() if the designated constraints
// aren't met.
type InstanceHealthMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m InstanceHealthMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m InstanceHealthMultiError) AllErrors() []error { return m }

// InstanceHealthValidationError is the validation error returned by
// InstanceHealth.Validate if the designated constraints aren't met.
type InstanceHealthValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e InstanceHealthValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e InstanceHealthValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e InstanceHealthValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e InstanceHealthValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e InstanceHealthValidationError) ErrorName() string { return "InstanceHealthValidationError" }

// Error satisfies the builtin error interface
func (e InstanceHealthValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sInstanceHealth.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = InstanceHealthValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = InstanceHealthValidationError{}

// Validate checks the field values on Instance with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Instance) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Instance with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in InstanceMultiError, or nil
// if none found.
func (m *Instance) ValidateAll() error {
	return m.validate(true)
}

func (m *Instance) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if !_Instance_InstanceId_Pattern.MatchString(m.GetInstanceId()) {
		err := InstanceValidationError{
			field:  "InstanceId",
			reason: "value does not match regex pattern \"^[_\\\\-a-zA-Z0-9]+$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Environment

	// no validation rules for OlapConnector

	// no validation rules for RepoConnector

	// no validation rules for AdminConnector

	// no validation rules for AiConnector

	if all {
		switch v := interface{}(m.GetCreatedOn()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, InstanceValidationError{
					field:  "CreatedOn",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, InstanceValidationError{
					field:  "CreatedOn",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCreatedOn()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return InstanceValidationError{
				field:  "CreatedOn",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetUpdatedOn()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, InstanceValidationError{
					field:  "UpdatedOn",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, InstanceValidationError{
					field:  "UpdatedOn",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetUpdatedOn()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return InstanceValidationError{
				field:  "UpdatedOn",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetConnectors() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, InstanceValidationError{
						field:  fmt.Sprintf("Connectors[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, InstanceValidationError{
						field:  fmt.Sprintf("Connectors[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return InstanceValidationError{
					field:  fmt.Sprintf("Connectors[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetProjectConnectors() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, InstanceValidationError{
						field:  fmt.Sprintf("ProjectConnectors[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, InstanceValidationError{
						field:  fmt.Sprintf("ProjectConnectors[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return InstanceValidationError{
					field:  fmt.Sprintf("ProjectConnectors[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for Variables

	// no validation rules for ProjectVariables

	// no validation rules for FeatureFlags

	// no validation rules for Annotations

	// no validation rules for EmbedCatalog

	// no validation rules for WatchRepo

	if len(errors) > 0 {
		return InstanceMultiError(errors)
	}

	return nil
}

// InstanceMultiError is an error wrapping multiple validation errors returned
// by Instance.ValidateAll() if the designated constraints aren't met.
type InstanceMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m InstanceMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m InstanceMultiError) AllErrors() []error { return m }

// InstanceValidationError is the validation error returned by
// Instance.Validate if the designated constraints aren't met.
type InstanceValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e InstanceValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e InstanceValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e InstanceValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e InstanceValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e InstanceValidationError) ErrorName() string { return "InstanceValidationError" }

// Error satisfies the builtin error interface
func (e InstanceValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sInstance.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = InstanceValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = InstanceValidationError{}

var _Instance_InstanceId_Pattern = regexp.MustCompile("^[_\\-a-zA-Z0-9]+$")

// Validate checks the field values on Connector with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Connector) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Connector with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ConnectorMultiError, or nil
// if none found.
func (m *Connector) ValidateAll() error {
	return m.validate(true)
}

func (m *Connector) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Type

	// no validation rules for Name

	// no validation rules for Config

	// no validation rules for Provision

	if all {
		switch v := interface{}(m.GetProvisionArgs()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ConnectorValidationError{
					field:  "ProvisionArgs",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ConnectorValidationError{
					field:  "ProvisionArgs",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetProvisionArgs()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ConnectorValidationError{
				field:  "ProvisionArgs",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for ConfigFromVariables

	if len(errors) > 0 {
		return ConnectorMultiError(errors)
	}

	return nil
}

// ConnectorMultiError is an error wrapping multiple validation errors returned
// by Connector.ValidateAll() if the designated constraints aren't met.
type ConnectorMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ConnectorMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ConnectorMultiError) AllErrors() []error { return m }

// ConnectorValidationError is the validation error returned by
// Connector.Validate if the designated constraints aren't met.
type ConnectorValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ConnectorValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ConnectorValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ConnectorValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ConnectorValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ConnectorValidationError) ErrorName() string { return "ConnectorValidationError" }

// Error satisfies the builtin error interface
func (e ConnectorValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sConnector.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ConnectorValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ConnectorValidationError{}

// Validate checks the field values on ListInstancesRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListInstancesRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListInstancesRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListInstancesRequestMultiError, or nil if none found.
func (m *ListInstancesRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ListInstancesRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for PageSize

	// no validation rules for PageToken

	if len(errors) > 0 {
		return ListInstancesRequestMultiError(errors)
	}

	return nil
}

// ListInstancesRequestMultiError is an error wrapping multiple validation
// errors returned by ListInstancesRequest.ValidateAll() if the designated
// constraints aren't met.
type ListInstancesRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListInstancesRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListInstancesRequestMultiError) AllErrors() []error { return m }

// ListInstancesRequestValidationError is the validation error returned by
// ListInstancesRequest.Validate if the designated constraints aren't met.
type ListInstancesRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListInstancesRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListInstancesRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListInstancesRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListInstancesRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListInstancesRequestValidationError) ErrorName() string {
	return "ListInstancesRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ListInstancesRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListInstancesRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListInstancesRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListInstancesRequestValidationError{}

// Validate checks the field values on ListInstancesResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListInstancesResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListInstancesResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListInstancesResponseMultiError, or nil if none found.
func (m *ListInstancesResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ListInstancesResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetInstances() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListInstancesResponseValidationError{
						field:  fmt.Sprintf("Instances[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListInstancesResponseValidationError{
						field:  fmt.Sprintf("Instances[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListInstancesResponseValidationError{
					field:  fmt.Sprintf("Instances[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for NextPageToken

	if len(errors) > 0 {
		return ListInstancesResponseMultiError(errors)
	}

	return nil
}

// ListInstancesResponseMultiError is an error wrapping multiple validation
// errors returned by ListInstancesResponse.ValidateAll() if the designated
// constraints aren't met.
type ListInstancesResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListInstancesResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListInstancesResponseMultiError) AllErrors() []error { return m }

// ListInstancesResponseValidationError is the validation error returned by
// ListInstancesResponse.Validate if the designated constraints aren't met.
type ListInstancesResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListInstancesResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListInstancesResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListInstancesResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListInstancesResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListInstancesResponseValidationError) ErrorName() string {
	return "ListInstancesResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ListInstancesResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListInstancesResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListInstancesResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListInstancesResponseValidationError{}

// Validate checks the field values on GetInstanceRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetInstanceRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetInstanceRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetInstanceRequestMultiError, or nil if none found.
func (m *GetInstanceRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetInstanceRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if !_GetInstanceRequest_InstanceId_Pattern.MatchString(m.GetInstanceId()) {
		err := GetInstanceRequestValidationError{
			field:  "InstanceId",
			reason: "value does not match regex pattern \"^[_\\\\-a-zA-Z0-9]+$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Sensitive

	if len(errors) > 0 {
		return GetInstanceRequestMultiError(errors)
	}

	return nil
}

// GetInstanceRequestMultiError is an error wrapping multiple validation errors
// returned by GetInstanceRequest.ValidateAll() if the designated constraints
// aren't met.
type GetInstanceRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetInstanceRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetInstanceRequestMultiError) AllErrors() []error { return m }

// GetInstanceRequestValidationError is the validation error returned by
// GetInstanceRequest.Validate if the designated constraints aren't met.
type GetInstanceRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetInstanceRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetInstanceRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetInstanceRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetInstanceRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetInstanceRequestValidationError) ErrorName() string {
	return "GetInstanceRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetInstanceRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetInstanceRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetInstanceRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetInstanceRequestValidationError{}

var _GetInstanceRequest_InstanceId_Pattern = regexp.MustCompile("^[_\\-a-zA-Z0-9]+$")

// Validate checks the field values on GetInstanceResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetInstanceResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetInstanceResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetInstanceResponseMultiError, or nil if none found.
func (m *GetInstanceResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GetInstanceResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetInstance()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetInstanceResponseValidationError{
					field:  "Instance",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetInstanceResponseValidationError{
					field:  "Instance",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetInstance()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetInstanceResponseValidationError{
				field:  "Instance",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return GetInstanceResponseMultiError(errors)
	}

	return nil
}

// GetInstanceResponseMultiError is an error wrapping multiple validation
// errors returned by GetInstanceResponse.ValidateAll() if the designated
// constraints aren't met.
type GetInstanceResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetInstanceResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetInstanceResponseMultiError) AllErrors() []error { return m }

// GetInstanceResponseValidationError is the validation error returned by
// GetInstanceResponse.Validate if the designated constraints aren't met.
type GetInstanceResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetInstanceResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetInstanceResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetInstanceResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetInstanceResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetInstanceResponseValidationError) ErrorName() string {
	return "GetInstanceResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GetInstanceResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetInstanceResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetInstanceResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetInstanceResponseValidationError{}

// Validate checks the field values on CreateInstanceRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreateInstanceRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateInstanceRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateInstanceRequestMultiError, or nil if none found.
func (m *CreateInstanceRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateInstanceRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetInstanceId() != "" {

		if !_CreateInstanceRequest_InstanceId_Pattern.MatchString(m.GetInstanceId()) {
			err := CreateInstanceRequestValidationError{
				field:  "InstanceId",
				reason: "value does not match regex pattern \"^[_\\\\-a-zA-Z0-9]+$\"",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	// no validation rules for Environment

	// no validation rules for OlapConnector

	// no validation rules for RepoConnector

	// no validation rules for AdminConnector

	// no validation rules for AiConnector

	for idx, item := range m.GetConnectors() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, CreateInstanceRequestValidationError{
						field:  fmt.Sprintf("Connectors[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, CreateInstanceRequestValidationError{
						field:  fmt.Sprintf("Connectors[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return CreateInstanceRequestValidationError{
					field:  fmt.Sprintf("Connectors[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for Variables

	// no validation rules for Annotations

	// no validation rules for EmbedCatalog

	// no validation rules for WatchRepo

	if len(errors) > 0 {
		return CreateInstanceRequestMultiError(errors)
	}

	return nil
}

// CreateInstanceRequestMultiError is an error wrapping multiple validation
// errors returned by CreateInstanceRequest.ValidateAll() if the designated
// constraints aren't met.
type CreateInstanceRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateInstanceRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateInstanceRequestMultiError) AllErrors() []error { return m }

// CreateInstanceRequestValidationError is the validation error returned by
// CreateInstanceRequest.Validate if the designated constraints aren't met.
type CreateInstanceRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateInstanceRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateInstanceRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateInstanceRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateInstanceRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateInstanceRequestValidationError) ErrorName() string {
	return "CreateInstanceRequestValidationError"
}

// Error satisfies the builtin error interface
func (e CreateInstanceRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateInstanceRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateInstanceRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateInstanceRequestValidationError{}

var _CreateInstanceRequest_InstanceId_Pattern = regexp.MustCompile("^[_\\-a-zA-Z0-9]+$")

// Validate checks the field values on CreateInstanceResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreateInstanceResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateInstanceResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateInstanceResponseMultiError, or nil if none found.
func (m *CreateInstanceResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateInstanceResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetInstance()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreateInstanceResponseValidationError{
					field:  "Instance",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreateInstanceResponseValidationError{
					field:  "Instance",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetInstance()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreateInstanceResponseValidationError{
				field:  "Instance",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CreateInstanceResponseMultiError(errors)
	}

	return nil
}

// CreateInstanceResponseMultiError is an error wrapping multiple validation
// errors returned by CreateInstanceResponse.ValidateAll() if the designated
// constraints aren't met.
type CreateInstanceResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateInstanceResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateInstanceResponseMultiError) AllErrors() []error { return m }

// CreateInstanceResponseValidationError is the validation error returned by
// CreateInstanceResponse.Validate if the designated constraints aren't met.
type CreateInstanceResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateInstanceResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateInstanceResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateInstanceResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateInstanceResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateInstanceResponseValidationError) ErrorName() string {
	return "CreateInstanceResponseValidationError"
}

// Error satisfies the builtin error interface
func (e CreateInstanceResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateInstanceResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateInstanceResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateInstanceResponseValidationError{}

// Validate checks the field values on DeleteInstanceRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DeleteInstanceRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeleteInstanceRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DeleteInstanceRequestMultiError, or nil if none found.
func (m *DeleteInstanceRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteInstanceRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if !_DeleteInstanceRequest_InstanceId_Pattern.MatchString(m.GetInstanceId()) {
		err := DeleteInstanceRequestValidationError{
			field:  "InstanceId",
			reason: "value does not match regex pattern \"^[_\\\\-a-zA-Z0-9]+$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return DeleteInstanceRequestMultiError(errors)
	}

	return nil
}

// DeleteInstanceRequestMultiError is an error wrapping multiple validation
// errors returned by DeleteInstanceRequest.ValidateAll() if the designated
// constraints aren't met.
type DeleteInstanceRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteInstanceRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteInstanceRequestMultiError) AllErrors() []error { return m }

// DeleteInstanceRequestValidationError is the validation error returned by
// DeleteInstanceRequest.Validate if the designated constraints aren't met.
type DeleteInstanceRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteInstanceRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteInstanceRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteInstanceRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteInstanceRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteInstanceRequestValidationError) ErrorName() string {
	return "DeleteInstanceRequestValidationError"
}

// Error satisfies the builtin error interface
func (e DeleteInstanceRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteInstanceRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteInstanceRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteInstanceRequestValidationError{}

var _DeleteInstanceRequest_InstanceId_Pattern = regexp.MustCompile("^[_\\-a-zA-Z0-9]+$")

// Validate checks the field values on DeleteInstanceResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DeleteInstanceResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeleteInstanceResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DeleteInstanceResponseMultiError, or nil if none found.
func (m *DeleteInstanceResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteInstanceResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return DeleteInstanceResponseMultiError(errors)
	}

	return nil
}

// DeleteInstanceResponseMultiError is an error wrapping multiple validation
// errors returned by DeleteInstanceResponse.ValidateAll() if the designated
// constraints aren't met.
type DeleteInstanceResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteInstanceResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteInstanceResponseMultiError) AllErrors() []error { return m }

// DeleteInstanceResponseValidationError is the validation error returned by
// DeleteInstanceResponse.Validate if the designated constraints aren't met.
type DeleteInstanceResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteInstanceResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteInstanceResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteInstanceResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteInstanceResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteInstanceResponseValidationError) ErrorName() string {
	return "DeleteInstanceResponseValidationError"
}

// Error satisfies the builtin error interface
func (e DeleteInstanceResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteInstanceResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteInstanceResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteInstanceResponseValidationError{}

// Validate checks the field values on EditInstanceRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *EditInstanceRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on EditInstanceRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// EditInstanceRequestMultiError, or nil if none found.
func (m *EditInstanceRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *EditInstanceRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if !_EditInstanceRequest_InstanceId_Pattern.MatchString(m.GetInstanceId()) {
		err := EditInstanceRequestValidationError{
			field:  "InstanceId",
			reason: "value does not match regex pattern \"^[_\\\\-a-zA-Z0-9]+$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	for idx, item := range m.GetConnectors() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, EditInstanceRequestValidationError{
						field:  fmt.Sprintf("Connectors[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, EditInstanceRequestValidationError{
						field:  fmt.Sprintf("Connectors[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return EditInstanceRequestValidationError{
					field:  fmt.Sprintf("Connectors[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for Variables

	// no validation rules for Annotations

	if m.Environment != nil {
		// no validation rules for Environment
	}

	if m.OlapConnector != nil {
		// no validation rules for OlapConnector
	}

	if m.RepoConnector != nil {
		// no validation rules for RepoConnector
	}

	if m.AdminConnector != nil {
		// no validation rules for AdminConnector
	}

	if m.AiConnector != nil {
		// no validation rules for AiConnector
	}

	if m.EmbedCatalog != nil {
		// no validation rules for EmbedCatalog
	}

	if m.WatchRepo != nil {
		// no validation rules for WatchRepo
	}

	if len(errors) > 0 {
		return EditInstanceRequestMultiError(errors)
	}

	return nil
}

// EditInstanceRequestMultiError is an error wrapping multiple validation
// errors returned by EditInstanceRequest.ValidateAll() if the designated
// constraints aren't met.
type EditInstanceRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m EditInstanceRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m EditInstanceRequestMultiError) AllErrors() []error { return m }

// EditInstanceRequestValidationError is the validation error returned by
// EditInstanceRequest.Validate if the designated constraints aren't met.
type EditInstanceRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e EditInstanceRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e EditInstanceRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e EditInstanceRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e EditInstanceRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e EditInstanceRequestValidationError) ErrorName() string {
	return "EditInstanceRequestValidationError"
}

// Error satisfies the builtin error interface
func (e EditInstanceRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sEditInstanceRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = EditInstanceRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = EditInstanceRequestValidationError{}

var _EditInstanceRequest_InstanceId_Pattern = regexp.MustCompile("^[_\\-a-zA-Z0-9]+$")

// Validate checks the field values on EditInstanceResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *EditInstanceResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on EditInstanceResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// EditInstanceResponseMultiError, or nil if none found.
func (m *EditInstanceResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *EditInstanceResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetInstance()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, EditInstanceResponseValidationError{
					field:  "Instance",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, EditInstanceResponseValidationError{
					field:  "Instance",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetInstance()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return EditInstanceResponseValidationError{
				field:  "Instance",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return EditInstanceResponseMultiError(errors)
	}

	return nil
}

// EditInstanceResponseMultiError is an error wrapping multiple validation
// errors returned by EditInstanceResponse.ValidateAll() if the designated
// constraints aren't met.
type EditInstanceResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m EditInstanceResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m EditInstanceResponseMultiError) AllErrors() []error { return m }

// EditInstanceResponseValidationError is the validation error returned by
// EditInstanceResponse.Validate if the designated constraints aren't met.
type EditInstanceResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e EditInstanceResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e EditInstanceResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e EditInstanceResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e EditInstanceResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e EditInstanceResponseValidationError) ErrorName() string {
	return "EditInstanceResponseValidationError"
}

// Error satisfies the builtin error interface
func (e EditInstanceResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sEditInstanceResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = EditInstanceResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = EditInstanceResponseValidationError{}

// Validate checks the field values on ListFilesRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *ListFilesRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListFilesRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListFilesRequestMultiError, or nil if none found.
func (m *ListFilesRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ListFilesRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if !_ListFilesRequest_InstanceId_Pattern.MatchString(m.GetInstanceId()) {
		err := ListFilesRequestValidationError{
			field:  "InstanceId",
			reason: "value does not match regex pattern \"^[_\\\\-a-zA-Z0-9]+$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Glob

	if len(errors) > 0 {
		return ListFilesRequestMultiError(errors)
	}

	return nil
}

// ListFilesRequestMultiError is an error wrapping multiple validation errors
// returned by ListFilesRequest.ValidateAll() if the designated constraints
// aren't met.
type ListFilesRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListFilesRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListFilesRequestMultiError) AllErrors() []error { return m }

// ListFilesRequestValidationError is the validation error returned by
// ListFilesRequest.Validate if the designated constraints aren't met.
type ListFilesRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListFilesRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListFilesRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListFilesRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListFilesRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListFilesRequestValidationError) ErrorName() string { return "ListFilesRequestValidationError" }

// Error satisfies the builtin error interface
func (e ListFilesRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListFilesRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListFilesRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListFilesRequestValidationError{}

var _ListFilesRequest_InstanceId_Pattern = regexp.MustCompile("^[_\\-a-zA-Z0-9]+$")

// Validate checks the field values on ListFilesResponse with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *ListFilesResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListFilesResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListFilesResponseMultiError, or nil if none found.
func (m *ListFilesResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ListFilesResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetFiles() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListFilesResponseValidationError{
						field:  fmt.Sprintf("Files[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListFilesResponseValidationError{
						field:  fmt.Sprintf("Files[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListFilesResponseValidationError{
					field:  fmt.Sprintf("Files[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ListFilesResponseMultiError(errors)
	}

	return nil
}

// ListFilesResponseMultiError is an error wrapping multiple validation errors
// returned by ListFilesResponse.ValidateAll() if the designated constraints
// aren't met.
type ListFilesResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListFilesResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListFilesResponseMultiError) AllErrors() []error { return m }

// ListFilesResponseValidationError is the validation error returned by
// ListFilesResponse.Validate if the designated constraints aren't met.
type ListFilesResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListFilesResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListFilesResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListFilesResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListFilesResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListFilesResponseValidationError) ErrorName() string {
	return "ListFilesResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ListFilesResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListFilesResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListFilesResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListFilesResponseValidationError{}

// Validate checks the field values on DirEntry with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *DirEntry) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DirEntry with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in DirEntryMultiError, or nil
// if none found.
func (m *DirEntry) ValidateAll() error {
	return m.validate(true)
}

func (m *DirEntry) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Path

	// no validation rules for IsDir

	if len(errors) > 0 {
		return DirEntryMultiError(errors)
	}

	return nil
}

// DirEntryMultiError is an error wrapping multiple validation errors returned
// by DirEntry.ValidateAll() if the designated constraints aren't met.
type DirEntryMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DirEntryMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DirEntryMultiError) AllErrors() []error { return m }

// DirEntryValidationError is the validation error returned by
// DirEntry.Validate if the designated constraints aren't met.
type DirEntryValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DirEntryValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DirEntryValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DirEntryValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DirEntryValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DirEntryValidationError) ErrorName() string { return "DirEntryValidationError" }

// Error satisfies the builtin error interface
func (e DirEntryValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDirEntry.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DirEntryValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DirEntryValidationError{}

// Validate checks the field values on WatchFilesRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *WatchFilesRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on WatchFilesRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// WatchFilesRequestMultiError, or nil if none found.
func (m *WatchFilesRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *WatchFilesRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if !_WatchFilesRequest_InstanceId_Pattern.MatchString(m.GetInstanceId()) {
		err := WatchFilesRequestValidationError{
			field:  "InstanceId",
			reason: "value does not match regex pattern \"^[_\\\\-a-zA-Z0-9]+$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Replay

	if len(errors) > 0 {
		return WatchFilesRequestMultiError(errors)
	}

	return nil
}

// WatchFilesRequestMultiError is an error wrapping multiple validation errors
// returned by WatchFilesRequest.ValidateAll() if the designated constraints
// aren't met.
type WatchFilesRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m WatchFilesRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m WatchFilesRequestMultiError) AllErrors() []error { return m }

// WatchFilesRequestValidationError is the validation error returned by
// WatchFilesRequest.Validate if the designated constraints aren't met.
type WatchFilesRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e WatchFilesRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e WatchFilesRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e WatchFilesRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e WatchFilesRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e WatchFilesRequestValidationError) ErrorName() string {
	return "WatchFilesRequestValidationError"
}

// Error satisfies the builtin error interface
func (e WatchFilesRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sWatchFilesRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = WatchFilesRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = WatchFilesRequestValidationError{}

var _WatchFilesRequest_InstanceId_Pattern = regexp.MustCompile("^[_\\-a-zA-Z0-9]+$")

// Validate checks the field values on WatchFilesResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *WatchFilesResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on WatchFilesResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// WatchFilesResponseMultiError, or nil if none found.
func (m *WatchFilesResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *WatchFilesResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Event

	// no validation rules for Path

	// no validation rules for IsDir

	if len(errors) > 0 {
		return WatchFilesResponseMultiError(errors)
	}

	return nil
}

// WatchFilesResponseMultiError is an error wrapping multiple validation errors
// returned by WatchFilesResponse.ValidateAll() if the designated constraints
// aren't met.
type WatchFilesResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m WatchFilesResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m WatchFilesResponseMultiError) AllErrors() []error { return m }

// WatchFilesResponseValidationError is the validation error returned by
// WatchFilesResponse.Validate if the designated constraints aren't met.
type WatchFilesResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e WatchFilesResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e WatchFilesResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e WatchFilesResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e WatchFilesResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e WatchFilesResponseValidationError) ErrorName() string {
	return "WatchFilesResponseValidationError"
}

// Error satisfies the builtin error interface
func (e WatchFilesResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sWatchFilesResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = WatchFilesResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = WatchFilesResponseValidationError{}

// Validate checks the field values on GetFileRequest with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *GetFileRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetFileRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in GetFileRequestMultiError,
// or nil if none found.
func (m *GetFileRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetFileRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if !_GetFileRequest_InstanceId_Pattern.MatchString(m.GetInstanceId()) {
		err := GetFileRequestValidationError{
			field:  "InstanceId",
			reason: "value does not match regex pattern \"^[_\\\\-a-zA-Z0-9]+$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetPath()) < 1 {
		err := GetFileRequestValidationError{
			field:  "Path",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return GetFileRequestMultiError(errors)
	}

	return nil
}

// GetFileRequestMultiError is an error wrapping multiple validation errors
// returned by GetFileRequest.ValidateAll() if the designated constraints
// aren't met.
type GetFileRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetFileRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetFileRequestMultiError) AllErrors() []error { return m }

// GetFileRequestValidationError is the validation error returned by
// GetFileRequest.Validate if the designated constraints aren't met.
type GetFileRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetFileRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetFileRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetFileRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetFileRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetFileRequestValidationError) ErrorName() string { return "GetFileRequestValidationError" }

// Error satisfies the builtin error interface
func (e GetFileRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetFileRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetFileRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetFileRequestValidationError{}

var _GetFileRequest_InstanceId_Pattern = regexp.MustCompile("^[_\\-a-zA-Z0-9]+$")

// Validate checks the field values on GetFileResponse with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *GetFileResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetFileResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetFileResponseMultiError, or nil if none found.
func (m *GetFileResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GetFileResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Blob

	if all {
		switch v := interface{}(m.GetUpdatedOn()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetFileResponseValidationError{
					field:  "UpdatedOn",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetFileResponseValidationError{
					field:  "UpdatedOn",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetUpdatedOn()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetFileResponseValidationError{
				field:  "UpdatedOn",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return GetFileResponseMultiError(errors)
	}

	return nil
}

// GetFileResponseMultiError is an error wrapping multiple validation errors
// returned by GetFileResponse.ValidateAll() if the designated constraints
// aren't met.
type GetFileResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetFileResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetFileResponseMultiError) AllErrors() []error { return m }

// GetFileResponseValidationError is the validation error returned by
// GetFileResponse.Validate if the designated constraints aren't met.
type GetFileResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetFileResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetFileResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetFileResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetFileResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetFileResponseValidationError) ErrorName() string { return "GetFileResponseValidationError" }

// Error satisfies the builtin error interface
func (e GetFileResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetFileResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetFileResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetFileResponseValidationError{}

// Validate checks the field values on PutFileRequest with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *PutFileRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PutFileRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in PutFileRequestMultiError,
// or nil if none found.
func (m *PutFileRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *PutFileRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if !_PutFileRequest_InstanceId_Pattern.MatchString(m.GetInstanceId()) {
		err := PutFileRequestValidationError{
			field:  "InstanceId",
			reason: "value does not match regex pattern \"^[_\\\\-a-zA-Z0-9]+$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetPath()) < 1 {
		err := PutFileRequestValidationError{
			field:  "Path",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Blob

	// no validation rules for Create

	// no validation rules for CreateOnly

	if len(errors) > 0 {
		return PutFileRequestMultiError(errors)
	}

	return nil
}

// PutFileRequestMultiError is an error wrapping multiple validation errors
// returned by PutFileRequest.ValidateAll() if the designated constraints
// aren't met.
type PutFileRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PutFileRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PutFileRequestMultiError) AllErrors() []error { return m }

// PutFileRequestValidationError is the validation error returned by
// PutFileRequest.Validate if the designated constraints aren't met.
type PutFileRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PutFileRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PutFileRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PutFileRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PutFileRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PutFileRequestValidationError) ErrorName() string { return "PutFileRequestValidationError" }

// Error satisfies the builtin error interface
func (e PutFileRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPutFileRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PutFileRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PutFileRequestValidationError{}

var _PutFileRequest_InstanceId_Pattern = regexp.MustCompile("^[_\\-a-zA-Z0-9]+$")

// Validate checks the field values on PutFileResponse with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *PutFileResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PutFileResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// PutFileResponseMultiError, or nil if none found.
func (m *PutFileResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *PutFileResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for FilePath

	if len(errors) > 0 {
		return PutFileResponseMultiError(errors)
	}

	return nil
}

// PutFileResponseMultiError is an error wrapping multiple validation errors
// returned by PutFileResponse.ValidateAll() if the designated constraints
// aren't met.
type PutFileResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PutFileResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PutFileResponseMultiError) AllErrors() []error { return m }

// PutFileResponseValidationError is the validation error returned by
// PutFileResponse.Validate if the designated constraints aren't met.
type PutFileResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PutFileResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PutFileResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PutFileResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PutFileResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PutFileResponseValidationError) ErrorName() string { return "PutFileResponseValidationError" }

// Error satisfies the builtin error interface
func (e PutFileResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPutFileResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PutFileResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PutFileResponseValidationError{}

// Validate checks the field values on CreateDirectoryRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreateDirectoryRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateDirectoryRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateDirectoryRequestMultiError, or nil if none found.
func (m *CreateDirectoryRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateDirectoryRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if !_CreateDirectoryRequest_InstanceId_Pattern.MatchString(m.GetInstanceId()) {
		err := CreateDirectoryRequestValidationError{
			field:  "InstanceId",
			reason: "value does not match regex pattern \"^[_\\\\-a-zA-Z0-9]+$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetPath()) < 1 {
		err := CreateDirectoryRequestValidationError{
			field:  "Path",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return CreateDirectoryRequestMultiError(errors)
	}

	return nil
}

// CreateDirectoryRequestMultiError is an error wrapping multiple validation
// errors returned by CreateDirectoryRequest.ValidateAll() if the designated
// constraints aren't met.
type CreateDirectoryRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateDirectoryRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateDirectoryRequestMultiError) AllErrors() []error { return m }

// CreateDirectoryRequestValidationError is the validation error returned by
// CreateDirectoryRequest.Validate if the designated constraints aren't met.
type CreateDirectoryRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateDirectoryRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateDirectoryRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateDirectoryRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateDirectoryRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateDirectoryRequestValidationError) ErrorName() string {
	return "CreateDirectoryRequestValidationError"
}

// Error satisfies the builtin error interface
func (e CreateDirectoryRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateDirectoryRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateDirectoryRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateDirectoryRequestValidationError{}

var _CreateDirectoryRequest_InstanceId_Pattern = regexp.MustCompile("^[_\\-a-zA-Z0-9]+$")

// Validate checks the field values on CreateDirectoryResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreateDirectoryResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateDirectoryResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateDirectoryResponseMultiError, or nil if none found.
func (m *CreateDirectoryResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateDirectoryResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return CreateDirectoryResponseMultiError(errors)
	}

	return nil
}

// CreateDirectoryResponseMultiError is an error wrapping multiple validation
// errors returned by CreateDirectoryResponse.ValidateAll() if the designated
// constraints aren't met.
type CreateDirectoryResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateDirectoryResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateDirectoryResponseMultiError) AllErrors() []error { return m }

// CreateDirectoryResponseValidationError is the validation error returned by
// CreateDirectoryResponse.Validate if the designated constraints aren't met.
type CreateDirectoryResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateDirectoryResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateDirectoryResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateDirectoryResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateDirectoryResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateDirectoryResponseValidationError) ErrorName() string {
	return "CreateDirectoryResponseValidationError"
}

// Error satisfies the builtin error interface
func (e CreateDirectoryResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateDirectoryResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateDirectoryResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateDirectoryResponseValidationError{}

// Validate checks the field values on DeleteFileRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *DeleteFileRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeleteFileRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DeleteFileRequestMultiError, or nil if none found.
func (m *DeleteFileRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteFileRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if !_DeleteFileRequest_InstanceId_Pattern.MatchString(m.GetInstanceId()) {
		err := DeleteFileRequestValidationError{
			field:  "InstanceId",
			reason: "value does not match regex pattern \"^[_\\\\-a-zA-Z0-9]+$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetPath()) < 1 {
		err := DeleteFileRequestValidationError{
			field:  "Path",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Force

	if len(errors) > 0 {
		return DeleteFileRequestMultiError(errors)
	}

	return nil
}

// DeleteFileRequestMultiError is an error wrapping multiple validation errors
// returned by DeleteFileRequest.ValidateAll() if the designated constraints
// aren't met.
type DeleteFileRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteFileRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteFileRequestMultiError) AllErrors() []error { return m }

// DeleteFileRequestValidationError is the validation error returned by
// DeleteFileRequest.Validate if the designated constraints aren't met.
type DeleteFileRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteFileRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteFileRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteFileRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteFileRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteFileRequestValidationError) ErrorName() string {
	return "DeleteFileRequestValidationError"
}

// Error satisfies the builtin error interface
func (e DeleteFileRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteFileRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteFileRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteFileRequestValidationError{}

var _DeleteFileRequest_InstanceId_Pattern = regexp.MustCompile("^[_\\-a-zA-Z0-9]+$")

// Validate checks the field values on DeleteFileResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DeleteFileResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeleteFileResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DeleteFileResponseMultiError, or nil if none found.
func (m *DeleteFileResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteFileResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return DeleteFileResponseMultiError(errors)
	}

	return nil
}

// DeleteFileResponseMultiError is an error wrapping multiple validation errors
// returned by DeleteFileResponse.ValidateAll() if the designated constraints
// aren't met.
type DeleteFileResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteFileResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteFileResponseMultiError) AllErrors() []error { return m }

// DeleteFileResponseValidationError is the validation error returned by
// DeleteFileResponse.Validate if the designated constraints aren't met.
type DeleteFileResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteFileResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteFileResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteFileResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteFileResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteFileResponseValidationError) ErrorName() string {
	return "DeleteFileResponseValidationError"
}

// Error satisfies the builtin error interface
func (e DeleteFileResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteFileResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteFileResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteFileResponseValidationError{}

// Validate checks the field values on RenameFileRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *RenameFileRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RenameFileRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// RenameFileRequestMultiError, or nil if none found.
func (m *RenameFileRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *RenameFileRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if !_RenameFileRequest_InstanceId_Pattern.MatchString(m.GetInstanceId()) {
		err := RenameFileRequestValidationError{
			field:  "InstanceId",
			reason: "value does not match regex pattern \"^[_\\\\-a-zA-Z0-9]+$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetFromPath()) < 1 {
		err := RenameFileRequestValidationError{
			field:  "FromPath",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetToPath()) < 1 {
		err := RenameFileRequestValidationError{
			field:  "ToPath",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return RenameFileRequestMultiError(errors)
	}

	return nil
}

// RenameFileRequestMultiError is an error wrapping multiple validation errors
// returned by RenameFileRequest.ValidateAll() if the designated constraints
// aren't met.
type RenameFileRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RenameFileRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RenameFileRequestMultiError) AllErrors() []error { return m }

// RenameFileRequestValidationError is the validation error returned by
// RenameFileRequest.Validate if the designated constraints aren't met.
type RenameFileRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RenameFileRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RenameFileRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RenameFileRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RenameFileRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RenameFileRequestValidationError) ErrorName() string {
	return "RenameFileRequestValidationError"
}

// Error satisfies the builtin error interface
func (e RenameFileRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRenameFileRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RenameFileRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RenameFileRequestValidationError{}

var _RenameFileRequest_InstanceId_Pattern = regexp.MustCompile("^[_\\-a-zA-Z0-9]+$")

// Validate checks the field values on RenameFileResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *RenameFileResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RenameFileResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// RenameFileResponseMultiError, or nil if none found.
func (m *RenameFileResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *RenameFileResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return RenameFileResponseMultiError(errors)
	}

	return nil
}

// RenameFileResponseMultiError is an error wrapping multiple validation errors
// returned by RenameFileResponse.ValidateAll() if the designated constraints
// aren't met.
type RenameFileResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RenameFileResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RenameFileResponseMultiError) AllErrors() []error { return m }

// RenameFileResponseValidationError is the validation error returned by
// RenameFileResponse.Validate if the designated constraints aren't met.
type RenameFileResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RenameFileResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RenameFileResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RenameFileResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RenameFileResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RenameFileResponseValidationError) ErrorName() string {
	return "RenameFileResponseValidationError"
}

// Error satisfies the builtin error interface
func (e RenameFileResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRenameFileResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RenameFileResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RenameFileResponseValidationError{}

// Validate checks the field values on Example with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Example) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Example with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in ExampleMultiError, or nil if none found.
func (m *Example) ValidateAll() error {
	return m.validate(true)
}

func (m *Example) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Name

	// no validation rules for DisplayName

	// no validation rules for Description

	if len(errors) > 0 {
		return ExampleMultiError(errors)
	}

	return nil
}

// ExampleMultiError is an error wrapping multiple validation errors returned
// by Example.ValidateAll() if the designated constraints aren't met.
type ExampleMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ExampleMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ExampleMultiError) AllErrors() []error { return m }

// ExampleValidationError is the validation error returned by Example.Validate
// if the designated constraints aren't met.
type ExampleValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ExampleValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ExampleValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ExampleValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ExampleValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ExampleValidationError) ErrorName() string { return "ExampleValidationError" }

// Error satisfies the builtin error interface
func (e ExampleValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sExample.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ExampleValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ExampleValidationError{}

// Validate checks the field values on ListExamplesRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListExamplesRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListExamplesRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListExamplesRequestMultiError, or nil if none found.
func (m *ListExamplesRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ListExamplesRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return ListExamplesRequestMultiError(errors)
	}

	return nil
}

// ListExamplesRequestMultiError is an error wrapping multiple validation
// errors returned by ListExamplesRequest.ValidateAll() if the designated
// constraints aren't met.
type ListExamplesRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListExamplesRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListExamplesRequestMultiError) AllErrors() []error { return m }

// ListExamplesRequestValidationError is the validation error returned by
// ListExamplesRequest.Validate if the designated constraints aren't met.
type ListExamplesRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListExamplesRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListExamplesRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListExamplesRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListExamplesRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListExamplesRequestValidationError) ErrorName() string {
	return "ListExamplesRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ListExamplesRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListExamplesRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListExamplesRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListExamplesRequestValidationError{}

// Validate checks the field values on ListExamplesResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListExamplesResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListExamplesResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListExamplesResponseMultiError, or nil if none found.
func (m *ListExamplesResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ListExamplesResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetExamples() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListExamplesResponseValidationError{
						field:  fmt.Sprintf("Examples[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListExamplesResponseValidationError{
						field:  fmt.Sprintf("Examples[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListExamplesResponseValidationError{
					field:  fmt.Sprintf("Examples[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ListExamplesResponseMultiError(errors)
	}

	return nil
}

// ListExamplesResponseMultiError is an error wrapping multiple validation
// errors returned by ListExamplesResponse.ValidateAll() if the designated
// constraints aren't met.
type ListExamplesResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListExamplesResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListExamplesResponseMultiError) AllErrors() []error { return m }

// ListExamplesResponseValidationError is the validation error returned by
// ListExamplesResponse.Validate if the designated constraints aren't met.
type ListExamplesResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListExamplesResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListExamplesResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListExamplesResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListExamplesResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListExamplesResponseValidationError) ErrorName() string {
	return "ListExamplesResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ListExamplesResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListExamplesResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListExamplesResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListExamplesResponseValidationError{}

// Validate checks the field values on UnpackExampleRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UnpackExampleRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UnpackExampleRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UnpackExampleRequestMultiError, or nil if none found.
func (m *UnpackExampleRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *UnpackExampleRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if !_UnpackExampleRequest_InstanceId_Pattern.MatchString(m.GetInstanceId()) {
		err := UnpackExampleRequestValidationError{
			field:  "InstanceId",
			reason: "value does not match regex pattern \"^[_\\\\-a-zA-Z0-9]+$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetName()) < 1 {
		err := UnpackExampleRequestValidationError{
			field:  "Name",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Force

	if len(errors) > 0 {
		return UnpackExampleRequestMultiError(errors)
	}

	return nil
}

// UnpackExampleRequestMultiError is an error wrapping multiple validation
// errors returned by UnpackExampleRequest.ValidateAll() if the designated
// constraints aren't met.
type UnpackExampleRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UnpackExampleRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UnpackExampleRequestMultiError) AllErrors() []error { return m }

// UnpackExampleRequestValidationError is the validation error returned by
// UnpackExampleRequest.Validate if the designated constraints aren't met.
type UnpackExampleRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UnpackExampleRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UnpackExampleRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UnpackExampleRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UnpackExampleRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UnpackExampleRequestValidationError) ErrorName() string {
	return "UnpackExampleRequestValidationError"
}

// Error satisfies the builtin error interface
func (e UnpackExampleRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUnpackExampleRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UnpackExampleRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UnpackExampleRequestValidationError{}

var _UnpackExampleRequest_InstanceId_Pattern = regexp.MustCompile("^[_\\-a-zA-Z0-9]+$")

// Validate checks the field values on UnpackExampleResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UnpackExampleResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UnpackExampleResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UnpackExampleResponseMultiError, or nil if none found.
func (m *UnpackExampleResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *UnpackExampleResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return UnpackExampleResponseMultiError(errors)
	}

	return nil
}

// UnpackExampleResponseMultiError is an error wrapping multiple validation
// errors returned by UnpackExampleResponse.ValidateAll() if the designated
// constraints aren't met.
type UnpackExampleResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UnpackExampleResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UnpackExampleResponseMultiError) AllErrors() []error { return m }

// UnpackExampleResponseValidationError is the validation error returned by
// UnpackExampleResponse.Validate if the designated constraints aren't met.
type UnpackExampleResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UnpackExampleResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UnpackExampleResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UnpackExampleResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UnpackExampleResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UnpackExampleResponseValidationError) ErrorName() string {
	return "UnpackExampleResponseValidationError"
}

// Error satisfies the builtin error interface
func (e UnpackExampleResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUnpackExampleResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UnpackExampleResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UnpackExampleResponseValidationError{}

// Validate checks the field values on UnpackEmptyRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UnpackEmptyRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UnpackEmptyRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UnpackEmptyRequestMultiError, or nil if none found.
func (m *UnpackEmptyRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *UnpackEmptyRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if !_UnpackEmptyRequest_InstanceId_Pattern.MatchString(m.GetInstanceId()) {
		err := UnpackEmptyRequestValidationError{
			field:  "InstanceId",
			reason: "value does not match regex pattern \"^[_\\\\-a-zA-Z0-9]+$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for DisplayName

	// no validation rules for Force

	if len(errors) > 0 {
		return UnpackEmptyRequestMultiError(errors)
	}

	return nil
}

// UnpackEmptyRequestMultiError is an error wrapping multiple validation errors
// returned by UnpackEmptyRequest.ValidateAll() if the designated constraints
// aren't met.
type UnpackEmptyRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UnpackEmptyRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UnpackEmptyRequestMultiError) AllErrors() []error { return m }

// UnpackEmptyRequestValidationError is the validation error returned by
// UnpackEmptyRequest.Validate if the designated constraints aren't met.
type UnpackEmptyRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UnpackEmptyRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UnpackEmptyRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UnpackEmptyRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UnpackEmptyRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UnpackEmptyRequestValidationError) ErrorName() string {
	return "UnpackEmptyRequestValidationError"
}

// Error satisfies the builtin error interface
func (e UnpackEmptyRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUnpackEmptyRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UnpackEmptyRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UnpackEmptyRequestValidationError{}

var _UnpackEmptyRequest_InstanceId_Pattern = regexp.MustCompile("^[_\\-a-zA-Z0-9]+$")

// Validate checks the field values on UnpackEmptyResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UnpackEmptyResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UnpackEmptyResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UnpackEmptyResponseMultiError, or nil if none found.
func (m *UnpackEmptyResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *UnpackEmptyResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return UnpackEmptyResponseMultiError(errors)
	}

	return nil
}

// UnpackEmptyResponseMultiError is an error wrapping multiple validation
// errors returned by UnpackEmptyResponse.ValidateAll() if the designated
// constraints aren't met.
type UnpackEmptyResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UnpackEmptyResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UnpackEmptyResponseMultiError) AllErrors() []error { return m }

// UnpackEmptyResponseValidationError is the validation error returned by
// UnpackEmptyResponse.Validate if the designated constraints aren't met.
type UnpackEmptyResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UnpackEmptyResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UnpackEmptyResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UnpackEmptyResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UnpackEmptyResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UnpackEmptyResponseValidationError) ErrorName() string {
	return "UnpackEmptyResponseValidationError"
}

// Error satisfies the builtin error interface
func (e UnpackEmptyResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUnpackEmptyResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UnpackEmptyResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UnpackEmptyResponseValidationError{}

// Validate checks the field values on GenerateMetricsViewFileRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GenerateMetricsViewFileRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GenerateMetricsViewFileRequest with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// GenerateMetricsViewFileRequestMultiError, or nil if none found.
func (m *GenerateMetricsViewFileRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GenerateMetricsViewFileRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if !_GenerateMetricsViewFileRequest_InstanceId_Pattern.MatchString(m.GetInstanceId()) {
		err := GenerateMetricsViewFileRequestValidationError{
			field:  "InstanceId",
			reason: "value does not match regex pattern \"^[_\\\\-a-zA-Z0-9]+$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Model

	// no validation rules for Connector

	// no validation rules for Database

	// no validation rules for DatabaseSchema

	// no validation rules for Table

	// no validation rules for Path

	// no validation rules for UseAi

	if len(errors) > 0 {
		return GenerateMetricsViewFileRequestMultiError(errors)
	}

	return nil
}

// GenerateMetricsViewFileRequestMultiError is an error wrapping multiple
// validation errors returned by GenerateMetricsViewFileRequest.ValidateAll()
// if the designated constraints aren't met.
type GenerateMetricsViewFileRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GenerateMetricsViewFileRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GenerateMetricsViewFileRequestMultiError) AllErrors() []error { return m }

// GenerateMetricsViewFileRequestValidationError is the validation error
// returned by GenerateMetricsViewFileRequest.Validate if the designated
// constraints aren't met.
type GenerateMetricsViewFileRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GenerateMetricsViewFileRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GenerateMetricsViewFileRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GenerateMetricsViewFileRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GenerateMetricsViewFileRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GenerateMetricsViewFileRequestValidationError) ErrorName() string {
	return "GenerateMetricsViewFileRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GenerateMetricsViewFileRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGenerateMetricsViewFileRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GenerateMetricsViewFileRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GenerateMetricsViewFileRequestValidationError{}

var _GenerateMetricsViewFileRequest_InstanceId_Pattern = regexp.MustCompile("^[_\\-a-zA-Z0-9]+$")

// Validate checks the field values on GenerateMetricsViewFileResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GenerateMetricsViewFileResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GenerateMetricsViewFileResponse with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// GenerateMetricsViewFileResponseMultiError, or nil if none found.
func (m *GenerateMetricsViewFileResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GenerateMetricsViewFileResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for AiSucceeded

	if len(errors) > 0 {
		return GenerateMetricsViewFileResponseMultiError(errors)
	}

	return nil
}

// GenerateMetricsViewFileResponseMultiError is an error wrapping multiple
// validation errors returned by GenerateMetricsViewFileResponse.ValidateAll()
// if the designated constraints aren't met.
type GenerateMetricsViewFileResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GenerateMetricsViewFileResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GenerateMetricsViewFileResponseMultiError) AllErrors() []error { return m }

// GenerateMetricsViewFileResponseValidationError is the validation error
// returned by GenerateMetricsViewFileResponse.Validate if the designated
// constraints aren't met.
type GenerateMetricsViewFileResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GenerateMetricsViewFileResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GenerateMetricsViewFileResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GenerateMetricsViewFileResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GenerateMetricsViewFileResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GenerateMetricsViewFileResponseValidationError) ErrorName() string {
	return "GenerateMetricsViewFileResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GenerateMetricsViewFileResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGenerateMetricsViewFileResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GenerateMetricsViewFileResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GenerateMetricsViewFileResponseValidationError{}

// Validate checks the field values on GenerateResolverRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GenerateResolverRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GenerateResolverRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GenerateResolverRequestMultiError, or nil if none found.
func (m *GenerateResolverRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GenerateResolverRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if !_GenerateResolverRequest_InstanceId_Pattern.MatchString(m.GetInstanceId()) {
		err := GenerateResolverRequestValidationError{
			field:  "InstanceId",
			reason: "value does not match regex pattern \"^[_\\\\-a-zA-Z0-9]+$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Prompt

	// no validation rules for Connector

	// no validation rules for Table

	// no validation rules for MetricsView

	if len(errors) > 0 {
		return GenerateResolverRequestMultiError(errors)
	}

	return nil
}

// GenerateResolverRequestMultiError is an error wrapping multiple validation
// errors returned by GenerateResolverRequest.ValidateAll() if the designated
// constraints aren't met.
type GenerateResolverRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GenerateResolverRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GenerateResolverRequestMultiError) AllErrors() []error { return m }

// GenerateResolverRequestValidationError is the validation error returned by
// GenerateResolverRequest.Validate if the designated constraints aren't met.
type GenerateResolverRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GenerateResolverRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GenerateResolverRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GenerateResolverRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GenerateResolverRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GenerateResolverRequestValidationError) ErrorName() string {
	return "GenerateResolverRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GenerateResolverRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGenerateResolverRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GenerateResolverRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GenerateResolverRequestValidationError{}

var _GenerateResolverRequest_InstanceId_Pattern = regexp.MustCompile("^[_\\-a-zA-Z0-9]+$")

// Validate checks the field values on GenerateResolverResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GenerateResolverResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GenerateResolverResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GenerateResolverResponseMultiError, or nil if none found.
func (m *GenerateResolverResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GenerateResolverResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Resolver

	if all {
		switch v := interface{}(m.GetResolverProperties()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GenerateResolverResponseValidationError{
					field:  "ResolverProperties",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GenerateResolverResponseValidationError{
					field:  "ResolverProperties",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetResolverProperties()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GenerateResolverResponseValidationError{
				field:  "ResolverProperties",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return GenerateResolverResponseMultiError(errors)
	}

	return nil
}

// GenerateResolverResponseMultiError is an error wrapping multiple validation
// errors returned by GenerateResolverResponse.ValidateAll() if the designated
// constraints aren't met.
type GenerateResolverResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GenerateResolverResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GenerateResolverResponseMultiError) AllErrors() []error { return m }

// GenerateResolverResponseValidationError is the validation error returned by
// GenerateResolverResponse.Validate if the designated constraints aren't met.
type GenerateResolverResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GenerateResolverResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GenerateResolverResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GenerateResolverResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GenerateResolverResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GenerateResolverResponseValidationError) ErrorName() string {
	return "GenerateResolverResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GenerateResolverResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGenerateResolverResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GenerateResolverResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GenerateResolverResponseValidationError{}

// Validate checks the field values on GenerateRendererRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GenerateRendererRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GenerateRendererRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GenerateRendererRequestMultiError, or nil if none found.
func (m *GenerateRendererRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GenerateRendererRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if !_GenerateRendererRequest_InstanceId_Pattern.MatchString(m.GetInstanceId()) {
		err := GenerateRendererRequestValidationError{
			field:  "InstanceId",
			reason: "value does not match regex pattern \"^[_\\\\-a-zA-Z0-9]+$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Prompt

	// no validation rules for Resolver

	if all {
		switch v := interface{}(m.GetResolverProperties()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GenerateRendererRequestValidationError{
					field:  "ResolverProperties",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GenerateRendererRequestValidationError{
					field:  "ResolverProperties",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetResolverProperties()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GenerateRendererRequestValidationError{
				field:  "ResolverProperties",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return GenerateRendererRequestMultiError(errors)
	}

	return nil
}

// GenerateRendererRequestMultiError is an error wrapping multiple validation
// errors returned by GenerateRendererRequest.ValidateAll() if the designated
// constraints aren't met.
type GenerateRendererRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GenerateRendererRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GenerateRendererRequestMultiError) AllErrors() []error { return m }

// GenerateRendererRequestValidationError is the validation error returned by
// GenerateRendererRequest.Validate if the designated constraints aren't met.
type GenerateRendererRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GenerateRendererRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GenerateRendererRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GenerateRendererRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GenerateRendererRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GenerateRendererRequestValidationError) ErrorName() string {
	return "GenerateRendererRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GenerateRendererRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGenerateRendererRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GenerateRendererRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GenerateRendererRequestValidationError{}

var _GenerateRendererRequest_InstanceId_Pattern = regexp.MustCompile("^[_\\-a-zA-Z0-9]+$")

// Validate checks the field values on GenerateRendererResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GenerateRendererResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GenerateRendererResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GenerateRendererResponseMultiError, or nil if none found.
func (m *GenerateRendererResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GenerateRendererResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Renderer

	if all {
		switch v := interface{}(m.GetRendererProperties()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GenerateRendererResponseValidationError{
					field:  "RendererProperties",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GenerateRendererResponseValidationError{
					field:  "RendererProperties",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetRendererProperties()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GenerateRendererResponseValidationError{
				field:  "RendererProperties",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return GenerateRendererResponseMultiError(errors)
	}

	return nil
}

// GenerateRendererResponseMultiError is an error wrapping multiple validation
// errors returned by GenerateRendererResponse.ValidateAll() if the designated
// constraints aren't met.
type GenerateRendererResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GenerateRendererResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GenerateRendererResponseMultiError) AllErrors() []error { return m }

// GenerateRendererResponseValidationError is the validation error returned by
// GenerateRendererResponse.Validate if the designated constraints aren't met.
type GenerateRendererResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GenerateRendererResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GenerateRendererResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GenerateRendererResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GenerateRendererResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GenerateRendererResponseValidationError) ErrorName() string {
	return "GenerateRendererResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GenerateRendererResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGenerateRendererResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GenerateRendererResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GenerateRendererResponseValidationError{}

// Validate checks the field values on QueryResolverRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *QueryResolverRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on QueryResolverRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// QueryResolverRequestMultiError, or nil if none found.
func (m *QueryResolverRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *QueryResolverRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for InstanceId

	// no validation rules for Resolver

	if all {
		switch v := interface{}(m.GetResolverProperties()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, QueryResolverRequestValidationError{
					field:  "ResolverProperties",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, QueryResolverRequestValidationError{
					field:  "ResolverProperties",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetResolverProperties()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return QueryResolverRequestValidationError{
				field:  "ResolverProperties",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetResolverArgs()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, QueryResolverRequestValidationError{
					field:  "ResolverArgs",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, QueryResolverRequestValidationError{
					field:  "ResolverArgs",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetResolverArgs()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return QueryResolverRequestValidationError{
				field:  "ResolverArgs",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Limit

	if len(errors) > 0 {
		return QueryResolverRequestMultiError(errors)
	}

	return nil
}

// QueryResolverRequestMultiError is an error wrapping multiple validation
// errors returned by QueryResolverRequest.ValidateAll() if the designated
// constraints aren't met.
type QueryResolverRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m QueryResolverRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m QueryResolverRequestMultiError) AllErrors() []error { return m }

// QueryResolverRequestValidationError is the validation error returned by
// QueryResolverRequest.Validate if the designated constraints aren't met.
type QueryResolverRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e QueryResolverRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e QueryResolverRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e QueryResolverRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e QueryResolverRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e QueryResolverRequestValidationError) ErrorName() string {
	return "QueryResolverRequestValidationError"
}

// Error satisfies the builtin error interface
func (e QueryResolverRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sQueryResolverRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = QueryResolverRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = QueryResolverRequestValidationError{}

// Validate checks the field values on QueryResolverResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *QueryResolverResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on QueryResolverResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// QueryResolverResponseMultiError, or nil if none found.
func (m *QueryResolverResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *QueryResolverResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetSchema()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, QueryResolverResponseValidationError{
					field:  "Schema",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, QueryResolverResponseValidationError{
					field:  "Schema",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSchema()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return QueryResolverResponseValidationError{
				field:  "Schema",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetData() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, QueryResolverResponseValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, QueryResolverResponseValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return QueryResolverResponseValidationError{
					field:  fmt.Sprintf("Data[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return QueryResolverResponseMultiError(errors)
	}

	return nil
}

// QueryResolverResponseMultiError is an error wrapping multiple validation
// errors returned by QueryResolverResponse.ValidateAll() if the designated
// constraints aren't met.
type QueryResolverResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m QueryResolverResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m QueryResolverResponseMultiError) AllErrors() []error { return m }

// QueryResolverResponseValidationError is the validation error returned by
// QueryResolverResponse.Validate if the designated constraints aren't met.
type QueryResolverResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e QueryResolverResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e QueryResolverResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e QueryResolverResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e QueryResolverResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e QueryResolverResponseValidationError) ErrorName() string {
	return "QueryResolverResponseValidationError"
}

// Error satisfies the builtin error interface
func (e QueryResolverResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sQueryResolverResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = QueryResolverResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = QueryResolverResponseValidationError{}

// Validate checks the field values on Log with the rules defined in the proto
// definition for this message. If any rules are violated, the first error
// encountered is returned, or nil if there are no violations.
func (m *Log) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Log with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in LogMultiError, or nil if none found.
func (m *Log) ValidateAll() error {
	return m.validate(true)
}

func (m *Log) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Level

	if all {
		switch v := interface{}(m.GetTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, LogValidationError{
					field:  "Time",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, LogValidationError{
					field:  "Time",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return LogValidationError{
				field:  "Time",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Message

	// no validation rules for JsonPayload

	if len(errors) > 0 {
		return LogMultiError(errors)
	}

	return nil
}

// LogMultiError is an error wrapping multiple validation errors returned by
// Log.ValidateAll() if the designated constraints aren't met.
type LogMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m LogMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m LogMultiError) AllErrors() []error { return m }

// LogValidationError is the validation error returned by Log.Validate if the
// designated constraints aren't met.
type LogValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e LogValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e LogValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e LogValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e LogValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e LogValidationError) ErrorName() string { return "LogValidationError" }

// Error satisfies the builtin error interface
func (e LogValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sLog.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = LogValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = LogValidationError{}

// Validate checks the field values on ModelPartition with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ModelPartition) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ModelPartition with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ModelPartitionMultiError,
// or nil if none found.
func (m *ModelPartition) ValidateAll() error {
	return m.validate(true)
}

func (m *ModelPartition) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Key

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ModelPartitionValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ModelPartitionValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ModelPartitionValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetWatermark()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ModelPartitionValidationError{
					field:  "Watermark",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ModelPartitionValidationError{
					field:  "Watermark",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetWatermark()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ModelPartitionValidationError{
				field:  "Watermark",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetExecutedOn()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ModelPartitionValidationError{
					field:  "ExecutedOn",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ModelPartitionValidationError{
					field:  "ExecutedOn",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetExecutedOn()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ModelPartitionValidationError{
				field:  "ExecutedOn",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Error

	// no validation rules for ElapsedMs

	if len(errors) > 0 {
		return ModelPartitionMultiError(errors)
	}

	return nil
}

// ModelPartitionMultiError is an error wrapping multiple validation errors
// returned by ModelPartition.ValidateAll() if the designated constraints
// aren't met.
type ModelPartitionMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ModelPartitionMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ModelPartitionMultiError) AllErrors() []error { return m }

// ModelPartitionValidationError is the validation error returned by
// ModelPartition.Validate if the designated constraints aren't met.
type ModelPartitionValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ModelPartitionValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ModelPartitionValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ModelPartitionValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ModelPartitionValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ModelPartitionValidationError) ErrorName() string { return "ModelPartitionValidationError" }

// Error satisfies the builtin error interface
func (e ModelPartitionValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sModelPartition.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ModelPartitionValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ModelPartitionValidationError{}

// Validate checks the field values on GetLogsRequest with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *GetLogsRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetLogsRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in GetLogsRequestMultiError,
// or nil if none found.
func (m *GetLogsRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetLogsRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for InstanceId

	// no validation rules for Ascending

	if m.GetLimit() < -1 {
		err := GetLogsRequestValidationError{
			field:  "Limit",
			reason: "value must be greater than or equal to -1",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Level

	if len(errors) > 0 {
		return GetLogsRequestMultiError(errors)
	}

	return nil
}

// GetLogsRequestMultiError is an error wrapping multiple validation errors
// returned by GetLogsRequest.ValidateAll() if the designated constraints
// aren't met.
type GetLogsRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetLogsRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetLogsRequestMultiError) AllErrors() []error { return m }

// GetLogsRequestValidationError is the validation error returned by
// GetLogsRequest.Validate if the designated constraints aren't met.
type GetLogsRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetLogsRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetLogsRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetLogsRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetLogsRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetLogsRequestValidationError) ErrorName() string { return "GetLogsRequestValidationError" }

// Error satisfies the builtin error interface
func (e GetLogsRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetLogsRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetLogsRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetLogsRequestValidationError{}

// Validate checks the field values on GetLogsResponse with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *GetLogsResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetLogsResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetLogsResponseMultiError, or nil if none found.
func (m *GetLogsResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GetLogsResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetLogs() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, GetLogsResponseValidationError{
						field:  fmt.Sprintf("Logs[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, GetLogsResponseValidationError{
						field:  fmt.Sprintf("Logs[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return GetLogsResponseValidationError{
					field:  fmt.Sprintf("Logs[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return GetLogsResponseMultiError(errors)
	}

	return nil
}

// GetLogsResponseMultiError is an error wrapping multiple validation errors
// returned by GetLogsResponse.ValidateAll() if the designated constraints
// aren't met.
type GetLogsResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetLogsResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetLogsResponseMultiError) AllErrors() []error { return m }

// GetLogsResponseValidationError is the validation error returned by
// GetLogsResponse.Validate if the designated constraints aren't met.
type GetLogsResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetLogsResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetLogsResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetLogsResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetLogsResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetLogsResponseValidationError) ErrorName() string { return "GetLogsResponseValidationError" }

// Error satisfies the builtin error interface
func (e GetLogsResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetLogsResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetLogsResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetLogsResponseValidationError{}

// Validate checks the field values on WatchLogsRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *WatchLogsRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on WatchLogsRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// WatchLogsRequestMultiError, or nil if none found.
func (m *WatchLogsRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *WatchLogsRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for InstanceId

	// no validation rules for Replay

	if m.GetReplayLimit() < -1 {
		err := WatchLogsRequestValidationError{
			field:  "ReplayLimit",
			reason: "value must be greater than or equal to -1",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Level

	if len(errors) > 0 {
		return WatchLogsRequestMultiError(errors)
	}

	return nil
}

// WatchLogsRequestMultiError is an error wrapping multiple validation errors
// returned by WatchLogsRequest.ValidateAll() if the designated constraints
// aren't met.
type WatchLogsRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m WatchLogsRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m WatchLogsRequestMultiError) AllErrors() []error { return m }

// WatchLogsRequestValidationError is the validation error returned by
// WatchLogsRequest.Validate if the designated constraints aren't met.
type WatchLogsRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e WatchLogsRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e WatchLogsRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e WatchLogsRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e WatchLogsRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e WatchLogsRequestValidationError) ErrorName() string { return "WatchLogsRequestValidationError" }

// Error satisfies the builtin error interface
func (e WatchLogsRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sWatchLogsRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = WatchLogsRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = WatchLogsRequestValidationError{}

// Validate checks the field values on WatchLogsResponse with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *WatchLogsResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on WatchLogsResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// WatchLogsResponseMultiError, or nil if none found.
func (m *WatchLogsResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *WatchLogsResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetLog()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, WatchLogsResponseValidationError{
					field:  "Log",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, WatchLogsResponseValidationError{
					field:  "Log",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetLog()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return WatchLogsResponseValidationError{
				field:  "Log",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return WatchLogsResponseMultiError(errors)
	}

	return nil
}

// WatchLogsResponseMultiError is an error wrapping multiple validation errors
// returned by WatchLogsResponse.ValidateAll() if the designated constraints
// aren't met.
type WatchLogsResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m WatchLogsResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m WatchLogsResponseMultiError) AllErrors() []error { return m }

// WatchLogsResponseValidationError is the validation error returned by
// WatchLogsResponse.Validate if the designated constraints aren't met.
type WatchLogsResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e WatchLogsResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e WatchLogsResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e WatchLogsResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e WatchLogsResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e WatchLogsResponseValidationError) ErrorName() string {
	return "WatchLogsResponseValidationError"
}

// Error satisfies the builtin error interface
func (e WatchLogsResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sWatchLogsResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = WatchLogsResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = WatchLogsResponseValidationError{}

// Validate checks the field values on ListResourcesRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListResourcesRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListResourcesRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListResourcesRequestMultiError, or nil if none found.
func (m *ListResourcesRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ListResourcesRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for InstanceId

	// no validation rules for Kind

	// no validation rules for Path

	// no validation rules for SkipSecurityChecks

	if len(errors) > 0 {
		return ListResourcesRequestMultiError(errors)
	}

	return nil
}

// ListResourcesRequestMultiError is an error wrapping multiple validation
// errors returned by ListResourcesRequest.ValidateAll() if the designated
// constraints aren't met.
type ListResourcesRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListResourcesRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListResourcesRequestMultiError) AllErrors() []error { return m }

// ListResourcesRequestValidationError is the validation error returned by
// ListResourcesRequest.Validate if the designated constraints aren't met.
type ListResourcesRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListResourcesRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListResourcesRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListResourcesRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListResourcesRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListResourcesRequestValidationError) ErrorName() string {
	return "ListResourcesRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ListResourcesRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListResourcesRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListResourcesRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListResourcesRequestValidationError{}

// Validate checks the field values on ListResourcesResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListResourcesResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListResourcesResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListResourcesResponseMultiError, or nil if none found.
func (m *ListResourcesResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ListResourcesResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetResources() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListResourcesResponseValidationError{
						field:  fmt.Sprintf("Resources[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListResourcesResponseValidationError{
						field:  fmt.Sprintf("Resources[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListResourcesResponseValidationError{
					field:  fmt.Sprintf("Resources[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ListResourcesResponseMultiError(errors)
	}

	return nil
}

// ListResourcesResponseMultiError is an error wrapping multiple validation
// errors returned by ListResourcesResponse.ValidateAll() if the designated
// constraints aren't met.
type ListResourcesResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListResourcesResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListResourcesResponseMultiError) AllErrors() []error { return m }

// ListResourcesResponseValidationError is the validation error returned by
// ListResourcesResponse.Validate if the designated constraints aren't met.
type ListResourcesResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListResourcesResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListResourcesResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListResourcesResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListResourcesResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListResourcesResponseValidationError) ErrorName() string {
	return "ListResourcesResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ListResourcesResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListResourcesResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListResourcesResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListResourcesResponseValidationError{}

// Validate checks the field values on WatchResourcesRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *WatchResourcesRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on WatchResourcesRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// WatchResourcesRequestMultiError, or nil if none found.
func (m *WatchResourcesRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *WatchResourcesRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for InstanceId

	// no validation rules for Kind

	// no validation rules for Replay

	// no validation rules for Level

	if len(errors) > 0 {
		return WatchResourcesRequestMultiError(errors)
	}

	return nil
}

// WatchResourcesRequestMultiError is an error wrapping multiple validation
// errors returned by WatchResourcesRequest.ValidateAll() if the designated
// constraints aren't met.
type WatchResourcesRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m WatchResourcesRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m WatchResourcesRequestMultiError) AllErrors() []error { return m }

// WatchResourcesRequestValidationError is the validation error returned by
// WatchResourcesRequest.Validate if the designated constraints aren't met.
type WatchResourcesRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e WatchResourcesRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e WatchResourcesRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e WatchResourcesRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e WatchResourcesRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e WatchResourcesRequestValidationError) ErrorName() string {
	return "WatchResourcesRequestValidationError"
}

// Error satisfies the builtin error interface
func (e WatchResourcesRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sWatchResourcesRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = WatchResourcesRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = WatchResourcesRequestValidationError{}

// Validate checks the field values on WatchResourcesResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *WatchResourcesResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on WatchResourcesResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// WatchResourcesResponseMultiError, or nil if none found.
func (m *WatchResourcesResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *WatchResourcesResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Event

	if all {
		switch v := interface{}(m.GetName()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, WatchResourcesResponseValidationError{
					field:  "Name",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, WatchResourcesResponseValidationError{
					field:  "Name",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetName()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return WatchResourcesResponseValidationError{
				field:  "Name",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetResource()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, WatchResourcesResponseValidationError{
					field:  "Resource",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, WatchResourcesResponseValidationError{
					field:  "Resource",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetResource()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return WatchResourcesResponseValidationError{
				field:  "Resource",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return WatchResourcesResponseMultiError(errors)
	}

	return nil
}

// WatchResourcesResponseMultiError is an error wrapping multiple validation
// errors returned by WatchResourcesResponse.ValidateAll() if the designated
// constraints aren't met.
type WatchResourcesResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m WatchResourcesResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m WatchResourcesResponseMultiError) AllErrors() []error { return m }

// WatchResourcesResponseValidationError is the validation error returned by
// WatchResourcesResponse.Validate if the designated constraints aren't met.
type WatchResourcesResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e WatchResourcesResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e WatchResourcesResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e WatchResourcesResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e WatchResourcesResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e WatchResourcesResponseValidationError) ErrorName() string {
	return "WatchResourcesResponseValidationError"
}

// Error satisfies the builtin error interface
func (e WatchResourcesResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sWatchResourcesResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = WatchResourcesResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = WatchResourcesResponseValidationError{}

// Validate checks the field values on GetResourceRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetResourceRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetResourceRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetResourceRequestMultiError, or nil if none found.
func (m *GetResourceRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetResourceRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for InstanceId

	if all {
		switch v := interface{}(m.GetName()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetResourceRequestValidationError{
					field:  "Name",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetResourceRequestValidationError{
					field:  "Name",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetName()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetResourceRequestValidationError{
				field:  "Name",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for SkipSecurityChecks

	if len(errors) > 0 {
		return GetResourceRequestMultiError(errors)
	}

	return nil
}

// GetResourceRequestMultiError is an error wrapping multiple validation errors
// returned by GetResourceRequest.ValidateAll() if the designated constraints
// aren't met.
type GetResourceRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetResourceRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetResourceRequestMultiError) AllErrors() []error { return m }

// GetResourceRequestValidationError is the validation error returned by
// GetResourceRequest.Validate if the designated constraints aren't met.
type GetResourceRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetResourceRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetResourceRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetResourceRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetResourceRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetResourceRequestValidationError) ErrorName() string {
	return "GetResourceRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetResourceRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetResourceRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetResourceRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetResourceRequestValidationError{}

// Validate checks the field values on GetResourceResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetResourceResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetResourceResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetResourceResponseMultiError, or nil if none found.
func (m *GetResourceResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GetResourceResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetResource()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetResourceResponseValidationError{
					field:  "Resource",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetResourceResponseValidationError{
					field:  "Resource",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetResource()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetResourceResponseValidationError{
				field:  "Resource",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return GetResourceResponseMultiError(errors)
	}

	return nil
}

// GetResourceResponseMultiError is an error wrapping multiple validation
// errors returned by GetResourceResponse.ValidateAll() if the designated
// constraints aren't met.
type GetResourceResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetResourceResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetResourceResponseMultiError) AllErrors() []error { return m }

// GetResourceResponseValidationError is the validation error returned by
// GetResourceResponse.Validate if the designated constraints aren't met.
type GetResourceResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetResourceResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetResourceResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetResourceResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetResourceResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetResourceResponseValidationError) ErrorName() string {
	return "GetResourceResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GetResourceResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetResourceResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetResourceResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetResourceResponseValidationError{}

// Validate checks the field values on GetExploreRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *GetExploreRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetExploreRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetExploreRequestMultiError, or nil if none found.
func (m *GetExploreRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetExploreRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for InstanceId

	// no validation rules for Name

	if len(errors) > 0 {
		return GetExploreRequestMultiError(errors)
	}

	return nil
}

// GetExploreRequestMultiError is an error wrapping multiple validation errors
// returned by GetExploreRequest.ValidateAll() if the designated constraints
// aren't met.
type GetExploreRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetExploreRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetExploreRequestMultiError) AllErrors() []error { return m }

// GetExploreRequestValidationError is the validation error returned by
// GetExploreRequest.Validate if the designated constraints aren't met.
type GetExploreRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetExploreRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetExploreRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetExploreRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetExploreRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetExploreRequestValidationError) ErrorName() string {
	return "GetExploreRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetExploreRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetExploreRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetExploreRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetExploreRequestValidationError{}

// Validate checks the field values on GetExploreResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetExploreResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetExploreResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetExploreResponseMultiError, or nil if none found.
func (m *GetExploreResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GetExploreResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetExplore()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetExploreResponseValidationError{
					field:  "Explore",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetExploreResponseValidationError{
					field:  "Explore",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetExplore()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetExploreResponseValidationError{
				field:  "Explore",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetMetricsView()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetExploreResponseValidationError{
					field:  "MetricsView",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetExploreResponseValidationError{
					field:  "MetricsView",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetMetricsView()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetExploreResponseValidationError{
				field:  "MetricsView",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return GetExploreResponseMultiError(errors)
	}

	return nil
}

// GetExploreResponseMultiError is an error wrapping multiple validation errors
// returned by GetExploreResponse.ValidateAll() if the designated constraints
// aren't met.
type GetExploreResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetExploreResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetExploreResponseMultiError) AllErrors() []error { return m }

// GetExploreResponseValidationError is the validation error returned by
// GetExploreResponse.Validate if the designated constraints aren't met.
type GetExploreResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetExploreResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetExploreResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetExploreResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetExploreResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetExploreResponseValidationError) ErrorName() string {
	return "GetExploreResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GetExploreResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetExploreResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetExploreResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetExploreResponseValidationError{}

// Validate checks the field values on GetModelPartitionsRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetModelPartitionsRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetModelPartitionsRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetModelPartitionsRequestMultiError, or nil if none found.
func (m *GetModelPartitionsRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetModelPartitionsRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for InstanceId

	// no validation rules for Model

	// no validation rules for Pending

	// no validation rules for Errored

	if m.GetPageSize() != 0 {

		if m.GetPageSize() > 10000 {
			err := GetModelPartitionsRequestValidationError{
				field:  "PageSize",
				reason: "value must be less than or equal to 10000",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	// no validation rules for PageToken

	if len(errors) > 0 {
		return GetModelPartitionsRequestMultiError(errors)
	}

	return nil
}

// GetModelPartitionsRequestMultiError is an error wrapping multiple validation
// errors returned by GetModelPartitionsRequest.ValidateAll() if the
// designated constraints aren't met.
type GetModelPartitionsRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetModelPartitionsRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetModelPartitionsRequestMultiError) AllErrors() []error { return m }

// GetModelPartitionsRequestValidationError is the validation error returned by
// GetModelPartitionsRequest.Validate if the designated constraints aren't met.
type GetModelPartitionsRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetModelPartitionsRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetModelPartitionsRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetModelPartitionsRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetModelPartitionsRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetModelPartitionsRequestValidationError) ErrorName() string {
	return "GetModelPartitionsRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetModelPartitionsRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetModelPartitionsRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetModelPartitionsRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetModelPartitionsRequestValidationError{}

// Validate checks the field values on GetModelPartitionsResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetModelPartitionsResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetModelPartitionsResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetModelPartitionsResponseMultiError, or nil if none found.
func (m *GetModelPartitionsResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GetModelPartitionsResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetPartitions() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, GetModelPartitionsResponseValidationError{
						field:  fmt.Sprintf("Partitions[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, GetModelPartitionsResponseValidationError{
						field:  fmt.Sprintf("Partitions[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return GetModelPartitionsResponseValidationError{
					field:  fmt.Sprintf("Partitions[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for NextPageToken

	if len(errors) > 0 {
		return GetModelPartitionsResponseMultiError(errors)
	}

	return nil
}

// GetModelPartitionsResponseMultiError is an error wrapping multiple
// validation errors returned by GetModelPartitionsResponse.ValidateAll() if
// the designated constraints aren't met.
type GetModelPartitionsResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetModelPartitionsResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetModelPartitionsResponseMultiError) AllErrors() []error { return m }

// GetModelPartitionsResponseValidationError is the validation error returned
// by GetModelPartitionsResponse.Validate if the designated constraints aren't met.
type GetModelPartitionsResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetModelPartitionsResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetModelPartitionsResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetModelPartitionsResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetModelPartitionsResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetModelPartitionsResponseValidationError) ErrorName() string {
	return "GetModelPartitionsResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GetModelPartitionsResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetModelPartitionsResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetModelPartitionsResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetModelPartitionsResponseValidationError{}

// Validate checks the field values on CreateTriggerRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreateTriggerRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateTriggerRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateTriggerRequestMultiError, or nil if none found.
func (m *CreateTriggerRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateTriggerRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for InstanceId

	for idx, item := range m.GetResources() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, CreateTriggerRequestValidationError{
						field:  fmt.Sprintf("Resources[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, CreateTriggerRequestValidationError{
						field:  fmt.Sprintf("Resources[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return CreateTriggerRequestValidationError{
					field:  fmt.Sprintf("Resources[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetModels() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, CreateTriggerRequestValidationError{
						field:  fmt.Sprintf("Models[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, CreateTriggerRequestValidationError{
						field:  fmt.Sprintf("Models[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return CreateTriggerRequestValidationError{
					field:  fmt.Sprintf("Models[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for Parser

	// no validation rules for AllSourcesModels

	// no validation rules for AllSourcesModelsFull

	if len(errors) > 0 {
		return CreateTriggerRequestMultiError(errors)
	}

	return nil
}

// CreateTriggerRequestMultiError is an error wrapping multiple validation
// errors returned by CreateTriggerRequest.ValidateAll() if the designated
// constraints aren't met.
type CreateTriggerRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateTriggerRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateTriggerRequestMultiError) AllErrors() []error { return m }

// CreateTriggerRequestValidationError is the validation error returned by
// CreateTriggerRequest.Validate if the designated constraints aren't met.
type CreateTriggerRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateTriggerRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateTriggerRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateTriggerRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateTriggerRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateTriggerRequestValidationError) ErrorName() string {
	return "CreateTriggerRequestValidationError"
}

// Error satisfies the builtin error interface
func (e CreateTriggerRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateTriggerRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateTriggerRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateTriggerRequestValidationError{}

// Validate checks the field values on CreateTriggerResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreateTriggerResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateTriggerResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateTriggerResponseMultiError, or nil if none found.
func (m *CreateTriggerResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateTriggerResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return CreateTriggerResponseMultiError(errors)
	}

	return nil
}

// CreateTriggerResponseMultiError is an error wrapping multiple validation
// errors returned by CreateTriggerResponse.ValidateAll() if the designated
// constraints aren't met.
type CreateTriggerResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateTriggerResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateTriggerResponseMultiError) AllErrors() []error { return m }

// CreateTriggerResponseValidationError is the validation error returned by
// CreateTriggerResponse.Validate if the designated constraints aren't met.
type CreateTriggerResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateTriggerResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateTriggerResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateTriggerResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateTriggerResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateTriggerResponseValidationError) ErrorName() string {
	return "CreateTriggerResponseValidationError"
}

// Error satisfies the builtin error interface
func (e CreateTriggerResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateTriggerResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateTriggerResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateTriggerResponseValidationError{}

// Validate checks the field values on ConnectorDriver with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *ConnectorDriver) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ConnectorDriver with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ConnectorDriverMultiError, or nil if none found.
func (m *ConnectorDriver) ValidateAll() error {
	return m.validate(true)
}

func (m *ConnectorDriver) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Name

	for idx, item := range m.GetConfigProperties() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ConnectorDriverValidationError{
						field:  fmt.Sprintf("ConfigProperties[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ConnectorDriverValidationError{
						field:  fmt.Sprintf("ConfigProperties[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ConnectorDriverValidationError{
					field:  fmt.Sprintf("ConfigProperties[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetSourceProperties() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ConnectorDriverValidationError{
						field:  fmt.Sprintf("SourceProperties[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ConnectorDriverValidationError{
						field:  fmt.Sprintf("SourceProperties[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ConnectorDriverValidationError{
					field:  fmt.Sprintf("SourceProperties[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for DisplayName

	// no validation rules for Description

	// no validation rules for ImplementsRegistry

	// no validation rules for ImplementsCatalog

	// no validation rules for ImplementsRepo

	// no validation rules for ImplementsAdmin

	// no validation rules for ImplementsAi

	// no validation rules for ImplementsSqlStore

	// no validation rules for ImplementsOlap

	// no validation rules for ImplementsObjectStore

	// no validation rules for ImplementsFileStore

	// no validation rules for ImplementsNotifier

	// no validation rules for ImplementsWarehouse

	if len(errors) > 0 {
		return ConnectorDriverMultiError(errors)
	}

	return nil
}

// ConnectorDriverMultiError is an error wrapping multiple validation errors
// returned by ConnectorDriver.ValidateAll() if the designated constraints
// aren't met.
type ConnectorDriverMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ConnectorDriverMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ConnectorDriverMultiError) AllErrors() []error { return m }

// ConnectorDriverValidationError is the validation error returned by
// ConnectorDriver.Validate if the designated constraints aren't met.
type ConnectorDriverValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ConnectorDriverValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ConnectorDriverValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ConnectorDriverValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ConnectorDriverValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ConnectorDriverValidationError) ErrorName() string { return "ConnectorDriverValidationError" }

// Error satisfies the builtin error interface
func (e ConnectorDriverValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sConnectorDriver.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ConnectorDriverValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ConnectorDriverValidationError{}

// Validate checks the field values on AnalyzedConnector with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *AnalyzedConnector) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on AnalyzedConnector with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// AnalyzedConnectorMultiError, or nil if none found.
func (m *AnalyzedConnector) ValidateAll() error {
	return m.validate(true)
}

func (m *AnalyzedConnector) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Name

	if all {
		switch v := interface{}(m.GetDriver()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, AnalyzedConnectorValidationError{
					field:  "Driver",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, AnalyzedConnectorValidationError{
					field:  "Driver",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDriver()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return AnalyzedConnectorValidationError{
				field:  "Driver",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Config

	// no validation rules for PresetConfig

	// no validation rules for ProjectConfig

	// no validation rules for EnvConfig

	// no validation rules for Provision

	if all {
		switch v := interface{}(m.GetProvisionArgs()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, AnalyzedConnectorValidationError{
					field:  "ProvisionArgs",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, AnalyzedConnectorValidationError{
					field:  "ProvisionArgs",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetProvisionArgs()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return AnalyzedConnectorValidationError{
				field:  "ProvisionArgs",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for HasAnonymousAccess

	for idx, item := range m.GetUsedBy() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, AnalyzedConnectorValidationError{
						field:  fmt.Sprintf("UsedBy[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, AnalyzedConnectorValidationError{
						field:  fmt.Sprintf("UsedBy[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return AnalyzedConnectorValidationError{
					field:  fmt.Sprintf("UsedBy[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for ErrorMessage

	if len(errors) > 0 {
		return AnalyzedConnectorMultiError(errors)
	}

	return nil
}

// AnalyzedConnectorMultiError is an error wrapping multiple validation errors
// returned by AnalyzedConnector.ValidateAll() if the designated constraints
// aren't met.
type AnalyzedConnectorMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AnalyzedConnectorMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AnalyzedConnectorMultiError) AllErrors() []error { return m }

// AnalyzedConnectorValidationError is the validation error returned by
// AnalyzedConnector.Validate if the designated constraints aren't met.
type AnalyzedConnectorValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AnalyzedConnectorValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AnalyzedConnectorValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AnalyzedConnectorValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AnalyzedConnectorValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AnalyzedConnectorValidationError) ErrorName() string {
	return "AnalyzedConnectorValidationError"
}

// Error satisfies the builtin error interface
func (e AnalyzedConnectorValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAnalyzedConnector.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AnalyzedConnectorValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AnalyzedConnectorValidationError{}

// Validate checks the field values on ListConnectorDriversRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListConnectorDriversRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListConnectorDriversRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListConnectorDriversRequestMultiError, or nil if none found.
func (m *ListConnectorDriversRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ListConnectorDriversRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return ListConnectorDriversRequestMultiError(errors)
	}

	return nil
}

// ListConnectorDriversRequestMultiError is an error wrapping multiple
// validation errors returned by ListConnectorDriversRequest.ValidateAll() if
// the designated constraints aren't met.
type ListConnectorDriversRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListConnectorDriversRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListConnectorDriversRequestMultiError) AllErrors() []error { return m }

// ListConnectorDriversRequestValidationError is the validation error returned
// by ListConnectorDriversRequest.Validate if the designated constraints
// aren't met.
type ListConnectorDriversRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListConnectorDriversRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListConnectorDriversRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListConnectorDriversRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListConnectorDriversRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListConnectorDriversRequestValidationError) ErrorName() string {
	return "ListConnectorDriversRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ListConnectorDriversRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListConnectorDriversRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListConnectorDriversRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListConnectorDriversRequestValidationError{}

// Validate checks the field values on ListConnectorDriversResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListConnectorDriversResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListConnectorDriversResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListConnectorDriversResponseMultiError, or nil if none found.
func (m *ListConnectorDriversResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ListConnectorDriversResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetConnectors() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListConnectorDriversResponseValidationError{
						field:  fmt.Sprintf("Connectors[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListConnectorDriversResponseValidationError{
						field:  fmt.Sprintf("Connectors[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListConnectorDriversResponseValidationError{
					field:  fmt.Sprintf("Connectors[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ListConnectorDriversResponseMultiError(errors)
	}

	return nil
}

// ListConnectorDriversResponseMultiError is an error wrapping multiple
// validation errors returned by ListConnectorDriversResponse.ValidateAll() if
// the designated constraints aren't met.
type ListConnectorDriversResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListConnectorDriversResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListConnectorDriversResponseMultiError) AllErrors() []error { return m }

// ListConnectorDriversResponseValidationError is the validation error returned
// by ListConnectorDriversResponse.Validate if the designated constraints
// aren't met.
type ListConnectorDriversResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListConnectorDriversResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListConnectorDriversResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListConnectorDriversResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListConnectorDriversResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListConnectorDriversResponseValidationError) ErrorName() string {
	return "ListConnectorDriversResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ListConnectorDriversResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListConnectorDriversResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListConnectorDriversResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListConnectorDriversResponseValidationError{}

// Validate checks the field values on AnalyzeConnectorsRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *AnalyzeConnectorsRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on AnalyzeConnectorsRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// AnalyzeConnectorsRequestMultiError, or nil if none found.
func (m *AnalyzeConnectorsRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *AnalyzeConnectorsRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for InstanceId

	if len(errors) > 0 {
		return AnalyzeConnectorsRequestMultiError(errors)
	}

	return nil
}

// AnalyzeConnectorsRequestMultiError is an error wrapping multiple validation
// errors returned by AnalyzeConnectorsRequest.ValidateAll() if the designated
// constraints aren't met.
type AnalyzeConnectorsRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AnalyzeConnectorsRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AnalyzeConnectorsRequestMultiError) AllErrors() []error { return m }

// AnalyzeConnectorsRequestValidationError is the validation error returned by
// AnalyzeConnectorsRequest.Validate if the designated constraints aren't met.
type AnalyzeConnectorsRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AnalyzeConnectorsRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AnalyzeConnectorsRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AnalyzeConnectorsRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AnalyzeConnectorsRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AnalyzeConnectorsRequestValidationError) ErrorName() string {
	return "AnalyzeConnectorsRequestValidationError"
}

// Error satisfies the builtin error interface
func (e AnalyzeConnectorsRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAnalyzeConnectorsRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AnalyzeConnectorsRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AnalyzeConnectorsRequestValidationError{}

// Validate checks the field values on AnalyzeConnectorsResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *AnalyzeConnectorsResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on AnalyzeConnectorsResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// AnalyzeConnectorsResponseMultiError, or nil if none found.
func (m *AnalyzeConnectorsResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *AnalyzeConnectorsResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetConnectors() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, AnalyzeConnectorsResponseValidationError{
						field:  fmt.Sprintf("Connectors[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, AnalyzeConnectorsResponseValidationError{
						field:  fmt.Sprintf("Connectors[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return AnalyzeConnectorsResponseValidationError{
					field:  fmt.Sprintf("Connectors[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return AnalyzeConnectorsResponseMultiError(errors)
	}

	return nil
}

// AnalyzeConnectorsResponseMultiError is an error wrapping multiple validation
// errors returned by AnalyzeConnectorsResponse.ValidateAll() if the
// designated constraints aren't met.
type AnalyzeConnectorsResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AnalyzeConnectorsResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AnalyzeConnectorsResponseMultiError) AllErrors() []error { return m }

// AnalyzeConnectorsResponseValidationError is the validation error returned by
// AnalyzeConnectorsResponse.Validate if the designated constraints aren't met.
type AnalyzeConnectorsResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AnalyzeConnectorsResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AnalyzeConnectorsResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AnalyzeConnectorsResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AnalyzeConnectorsResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AnalyzeConnectorsResponseValidationError) ErrorName() string {
	return "AnalyzeConnectorsResponseValidationError"
}

// Error satisfies the builtin error interface
func (e AnalyzeConnectorsResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAnalyzeConnectorsResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AnalyzeConnectorsResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AnalyzeConnectorsResponseValidationError{}

// Validate checks the field values on ListNotifierConnectorsRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListNotifierConnectorsRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListNotifierConnectorsRequest with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// ListNotifierConnectorsRequestMultiError, or nil if none found.
func (m *ListNotifierConnectorsRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ListNotifierConnectorsRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for InstanceId

	if len(errors) > 0 {
		return ListNotifierConnectorsRequestMultiError(errors)
	}

	return nil
}

// ListNotifierConnectorsRequestMultiError is an error wrapping multiple
// validation errors returned by ListNotifierConnectorsRequest.ValidateAll()
// if the designated constraints aren't met.
type ListNotifierConnectorsRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListNotifierConnectorsRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListNotifierConnectorsRequestMultiError) AllErrors() []error { return m }

// ListNotifierConnectorsRequestValidationError is the validation error
// returned by ListNotifierConnectorsRequest.Validate if the designated
// constraints aren't met.
type ListNotifierConnectorsRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListNotifierConnectorsRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListNotifierConnectorsRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListNotifierConnectorsRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListNotifierConnectorsRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListNotifierConnectorsRequestValidationError) ErrorName() string {
	return "ListNotifierConnectorsRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ListNotifierConnectorsRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListNotifierConnectorsRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListNotifierConnectorsRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListNotifierConnectorsRequestValidationError{}

// Validate checks the field values on ListNotifierConnectorsResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListNotifierConnectorsResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListNotifierConnectorsResponse with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// ListNotifierConnectorsResponseMultiError, or nil if none found.
func (m *ListNotifierConnectorsResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ListNotifierConnectorsResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetConnectors() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListNotifierConnectorsResponseValidationError{
						field:  fmt.Sprintf("Connectors[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListNotifierConnectorsResponseValidationError{
						field:  fmt.Sprintf("Connectors[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListNotifierConnectorsResponseValidationError{
					field:  fmt.Sprintf("Connectors[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ListNotifierConnectorsResponseMultiError(errors)
	}

	return nil
}

// ListNotifierConnectorsResponseMultiError is an error wrapping multiple
// validation errors returned by ListNotifierConnectorsResponse.ValidateAll()
// if the designated constraints aren't met.
type ListNotifierConnectorsResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListNotifierConnectorsResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListNotifierConnectorsResponseMultiError) AllErrors() []error { return m }

// ListNotifierConnectorsResponseValidationError is the validation error
// returned by ListNotifierConnectorsResponse.Validate if the designated
// constraints aren't met.
type ListNotifierConnectorsResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListNotifierConnectorsResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListNotifierConnectorsResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListNotifierConnectorsResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListNotifierConnectorsResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListNotifierConnectorsResponseValidationError) ErrorName() string {
	return "ListNotifierConnectorsResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ListNotifierConnectorsResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListNotifierConnectorsResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListNotifierConnectorsResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListNotifierConnectorsResponseValidationError{}

// Validate checks the field values on IssueDevJWTRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *IssueDevJWTRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on IssueDevJWTRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// IssueDevJWTRequestMultiError, or nil if none found.
func (m *IssueDevJWTRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *IssueDevJWTRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetName()) < 1 {
		err := IssueDevJWTRequestValidationError{
			field:  "Name",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetEmail()) < 1 {
		err := IssueDevJWTRequestValidationError{
			field:  "Email",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Admin

	if all {
		switch v := interface{}(m.GetAttributes()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, IssueDevJWTRequestValidationError{
					field:  "Attributes",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, IssueDevJWTRequestValidationError{
					field:  "Attributes",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetAttributes()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return IssueDevJWTRequestValidationError{
				field:  "Attributes",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return IssueDevJWTRequestMultiError(errors)
	}

	return nil
}

// IssueDevJWTRequestMultiError is an error wrapping multiple validation errors
// returned by IssueDevJWTRequest.ValidateAll() if the designated constraints
// aren't met.
type IssueDevJWTRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m IssueDevJWTRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m IssueDevJWTRequestMultiError) AllErrors() []error { return m }

// IssueDevJWTRequestValidationError is the validation error returned by
// IssueDevJWTRequest.Validate if the designated constraints aren't met.
type IssueDevJWTRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e IssueDevJWTRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e IssueDevJWTRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e IssueDevJWTRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e IssueDevJWTRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e IssueDevJWTRequestValidationError) ErrorName() string {
	return "IssueDevJWTRequestValidationError"
}

// Error satisfies the builtin error interface
func (e IssueDevJWTRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sIssueDevJWTRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = IssueDevJWTRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = IssueDevJWTRequestValidationError{}

// Validate checks the field values on IssueDevJWTResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *IssueDevJWTResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on IssueDevJWTResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// IssueDevJWTResponseMultiError, or nil if none found.
func (m *IssueDevJWTResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *IssueDevJWTResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Jwt

	if len(errors) > 0 {
		return IssueDevJWTResponseMultiError(errors)
	}

	return nil
}

// IssueDevJWTResponseMultiError is an error wrapping multiple validation
// errors returned by IssueDevJWTResponse.ValidateAll() if the designated
// constraints aren't met.
type IssueDevJWTResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m IssueDevJWTResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m IssueDevJWTResponseMultiError) AllErrors() []error { return m }

// IssueDevJWTResponseValidationError is the validation error returned by
// IssueDevJWTResponse.Validate if the designated constraints aren't met.
type IssueDevJWTResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e IssueDevJWTResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e IssueDevJWTResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e IssueDevJWTResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e IssueDevJWTResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e IssueDevJWTResponseValidationError) ErrorName() string {
	return "IssueDevJWTResponseValidationError"
}

// Error satisfies the builtin error interface
func (e IssueDevJWTResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sIssueDevJWTResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = IssueDevJWTResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = IssueDevJWTResponseValidationError{}

// Validate checks the field values on AnalyzeVariablesRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *AnalyzeVariablesRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on AnalyzeVariablesRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// AnalyzeVariablesRequestMultiError, or nil if none found.
func (m *AnalyzeVariablesRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *AnalyzeVariablesRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for InstanceId

	if len(errors) > 0 {
		return AnalyzeVariablesRequestMultiError(errors)
	}

	return nil
}

// AnalyzeVariablesRequestMultiError is an error wrapping multiple validation
// errors returned by AnalyzeVariablesRequest.ValidateAll() if the designated
// constraints aren't met.
type AnalyzeVariablesRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AnalyzeVariablesRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AnalyzeVariablesRequestMultiError) AllErrors() []error { return m }

// AnalyzeVariablesRequestValidationError is the validation error returned by
// AnalyzeVariablesRequest.Validate if the designated constraints aren't met.
type AnalyzeVariablesRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AnalyzeVariablesRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AnalyzeVariablesRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AnalyzeVariablesRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AnalyzeVariablesRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AnalyzeVariablesRequestValidationError) ErrorName() string {
	return "AnalyzeVariablesRequestValidationError"
}

// Error satisfies the builtin error interface
func (e AnalyzeVariablesRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAnalyzeVariablesRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AnalyzeVariablesRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AnalyzeVariablesRequestValidationError{}

// Validate checks the field values on AnalyzeVariablesResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *AnalyzeVariablesResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on AnalyzeVariablesResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// AnalyzeVariablesResponseMultiError, or nil if none found.
func (m *AnalyzeVariablesResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *AnalyzeVariablesResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetVariables() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, AnalyzeVariablesResponseValidationError{
						field:  fmt.Sprintf("Variables[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, AnalyzeVariablesResponseValidationError{
						field:  fmt.Sprintf("Variables[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return AnalyzeVariablesResponseValidationError{
					field:  fmt.Sprintf("Variables[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return AnalyzeVariablesResponseMultiError(errors)
	}

	return nil
}

// AnalyzeVariablesResponseMultiError is an error wrapping multiple validation
// errors returned by AnalyzeVariablesResponse.ValidateAll() if the designated
// constraints aren't met.
type AnalyzeVariablesResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AnalyzeVariablesResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AnalyzeVariablesResponseMultiError) AllErrors() []error { return m }

// AnalyzeVariablesResponseValidationError is the validation error returned by
// AnalyzeVariablesResponse.Validate if the designated constraints aren't met.
type AnalyzeVariablesResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AnalyzeVariablesResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AnalyzeVariablesResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AnalyzeVariablesResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AnalyzeVariablesResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AnalyzeVariablesResponseValidationError) ErrorName() string {
	return "AnalyzeVariablesResponseValidationError"
}

// Error satisfies the builtin error interface
func (e AnalyzeVariablesResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAnalyzeVariablesResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AnalyzeVariablesResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AnalyzeVariablesResponseValidationError{}

// Validate checks the field values on AnalyzedVariable with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *AnalyzedVariable) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on AnalyzedVariable with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// AnalyzedVariableMultiError, or nil if none found.
func (m *AnalyzedVariable) ValidateAll() error {
	return m.validate(true)
}

func (m *AnalyzedVariable) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Name

	// no validation rules for DefaultValue

	for idx, item := range m.GetUsedBy() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, AnalyzedVariableValidationError{
						field:  fmt.Sprintf("UsedBy[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, AnalyzedVariableValidationError{
						field:  fmt.Sprintf("UsedBy[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return AnalyzedVariableValidationError{
					field:  fmt.Sprintf("UsedBy[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return AnalyzedVariableMultiError(errors)
	}

	return nil
}

// AnalyzedVariableMultiError is an error wrapping multiple validation errors
// returned by AnalyzedVariable.ValidateAll() if the designated constraints
// aren't met.
type AnalyzedVariableMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AnalyzedVariableMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AnalyzedVariableMultiError) AllErrors() []error { return m }

// AnalyzedVariableValidationError is the validation error returned by
// AnalyzedVariable.Validate if the designated constraints aren't met.
type AnalyzedVariableValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AnalyzedVariableValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AnalyzedVariableValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AnalyzedVariableValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AnalyzedVariableValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AnalyzedVariableValidationError) ErrorName() string { return "AnalyzedVariableValidationError" }

// Error satisfies the builtin error interface
func (e AnalyzedVariableValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAnalyzedVariable.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AnalyzedVariableValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AnalyzedVariableValidationError{}

// Validate checks the field values on ConnectorDriver_Property with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ConnectorDriver_Property) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ConnectorDriver_Property with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ConnectorDriver_PropertyMultiError, or nil if none found.
func (m *ConnectorDriver_Property) ValidateAll() error {
	return m.validate(true)
}

func (m *ConnectorDriver_Property) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Key

	// no validation rules for Type

	// no validation rules for Required

	// no validation rules for DisplayName

	// no validation rules for Description

	// no validation rules for DocsUrl

	// no validation rules for Hint

	// no validation rules for Default

	// no validation rules for Placeholder

	// no validation rules for Secret

	// no validation rules for NoPrompt

	if len(errors) > 0 {
		return ConnectorDriver_PropertyMultiError(errors)
	}

	return nil
}

// ConnectorDriver_PropertyMultiError is an error wrapping multiple validation
// errors returned by ConnectorDriver_Property.ValidateAll() if the designated
// constraints aren't met.
type ConnectorDriver_PropertyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ConnectorDriver_PropertyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ConnectorDriver_PropertyMultiError) AllErrors() []error { return m }

// ConnectorDriver_PropertyValidationError is the validation error returned by
// ConnectorDriver_Property.Validate if the designated constraints aren't met.
type ConnectorDriver_PropertyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ConnectorDriver_PropertyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ConnectorDriver_PropertyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ConnectorDriver_PropertyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ConnectorDriver_PropertyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ConnectorDriver_PropertyValidationError) ErrorName() string {
	return "ConnectorDriver_PropertyValidationError"
}

// Error satisfies the builtin error interface
func (e ConnectorDriver_PropertyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sConnectorDriver_Property.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ConnectorDriver_PropertyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ConnectorDriver_PropertyValidationError{}

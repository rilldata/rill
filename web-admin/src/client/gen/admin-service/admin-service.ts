/**
 * Generated by orval v7.9.0 üç∫
 * Do not edit manually.
 * rill/admin/v1/ai.proto
 * OpenAPI spec version: version not set
 */
import {
  createInfiniteQuery,
  createMutation,
  createQuery,
} from "@tanstack/svelte-query";
import type {
  CreateInfiniteQueryOptions,
  CreateInfiniteQueryResult,
  CreateMutationOptions,
  CreateMutationResult,
  CreateQueryOptions,
  CreateQueryResult,
  DataTag,
  InfiniteData,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
} from "@tanstack/svelte-query";

import type {
  AdminServiceAddOrganizationMemberUserBody,
  AdminServiceAddProjectMemberUserBody,
  AdminServiceCancelBillingSubscriptionParams,
  AdminServiceConnectProjectToGithubBody,
  AdminServiceCreateAlertBodyBody,
  AdminServiceCreateAssetBody,
  AdminServiceCreateDeploymentBody,
  AdminServiceCreateManagedGitRepoBody,
  AdminServiceCreateProjectBody,
  AdminServiceCreateProjectWhitelistedDomainBodyBody,
  AdminServiceCreateReportBodyBody,
  AdminServiceCreateServiceBody,
  AdminServiceCreateUsergroupBodyBody,
  AdminServiceDeleteUserParams,
  AdminServiceEditUsergroupBody,
  AdminServiceGetAlertMetaBody,
  AdminServiceGetBillingSubscriptionParams,
  AdminServiceGetCloneCredentialsParams,
  AdminServiceGetDeploymentBody,
  AdminServiceGetDeploymentCredentialsBody,
  AdminServiceGetGithubRepoStatusParams,
  AdminServiceGetIFrameBody,
  AdminServiceGetOrganizationParams,
  AdminServiceGetPaymentsPortalURLParams,
  AdminServiceGetProjectParams,
  AdminServiceGetProjectVariablesParams,
  AdminServiceGetReportMetaBody,
  AdminServiceGetUserParams,
  AdminServiceGetUsergroupParams,
  AdminServiceHibernateProjectParams,
  AdminServiceIssueMagicAuthTokenBody,
  AdminServiceIssueUserAuthTokenBody,
  AdminServiceListBookmarksParams,
  AdminServiceListDeploymentsParams,
  AdminServiceListMagicAuthTokensParams,
  AdminServiceListOrganizationBillingIssuesParams,
  AdminServiceListOrganizationInvitesParams,
  AdminServiceListOrganizationMemberUsergroupsParams,
  AdminServiceListOrganizationMemberUsersParams,
  AdminServiceListOrganizationsParams,
  AdminServiceListProjectInvitesParams,
  AdminServiceListProjectMemberUsergroupsParams,
  AdminServiceListProjectMemberUsersParams,
  AdminServiceListProjectsForFingerprintParams,
  AdminServiceListProjectsForOrganizationAndUserParams,
  AdminServiceListProjectsForOrganizationParams,
  AdminServiceListProjectsForUserByNameParams,
  AdminServiceListUserAuthTokensParams,
  AdminServiceListUsergroupMemberUsersParams,
  AdminServiceListUsergroupsForOrganizationAndUserParams,
  AdminServiceProvisionBody,
  AdminServicePullVirtualRepoParams,
  AdminServiceRedeployProjectParams,
  AdminServiceRevokeUserAuthTokenParams,
  AdminServiceSearchProjectNamesParams,
  AdminServiceSearchProjectUsersParams,
  AdminServiceSearchUsersParams,
  AdminServiceSetOrganizationMemberUserRoleBody,
  AdminServiceSetProjectMemberUserRoleBodyBody,
  AdminServiceSudoGetResourceParams,
  AdminServiceTriggerReconcileBodyBody,
  AdminServiceTriggerRefreshSourcesBody,
  AdminServiceUnsubscribeReportBody,
  AdminServiceUpdateBillingSubscriptionBodyBody,
  AdminServiceUpdateOrganizationBody,
  AdminServiceUpdateProjectBody,
  AdminServiceUpdateProjectVariablesBody,
  AdminServiceUpdateServiceBody,
  RpcStatus,
  V1AddOrganizationMemberUserResponse,
  V1AddOrganizationMemberUsergroupResponse,
  V1AddProjectMemberUserResponse,
  V1AddProjectMemberUsergroupResponse,
  V1AddUsergroupMemberUserResponse,
  V1ApproveProjectAccessResponse,
  V1CancelBillingSubscriptionResponse,
  V1ConnectProjectToGithubResponse,
  V1CreateAlertResponse,
  V1CreateAssetResponse,
  V1CreateBookmarkRequest,
  V1CreateBookmarkResponse,
  V1CreateDeploymentResponse,
  V1CreateManagedGitRepoResponse,
  V1CreateOrganizationRequest,
  V1CreateOrganizationResponse,
  V1CreateProjectResponse,
  V1CreateProjectWhitelistedDomainResponse,
  V1CreateReportResponse,
  V1CreateServiceResponse,
  V1CreateUsergroupResponse,
  V1CreateWhitelistedDomainResponse,
  V1DeleteAlertResponse,
  V1DeleteDeploymentResponse,
  V1DeleteOrganizationResponse,
  V1DeleteProjectResponse,
  V1DeleteReportResponse,
  V1DeleteServiceResponse,
  V1DeleteUserResponse,
  V1DeleteUsergroupResponse,
  V1DenyProjectAccessResponse,
  V1DisconnectProjectFromGithubResponse,
  V1EditAlertResponse,
  V1EditReportResponse,
  V1EditUsergroupResponse,
  V1GenerateAlertYAMLResponse,
  V1GenerateReportYAMLResponse,
  V1GetAlertMetaResponse,
  V1GetAlertYAMLResponse,
  V1GetBillingProjectCredentialsRequest,
  V1GetBillingProjectCredentialsResponse,
  V1GetBillingSubscriptionResponse,
  V1GetBookmarkResponse,
  V1GetCloneCredentialsResponse,
  V1GetCurrentMagicAuthTokenResponse,
  V1GetCurrentUserResponse,
  V1GetDeploymentCredentialsResponse,
  V1GetDeploymentResponse,
  V1GetGithubRepoStatusResponse,
  V1GetGithubUserStatusResponse,
  V1GetIFrameResponse,
  V1GetOrganizationNameForDomainResponse,
  V1GetOrganizationResponse,
  V1GetPaymentsPortalURLResponse,
  V1GetProjectAccessRequestResponse,
  V1GetProjectByIDResponse,
  V1GetProjectResponse,
  V1GetProjectVariablesResponse,
  V1GetRepoMetaResponse,
  V1GetReportMetaResponse,
  V1GetServiceResponse,
  V1GetUserResponse,
  V1GetUsergroupResponse,
  V1HibernateProjectResponse,
  V1IssueMagicAuthTokenResponse,
  V1IssueRepresentativeAuthTokenRequest,
  V1IssueRepresentativeAuthTokenResponse,
  V1IssueServiceAuthTokenResponse,
  V1IssueUserAuthTokenResponse,
  V1LeaveOrganizationResponse,
  V1ListBookmarksResponse,
  V1ListDeploymentsResponse,
  V1ListGithubUserReposResponse,
  V1ListMagicAuthTokensResponse,
  V1ListOrganizationBillingIssuesResponse,
  V1ListOrganizationInvitesResponse,
  V1ListOrganizationMemberUsergroupsResponse,
  V1ListOrganizationMemberUsersResponse,
  V1ListOrganizationsResponse,
  V1ListProjectInvitesResponse,
  V1ListProjectMemberServicesResponse,
  V1ListProjectMemberUsergroupsResponse,
  V1ListProjectMemberUsersResponse,
  V1ListProjectWhitelistedDomainsResponse,
  V1ListProjectsForFingerprintResponse,
  V1ListProjectsForOrganizationAndUserResponse,
  V1ListProjectsForOrganizationResponse,
  V1ListProjectsForUserByNameResponse,
  V1ListPublicBillingPlansResponse,
  V1ListRolesResponse,
  V1ListServiceAuthTokensResponse,
  V1ListServicesResponse,
  V1ListSuperusersResponse,
  V1ListUserAuthTokensResponse,
  V1ListUsergroupMemberUsersResponse,
  V1ListUsergroupsForOrganizationAndUserResponse,
  V1ListWhitelistedDomainsResponse,
  V1PingResponse,
  V1ProvisionResponse,
  V1PullVirtualRepoResponse,
  V1RedeployProjectResponse,
  V1RemoveBookmarkResponse,
  V1RemoveOrganizationMemberServiceResponse,
  V1RemoveOrganizationMemberUserResponse,
  V1RemoveOrganizationMemberUsergroupResponse,
  V1RemoveProjectMemberServiceResponse,
  V1RemoveProjectMemberUserResponse,
  V1RemoveProjectMemberUsergroupResponse,
  V1RemoveProjectWhitelistedDomainResponse,
  V1RemoveUsergroupMemberUserResponse,
  V1RemoveWhitelistedDomainResponse,
  V1RenameUsergroupResponse,
  V1RenewBillingSubscriptionResponse,
  V1RequestProjectAccessResponse,
  V1RevokeCurrentAuthTokenResponse,
  V1RevokeMagicAuthTokenResponse,
  V1RevokeServiceAuthTokenResponse,
  V1RevokeUserAuthTokenResponse,
  V1SearchProjectNamesResponse,
  V1SearchProjectUsersResponse,
  V1SearchUsersResponse,
  V1SetOrganizationMemberServiceRoleResponse,
  V1SetOrganizationMemberUserRoleResponse,
  V1SetOrganizationMemberUsergroupRoleResponse,
  V1SetProjectMemberServiceRoleResponse,
  V1SetProjectMemberUserRoleResponse,
  V1SetProjectMemberUsergroupRoleResponse,
  V1SetSuperuserRequest,
  V1SetSuperuserResponse,
  V1StartDeploymentResponse,
  V1StopDeploymentResponse,
  V1SudoDeleteOrganizationBillingIssueResponse,
  V1SudoExtendTrialRequest,
  V1SudoExtendTrialResponse,
  V1SudoGetResourceResponse,
  V1SudoIssueRuntimeManagerTokenRequest,
  V1SudoIssueRuntimeManagerTokenResponse,
  V1SudoTriggerBillingRepairRequest,
  V1SudoTriggerBillingRepairResponse,
  V1SudoUpdateAnnotationsRequest,
  V1SudoUpdateAnnotationsResponse,
  V1SudoUpdateOrganizationBillingCustomerRequest,
  V1SudoUpdateOrganizationBillingCustomerResponse,
  V1SudoUpdateOrganizationCustomDomainRequest,
  V1SudoUpdateOrganizationCustomDomainResponse,
  V1SudoUpdateOrganizationQuotasRequest,
  V1SudoUpdateOrganizationQuotasResponse,
  V1SudoUpdateUserQuotasRequest,
  V1SudoUpdateUserQuotasResponse,
  V1TriggerReconcileResponse,
  V1TriggerRedeployRequest,
  V1TriggerRedeployResponse,
  V1TriggerRefreshSourcesResponse,
  V1TriggerReportResponse,
  V1UnsubscribeAlertResponse,
  V1UnsubscribeReportResponse,
  V1UpdateBillingSubscriptionResponse,
  V1UpdateBookmarkRequest,
  V1UpdateBookmarkResponse,
  V1UpdateOrganizationResponse,
  V1UpdateProjectResponse,
  V1UpdateProjectVariablesResponse,
  V1UpdateServiceResponse,
  V1UpdateUserPreferencesRequest,
  V1UpdateUserPreferencesResponse,
} from "../index.schemas";

import { httpClient } from "../../http-client";

type AwaitedInput<T> = PromiseLike<T> | T;

type Awaited<O> = O extends AwaitedInput<infer T> ? T : never;

/**
 * @summary GetBillingProjectCredentials returns credentials for the configured cloud metrics project filtered by request organization
 */
export const adminServiceGetBillingProjectCredentials = (
  v1GetBillingProjectCredentialsRequest: V1GetBillingProjectCredentialsRequest,
  signal?: AbortSignal,
) => {
  return httpClient<V1GetBillingProjectCredentialsResponse>({
    url: `/v1/billing/metrics-project-credentials`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: v1GetBillingProjectCredentialsRequest,
    signal,
  });
};

export const getAdminServiceGetBillingProjectCredentialsQueryKey = (
  v1GetBillingProjectCredentialsRequest: V1GetBillingProjectCredentialsRequest,
) => {
  return [
    `/v1/billing/metrics-project-credentials`,
    v1GetBillingProjectCredentialsRequest,
  ] as const;
};

export const getAdminServiceGetBillingProjectCredentialsQueryOptions = <
  TData = Awaited<ReturnType<typeof adminServiceGetBillingProjectCredentials>>,
  TError = RpcStatus,
>(
  v1GetBillingProjectCredentialsRequest: V1GetBillingProjectCredentialsRequest,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof adminServiceGetBillingProjectCredentials>>,
        TError,
        TData
      >
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getAdminServiceGetBillingProjectCredentialsQueryKey(
      v1GetBillingProjectCredentialsRequest,
    );

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof adminServiceGetBillingProjectCredentials>>
  > = ({ signal }) =>
    adminServiceGetBillingProjectCredentials(
      v1GetBillingProjectCredentialsRequest,
      signal,
    );

  return { queryKey, queryFn, ...queryOptions } as CreateQueryOptions<
    Awaited<ReturnType<typeof adminServiceGetBillingProjectCredentials>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type AdminServiceGetBillingProjectCredentialsQueryResult = NonNullable<
  Awaited<ReturnType<typeof adminServiceGetBillingProjectCredentials>>
>;
export type AdminServiceGetBillingProjectCredentialsQueryError = RpcStatus;

/**
 * @summary GetBillingProjectCredentials returns credentials for the configured cloud metrics project filtered by request organization
 */

export function createAdminServiceGetBillingProjectCredentials<
  TData = Awaited<ReturnType<typeof adminServiceGetBillingProjectCredentials>>,
  TError = RpcStatus,
>(
  v1GetBillingProjectCredentialsRequest: V1GetBillingProjectCredentialsRequest,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof adminServiceGetBillingProjectCredentials>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): CreateQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getAdminServiceGetBillingProjectCredentialsQueryOptions(
    v1GetBillingProjectCredentialsRequest,
    options,
  );

  const query = createQuery(queryOptions, queryClient) as CreateQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary ListPublicBillingPlans lists all public billing plans
 */
export const adminServiceListPublicBillingPlans = (signal?: AbortSignal) => {
  return httpClient<V1ListPublicBillingPlansResponse>({
    url: `/v1/billing/plans`,
    method: "GET",
    signal,
  });
};

export const getAdminServiceListPublicBillingPlansQueryKey = () => {
  return [`/v1/billing/plans`] as const;
};

export const getAdminServiceListPublicBillingPlansQueryOptions = <
  TData = Awaited<ReturnType<typeof adminServiceListPublicBillingPlans>>,
  TError = RpcStatus,
>(options?: {
  query?: Partial<
    CreateQueryOptions<
      Awaited<ReturnType<typeof adminServiceListPublicBillingPlans>>,
      TError,
      TData
    >
  >;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getAdminServiceListPublicBillingPlansQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof adminServiceListPublicBillingPlans>>
  > = ({ signal }) => adminServiceListPublicBillingPlans(signal);

  return { queryKey, queryFn, ...queryOptions } as CreateQueryOptions<
    Awaited<ReturnType<typeof adminServiceListPublicBillingPlans>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type AdminServiceListPublicBillingPlansQueryResult = NonNullable<
  Awaited<ReturnType<typeof adminServiceListPublicBillingPlans>>
>;
export type AdminServiceListPublicBillingPlansQueryError = RpcStatus;

/**
 * @summary ListPublicBillingPlans lists all public billing plans
 */

export function createAdminServiceListPublicBillingPlans<
  TData = Awaited<ReturnType<typeof adminServiceListPublicBillingPlans>>,
  TError = RpcStatus,
>(
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof adminServiceListPublicBillingPlans>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): CreateQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions =
    getAdminServiceListPublicBillingPlansQueryOptions(options);

  const query = createQuery(queryOptions, queryClient) as CreateQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary DeleteDeployment deletes a deployment.
 */
export const adminServiceDeleteDeployment = (deploymentId: string) => {
  return httpClient<V1DeleteDeploymentResponse>({
    url: `/v1/deployments/${deploymentId}`,
    method: "DELETE",
  });
};

export const getAdminServiceDeleteDeploymentMutationOptions = <
  TError = RpcStatus,
  TContext = unknown,
>(options?: {
  mutation?: CreateMutationOptions<
    Awaited<ReturnType<typeof adminServiceDeleteDeployment>>,
    TError,
    { deploymentId: string },
    TContext
  >;
}): CreateMutationOptions<
  Awaited<ReturnType<typeof adminServiceDeleteDeployment>>,
  TError,
  { deploymentId: string },
  TContext
> => {
  const mutationKey = ["adminServiceDeleteDeployment"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof adminServiceDeleteDeployment>>,
    { deploymentId: string }
  > = (props) => {
    const { deploymentId } = props ?? {};

    return adminServiceDeleteDeployment(deploymentId);
  };

  return { mutationFn, ...mutationOptions };
};

export type AdminServiceDeleteDeploymentMutationResult = NonNullable<
  Awaited<ReturnType<typeof adminServiceDeleteDeployment>>
>;

export type AdminServiceDeleteDeploymentMutationError = RpcStatus;

/**
 * @summary DeleteDeployment deletes a deployment.
 */
export const createAdminServiceDeleteDeployment = <
  TError = RpcStatus,
  TContext = unknown,
>(
  options?: {
    mutation?: CreateMutationOptions<
      Awaited<ReturnType<typeof adminServiceDeleteDeployment>>,
      TError,
      { deploymentId: string },
      TContext
    >;
  },
  queryClient?: QueryClient,
): CreateMutationResult<
  Awaited<ReturnType<typeof adminServiceDeleteDeployment>>,
  TError,
  { deploymentId: string },
  TContext
> => {
  const mutationOptions =
    getAdminServiceDeleteDeploymentMutationOptions(options);

  return createMutation(mutationOptions, queryClient);
};
/**
 * @summary GetDeployment returns runtime info and access token on behalf of a specific user, or alternatively for a raw set of JWT attributes
 */
export const adminServiceGetDeployment = (
  deploymentId: string,
  adminServiceGetDeploymentBody: AdminServiceGetDeploymentBody,
  signal?: AbortSignal,
) => {
  return httpClient<V1GetDeploymentResponse>({
    url: `/v1/deployments/${deploymentId}/credentials`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: adminServiceGetDeploymentBody,
    signal,
  });
};

export const getAdminServiceGetDeploymentMutationOptions = <
  TError = RpcStatus,
  TContext = unknown,
>(options?: {
  mutation?: CreateMutationOptions<
    Awaited<ReturnType<typeof adminServiceGetDeployment>>,
    TError,
    { deploymentId: string; data: AdminServiceGetDeploymentBody },
    TContext
  >;
}): CreateMutationOptions<
  Awaited<ReturnType<typeof adminServiceGetDeployment>>,
  TError,
  { deploymentId: string; data: AdminServiceGetDeploymentBody },
  TContext
> => {
  const mutationKey = ["adminServiceGetDeployment"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof adminServiceGetDeployment>>,
    { deploymentId: string; data: AdminServiceGetDeploymentBody }
  > = (props) => {
    const { deploymentId, data } = props ?? {};

    return adminServiceGetDeployment(deploymentId, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type AdminServiceGetDeploymentMutationResult = NonNullable<
  Awaited<ReturnType<typeof adminServiceGetDeployment>>
>;
export type AdminServiceGetDeploymentMutationBody =
  AdminServiceGetDeploymentBody;
export type AdminServiceGetDeploymentMutationError = RpcStatus;

/**
 * @summary GetDeployment returns runtime info and access token on behalf of a specific user, or alternatively for a raw set of JWT attributes
 */
export const createAdminServiceGetDeployment = <
  TError = RpcStatus,
  TContext = unknown,
>(
  options?: {
    mutation?: CreateMutationOptions<
      Awaited<ReturnType<typeof adminServiceGetDeployment>>,
      TError,
      { deploymentId: string; data: AdminServiceGetDeploymentBody },
      TContext
    >;
  },
  queryClient?: QueryClient,
): CreateMutationResult<
  Awaited<ReturnType<typeof adminServiceGetDeployment>>,
  TError,
  { deploymentId: string; data: AdminServiceGetDeploymentBody },
  TContext
> => {
  const mutationOptions = getAdminServiceGetDeploymentMutationOptions(options);

  return createMutation(mutationOptions, queryClient);
};
/**
 * @summary Provision provisions a new resource for a deployment.
If an existing resource matches the request, it will be returned without provisioning a new resource.
 */
export const adminServiceProvision = (
  deploymentId: string,
  adminServiceProvisionBody: AdminServiceProvisionBody,
  signal?: AbortSignal,
) => {
  return httpClient<V1ProvisionResponse>({
    url: `/v1/deployments/${deploymentId}/provision`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: adminServiceProvisionBody,
    signal,
  });
};

export const getAdminServiceProvisionMutationOptions = <
  TError = RpcStatus,
  TContext = unknown,
>(options?: {
  mutation?: CreateMutationOptions<
    Awaited<ReturnType<typeof adminServiceProvision>>,
    TError,
    { deploymentId: string; data: AdminServiceProvisionBody },
    TContext
  >;
}): CreateMutationOptions<
  Awaited<ReturnType<typeof adminServiceProvision>>,
  TError,
  { deploymentId: string; data: AdminServiceProvisionBody },
  TContext
> => {
  const mutationKey = ["adminServiceProvision"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof adminServiceProvision>>,
    { deploymentId: string; data: AdminServiceProvisionBody }
  > = (props) => {
    const { deploymentId, data } = props ?? {};

    return adminServiceProvision(deploymentId, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type AdminServiceProvisionMutationResult = NonNullable<
  Awaited<ReturnType<typeof adminServiceProvision>>
>;
export type AdminServiceProvisionMutationBody = AdminServiceProvisionBody;
export type AdminServiceProvisionMutationError = RpcStatus;

/**
 * @summary Provision provisions a new resource for a deployment.
If an existing resource matches the request, it will be returned without provisioning a new resource.
 */
export const createAdminServiceProvision = <
  TError = RpcStatus,
  TContext = unknown,
>(
  options?: {
    mutation?: CreateMutationOptions<
      Awaited<ReturnType<typeof adminServiceProvision>>,
      TError,
      { deploymentId: string; data: AdminServiceProvisionBody },
      TContext
    >;
  },
  queryClient?: QueryClient,
): CreateMutationResult<
  Awaited<ReturnType<typeof adminServiceProvision>>,
  TError,
  { deploymentId: string; data: AdminServiceProvisionBody },
  TContext
> => {
  const mutationOptions = getAdminServiceProvisionMutationOptions(options);

  return createMutation(mutationOptions, queryClient);
};
/**
 * @summary TriggerReconcile triggers reconcile for the project's prod deployment.
DEPRECATED: Clients should call CreateTrigger directly on the deployed runtime instead.
 */
export const adminServiceTriggerReconcile = (
  deploymentId: string,
  adminServiceTriggerReconcileBodyBody: AdminServiceTriggerReconcileBodyBody,
  signal?: AbortSignal,
) => {
  return httpClient<V1TriggerReconcileResponse>({
    url: `/v1/deployments/${deploymentId}/reconcile`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: adminServiceTriggerReconcileBodyBody,
    signal,
  });
};

export const getAdminServiceTriggerReconcileMutationOptions = <
  TError = RpcStatus,
  TContext = unknown,
>(options?: {
  mutation?: CreateMutationOptions<
    Awaited<ReturnType<typeof adminServiceTriggerReconcile>>,
    TError,
    { deploymentId: string; data: AdminServiceTriggerReconcileBodyBody },
    TContext
  >;
}): CreateMutationOptions<
  Awaited<ReturnType<typeof adminServiceTriggerReconcile>>,
  TError,
  { deploymentId: string; data: AdminServiceTriggerReconcileBodyBody },
  TContext
> => {
  const mutationKey = ["adminServiceTriggerReconcile"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof adminServiceTriggerReconcile>>,
    { deploymentId: string; data: AdminServiceTriggerReconcileBodyBody }
  > = (props) => {
    const { deploymentId, data } = props ?? {};

    return adminServiceTriggerReconcile(deploymentId, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type AdminServiceTriggerReconcileMutationResult = NonNullable<
  Awaited<ReturnType<typeof adminServiceTriggerReconcile>>
>;
export type AdminServiceTriggerReconcileMutationBody =
  AdminServiceTriggerReconcileBodyBody;
export type AdminServiceTriggerReconcileMutationError = RpcStatus;

/**
 * @summary TriggerReconcile triggers reconcile for the project's prod deployment.
DEPRECATED: Clients should call CreateTrigger directly on the deployed runtime instead.
 */
export const createAdminServiceTriggerReconcile = <
  TError = RpcStatus,
  TContext = unknown,
>(
  options?: {
    mutation?: CreateMutationOptions<
      Awaited<ReturnType<typeof adminServiceTriggerReconcile>>,
      TError,
      { deploymentId: string; data: AdminServiceTriggerReconcileBodyBody },
      TContext
    >;
  },
  queryClient?: QueryClient,
): CreateMutationResult<
  Awaited<ReturnType<typeof adminServiceTriggerReconcile>>,
  TError,
  { deploymentId: string; data: AdminServiceTriggerReconcileBodyBody },
  TContext
> => {
  const mutationOptions =
    getAdminServiceTriggerReconcileMutationOptions(options);

  return createMutation(mutationOptions, queryClient);
};
/**
 * @summary TriggerRefreshSources refresh the source for production deployment.
DEPRECATED: Clients should call CreateTrigger directly on the deployed runtime instead.
 */
export const adminServiceTriggerRefreshSources = (
  deploymentId: string,
  adminServiceTriggerRefreshSourcesBody: AdminServiceTriggerRefreshSourcesBody,
  signal?: AbortSignal,
) => {
  return httpClient<V1TriggerRefreshSourcesResponse>({
    url: `/v1/deployments/${deploymentId}/refresh`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: adminServiceTriggerRefreshSourcesBody,
    signal,
  });
};

export const getAdminServiceTriggerRefreshSourcesMutationOptions = <
  TError = RpcStatus,
  TContext = unknown,
>(options?: {
  mutation?: CreateMutationOptions<
    Awaited<ReturnType<typeof adminServiceTriggerRefreshSources>>,
    TError,
    { deploymentId: string; data: AdminServiceTriggerRefreshSourcesBody },
    TContext
  >;
}): CreateMutationOptions<
  Awaited<ReturnType<typeof adminServiceTriggerRefreshSources>>,
  TError,
  { deploymentId: string; data: AdminServiceTriggerRefreshSourcesBody },
  TContext
> => {
  const mutationKey = ["adminServiceTriggerRefreshSources"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof adminServiceTriggerRefreshSources>>,
    { deploymentId: string; data: AdminServiceTriggerRefreshSourcesBody }
  > = (props) => {
    const { deploymentId, data } = props ?? {};

    return adminServiceTriggerRefreshSources(deploymentId, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type AdminServiceTriggerRefreshSourcesMutationResult = NonNullable<
  Awaited<ReturnType<typeof adminServiceTriggerRefreshSources>>
>;
export type AdminServiceTriggerRefreshSourcesMutationBody =
  AdminServiceTriggerRefreshSourcesBody;
export type AdminServiceTriggerRefreshSourcesMutationError = RpcStatus;

/**
 * @summary TriggerRefreshSources refresh the source for production deployment.
DEPRECATED: Clients should call CreateTrigger directly on the deployed runtime instead.
 */
export const createAdminServiceTriggerRefreshSources = <
  TError = RpcStatus,
  TContext = unknown,
>(
  options?: {
    mutation?: CreateMutationOptions<
      Awaited<ReturnType<typeof adminServiceTriggerRefreshSources>>,
      TError,
      { deploymentId: string; data: AdminServiceTriggerRefreshSourcesBody },
      TContext
    >;
  },
  queryClient?: QueryClient,
): CreateMutationResult<
  Awaited<ReturnType<typeof adminServiceTriggerRefreshSources>>,
  TError,
  { deploymentId: string; data: AdminServiceTriggerRefreshSourcesBody },
  TContext
> => {
  const mutationOptions =
    getAdminServiceTriggerRefreshSourcesMutationOptions(options);

  return createMutation(mutationOptions, queryClient);
};
/**
 * @summary StartDeployment starts a deployment.
 */
export const adminServiceStartDeployment = (
  deploymentId: string,
  adminServiceTriggerReconcileBodyBody: AdminServiceTriggerReconcileBodyBody,
  signal?: AbortSignal,
) => {
  return httpClient<V1StartDeploymentResponse>({
    url: `/v1/deployments/${deploymentId}/start`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: adminServiceTriggerReconcileBodyBody,
    signal,
  });
};

export const getAdminServiceStartDeploymentMutationOptions = <
  TError = RpcStatus,
  TContext = unknown,
>(options?: {
  mutation?: CreateMutationOptions<
    Awaited<ReturnType<typeof adminServiceStartDeployment>>,
    TError,
    { deploymentId: string; data: AdminServiceTriggerReconcileBodyBody },
    TContext
  >;
}): CreateMutationOptions<
  Awaited<ReturnType<typeof adminServiceStartDeployment>>,
  TError,
  { deploymentId: string; data: AdminServiceTriggerReconcileBodyBody },
  TContext
> => {
  const mutationKey = ["adminServiceStartDeployment"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof adminServiceStartDeployment>>,
    { deploymentId: string; data: AdminServiceTriggerReconcileBodyBody }
  > = (props) => {
    const { deploymentId, data } = props ?? {};

    return adminServiceStartDeployment(deploymentId, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type AdminServiceStartDeploymentMutationResult = NonNullable<
  Awaited<ReturnType<typeof adminServiceStartDeployment>>
>;
export type AdminServiceStartDeploymentMutationBody =
  AdminServiceTriggerReconcileBodyBody;
export type AdminServiceStartDeploymentMutationError = RpcStatus;

/**
 * @summary StartDeployment starts a deployment.
 */
export const createAdminServiceStartDeployment = <
  TError = RpcStatus,
  TContext = unknown,
>(
  options?: {
    mutation?: CreateMutationOptions<
      Awaited<ReturnType<typeof adminServiceStartDeployment>>,
      TError,
      { deploymentId: string; data: AdminServiceTriggerReconcileBodyBody },
      TContext
    >;
  },
  queryClient?: QueryClient,
): CreateMutationResult<
  Awaited<ReturnType<typeof adminServiceStartDeployment>>,
  TError,
  { deploymentId: string; data: AdminServiceTriggerReconcileBodyBody },
  TContext
> => {
  const mutationOptions =
    getAdminServiceStartDeploymentMutationOptions(options);

  return createMutation(mutationOptions, queryClient);
};
/**
 * @summary StopDeployment stops a deployment.
 */
export const adminServiceStopDeployment = (
  deploymentId: string,
  adminServiceTriggerReconcileBodyBody: AdminServiceTriggerReconcileBodyBody,
  signal?: AbortSignal,
) => {
  return httpClient<V1StopDeploymentResponse>({
    url: `/v1/deployments/${deploymentId}/stop`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: adminServiceTriggerReconcileBodyBody,
    signal,
  });
};

export const getAdminServiceStopDeploymentMutationOptions = <
  TError = RpcStatus,
  TContext = unknown,
>(options?: {
  mutation?: CreateMutationOptions<
    Awaited<ReturnType<typeof adminServiceStopDeployment>>,
    TError,
    { deploymentId: string; data: AdminServiceTriggerReconcileBodyBody },
    TContext
  >;
}): CreateMutationOptions<
  Awaited<ReturnType<typeof adminServiceStopDeployment>>,
  TError,
  { deploymentId: string; data: AdminServiceTriggerReconcileBodyBody },
  TContext
> => {
  const mutationKey = ["adminServiceStopDeployment"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof adminServiceStopDeployment>>,
    { deploymentId: string; data: AdminServiceTriggerReconcileBodyBody }
  > = (props) => {
    const { deploymentId, data } = props ?? {};

    return adminServiceStopDeployment(deploymentId, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type AdminServiceStopDeploymentMutationResult = NonNullable<
  Awaited<ReturnType<typeof adminServiceStopDeployment>>
>;
export type AdminServiceStopDeploymentMutationBody =
  AdminServiceTriggerReconcileBodyBody;
export type AdminServiceStopDeploymentMutationError = RpcStatus;

/**
 * @summary StopDeployment stops a deployment.
 */
export const createAdminServiceStopDeployment = <
  TError = RpcStatus,
  TContext = unknown,
>(
  options?: {
    mutation?: CreateMutationOptions<
      Awaited<ReturnType<typeof adminServiceStopDeployment>>,
      TError,
      { deploymentId: string; data: AdminServiceTriggerReconcileBodyBody },
      TContext
    >;
  },
  queryClient?: QueryClient,
): CreateMutationResult<
  Awaited<ReturnType<typeof adminServiceStopDeployment>>,
  TError,
  { deploymentId: string; data: AdminServiceTriggerReconcileBodyBody },
  TContext
> => {
  const mutationOptions = getAdminServiceStopDeploymentMutationOptions(options);

  return createMutation(mutationOptions, queryClient);
};
/**
 * @summary GetGithubRepoRequest returns info about a Github repo based on the caller's installations.
If the caller has not granted access to the repository, instructions for granting access are returned.
 */
export const adminServiceGetGithubRepoStatus = (
  params?: AdminServiceGetGithubRepoStatusParams,
  signal?: AbortSignal,
) => {
  return httpClient<V1GetGithubRepoStatusResponse>({
    url: `/v1/github/repositories`,
    method: "GET",
    params,
    signal,
  });
};

export const getAdminServiceGetGithubRepoStatusQueryKey = (
  params?: AdminServiceGetGithubRepoStatusParams,
) => {
  return [`/v1/github/repositories`, ...(params ? [params] : [])] as const;
};

export const getAdminServiceGetGithubRepoStatusQueryOptions = <
  TData = Awaited<ReturnType<typeof adminServiceGetGithubRepoStatus>>,
  TError = RpcStatus,
>(
  params?: AdminServiceGetGithubRepoStatusParams,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof adminServiceGetGithubRepoStatus>>,
        TError,
        TData
      >
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getAdminServiceGetGithubRepoStatusQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof adminServiceGetGithubRepoStatus>>
  > = ({ signal }) => adminServiceGetGithubRepoStatus(params, signal);

  return { queryKey, queryFn, ...queryOptions } as CreateQueryOptions<
    Awaited<ReturnType<typeof adminServiceGetGithubRepoStatus>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type AdminServiceGetGithubRepoStatusQueryResult = NonNullable<
  Awaited<ReturnType<typeof adminServiceGetGithubRepoStatus>>
>;
export type AdminServiceGetGithubRepoStatusQueryError = RpcStatus;

/**
 * @summary GetGithubRepoRequest returns info about a Github repo based on the caller's installations.
If the caller has not granted access to the repository, instructions for granting access are returned.
 */

export function createAdminServiceGetGithubRepoStatus<
  TData = Awaited<ReturnType<typeof adminServiceGetGithubRepoStatus>>,
  TError = RpcStatus,
>(
  params?: AdminServiceGetGithubRepoStatusParams,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof adminServiceGetGithubRepoStatus>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): CreateQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getAdminServiceGetGithubRepoStatusQueryOptions(
    params,
    options,
  );

  const query = createQuery(queryOptions, queryClient) as CreateQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary GetGithubUserStatus returns info about a Github user account based on the caller's installations.
If we don't have access to user's personal account tokens or it is expired, instructions for granting access are returned.
 */
export const adminServiceGetGithubUserStatus = (signal?: AbortSignal) => {
  return httpClient<V1GetGithubUserStatusResponse>({
    url: `/v1/github/user`,
    method: "GET",
    signal,
  });
};

export const getAdminServiceGetGithubUserStatusQueryKey = () => {
  return [`/v1/github/user`] as const;
};

export const getAdminServiceGetGithubUserStatusQueryOptions = <
  TData = Awaited<ReturnType<typeof adminServiceGetGithubUserStatus>>,
  TError = RpcStatus,
>(options?: {
  query?: Partial<
    CreateQueryOptions<
      Awaited<ReturnType<typeof adminServiceGetGithubUserStatus>>,
      TError,
      TData
    >
  >;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getAdminServiceGetGithubUserStatusQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof adminServiceGetGithubUserStatus>>
  > = ({ signal }) => adminServiceGetGithubUserStatus(signal);

  return { queryKey, queryFn, ...queryOptions } as CreateQueryOptions<
    Awaited<ReturnType<typeof adminServiceGetGithubUserStatus>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type AdminServiceGetGithubUserStatusQueryResult = NonNullable<
  Awaited<ReturnType<typeof adminServiceGetGithubUserStatus>>
>;
export type AdminServiceGetGithubUserStatusQueryError = RpcStatus;

/**
 * @summary GetGithubUserStatus returns info about a Github user account based on the caller's installations.
If we don't have access to user's personal account tokens or it is expired, instructions for granting access are returned.
 */

export function createAdminServiceGetGithubUserStatus<
  TData = Awaited<ReturnType<typeof adminServiceGetGithubUserStatus>>,
  TError = RpcStatus,
>(
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof adminServiceGetGithubUserStatus>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): CreateQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getAdminServiceGetGithubUserStatusQueryOptions(options);

  const query = createQuery(queryOptions, queryClient) as CreateQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const adminServiceListGithubUserRepos = (signal?: AbortSignal) => {
  return httpClient<V1ListGithubUserReposResponse>({
    url: `/v1/github/user/repositories`,
    method: "GET",
    signal,
  });
};

export const getAdminServiceListGithubUserReposQueryKey = () => {
  return [`/v1/github/user/repositories`] as const;
};

export const getAdminServiceListGithubUserReposQueryOptions = <
  TData = Awaited<ReturnType<typeof adminServiceListGithubUserRepos>>,
  TError = RpcStatus,
>(options?: {
  query?: Partial<
    CreateQueryOptions<
      Awaited<ReturnType<typeof adminServiceListGithubUserRepos>>,
      TError,
      TData
    >
  >;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getAdminServiceListGithubUserReposQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof adminServiceListGithubUserRepos>>
  > = ({ signal }) => adminServiceListGithubUserRepos(signal);

  return { queryKey, queryFn, ...queryOptions } as CreateQueryOptions<
    Awaited<ReturnType<typeof adminServiceListGithubUserRepos>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type AdminServiceListGithubUserReposQueryResult = NonNullable<
  Awaited<ReturnType<typeof adminServiceListGithubUserRepos>>
>;
export type AdminServiceListGithubUserReposQueryError = RpcStatus;

export function createAdminServiceListGithubUserRepos<
  TData = Awaited<ReturnType<typeof adminServiceListGithubUserRepos>>,
  TError = RpcStatus,
>(
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof adminServiceListGithubUserRepos>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): CreateQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getAdminServiceListGithubUserReposQueryOptions(options);

  const query = createQuery(queryOptions, queryClient) as CreateQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary RevokeMagicAuthToken revokes a magic auth token.
 */
export const adminServiceRevokeMagicAuthToken = (tokenId: string) => {
  return httpClient<V1RevokeMagicAuthTokenResponse>({
    url: `/v1/magic-tokens/${tokenId}`,
    method: "DELETE",
  });
};

export const getAdminServiceRevokeMagicAuthTokenMutationOptions = <
  TError = RpcStatus,
  TContext = unknown,
>(options?: {
  mutation?: CreateMutationOptions<
    Awaited<ReturnType<typeof adminServiceRevokeMagicAuthToken>>,
    TError,
    { tokenId: string },
    TContext
  >;
}): CreateMutationOptions<
  Awaited<ReturnType<typeof adminServiceRevokeMagicAuthToken>>,
  TError,
  { tokenId: string },
  TContext
> => {
  const mutationKey = ["adminServiceRevokeMagicAuthToken"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof adminServiceRevokeMagicAuthToken>>,
    { tokenId: string }
  > = (props) => {
    const { tokenId } = props ?? {};

    return adminServiceRevokeMagicAuthToken(tokenId);
  };

  return { mutationFn, ...mutationOptions };
};

export type AdminServiceRevokeMagicAuthTokenMutationResult = NonNullable<
  Awaited<ReturnType<typeof adminServiceRevokeMagicAuthToken>>
>;

export type AdminServiceRevokeMagicAuthTokenMutationError = RpcStatus;

/**
 * @summary RevokeMagicAuthToken revokes a magic auth token.
 */
export const createAdminServiceRevokeMagicAuthToken = <
  TError = RpcStatus,
  TContext = unknown,
>(
  options?: {
    mutation?: CreateMutationOptions<
      Awaited<ReturnType<typeof adminServiceRevokeMagicAuthToken>>,
      TError,
      { tokenId: string },
      TContext
    >;
  },
  queryClient?: QueryClient,
): CreateMutationResult<
  Awaited<ReturnType<typeof adminServiceRevokeMagicAuthToken>>,
  TError,
  { tokenId: string },
  TContext
> => {
  const mutationOptions =
    getAdminServiceRevokeMagicAuthTokenMutationOptions(options);

  return createMutation(mutationOptions, queryClient);
};
/**
 * @summary GetCurrentMagicAuthToken returns information about the current magic auth token.
 */
export const adminServiceGetCurrentMagicAuthToken = (signal?: AbortSignal) => {
  return httpClient<V1GetCurrentMagicAuthTokenResponse>({
    url: `/v1/magic-tokens/current`,
    method: "GET",
    signal,
  });
};

export const getAdminServiceGetCurrentMagicAuthTokenQueryKey = () => {
  return [`/v1/magic-tokens/current`] as const;
};

export const getAdminServiceGetCurrentMagicAuthTokenQueryOptions = <
  TData = Awaited<ReturnType<typeof adminServiceGetCurrentMagicAuthToken>>,
  TError = RpcStatus,
>(options?: {
  query?: Partial<
    CreateQueryOptions<
      Awaited<ReturnType<typeof adminServiceGetCurrentMagicAuthToken>>,
      TError,
      TData
    >
  >;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getAdminServiceGetCurrentMagicAuthTokenQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof adminServiceGetCurrentMagicAuthToken>>
  > = ({ signal }) => adminServiceGetCurrentMagicAuthToken(signal);

  return { queryKey, queryFn, ...queryOptions } as CreateQueryOptions<
    Awaited<ReturnType<typeof adminServiceGetCurrentMagicAuthToken>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type AdminServiceGetCurrentMagicAuthTokenQueryResult = NonNullable<
  Awaited<ReturnType<typeof adminServiceGetCurrentMagicAuthToken>>
>;
export type AdminServiceGetCurrentMagicAuthTokenQueryError = RpcStatus;

/**
 * @summary GetCurrentMagicAuthToken returns information about the current magic auth token.
 */

export function createAdminServiceGetCurrentMagicAuthToken<
  TData = Awaited<ReturnType<typeof adminServiceGetCurrentMagicAuthToken>>,
  TError = RpcStatus,
>(
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof adminServiceGetCurrentMagicAuthToken>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): CreateQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions =
    getAdminServiceGetCurrentMagicAuthTokenQueryOptions(options);

  const query = createQuery(queryOptions, queryClient) as CreateQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary GetOrganizationNameForDomain finds the org name for a custom domain.
If the application detects it is running on a non-default domain, it can use this to find the org to present.
It can be called without being authenticated.
 */
export const adminServiceGetOrganizationNameForDomain = (
  domain: string,
  signal?: AbortSignal,
) => {
  return httpClient<V1GetOrganizationNameForDomainResponse>({
    url: `/v1/organization-for-domain/${domain}`,
    method: "GET",
    signal,
  });
};

export const getAdminServiceGetOrganizationNameForDomainQueryKey = (
  domain: string,
) => {
  return [`/v1/organization-for-domain/${domain}`] as const;
};

export const getAdminServiceGetOrganizationNameForDomainQueryOptions = <
  TData = Awaited<ReturnType<typeof adminServiceGetOrganizationNameForDomain>>,
  TError = RpcStatus,
>(
  domain: string,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof adminServiceGetOrganizationNameForDomain>>,
        TError,
        TData
      >
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getAdminServiceGetOrganizationNameForDomainQueryKey(domain);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof adminServiceGetOrganizationNameForDomain>>
  > = ({ signal }) => adminServiceGetOrganizationNameForDomain(domain, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!domain,
    ...queryOptions,
  } as CreateQueryOptions<
    Awaited<ReturnType<typeof adminServiceGetOrganizationNameForDomain>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type AdminServiceGetOrganizationNameForDomainQueryResult = NonNullable<
  Awaited<ReturnType<typeof adminServiceGetOrganizationNameForDomain>>
>;
export type AdminServiceGetOrganizationNameForDomainQueryError = RpcStatus;

/**
 * @summary GetOrganizationNameForDomain finds the org name for a custom domain.
If the application detects it is running on a non-default domain, it can use this to find the org to present.
It can be called without being authenticated.
 */

export function createAdminServiceGetOrganizationNameForDomain<
  TData = Awaited<ReturnType<typeof adminServiceGetOrganizationNameForDomain>>,
  TError = RpcStatus,
>(
  domain: string,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof adminServiceGetOrganizationNameForDomain>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): CreateQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getAdminServiceGetOrganizationNameForDomainQueryOptions(
    domain,
    options,
  );

  const query = createQuery(queryOptions, queryClient) as CreateQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary ListOrganizations lists all the organizations currently managed by the admin
 */
export const adminServiceListOrganizations = (
  params?: AdminServiceListOrganizationsParams,
  signal?: AbortSignal,
) => {
  return httpClient<V1ListOrganizationsResponse>({
    url: `/v1/organizations`,
    method: "GET",
    params,
    signal,
  });
};

export const getAdminServiceListOrganizationsQueryKey = (
  params?: AdminServiceListOrganizationsParams,
) => {
  return [`/v1/organizations`, ...(params ? [params] : [])] as const;
};

export const getAdminServiceListOrganizationsQueryOptions = <
  TData = Awaited<ReturnType<typeof adminServiceListOrganizations>>,
  TError = RpcStatus,
>(
  params?: AdminServiceListOrganizationsParams,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof adminServiceListOrganizations>>,
        TError,
        TData
      >
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getAdminServiceListOrganizationsQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof adminServiceListOrganizations>>
  > = ({ signal }) => adminServiceListOrganizations(params, signal);

  return { queryKey, queryFn, ...queryOptions } as CreateQueryOptions<
    Awaited<ReturnType<typeof adminServiceListOrganizations>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type AdminServiceListOrganizationsQueryResult = NonNullable<
  Awaited<ReturnType<typeof adminServiceListOrganizations>>
>;
export type AdminServiceListOrganizationsQueryError = RpcStatus;

/**
 * @summary ListOrganizations lists all the organizations currently managed by the admin
 */

export function createAdminServiceListOrganizations<
  TData = Awaited<ReturnType<typeof adminServiceListOrganizations>>,
  TError = RpcStatus,
>(
  params?: AdminServiceListOrganizationsParams,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof adminServiceListOrganizations>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): CreateQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getAdminServiceListOrganizationsQueryOptions(
    params,
    options,
  );

  const query = createQuery(queryOptions, queryClient) as CreateQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary CreateOrganization creates a new organization
 */
export const adminServiceCreateOrganization = (
  v1CreateOrganizationRequest: V1CreateOrganizationRequest,
  signal?: AbortSignal,
) => {
  return httpClient<V1CreateOrganizationResponse>({
    url: `/v1/organizations`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: v1CreateOrganizationRequest,
    signal,
  });
};

export const getAdminServiceCreateOrganizationMutationOptions = <
  TError = RpcStatus,
  TContext = unknown,
>(options?: {
  mutation?: CreateMutationOptions<
    Awaited<ReturnType<typeof adminServiceCreateOrganization>>,
    TError,
    { data: V1CreateOrganizationRequest },
    TContext
  >;
}): CreateMutationOptions<
  Awaited<ReturnType<typeof adminServiceCreateOrganization>>,
  TError,
  { data: V1CreateOrganizationRequest },
  TContext
> => {
  const mutationKey = ["adminServiceCreateOrganization"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof adminServiceCreateOrganization>>,
    { data: V1CreateOrganizationRequest }
  > = (props) => {
    const { data } = props ?? {};

    return adminServiceCreateOrganization(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type AdminServiceCreateOrganizationMutationResult = NonNullable<
  Awaited<ReturnType<typeof adminServiceCreateOrganization>>
>;
export type AdminServiceCreateOrganizationMutationBody =
  V1CreateOrganizationRequest;
export type AdminServiceCreateOrganizationMutationError = RpcStatus;

/**
 * @summary CreateOrganization creates a new organization
 */
export const createAdminServiceCreateOrganization = <
  TError = RpcStatus,
  TContext = unknown,
>(
  options?: {
    mutation?: CreateMutationOptions<
      Awaited<ReturnType<typeof adminServiceCreateOrganization>>,
      TError,
      { data: V1CreateOrganizationRequest },
      TContext
    >;
  },
  queryClient?: QueryClient,
): CreateMutationResult<
  Awaited<ReturnType<typeof adminServiceCreateOrganization>>,
  TError,
  { data: V1CreateOrganizationRequest },
  TContext
> => {
  const mutationOptions =
    getAdminServiceCreateOrganizationMutationOptions(options);

  return createMutation(mutationOptions, queryClient);
};
/**
 * @summary GetOrganization returns information about a specific organization
 */
export const adminServiceGetOrganization = (
  name: string,
  params?: AdminServiceGetOrganizationParams,
  signal?: AbortSignal,
) => {
  return httpClient<V1GetOrganizationResponse>({
    url: `/v1/organizations/${name}`,
    method: "GET",
    params,
    signal,
  });
};

export const getAdminServiceGetOrganizationQueryKey = (
  name: string,
  params?: AdminServiceGetOrganizationParams,
) => {
  return [`/v1/organizations/${name}`, ...(params ? [params] : [])] as const;
};

export const getAdminServiceGetOrganizationQueryOptions = <
  TData = Awaited<ReturnType<typeof adminServiceGetOrganization>>,
  TError = RpcStatus,
>(
  name: string,
  params?: AdminServiceGetOrganizationParams,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof adminServiceGetOrganization>>,
        TError,
        TData
      >
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getAdminServiceGetOrganizationQueryKey(name, params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof adminServiceGetOrganization>>
  > = ({ signal }) => adminServiceGetOrganization(name, params, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!name,
    ...queryOptions,
  } as CreateQueryOptions<
    Awaited<ReturnType<typeof adminServiceGetOrganization>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type AdminServiceGetOrganizationQueryResult = NonNullable<
  Awaited<ReturnType<typeof adminServiceGetOrganization>>
>;
export type AdminServiceGetOrganizationQueryError = RpcStatus;

/**
 * @summary GetOrganization returns information about a specific organization
 */

export function createAdminServiceGetOrganization<
  TData = Awaited<ReturnType<typeof adminServiceGetOrganization>>,
  TError = RpcStatus,
>(
  name: string,
  params?: AdminServiceGetOrganizationParams,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof adminServiceGetOrganization>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): CreateQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getAdminServiceGetOrganizationQueryOptions(
    name,
    params,
    options,
  );

  const query = createQuery(queryOptions, queryClient) as CreateQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary DeleteOrganization deletes an organizations
 */
export const adminServiceDeleteOrganization = (name: string) => {
  return httpClient<V1DeleteOrganizationResponse>({
    url: `/v1/organizations/${name}`,
    method: "DELETE",
  });
};

export const getAdminServiceDeleteOrganizationMutationOptions = <
  TError = RpcStatus,
  TContext = unknown,
>(options?: {
  mutation?: CreateMutationOptions<
    Awaited<ReturnType<typeof adminServiceDeleteOrganization>>,
    TError,
    { name: string },
    TContext
  >;
}): CreateMutationOptions<
  Awaited<ReturnType<typeof adminServiceDeleteOrganization>>,
  TError,
  { name: string },
  TContext
> => {
  const mutationKey = ["adminServiceDeleteOrganization"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof adminServiceDeleteOrganization>>,
    { name: string }
  > = (props) => {
    const { name } = props ?? {};

    return adminServiceDeleteOrganization(name);
  };

  return { mutationFn, ...mutationOptions };
};

export type AdminServiceDeleteOrganizationMutationResult = NonNullable<
  Awaited<ReturnType<typeof adminServiceDeleteOrganization>>
>;

export type AdminServiceDeleteOrganizationMutationError = RpcStatus;

/**
 * @summary DeleteOrganization deletes an organizations
 */
export const createAdminServiceDeleteOrganization = <
  TError = RpcStatus,
  TContext = unknown,
>(
  options?: {
    mutation?: CreateMutationOptions<
      Awaited<ReturnType<typeof adminServiceDeleteOrganization>>,
      TError,
      { name: string },
      TContext
    >;
  },
  queryClient?: QueryClient,
): CreateMutationResult<
  Awaited<ReturnType<typeof adminServiceDeleteOrganization>>,
  TError,
  { name: string },
  TContext
> => {
  const mutationOptions =
    getAdminServiceDeleteOrganizationMutationOptions(options);

  return createMutation(mutationOptions, queryClient);
};
/**
 * @summary UpdateOrganization deletes an organizations
 */
export const adminServiceUpdateOrganization = (
  name: string,
  adminServiceUpdateOrganizationBody: AdminServiceUpdateOrganizationBody,
) => {
  return httpClient<V1UpdateOrganizationResponse>({
    url: `/v1/organizations/${name}`,
    method: "PATCH",
    headers: { "Content-Type": "application/json" },
    data: adminServiceUpdateOrganizationBody,
  });
};

export const getAdminServiceUpdateOrganizationMutationOptions = <
  TError = RpcStatus,
  TContext = unknown,
>(options?: {
  mutation?: CreateMutationOptions<
    Awaited<ReturnType<typeof adminServiceUpdateOrganization>>,
    TError,
    { name: string; data: AdminServiceUpdateOrganizationBody },
    TContext
  >;
}): CreateMutationOptions<
  Awaited<ReturnType<typeof adminServiceUpdateOrganization>>,
  TError,
  { name: string; data: AdminServiceUpdateOrganizationBody },
  TContext
> => {
  const mutationKey = ["adminServiceUpdateOrganization"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof adminServiceUpdateOrganization>>,
    { name: string; data: AdminServiceUpdateOrganizationBody }
  > = (props) => {
    const { name, data } = props ?? {};

    return adminServiceUpdateOrganization(name, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type AdminServiceUpdateOrganizationMutationResult = NonNullable<
  Awaited<ReturnType<typeof adminServiceUpdateOrganization>>
>;
export type AdminServiceUpdateOrganizationMutationBody =
  AdminServiceUpdateOrganizationBody;
export type AdminServiceUpdateOrganizationMutationError = RpcStatus;

/**
 * @summary UpdateOrganization deletes an organizations
 */
export const createAdminServiceUpdateOrganization = <
  TError = RpcStatus,
  TContext = unknown,
>(
  options?: {
    mutation?: CreateMutationOptions<
      Awaited<ReturnType<typeof adminServiceUpdateOrganization>>,
      TError,
      { name: string; data: AdminServiceUpdateOrganizationBody },
      TContext
    >;
  },
  queryClient?: QueryClient,
): CreateMutationResult<
  Awaited<ReturnType<typeof adminServiceUpdateOrganization>>,
  TError,
  { name: string; data: AdminServiceUpdateOrganizationBody },
  TContext
> => {
  const mutationOptions =
    getAdminServiceUpdateOrganizationMutationOptions(options);

  return createMutation(mutationOptions, queryClient);
};
/**
 * @summary ListOrganizationBillingIssues lists all the billing issues for the organization
 */
export const adminServiceListOrganizationBillingIssues = (
  organization: string,
  params?: AdminServiceListOrganizationBillingIssuesParams,
  signal?: AbortSignal,
) => {
  return httpClient<V1ListOrganizationBillingIssuesResponse>({
    url: `/v1/organizations/${organization}/billing/issues`,
    method: "GET",
    params,
    signal,
  });
};

export const getAdminServiceListOrganizationBillingIssuesQueryKey = (
  organization: string,
  params?: AdminServiceListOrganizationBillingIssuesParams,
) => {
  return [
    `/v1/organizations/${organization}/billing/issues`,
    ...(params ? [params] : []),
  ] as const;
};

export const getAdminServiceListOrganizationBillingIssuesQueryOptions = <
  TData = Awaited<ReturnType<typeof adminServiceListOrganizationBillingIssues>>,
  TError = RpcStatus,
>(
  organization: string,
  params?: AdminServiceListOrganizationBillingIssuesParams,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof adminServiceListOrganizationBillingIssues>>,
        TError,
        TData
      >
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getAdminServiceListOrganizationBillingIssuesQueryKey(organization, params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof adminServiceListOrganizationBillingIssues>>
  > = ({ signal }) =>
    adminServiceListOrganizationBillingIssues(organization, params, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!organization,
    ...queryOptions,
  } as CreateQueryOptions<
    Awaited<ReturnType<typeof adminServiceListOrganizationBillingIssues>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type AdminServiceListOrganizationBillingIssuesQueryResult = NonNullable<
  Awaited<ReturnType<typeof adminServiceListOrganizationBillingIssues>>
>;
export type AdminServiceListOrganizationBillingIssuesQueryError = RpcStatus;

/**
 * @summary ListOrganizationBillingIssues lists all the billing issues for the organization
 */

export function createAdminServiceListOrganizationBillingIssues<
  TData = Awaited<ReturnType<typeof adminServiceListOrganizationBillingIssues>>,
  TError = RpcStatus,
>(
  organization: string,
  params?: AdminServiceListOrganizationBillingIssuesParams,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof adminServiceListOrganizationBillingIssues>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): CreateQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getAdminServiceListOrganizationBillingIssuesQueryOptions(
    organization,
    params,
    options,
  );

  const query = createQuery(queryOptions, queryClient) as CreateQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary GetPaymentsPortalURL returns the URL for the billing session to collect payment method
 */
export const adminServiceGetPaymentsPortalURL = (
  organization: string,
  params?: AdminServiceGetPaymentsPortalURLParams,
  signal?: AbortSignal,
) => {
  return httpClient<V1GetPaymentsPortalURLResponse>({
    url: `/v1/organizations/${organization}/billing/payments/portal-url`,
    method: "GET",
    params,
    signal,
  });
};

export const getAdminServiceGetPaymentsPortalURLQueryKey = (
  organization: string,
  params?: AdminServiceGetPaymentsPortalURLParams,
) => {
  return [
    `/v1/organizations/${organization}/billing/payments/portal-url`,
    ...(params ? [params] : []),
  ] as const;
};

export const getAdminServiceGetPaymentsPortalURLQueryOptions = <
  TData = Awaited<ReturnType<typeof adminServiceGetPaymentsPortalURL>>,
  TError = RpcStatus,
>(
  organization: string,
  params?: AdminServiceGetPaymentsPortalURLParams,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof adminServiceGetPaymentsPortalURL>>,
        TError,
        TData
      >
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getAdminServiceGetPaymentsPortalURLQueryKey(organization, params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof adminServiceGetPaymentsPortalURL>>
  > = ({ signal }) =>
    adminServiceGetPaymentsPortalURL(organization, params, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!organization,
    ...queryOptions,
  } as CreateQueryOptions<
    Awaited<ReturnType<typeof adminServiceGetPaymentsPortalURL>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type AdminServiceGetPaymentsPortalURLQueryResult = NonNullable<
  Awaited<ReturnType<typeof adminServiceGetPaymentsPortalURL>>
>;
export type AdminServiceGetPaymentsPortalURLQueryError = RpcStatus;

/**
 * @summary GetPaymentsPortalURL returns the URL for the billing session to collect payment method
 */

export function createAdminServiceGetPaymentsPortalURL<
  TData = Awaited<ReturnType<typeof adminServiceGetPaymentsPortalURL>>,
  TError = RpcStatus,
>(
  organization: string,
  params?: AdminServiceGetPaymentsPortalURLParams,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof adminServiceGetPaymentsPortalURL>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): CreateQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getAdminServiceGetPaymentsPortalURLQueryOptions(
    organization,
    params,
    options,
  );

  const query = createQuery(queryOptions, queryClient) as CreateQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary GetBillingSubscription lists the subscription for the organization
 */
export const adminServiceGetBillingSubscription = (
  organization: string,
  params?: AdminServiceGetBillingSubscriptionParams,
  signal?: AbortSignal,
) => {
  return httpClient<V1GetBillingSubscriptionResponse>({
    url: `/v1/organizations/${organization}/billing/subscriptions`,
    method: "GET",
    params,
    signal,
  });
};

export const getAdminServiceGetBillingSubscriptionQueryKey = (
  organization: string,
  params?: AdminServiceGetBillingSubscriptionParams,
) => {
  return [
    `/v1/organizations/${organization}/billing/subscriptions`,
    ...(params ? [params] : []),
  ] as const;
};

export const getAdminServiceGetBillingSubscriptionQueryOptions = <
  TData = Awaited<ReturnType<typeof adminServiceGetBillingSubscription>>,
  TError = RpcStatus,
>(
  organization: string,
  params?: AdminServiceGetBillingSubscriptionParams,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof adminServiceGetBillingSubscription>>,
        TError,
        TData
      >
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getAdminServiceGetBillingSubscriptionQueryKey(organization, params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof adminServiceGetBillingSubscription>>
  > = ({ signal }) =>
    adminServiceGetBillingSubscription(organization, params, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!organization,
    ...queryOptions,
  } as CreateQueryOptions<
    Awaited<ReturnType<typeof adminServiceGetBillingSubscription>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type AdminServiceGetBillingSubscriptionQueryResult = NonNullable<
  Awaited<ReturnType<typeof adminServiceGetBillingSubscription>>
>;
export type AdminServiceGetBillingSubscriptionQueryError = RpcStatus;

/**
 * @summary GetBillingSubscription lists the subscription for the organization
 */

export function createAdminServiceGetBillingSubscription<
  TData = Awaited<ReturnType<typeof adminServiceGetBillingSubscription>>,
  TError = RpcStatus,
>(
  organization: string,
  params?: AdminServiceGetBillingSubscriptionParams,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof adminServiceGetBillingSubscription>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): CreateQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getAdminServiceGetBillingSubscriptionQueryOptions(
    organization,
    params,
    options,
  );

  const query = createQuery(queryOptions, queryClient) as CreateQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary CancelBillingSubscription cancels the billing subscription for the organization
 */
export const adminServiceCancelBillingSubscription = (
  organization: string,
  params?: AdminServiceCancelBillingSubscriptionParams,
) => {
  return httpClient<V1CancelBillingSubscriptionResponse>({
    url: `/v1/organizations/${organization}/billing/subscriptions`,
    method: "DELETE",
    params,
  });
};

export const getAdminServiceCancelBillingSubscriptionMutationOptions = <
  TError = RpcStatus,
  TContext = unknown,
>(options?: {
  mutation?: CreateMutationOptions<
    Awaited<ReturnType<typeof adminServiceCancelBillingSubscription>>,
    TError,
    {
      organization: string;
      params?: AdminServiceCancelBillingSubscriptionParams;
    },
    TContext
  >;
}): CreateMutationOptions<
  Awaited<ReturnType<typeof adminServiceCancelBillingSubscription>>,
  TError,
  {
    organization: string;
    params?: AdminServiceCancelBillingSubscriptionParams;
  },
  TContext
> => {
  const mutationKey = ["adminServiceCancelBillingSubscription"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof adminServiceCancelBillingSubscription>>,
    {
      organization: string;
      params?: AdminServiceCancelBillingSubscriptionParams;
    }
  > = (props) => {
    const { organization, params } = props ?? {};

    return adminServiceCancelBillingSubscription(organization, params);
  };

  return { mutationFn, ...mutationOptions };
};

export type AdminServiceCancelBillingSubscriptionMutationResult = NonNullable<
  Awaited<ReturnType<typeof adminServiceCancelBillingSubscription>>
>;

export type AdminServiceCancelBillingSubscriptionMutationError = RpcStatus;

/**
 * @summary CancelBillingSubscription cancels the billing subscription for the organization
 */
export const createAdminServiceCancelBillingSubscription = <
  TError = RpcStatus,
  TContext = unknown,
>(
  options?: {
    mutation?: CreateMutationOptions<
      Awaited<ReturnType<typeof adminServiceCancelBillingSubscription>>,
      TError,
      {
        organization: string;
        params?: AdminServiceCancelBillingSubscriptionParams;
      },
      TContext
    >;
  },
  queryClient?: QueryClient,
): CreateMutationResult<
  Awaited<ReturnType<typeof adminServiceCancelBillingSubscription>>,
  TError,
  {
    organization: string;
    params?: AdminServiceCancelBillingSubscriptionParams;
  },
  TContext
> => {
  const mutationOptions =
    getAdminServiceCancelBillingSubscriptionMutationOptions(options);

  return createMutation(mutationOptions, queryClient);
};
/**
 * @summary UpdateBillingSubscription updates the billing plan for the organization
 */
export const adminServiceUpdateBillingSubscription = (
  organization: string,
  adminServiceUpdateBillingSubscriptionBodyBody: AdminServiceUpdateBillingSubscriptionBodyBody,
) => {
  return httpClient<V1UpdateBillingSubscriptionResponse>({
    url: `/v1/organizations/${organization}/billing/subscriptions`,
    method: "PATCH",
    headers: { "Content-Type": "application/json" },
    data: adminServiceUpdateBillingSubscriptionBodyBody,
  });
};

export const getAdminServiceUpdateBillingSubscriptionMutationOptions = <
  TError = RpcStatus,
  TContext = unknown,
>(options?: {
  mutation?: CreateMutationOptions<
    Awaited<ReturnType<typeof adminServiceUpdateBillingSubscription>>,
    TError,
    {
      organization: string;
      data: AdminServiceUpdateBillingSubscriptionBodyBody;
    },
    TContext
  >;
}): CreateMutationOptions<
  Awaited<ReturnType<typeof adminServiceUpdateBillingSubscription>>,
  TError,
  { organization: string; data: AdminServiceUpdateBillingSubscriptionBodyBody },
  TContext
> => {
  const mutationKey = ["adminServiceUpdateBillingSubscription"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof adminServiceUpdateBillingSubscription>>,
    {
      organization: string;
      data: AdminServiceUpdateBillingSubscriptionBodyBody;
    }
  > = (props) => {
    const { organization, data } = props ?? {};

    return adminServiceUpdateBillingSubscription(organization, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type AdminServiceUpdateBillingSubscriptionMutationResult = NonNullable<
  Awaited<ReturnType<typeof adminServiceUpdateBillingSubscription>>
>;
export type AdminServiceUpdateBillingSubscriptionMutationBody =
  AdminServiceUpdateBillingSubscriptionBodyBody;
export type AdminServiceUpdateBillingSubscriptionMutationError = RpcStatus;

/**
 * @summary UpdateBillingSubscription updates the billing plan for the organization
 */
export const createAdminServiceUpdateBillingSubscription = <
  TError = RpcStatus,
  TContext = unknown,
>(
  options?: {
    mutation?: CreateMutationOptions<
      Awaited<ReturnType<typeof adminServiceUpdateBillingSubscription>>,
      TError,
      {
        organization: string;
        data: AdminServiceUpdateBillingSubscriptionBodyBody;
      },
      TContext
    >;
  },
  queryClient?: QueryClient,
): CreateMutationResult<
  Awaited<ReturnType<typeof adminServiceUpdateBillingSubscription>>,
  TError,
  { organization: string; data: AdminServiceUpdateBillingSubscriptionBodyBody },
  TContext
> => {
  const mutationOptions =
    getAdminServiceUpdateBillingSubscriptionMutationOptions(options);

  return createMutation(mutationOptions, queryClient);
};
/**
 * @summary RenewBillingSubscription renews the billing plan for the organization once cancelled
 */
export const adminServiceRenewBillingSubscription = (
  organization: string,
  adminServiceUpdateBillingSubscriptionBodyBody: AdminServiceUpdateBillingSubscriptionBodyBody,
  signal?: AbortSignal,
) => {
  return httpClient<V1RenewBillingSubscriptionResponse>({
    url: `/v1/organizations/${organization}/billing/subscriptions/renew`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: adminServiceUpdateBillingSubscriptionBodyBody,
    signal,
  });
};

export const getAdminServiceRenewBillingSubscriptionMutationOptions = <
  TError = RpcStatus,
  TContext = unknown,
>(options?: {
  mutation?: CreateMutationOptions<
    Awaited<ReturnType<typeof adminServiceRenewBillingSubscription>>,
    TError,
    {
      organization: string;
      data: AdminServiceUpdateBillingSubscriptionBodyBody;
    },
    TContext
  >;
}): CreateMutationOptions<
  Awaited<ReturnType<typeof adminServiceRenewBillingSubscription>>,
  TError,
  { organization: string; data: AdminServiceUpdateBillingSubscriptionBodyBody },
  TContext
> => {
  const mutationKey = ["adminServiceRenewBillingSubscription"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof adminServiceRenewBillingSubscription>>,
    {
      organization: string;
      data: AdminServiceUpdateBillingSubscriptionBodyBody;
    }
  > = (props) => {
    const { organization, data } = props ?? {};

    return adminServiceRenewBillingSubscription(organization, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type AdminServiceRenewBillingSubscriptionMutationResult = NonNullable<
  Awaited<ReturnType<typeof adminServiceRenewBillingSubscription>>
>;
export type AdminServiceRenewBillingSubscriptionMutationBody =
  AdminServiceUpdateBillingSubscriptionBodyBody;
export type AdminServiceRenewBillingSubscriptionMutationError = RpcStatus;

/**
 * @summary RenewBillingSubscription renews the billing plan for the organization once cancelled
 */
export const createAdminServiceRenewBillingSubscription = <
  TError = RpcStatus,
  TContext = unknown,
>(
  options?: {
    mutation?: CreateMutationOptions<
      Awaited<ReturnType<typeof adminServiceRenewBillingSubscription>>,
      TError,
      {
        organization: string;
        data: AdminServiceUpdateBillingSubscriptionBodyBody;
      },
      TContext
    >;
  },
  queryClient?: QueryClient,
): CreateMutationResult<
  Awaited<ReturnType<typeof adminServiceRenewBillingSubscription>>,
  TError,
  { organization: string; data: AdminServiceUpdateBillingSubscriptionBodyBody },
  TContext
> => {
  const mutationOptions =
    getAdminServiceRenewBillingSubscriptionMutationOptions(options);

  return createMutation(mutationOptions, queryClient);
};
/**
 * @summary CreateManagedGitRepo creates a new rill managed git repo for the organization.
 */
export const adminServiceCreateManagedGitRepo = (
  organization: string,
  adminServiceCreateManagedGitRepoBody: AdminServiceCreateManagedGitRepoBody,
) => {
  return httpClient<V1CreateManagedGitRepoResponse>({
    url: `/v1/organizations/${organization}/create-managed-git-repo`,
    method: "PUT",
    headers: { "Content-Type": "application/json" },
    data: adminServiceCreateManagedGitRepoBody,
  });
};

export const getAdminServiceCreateManagedGitRepoMutationOptions = <
  TError = RpcStatus,
  TContext = unknown,
>(options?: {
  mutation?: CreateMutationOptions<
    Awaited<ReturnType<typeof adminServiceCreateManagedGitRepo>>,
    TError,
    { organization: string; data: AdminServiceCreateManagedGitRepoBody },
    TContext
  >;
}): CreateMutationOptions<
  Awaited<ReturnType<typeof adminServiceCreateManagedGitRepo>>,
  TError,
  { organization: string; data: AdminServiceCreateManagedGitRepoBody },
  TContext
> => {
  const mutationKey = ["adminServiceCreateManagedGitRepo"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof adminServiceCreateManagedGitRepo>>,
    { organization: string; data: AdminServiceCreateManagedGitRepoBody }
  > = (props) => {
    const { organization, data } = props ?? {};

    return adminServiceCreateManagedGitRepo(organization, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type AdminServiceCreateManagedGitRepoMutationResult = NonNullable<
  Awaited<ReturnType<typeof adminServiceCreateManagedGitRepo>>
>;
export type AdminServiceCreateManagedGitRepoMutationBody =
  AdminServiceCreateManagedGitRepoBody;
export type AdminServiceCreateManagedGitRepoMutationError = RpcStatus;

/**
 * @summary CreateManagedGitRepo creates a new rill managed git repo for the organization.
 */
export const createAdminServiceCreateManagedGitRepo = <
  TError = RpcStatus,
  TContext = unknown,
>(
  options?: {
    mutation?: CreateMutationOptions<
      Awaited<ReturnType<typeof adminServiceCreateManagedGitRepo>>,
      TError,
      { organization: string; data: AdminServiceCreateManagedGitRepoBody },
      TContext
    >;
  },
  queryClient?: QueryClient,
): CreateMutationResult<
  Awaited<ReturnType<typeof adminServiceCreateManagedGitRepo>>,
  TError,
  { organization: string; data: AdminServiceCreateManagedGitRepoBody },
  TContext
> => {
  const mutationOptions =
    getAdminServiceCreateManagedGitRepoMutationOptions(options);

  return createMutation(mutationOptions, queryClient);
};
/**
 * @summary ListOrganizationInvites lists all the org invites
 */
export const adminServiceListOrganizationInvites = (
  organization: string,
  params?: AdminServiceListOrganizationInvitesParams,
  signal?: AbortSignal,
) => {
  return httpClient<V1ListOrganizationInvitesResponse>({
    url: `/v1/organizations/${organization}/invites`,
    method: "GET",
    params,
    signal,
  });
};

export const getAdminServiceListOrganizationInvitesQueryKey = (
  organization: string,
  params?: AdminServiceListOrganizationInvitesParams,
) => {
  return [
    `/v1/organizations/${organization}/invites`,
    ...(params ? [params] : []),
  ] as const;
};

export const getAdminServiceListOrganizationInvitesInfiniteQueryOptions = <
  TData = InfiniteData<
    Awaited<ReturnType<typeof adminServiceListOrganizationInvites>>,
    AdminServiceListOrganizationInvitesParams["pageToken"]
  >,
  TError = RpcStatus,
>(
  organization: string,
  params?: AdminServiceListOrganizationInvitesParams,
  options?: {
    query?: Partial<
      CreateInfiniteQueryOptions<
        Awaited<ReturnType<typeof adminServiceListOrganizationInvites>>,
        TError,
        TData,
        Awaited<ReturnType<typeof adminServiceListOrganizationInvites>>,
        QueryKey,
        AdminServiceListOrganizationInvitesParams["pageToken"]
      >
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getAdminServiceListOrganizationInvitesQueryKey(organization, params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof adminServiceListOrganizationInvites>>,
    QueryKey,
    AdminServiceListOrganizationInvitesParams["pageToken"]
  > = ({ signal, pageParam }) =>
    adminServiceListOrganizationInvites(
      organization,
      { ...params, pageToken: pageParam || params?.["pageToken"] },
      signal,
    );

  return {
    queryKey,
    queryFn,
    enabled: !!organization,
    ...queryOptions,
  } as CreateInfiniteQueryOptions<
    Awaited<ReturnType<typeof adminServiceListOrganizationInvites>>,
    TError,
    TData,
    Awaited<ReturnType<typeof adminServiceListOrganizationInvites>>,
    QueryKey,
    AdminServiceListOrganizationInvitesParams["pageToken"]
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type AdminServiceListOrganizationInvitesInfiniteQueryResult =
  NonNullable<Awaited<ReturnType<typeof adminServiceListOrganizationInvites>>>;
export type AdminServiceListOrganizationInvitesInfiniteQueryError = RpcStatus;

/**
 * @summary ListOrganizationInvites lists all the org invites
 */

export function createAdminServiceListOrganizationInvitesInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof adminServiceListOrganizationInvites>>,
    AdminServiceListOrganizationInvitesParams["pageToken"]
  >,
  TError = RpcStatus,
>(
  organization: string,
  params?: AdminServiceListOrganizationInvitesParams,
  options?: {
    query?: Partial<
      CreateInfiniteQueryOptions<
        Awaited<ReturnType<typeof adminServiceListOrganizationInvites>>,
        TError,
        TData,
        Awaited<ReturnType<typeof adminServiceListOrganizationInvites>>,
        QueryKey,
        AdminServiceListOrganizationInvitesParams["pageToken"]
      >
    >;
  },
  queryClient?: QueryClient,
): CreateInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions =
    getAdminServiceListOrganizationInvitesInfiniteQueryOptions(
      organization,
      params,
      options,
    );

  const query = createInfiniteQuery(
    queryOptions,
    queryClient,
  ) as CreateInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getAdminServiceListOrganizationInvitesQueryOptions = <
  TData = Awaited<ReturnType<typeof adminServiceListOrganizationInvites>>,
  TError = RpcStatus,
>(
  organization: string,
  params?: AdminServiceListOrganizationInvitesParams,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof adminServiceListOrganizationInvites>>,
        TError,
        TData
      >
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getAdminServiceListOrganizationInvitesQueryKey(organization, params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof adminServiceListOrganizationInvites>>
  > = ({ signal }) =>
    adminServiceListOrganizationInvites(organization, params, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!organization,
    ...queryOptions,
  } as CreateQueryOptions<
    Awaited<ReturnType<typeof adminServiceListOrganizationInvites>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type AdminServiceListOrganizationInvitesQueryResult = NonNullable<
  Awaited<ReturnType<typeof adminServiceListOrganizationInvites>>
>;
export type AdminServiceListOrganizationInvitesQueryError = RpcStatus;

/**
 * @summary ListOrganizationInvites lists all the org invites
 */

export function createAdminServiceListOrganizationInvites<
  TData = Awaited<ReturnType<typeof adminServiceListOrganizationInvites>>,
  TError = RpcStatus,
>(
  organization: string,
  params?: AdminServiceListOrganizationInvitesParams,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof adminServiceListOrganizationInvites>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): CreateQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getAdminServiceListOrganizationInvitesQueryOptions(
    organization,
    params,
    options,
  );

  const query = createQuery(queryOptions, queryClient) as CreateQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary ListOrganizationMemberUsers lists all the org members
 */
export const adminServiceListOrganizationMemberUsers = (
  organization: string,
  params?: AdminServiceListOrganizationMemberUsersParams,
  signal?: AbortSignal,
) => {
  return httpClient<V1ListOrganizationMemberUsersResponse>({
    url: `/v1/organizations/${organization}/members`,
    method: "GET",
    params,
    signal,
  });
};

export const getAdminServiceListOrganizationMemberUsersQueryKey = (
  organization: string,
  params?: AdminServiceListOrganizationMemberUsersParams,
) => {
  return [
    `/v1/organizations/${organization}/members`,
    ...(params ? [params] : []),
  ] as const;
};

export const getAdminServiceListOrganizationMemberUsersInfiniteQueryOptions = <
  TData = InfiniteData<
    Awaited<ReturnType<typeof adminServiceListOrganizationMemberUsers>>,
    AdminServiceListOrganizationMemberUsersParams["pageToken"]
  >,
  TError = RpcStatus,
>(
  organization: string,
  params?: AdminServiceListOrganizationMemberUsersParams,
  options?: {
    query?: Partial<
      CreateInfiniteQueryOptions<
        Awaited<ReturnType<typeof adminServiceListOrganizationMemberUsers>>,
        TError,
        TData,
        Awaited<ReturnType<typeof adminServiceListOrganizationMemberUsers>>,
        QueryKey,
        AdminServiceListOrganizationMemberUsersParams["pageToken"]
      >
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getAdminServiceListOrganizationMemberUsersQueryKey(organization, params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof adminServiceListOrganizationMemberUsers>>,
    QueryKey,
    AdminServiceListOrganizationMemberUsersParams["pageToken"]
  > = ({ signal, pageParam }) =>
    adminServiceListOrganizationMemberUsers(
      organization,
      { ...params, pageToken: pageParam || params?.["pageToken"] },
      signal,
    );

  return {
    queryKey,
    queryFn,
    enabled: !!organization,
    ...queryOptions,
  } as CreateInfiniteQueryOptions<
    Awaited<ReturnType<typeof adminServiceListOrganizationMemberUsers>>,
    TError,
    TData,
    Awaited<ReturnType<typeof adminServiceListOrganizationMemberUsers>>,
    QueryKey,
    AdminServiceListOrganizationMemberUsersParams["pageToken"]
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type AdminServiceListOrganizationMemberUsersInfiniteQueryResult =
  NonNullable<
    Awaited<ReturnType<typeof adminServiceListOrganizationMemberUsers>>
  >;
export type AdminServiceListOrganizationMemberUsersInfiniteQueryError =
  RpcStatus;

/**
 * @summary ListOrganizationMemberUsers lists all the org members
 */

export function createAdminServiceListOrganizationMemberUsersInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof adminServiceListOrganizationMemberUsers>>,
    AdminServiceListOrganizationMemberUsersParams["pageToken"]
  >,
  TError = RpcStatus,
>(
  organization: string,
  params?: AdminServiceListOrganizationMemberUsersParams,
  options?: {
    query?: Partial<
      CreateInfiniteQueryOptions<
        Awaited<ReturnType<typeof adminServiceListOrganizationMemberUsers>>,
        TError,
        TData,
        Awaited<ReturnType<typeof adminServiceListOrganizationMemberUsers>>,
        QueryKey,
        AdminServiceListOrganizationMemberUsersParams["pageToken"]
      >
    >;
  },
  queryClient?: QueryClient,
): CreateInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions =
    getAdminServiceListOrganizationMemberUsersInfiniteQueryOptions(
      organization,
      params,
      options,
    );

  const query = createInfiniteQuery(
    queryOptions,
    queryClient,
  ) as CreateInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getAdminServiceListOrganizationMemberUsersQueryOptions = <
  TData = Awaited<ReturnType<typeof adminServiceListOrganizationMemberUsers>>,
  TError = RpcStatus,
>(
  organization: string,
  params?: AdminServiceListOrganizationMemberUsersParams,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof adminServiceListOrganizationMemberUsers>>,
        TError,
        TData
      >
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getAdminServiceListOrganizationMemberUsersQueryKey(organization, params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof adminServiceListOrganizationMemberUsers>>
  > = ({ signal }) =>
    adminServiceListOrganizationMemberUsers(organization, params, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!organization,
    ...queryOptions,
  } as CreateQueryOptions<
    Awaited<ReturnType<typeof adminServiceListOrganizationMemberUsers>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type AdminServiceListOrganizationMemberUsersQueryResult = NonNullable<
  Awaited<ReturnType<typeof adminServiceListOrganizationMemberUsers>>
>;
export type AdminServiceListOrganizationMemberUsersQueryError = RpcStatus;

/**
 * @summary ListOrganizationMemberUsers lists all the org members
 */

export function createAdminServiceListOrganizationMemberUsers<
  TData = Awaited<ReturnType<typeof adminServiceListOrganizationMemberUsers>>,
  TError = RpcStatus,
>(
  organization: string,
  params?: AdminServiceListOrganizationMemberUsersParams,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof adminServiceListOrganizationMemberUsers>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): CreateQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getAdminServiceListOrganizationMemberUsersQueryOptions(
    organization,
    params,
    options,
  );

  const query = createQuery(queryOptions, queryClient) as CreateQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary AddOrganizationMemberUser adds a user to the organization
 */
export const adminServiceAddOrganizationMemberUser = (
  organization: string,
  adminServiceAddOrganizationMemberUserBody: AdminServiceAddOrganizationMemberUserBody,
  signal?: AbortSignal,
) => {
  return httpClient<V1AddOrganizationMemberUserResponse>({
    url: `/v1/organizations/${organization}/members`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: adminServiceAddOrganizationMemberUserBody,
    signal,
  });
};

export const getAdminServiceAddOrganizationMemberUserMutationOptions = <
  TError = RpcStatus,
  TContext = unknown,
>(options?: {
  mutation?: CreateMutationOptions<
    Awaited<ReturnType<typeof adminServiceAddOrganizationMemberUser>>,
    TError,
    { organization: string; data: AdminServiceAddOrganizationMemberUserBody },
    TContext
  >;
}): CreateMutationOptions<
  Awaited<ReturnType<typeof adminServiceAddOrganizationMemberUser>>,
  TError,
  { organization: string; data: AdminServiceAddOrganizationMemberUserBody },
  TContext
> => {
  const mutationKey = ["adminServiceAddOrganizationMemberUser"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof adminServiceAddOrganizationMemberUser>>,
    { organization: string; data: AdminServiceAddOrganizationMemberUserBody }
  > = (props) => {
    const { organization, data } = props ?? {};

    return adminServiceAddOrganizationMemberUser(organization, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type AdminServiceAddOrganizationMemberUserMutationResult = NonNullable<
  Awaited<ReturnType<typeof adminServiceAddOrganizationMemberUser>>
>;
export type AdminServiceAddOrganizationMemberUserMutationBody =
  AdminServiceAddOrganizationMemberUserBody;
export type AdminServiceAddOrganizationMemberUserMutationError = RpcStatus;

/**
 * @summary AddOrganizationMemberUser adds a user to the organization
 */
export const createAdminServiceAddOrganizationMemberUser = <
  TError = RpcStatus,
  TContext = unknown,
>(
  options?: {
    mutation?: CreateMutationOptions<
      Awaited<ReturnType<typeof adminServiceAddOrganizationMemberUser>>,
      TError,
      { organization: string; data: AdminServiceAddOrganizationMemberUserBody },
      TContext
    >;
  },
  queryClient?: QueryClient,
): CreateMutationResult<
  Awaited<ReturnType<typeof adminServiceAddOrganizationMemberUser>>,
  TError,
  { organization: string; data: AdminServiceAddOrganizationMemberUserBody },
  TContext
> => {
  const mutationOptions =
    getAdminServiceAddOrganizationMemberUserMutationOptions(options);

  return createMutation(mutationOptions, queryClient);
};
/**
 * @summary RemoveOrganizationMemberUser removes member from the organization
 */
export const adminServiceRemoveOrganizationMemberUser = (
  organization: string,
  email: string,
) => {
  return httpClient<V1RemoveOrganizationMemberUserResponse>({
    url: `/v1/organizations/${organization}/members/${email}`,
    method: "DELETE",
  });
};

export const getAdminServiceRemoveOrganizationMemberUserMutationOptions = <
  TError = RpcStatus,
  TContext = unknown,
>(options?: {
  mutation?: CreateMutationOptions<
    Awaited<ReturnType<typeof adminServiceRemoveOrganizationMemberUser>>,
    TError,
    { organization: string; email: string },
    TContext
  >;
}): CreateMutationOptions<
  Awaited<ReturnType<typeof adminServiceRemoveOrganizationMemberUser>>,
  TError,
  { organization: string; email: string },
  TContext
> => {
  const mutationKey = ["adminServiceRemoveOrganizationMemberUser"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof adminServiceRemoveOrganizationMemberUser>>,
    { organization: string; email: string }
  > = (props) => {
    const { organization, email } = props ?? {};

    return adminServiceRemoveOrganizationMemberUser(organization, email);
  };

  return { mutationFn, ...mutationOptions };
};

export type AdminServiceRemoveOrganizationMemberUserMutationResult =
  NonNullable<
    Awaited<ReturnType<typeof adminServiceRemoveOrganizationMemberUser>>
  >;

export type AdminServiceRemoveOrganizationMemberUserMutationError = RpcStatus;

/**
 * @summary RemoveOrganizationMemberUser removes member from the organization
 */
export const createAdminServiceRemoveOrganizationMemberUser = <
  TError = RpcStatus,
  TContext = unknown,
>(
  options?: {
    mutation?: CreateMutationOptions<
      Awaited<ReturnType<typeof adminServiceRemoveOrganizationMemberUser>>,
      TError,
      { organization: string; email: string },
      TContext
    >;
  },
  queryClient?: QueryClient,
): CreateMutationResult<
  Awaited<ReturnType<typeof adminServiceRemoveOrganizationMemberUser>>,
  TError,
  { organization: string; email: string },
  TContext
> => {
  const mutationOptions =
    getAdminServiceRemoveOrganizationMemberUserMutationOptions(options);

  return createMutation(mutationOptions, queryClient);
};
/**
 * @summary SetOrganizationMemberUserRole sets the role for the member
 */
export const adminServiceSetOrganizationMemberUserRole = (
  organization: string,
  email: string,
  adminServiceSetOrganizationMemberUserRoleBody: AdminServiceSetOrganizationMemberUserRoleBody,
) => {
  return httpClient<V1SetOrganizationMemberUserRoleResponse>({
    url: `/v1/organizations/${organization}/members/${email}`,
    method: "PUT",
    headers: { "Content-Type": "application/json" },
    data: adminServiceSetOrganizationMemberUserRoleBody,
  });
};

export const getAdminServiceSetOrganizationMemberUserRoleMutationOptions = <
  TError = RpcStatus,
  TContext = unknown,
>(options?: {
  mutation?: CreateMutationOptions<
    Awaited<ReturnType<typeof adminServiceSetOrganizationMemberUserRole>>,
    TError,
    {
      organization: string;
      email: string;
      data: AdminServiceSetOrganizationMemberUserRoleBody;
    },
    TContext
  >;
}): CreateMutationOptions<
  Awaited<ReturnType<typeof adminServiceSetOrganizationMemberUserRole>>,
  TError,
  {
    organization: string;
    email: string;
    data: AdminServiceSetOrganizationMemberUserRoleBody;
  },
  TContext
> => {
  const mutationKey = ["adminServiceSetOrganizationMemberUserRole"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof adminServiceSetOrganizationMemberUserRole>>,
    {
      organization: string;
      email: string;
      data: AdminServiceSetOrganizationMemberUserRoleBody;
    }
  > = (props) => {
    const { organization, email, data } = props ?? {};

    return adminServiceSetOrganizationMemberUserRole(organization, email, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type AdminServiceSetOrganizationMemberUserRoleMutationResult =
  NonNullable<
    Awaited<ReturnType<typeof adminServiceSetOrganizationMemberUserRole>>
  >;
export type AdminServiceSetOrganizationMemberUserRoleMutationBody =
  AdminServiceSetOrganizationMemberUserRoleBody;
export type AdminServiceSetOrganizationMemberUserRoleMutationError = RpcStatus;

/**
 * @summary SetOrganizationMemberUserRole sets the role for the member
 */
export const createAdminServiceSetOrganizationMemberUserRole = <
  TError = RpcStatus,
  TContext = unknown,
>(
  options?: {
    mutation?: CreateMutationOptions<
      Awaited<ReturnType<typeof adminServiceSetOrganizationMemberUserRole>>,
      TError,
      {
        organization: string;
        email: string;
        data: AdminServiceSetOrganizationMemberUserRoleBody;
      },
      TContext
    >;
  },
  queryClient?: QueryClient,
): CreateMutationResult<
  Awaited<ReturnType<typeof adminServiceSetOrganizationMemberUserRole>>,
  TError,
  {
    organization: string;
    email: string;
    data: AdminServiceSetOrganizationMemberUserRoleBody;
  },
  TContext
> => {
  const mutationOptions =
    getAdminServiceSetOrganizationMemberUserRoleMutationOptions(options);

  return createMutation(mutationOptions, queryClient);
};
/**
 * @summary LeaveOrganization removes the current user from the organization
 */
export const adminServiceLeaveOrganization = (organization: string) => {
  return httpClient<V1LeaveOrganizationResponse>({
    url: `/v1/organizations/${organization}/members/current`,
    method: "DELETE",
  });
};

export const getAdminServiceLeaveOrganizationMutationOptions = <
  TError = RpcStatus,
  TContext = unknown,
>(options?: {
  mutation?: CreateMutationOptions<
    Awaited<ReturnType<typeof adminServiceLeaveOrganization>>,
    TError,
    { organization: string },
    TContext
  >;
}): CreateMutationOptions<
  Awaited<ReturnType<typeof adminServiceLeaveOrganization>>,
  TError,
  { organization: string },
  TContext
> => {
  const mutationKey = ["adminServiceLeaveOrganization"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof adminServiceLeaveOrganization>>,
    { organization: string }
  > = (props) => {
    const { organization } = props ?? {};

    return adminServiceLeaveOrganization(organization);
  };

  return { mutationFn, ...mutationOptions };
};

export type AdminServiceLeaveOrganizationMutationResult = NonNullable<
  Awaited<ReturnType<typeof adminServiceLeaveOrganization>>
>;

export type AdminServiceLeaveOrganizationMutationError = RpcStatus;

/**
 * @summary LeaveOrganization removes the current user from the organization
 */
export const createAdminServiceLeaveOrganization = <
  TError = RpcStatus,
  TContext = unknown,
>(
  options?: {
    mutation?: CreateMutationOptions<
      Awaited<ReturnType<typeof adminServiceLeaveOrganization>>,
      TError,
      { organization: string },
      TContext
    >;
  },
  queryClient?: QueryClient,
): CreateMutationResult<
  Awaited<ReturnType<typeof adminServiceLeaveOrganization>>,
  TError,
  { organization: string },
  TContext
> => {
  const mutationOptions =
    getAdminServiceLeaveOrganizationMutationOptions(options);

  return createMutation(mutationOptions, queryClient);
};
/**
 * @summary ListProjectMemberUsergroups lists the project's user groups
 */
export const adminServiceListProjectMemberUsergroups = (
  organization: string,
  project: string,
  params?: AdminServiceListProjectMemberUsergroupsParams,
  signal?: AbortSignal,
) => {
  return httpClient<V1ListProjectMemberUsergroupsResponse>({
    url: `/v1/organizations/${organization}/project/${project}/usergroups`,
    method: "GET",
    params,
    signal,
  });
};

export const getAdminServiceListProjectMemberUsergroupsQueryKey = (
  organization: string,
  project: string,
  params?: AdminServiceListProjectMemberUsergroupsParams,
) => {
  return [
    `/v1/organizations/${organization}/project/${project}/usergroups`,
    ...(params ? [params] : []),
  ] as const;
};

export const getAdminServiceListProjectMemberUsergroupsQueryOptions = <
  TData = Awaited<ReturnType<typeof adminServiceListProjectMemberUsergroups>>,
  TError = RpcStatus,
>(
  organization: string,
  project: string,
  params?: AdminServiceListProjectMemberUsergroupsParams,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof adminServiceListProjectMemberUsergroups>>,
        TError,
        TData
      >
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getAdminServiceListProjectMemberUsergroupsQueryKey(
      organization,
      project,
      params,
    );

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof adminServiceListProjectMemberUsergroups>>
  > = ({ signal }) =>
    adminServiceListProjectMemberUsergroups(
      organization,
      project,
      params,
      signal,
    );

  return {
    queryKey,
    queryFn,
    enabled: !!(organization && project),
    ...queryOptions,
  } as CreateQueryOptions<
    Awaited<ReturnType<typeof adminServiceListProjectMemberUsergroups>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type AdminServiceListProjectMemberUsergroupsQueryResult = NonNullable<
  Awaited<ReturnType<typeof adminServiceListProjectMemberUsergroups>>
>;
export type AdminServiceListProjectMemberUsergroupsQueryError = RpcStatus;

/**
 * @summary ListProjectMemberUsergroups lists the project's user groups
 */

export function createAdminServiceListProjectMemberUsergroups<
  TData = Awaited<ReturnType<typeof adminServiceListProjectMemberUsergroups>>,
  TError = RpcStatus,
>(
  organization: string,
  project: string,
  params?: AdminServiceListProjectMemberUsergroupsParams,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof adminServiceListProjectMemberUsergroups>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): CreateQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getAdminServiceListProjectMemberUsergroupsQueryOptions(
    organization,
    project,
    params,
    options,
  );

  const query = createQuery(queryOptions, queryClient) as CreateQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary ListProjectsForOrganizationAndUser lists all the projects that an organization member user has access to.
It does not include projects that the user has access to through a usergroup.
 */
export const adminServiceListProjectsForOrganizationAndUser = (
  organization: string,
  params?: AdminServiceListProjectsForOrganizationAndUserParams,
  signal?: AbortSignal,
) => {
  return httpClient<V1ListProjectsForOrganizationAndUserResponse>({
    url: `/v1/organizations/${organization}/projects-for-user`,
    method: "GET",
    params,
    signal,
  });
};

export const getAdminServiceListProjectsForOrganizationAndUserQueryKey = (
  organization: string,
  params?: AdminServiceListProjectsForOrganizationAndUserParams,
) => {
  return [
    `/v1/organizations/${organization}/projects-for-user`,
    ...(params ? [params] : []),
  ] as const;
};

export const getAdminServiceListProjectsForOrganizationAndUserQueryOptions = <
  TData = Awaited<
    ReturnType<typeof adminServiceListProjectsForOrganizationAndUser>
  >,
  TError = RpcStatus,
>(
  organization: string,
  params?: AdminServiceListProjectsForOrganizationAndUserParams,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<
          ReturnType<typeof adminServiceListProjectsForOrganizationAndUser>
        >,
        TError,
        TData
      >
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getAdminServiceListProjectsForOrganizationAndUserQueryKey(
      organization,
      params,
    );

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof adminServiceListProjectsForOrganizationAndUser>>
  > = ({ signal }) =>
    adminServiceListProjectsForOrganizationAndUser(
      organization,
      params,
      signal,
    );

  return {
    queryKey,
    queryFn,
    enabled: !!organization,
    ...queryOptions,
  } as CreateQueryOptions<
    Awaited<ReturnType<typeof adminServiceListProjectsForOrganizationAndUser>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type AdminServiceListProjectsForOrganizationAndUserQueryResult =
  NonNullable<
    Awaited<ReturnType<typeof adminServiceListProjectsForOrganizationAndUser>>
  >;
export type AdminServiceListProjectsForOrganizationAndUserQueryError =
  RpcStatus;

/**
 * @summary ListProjectsForOrganizationAndUser lists all the projects that an organization member user has access to.
It does not include projects that the user has access to through a usergroup.
 */

export function createAdminServiceListProjectsForOrganizationAndUser<
  TData = Awaited<
    ReturnType<typeof adminServiceListProjectsForOrganizationAndUser>
  >,
  TError = RpcStatus,
>(
  organization: string,
  params?: AdminServiceListProjectsForOrganizationAndUserParams,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<
          ReturnType<typeof adminServiceListProjectsForOrganizationAndUser>
        >,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): CreateQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions =
    getAdminServiceListProjectsForOrganizationAndUserQueryOptions(
      organization,
      params,
      options,
    );

  const query = createQuery(queryOptions, queryClient) as CreateQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary CreateAlert adds a virtual file for an alert, triggers a reconcile, and waits for the alert to be added to the runtime catalog
 */
export const adminServiceCreateAlert = (
  organization: string,
  project: string,
  adminServiceCreateAlertBodyBody: AdminServiceCreateAlertBodyBody,
  signal?: AbortSignal,
) => {
  return httpClient<V1CreateAlertResponse>({
    url: `/v1/organizations/${organization}/projects/${project}/alerts`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: adminServiceCreateAlertBodyBody,
    signal,
  });
};

export const getAdminServiceCreateAlertMutationOptions = <
  TError = RpcStatus,
  TContext = unknown,
>(options?: {
  mutation?: CreateMutationOptions<
    Awaited<ReturnType<typeof adminServiceCreateAlert>>,
    TError,
    {
      organization: string;
      project: string;
      data: AdminServiceCreateAlertBodyBody;
    },
    TContext
  >;
}): CreateMutationOptions<
  Awaited<ReturnType<typeof adminServiceCreateAlert>>,
  TError,
  {
    organization: string;
    project: string;
    data: AdminServiceCreateAlertBodyBody;
  },
  TContext
> => {
  const mutationKey = ["adminServiceCreateAlert"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof adminServiceCreateAlert>>,
    {
      organization: string;
      project: string;
      data: AdminServiceCreateAlertBodyBody;
    }
  > = (props) => {
    const { organization, project, data } = props ?? {};

    return adminServiceCreateAlert(organization, project, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type AdminServiceCreateAlertMutationResult = NonNullable<
  Awaited<ReturnType<typeof adminServiceCreateAlert>>
>;
export type AdminServiceCreateAlertMutationBody =
  AdminServiceCreateAlertBodyBody;
export type AdminServiceCreateAlertMutationError = RpcStatus;

/**
 * @summary CreateAlert adds a virtual file for an alert, triggers a reconcile, and waits for the alert to be added to the runtime catalog
 */
export const createAdminServiceCreateAlert = <
  TError = RpcStatus,
  TContext = unknown,
>(
  options?: {
    mutation?: CreateMutationOptions<
      Awaited<ReturnType<typeof adminServiceCreateAlert>>,
      TError,
      {
        organization: string;
        project: string;
        data: AdminServiceCreateAlertBodyBody;
      },
      TContext
    >;
  },
  queryClient?: QueryClient,
): CreateMutationResult<
  Awaited<ReturnType<typeof adminServiceCreateAlert>>,
  TError,
  {
    organization: string;
    project: string;
    data: AdminServiceCreateAlertBodyBody;
  },
  TContext
> => {
  const mutationOptions = getAdminServiceCreateAlertMutationOptions(options);

  return createMutation(mutationOptions, queryClient);
};
/**
 * @summary GenerateAlertYAML generates YAML for an alert to be copied into a project's Git repository
 */
export const adminServiceGenerateAlertYAML = (
  organization: string,
  project: string,
  adminServiceCreateAlertBodyBody: AdminServiceCreateAlertBodyBody,
  signal?: AbortSignal,
) => {
  return httpClient<V1GenerateAlertYAMLResponse>({
    url: `/v1/organizations/${organization}/projects/${project}/alerts/-/yaml`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: adminServiceCreateAlertBodyBody,
    signal,
  });
};

export const getAdminServiceGenerateAlertYAMLMutationOptions = <
  TError = RpcStatus,
  TContext = unknown,
>(options?: {
  mutation?: CreateMutationOptions<
    Awaited<ReturnType<typeof adminServiceGenerateAlertYAML>>,
    TError,
    {
      organization: string;
      project: string;
      data: AdminServiceCreateAlertBodyBody;
    },
    TContext
  >;
}): CreateMutationOptions<
  Awaited<ReturnType<typeof adminServiceGenerateAlertYAML>>,
  TError,
  {
    organization: string;
    project: string;
    data: AdminServiceCreateAlertBodyBody;
  },
  TContext
> => {
  const mutationKey = ["adminServiceGenerateAlertYAML"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof adminServiceGenerateAlertYAML>>,
    {
      organization: string;
      project: string;
      data: AdminServiceCreateAlertBodyBody;
    }
  > = (props) => {
    const { organization, project, data } = props ?? {};

    return adminServiceGenerateAlertYAML(organization, project, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type AdminServiceGenerateAlertYAMLMutationResult = NonNullable<
  Awaited<ReturnType<typeof adminServiceGenerateAlertYAML>>
>;
export type AdminServiceGenerateAlertYAMLMutationBody =
  AdminServiceCreateAlertBodyBody;
export type AdminServiceGenerateAlertYAMLMutationError = RpcStatus;

/**
 * @summary GenerateAlertYAML generates YAML for an alert to be copied into a project's Git repository
 */
export const createAdminServiceGenerateAlertYAML = <
  TError = RpcStatus,
  TContext = unknown,
>(
  options?: {
    mutation?: CreateMutationOptions<
      Awaited<ReturnType<typeof adminServiceGenerateAlertYAML>>,
      TError,
      {
        organization: string;
        project: string;
        data: AdminServiceCreateAlertBodyBody;
      },
      TContext
    >;
  },
  queryClient?: QueryClient,
): CreateMutationResult<
  Awaited<ReturnType<typeof adminServiceGenerateAlertYAML>>,
  TError,
  {
    organization: string;
    project: string;
    data: AdminServiceCreateAlertBodyBody;
  },
  TContext
> => {
  const mutationOptions =
    getAdminServiceGenerateAlertYAMLMutationOptions(options);

  return createMutation(mutationOptions, queryClient);
};
/**
 * @summary DeleteAlert deletes the virtual file for a UI-managed alert, triggers a reconcile, and waits for the alert to be deleted in the runtime
 */
export const adminServiceDeleteAlert = (
  organization: string,
  project: string,
  name: string,
) => {
  return httpClient<V1DeleteAlertResponse>({
    url: `/v1/organizations/${organization}/projects/${project}/alerts/${name}`,
    method: "DELETE",
  });
};

export const getAdminServiceDeleteAlertMutationOptions = <
  TError = RpcStatus,
  TContext = unknown,
>(options?: {
  mutation?: CreateMutationOptions<
    Awaited<ReturnType<typeof adminServiceDeleteAlert>>,
    TError,
    { organization: string; project: string; name: string },
    TContext
  >;
}): CreateMutationOptions<
  Awaited<ReturnType<typeof adminServiceDeleteAlert>>,
  TError,
  { organization: string; project: string; name: string },
  TContext
> => {
  const mutationKey = ["adminServiceDeleteAlert"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof adminServiceDeleteAlert>>,
    { organization: string; project: string; name: string }
  > = (props) => {
    const { organization, project, name } = props ?? {};

    return adminServiceDeleteAlert(organization, project, name);
  };

  return { mutationFn, ...mutationOptions };
};

export type AdminServiceDeleteAlertMutationResult = NonNullable<
  Awaited<ReturnType<typeof adminServiceDeleteAlert>>
>;

export type AdminServiceDeleteAlertMutationError = RpcStatus;

/**
 * @summary DeleteAlert deletes the virtual file for a UI-managed alert, triggers a reconcile, and waits for the alert to be deleted in the runtime
 */
export const createAdminServiceDeleteAlert = <
  TError = RpcStatus,
  TContext = unknown,
>(
  options?: {
    mutation?: CreateMutationOptions<
      Awaited<ReturnType<typeof adminServiceDeleteAlert>>,
      TError,
      { organization: string; project: string; name: string },
      TContext
    >;
  },
  queryClient?: QueryClient,
): CreateMutationResult<
  Awaited<ReturnType<typeof adminServiceDeleteAlert>>,
  TError,
  { organization: string; project: string; name: string },
  TContext
> => {
  const mutationOptions = getAdminServiceDeleteAlertMutationOptions(options);

  return createMutation(mutationOptions, queryClient);
};
/**
 * @summary EditAlert edits a virtual file for a UI-managed alert, triggers a reconcile, and waits for the alert to be updated in the runtime
 */
export const adminServiceEditAlert = (
  organization: string,
  project: string,
  name: string,
  adminServiceCreateAlertBodyBody: AdminServiceCreateAlertBodyBody,
) => {
  return httpClient<V1EditAlertResponse>({
    url: `/v1/organizations/${organization}/projects/${project}/alerts/${name}`,
    method: "PUT",
    headers: { "Content-Type": "application/json" },
    data: adminServiceCreateAlertBodyBody,
  });
};

export const getAdminServiceEditAlertMutationOptions = <
  TError = RpcStatus,
  TContext = unknown,
>(options?: {
  mutation?: CreateMutationOptions<
    Awaited<ReturnType<typeof adminServiceEditAlert>>,
    TError,
    {
      organization: string;
      project: string;
      name: string;
      data: AdminServiceCreateAlertBodyBody;
    },
    TContext
  >;
}): CreateMutationOptions<
  Awaited<ReturnType<typeof adminServiceEditAlert>>,
  TError,
  {
    organization: string;
    project: string;
    name: string;
    data: AdminServiceCreateAlertBodyBody;
  },
  TContext
> => {
  const mutationKey = ["adminServiceEditAlert"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof adminServiceEditAlert>>,
    {
      organization: string;
      project: string;
      name: string;
      data: AdminServiceCreateAlertBodyBody;
    }
  > = (props) => {
    const { organization, project, name, data } = props ?? {};

    return adminServiceEditAlert(organization, project, name, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type AdminServiceEditAlertMutationResult = NonNullable<
  Awaited<ReturnType<typeof adminServiceEditAlert>>
>;
export type AdminServiceEditAlertMutationBody = AdminServiceCreateAlertBodyBody;
export type AdminServiceEditAlertMutationError = RpcStatus;

/**
 * @summary EditAlert edits a virtual file for a UI-managed alert, triggers a reconcile, and waits for the alert to be updated in the runtime
 */
export const createAdminServiceEditAlert = <
  TError = RpcStatus,
  TContext = unknown,
>(
  options?: {
    mutation?: CreateMutationOptions<
      Awaited<ReturnType<typeof adminServiceEditAlert>>,
      TError,
      {
        organization: string;
        project: string;
        name: string;
        data: AdminServiceCreateAlertBodyBody;
      },
      TContext
    >;
  },
  queryClient?: QueryClient,
): CreateMutationResult<
  Awaited<ReturnType<typeof adminServiceEditAlert>>,
  TError,
  {
    organization: string;
    project: string;
    name: string;
    data: AdminServiceCreateAlertBodyBody;
  },
  TContext
> => {
  const mutationOptions = getAdminServiceEditAlertMutationOptions(options);

  return createMutation(mutationOptions, queryClient);
};
/**
 * @summary UnsubscribeAlert removes the calling user from a alert's recipients list
 */
export const adminServiceUnsubscribeAlert = (
  organization: string,
  project: string,
  name: string,
  adminServiceTriggerReconcileBodyBody: AdminServiceTriggerReconcileBodyBody,
  signal?: AbortSignal,
) => {
  return httpClient<V1UnsubscribeAlertResponse>({
    url: `/v1/organizations/${organization}/projects/${project}/alerts/${name}/unsubscribe`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: adminServiceTriggerReconcileBodyBody,
    signal,
  });
};

export const getAdminServiceUnsubscribeAlertMutationOptions = <
  TError = RpcStatus,
  TContext = unknown,
>(options?: {
  mutation?: CreateMutationOptions<
    Awaited<ReturnType<typeof adminServiceUnsubscribeAlert>>,
    TError,
    {
      organization: string;
      project: string;
      name: string;
      data: AdminServiceTriggerReconcileBodyBody;
    },
    TContext
  >;
}): CreateMutationOptions<
  Awaited<ReturnType<typeof adminServiceUnsubscribeAlert>>,
  TError,
  {
    organization: string;
    project: string;
    name: string;
    data: AdminServiceTriggerReconcileBodyBody;
  },
  TContext
> => {
  const mutationKey = ["adminServiceUnsubscribeAlert"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof adminServiceUnsubscribeAlert>>,
    {
      organization: string;
      project: string;
      name: string;
      data: AdminServiceTriggerReconcileBodyBody;
    }
  > = (props) => {
    const { organization, project, name, data } = props ?? {};

    return adminServiceUnsubscribeAlert(organization, project, name, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type AdminServiceUnsubscribeAlertMutationResult = NonNullable<
  Awaited<ReturnType<typeof adminServiceUnsubscribeAlert>>
>;
export type AdminServiceUnsubscribeAlertMutationBody =
  AdminServiceTriggerReconcileBodyBody;
export type AdminServiceUnsubscribeAlertMutationError = RpcStatus;

/**
 * @summary UnsubscribeAlert removes the calling user from a alert's recipients list
 */
export const createAdminServiceUnsubscribeAlert = <
  TError = RpcStatus,
  TContext = unknown,
>(
  options?: {
    mutation?: CreateMutationOptions<
      Awaited<ReturnType<typeof adminServiceUnsubscribeAlert>>,
      TError,
      {
        organization: string;
        project: string;
        name: string;
        data: AdminServiceTriggerReconcileBodyBody;
      },
      TContext
    >;
  },
  queryClient?: QueryClient,
): CreateMutationResult<
  Awaited<ReturnType<typeof adminServiceUnsubscribeAlert>>,
  TError,
  {
    organization: string;
    project: string;
    name: string;
    data: AdminServiceTriggerReconcileBodyBody;
  },
  TContext
> => {
  const mutationOptions =
    getAdminServiceUnsubscribeAlertMutationOptions(options);

  return createMutation(mutationOptions, queryClient);
};
/**
 * @summary GenerateAlertYAML generates YAML for an alert to be copied into a project's Git repository
 */
export const adminServiceGetAlertYAML = (
  organization: string,
  project: string,
  name: string,
  signal?: AbortSignal,
) => {
  return httpClient<V1GetAlertYAMLResponse>({
    url: `/v1/organizations/${organization}/projects/${project}/alerts/${name}/yaml`,
    method: "GET",
    signal,
  });
};

export const getAdminServiceGetAlertYAMLQueryKey = (
  organization: string,
  project: string,
  name: string,
) => {
  return [
    `/v1/organizations/${organization}/projects/${project}/alerts/${name}/yaml`,
  ] as const;
};

export const getAdminServiceGetAlertYAMLQueryOptions = <
  TData = Awaited<ReturnType<typeof adminServiceGetAlertYAML>>,
  TError = RpcStatus,
>(
  organization: string,
  project: string,
  name: string,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof adminServiceGetAlertYAML>>,
        TError,
        TData
      >
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getAdminServiceGetAlertYAMLQueryKey(organization, project, name);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof adminServiceGetAlertYAML>>
  > = ({ signal }) =>
    adminServiceGetAlertYAML(organization, project, name, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!(organization && project && name),
    ...queryOptions,
  } as CreateQueryOptions<
    Awaited<ReturnType<typeof adminServiceGetAlertYAML>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type AdminServiceGetAlertYAMLQueryResult = NonNullable<
  Awaited<ReturnType<typeof adminServiceGetAlertYAML>>
>;
export type AdminServiceGetAlertYAMLQueryError = RpcStatus;

/**
 * @summary GenerateAlertYAML generates YAML for an alert to be copied into a project's Git repository
 */

export function createAdminServiceGetAlertYAML<
  TData = Awaited<ReturnType<typeof adminServiceGetAlertYAML>>,
  TError = RpcStatus,
>(
  organization: string,
  project: string,
  name: string,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof adminServiceGetAlertYAML>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): CreateQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getAdminServiceGetAlertYAMLQueryOptions(
    organization,
    project,
    name,
    options,
  );

  const query = createQuery(queryOptions, queryClient) as CreateQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary GetCloneCredentials returns credentials and other details for a project's Git repository or archive path if git repo is not configured.
 */
export const adminServiceGetCloneCredentials = (
  organization: string,
  project: string,
  params?: AdminServiceGetCloneCredentialsParams,
  signal?: AbortSignal,
) => {
  return httpClient<V1GetCloneCredentialsResponse>({
    url: `/v1/organizations/${organization}/projects/${project}/clone-credentials`,
    method: "GET",
    params,
    signal,
  });
};

export const getAdminServiceGetCloneCredentialsQueryKey = (
  organization: string,
  project: string,
  params?: AdminServiceGetCloneCredentialsParams,
) => {
  return [
    `/v1/organizations/${organization}/projects/${project}/clone-credentials`,
    ...(params ? [params] : []),
  ] as const;
};

export const getAdminServiceGetCloneCredentialsQueryOptions = <
  TData = Awaited<ReturnType<typeof adminServiceGetCloneCredentials>>,
  TError = RpcStatus,
>(
  organization: string,
  project: string,
  params?: AdminServiceGetCloneCredentialsParams,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof adminServiceGetCloneCredentials>>,
        TError,
        TData
      >
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getAdminServiceGetCloneCredentialsQueryKey(organization, project, params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof adminServiceGetCloneCredentials>>
  > = ({ signal }) =>
    adminServiceGetCloneCredentials(organization, project, params, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!(organization && project),
    ...queryOptions,
  } as CreateQueryOptions<
    Awaited<ReturnType<typeof adminServiceGetCloneCredentials>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type AdminServiceGetCloneCredentialsQueryResult = NonNullable<
  Awaited<ReturnType<typeof adminServiceGetCloneCredentials>>
>;
export type AdminServiceGetCloneCredentialsQueryError = RpcStatus;

/**
 * @summary GetCloneCredentials returns credentials and other details for a project's Git repository or archive path if git repo is not configured.
 */

export function createAdminServiceGetCloneCredentials<
  TData = Awaited<ReturnType<typeof adminServiceGetCloneCredentials>>,
  TError = RpcStatus,
>(
  organization: string,
  project: string,
  params?: AdminServiceGetCloneCredentialsParams,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof adminServiceGetCloneCredentials>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): CreateQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getAdminServiceGetCloneCredentialsQueryOptions(
    organization,
    project,
    params,
    options,
  );

  const query = createQuery(queryOptions, queryClient) as CreateQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Connects a rill managed project to github.
Replaces the contents of the remote repo with the contents of the project.
 */
export const adminServiceConnectProjectToGithub = (
  organization: string,
  project: string,
  adminServiceConnectProjectToGithubBody: AdminServiceConnectProjectToGithubBody,
  signal?: AbortSignal,
) => {
  return httpClient<V1ConnectProjectToGithubResponse>({
    url: `/v1/organizations/${organization}/projects/${project}/connect-to-github`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: adminServiceConnectProjectToGithubBody,
    signal,
  });
};

export const getAdminServiceConnectProjectToGithubMutationOptions = <
  TError = RpcStatus,
  TContext = unknown,
>(options?: {
  mutation?: CreateMutationOptions<
    Awaited<ReturnType<typeof adminServiceConnectProjectToGithub>>,
    TError,
    {
      organization: string;
      project: string;
      data: AdminServiceConnectProjectToGithubBody;
    },
    TContext
  >;
}): CreateMutationOptions<
  Awaited<ReturnType<typeof adminServiceConnectProjectToGithub>>,
  TError,
  {
    organization: string;
    project: string;
    data: AdminServiceConnectProjectToGithubBody;
  },
  TContext
> => {
  const mutationKey = ["adminServiceConnectProjectToGithub"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof adminServiceConnectProjectToGithub>>,
    {
      organization: string;
      project: string;
      data: AdminServiceConnectProjectToGithubBody;
    }
  > = (props) => {
    const { organization, project, data } = props ?? {};

    return adminServiceConnectProjectToGithub(organization, project, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type AdminServiceConnectProjectToGithubMutationResult = NonNullable<
  Awaited<ReturnType<typeof adminServiceConnectProjectToGithub>>
>;
export type AdminServiceConnectProjectToGithubMutationBody =
  AdminServiceConnectProjectToGithubBody;
export type AdminServiceConnectProjectToGithubMutationError = RpcStatus;

/**
 * @summary Connects a rill managed project to github.
Replaces the contents of the remote repo with the contents of the project.
 */
export const createAdminServiceConnectProjectToGithub = <
  TError = RpcStatus,
  TContext = unknown,
>(
  options?: {
    mutation?: CreateMutationOptions<
      Awaited<ReturnType<typeof adminServiceConnectProjectToGithub>>,
      TError,
      {
        organization: string;
        project: string;
        data: AdminServiceConnectProjectToGithubBody;
      },
      TContext
    >;
  },
  queryClient?: QueryClient,
): CreateMutationResult<
  Awaited<ReturnType<typeof adminServiceConnectProjectToGithub>>,
  TError,
  {
    organization: string;
    project: string;
    data: AdminServiceConnectProjectToGithubBody;
  },
  TContext
> => {
  const mutationOptions =
    getAdminServiceConnectProjectToGithubMutationOptions(options);

  return createMutation(mutationOptions, queryClient);
};
/**
 * @summary GetDeploymentCredentials returns runtime info and access token on behalf of a specific user, or alternatively for a raw set of JWT attributes
DEPRECATED: Clients should call GetDeployment instead.
 */
export const adminServiceGetDeploymentCredentials = (
  organization: string,
  project: string,
  adminServiceGetDeploymentCredentialsBody: AdminServiceGetDeploymentCredentialsBody,
  signal?: AbortSignal,
) => {
  return httpClient<V1GetDeploymentCredentialsResponse>({
    url: `/v1/organizations/${organization}/projects/${project}/credentials`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: adminServiceGetDeploymentCredentialsBody,
    signal,
  });
};

export const getAdminServiceGetDeploymentCredentialsQueryKey = (
  organization: string,
  project: string,
  adminServiceGetDeploymentCredentialsBody: AdminServiceGetDeploymentCredentialsBody,
) => {
  return [
    `/v1/organizations/${organization}/projects/${project}/credentials`,
    adminServiceGetDeploymentCredentialsBody,
  ] as const;
};

export const getAdminServiceGetDeploymentCredentialsQueryOptions = <
  TData = Awaited<ReturnType<typeof adminServiceGetDeploymentCredentials>>,
  TError = RpcStatus,
>(
  organization: string,
  project: string,
  adminServiceGetDeploymentCredentialsBody: AdminServiceGetDeploymentCredentialsBody,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof adminServiceGetDeploymentCredentials>>,
        TError,
        TData
      >
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getAdminServiceGetDeploymentCredentialsQueryKey(
      organization,
      project,
      adminServiceGetDeploymentCredentialsBody,
    );

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof adminServiceGetDeploymentCredentials>>
  > = ({ signal }) =>
    adminServiceGetDeploymentCredentials(
      organization,
      project,
      adminServiceGetDeploymentCredentialsBody,
      signal,
    );

  return {
    queryKey,
    queryFn,
    enabled: !!(organization && project),
    ...queryOptions,
  } as CreateQueryOptions<
    Awaited<ReturnType<typeof adminServiceGetDeploymentCredentials>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type AdminServiceGetDeploymentCredentialsQueryResult = NonNullable<
  Awaited<ReturnType<typeof adminServiceGetDeploymentCredentials>>
>;
export type AdminServiceGetDeploymentCredentialsQueryError = RpcStatus;

/**
 * @summary GetDeploymentCredentials returns runtime info and access token on behalf of a specific user, or alternatively for a raw set of JWT attributes
DEPRECATED: Clients should call GetDeployment instead.
 */

export function createAdminServiceGetDeploymentCredentials<
  TData = Awaited<ReturnType<typeof adminServiceGetDeploymentCredentials>>,
  TError = RpcStatus,
>(
  organization: string,
  project: string,
  adminServiceGetDeploymentCredentialsBody: AdminServiceGetDeploymentCredentialsBody,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof adminServiceGetDeploymentCredentials>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): CreateQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getAdminServiceGetDeploymentCredentialsQueryOptions(
    organization,
    project,
    adminServiceGetDeploymentCredentialsBody,
    options,
  );

  const query = createQuery(queryOptions, queryClient) as CreateQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary HibernateProject hibernates a project by tearing down its deployments.
 */
export const adminServiceHibernateProject = (
  organization: string,
  project: string,
  params?: AdminServiceHibernateProjectParams,
  signal?: AbortSignal,
) => {
  return httpClient<V1HibernateProjectResponse>({
    url: `/v1/organizations/${organization}/projects/${project}/hibernate`,
    method: "POST",
    params,
    signal,
  });
};

export const getAdminServiceHibernateProjectMutationOptions = <
  TError = RpcStatus,
  TContext = unknown,
>(options?: {
  mutation?: CreateMutationOptions<
    Awaited<ReturnType<typeof adminServiceHibernateProject>>,
    TError,
    {
      organization: string;
      project: string;
      params?: AdminServiceHibernateProjectParams;
    },
    TContext
  >;
}): CreateMutationOptions<
  Awaited<ReturnType<typeof adminServiceHibernateProject>>,
  TError,
  {
    organization: string;
    project: string;
    params?: AdminServiceHibernateProjectParams;
  },
  TContext
> => {
  const mutationKey = ["adminServiceHibernateProject"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof adminServiceHibernateProject>>,
    {
      organization: string;
      project: string;
      params?: AdminServiceHibernateProjectParams;
    }
  > = (props) => {
    const { organization, project, params } = props ?? {};

    return adminServiceHibernateProject(organization, project, params);
  };

  return { mutationFn, ...mutationOptions };
};

export type AdminServiceHibernateProjectMutationResult = NonNullable<
  Awaited<ReturnType<typeof adminServiceHibernateProject>>
>;

export type AdminServiceHibernateProjectMutationError = RpcStatus;

/**
 * @summary HibernateProject hibernates a project by tearing down its deployments.
 */
export const createAdminServiceHibernateProject = <
  TError = RpcStatus,
  TContext = unknown,
>(
  options?: {
    mutation?: CreateMutationOptions<
      Awaited<ReturnType<typeof adminServiceHibernateProject>>,
      TError,
      {
        organization: string;
        project: string;
        params?: AdminServiceHibernateProjectParams;
      },
      TContext
    >;
  },
  queryClient?: QueryClient,
): CreateMutationResult<
  Awaited<ReturnType<typeof adminServiceHibernateProject>>,
  TError,
  {
    organization: string;
    project: string;
    params?: AdminServiceHibernateProjectParams;
  },
  TContext
> => {
  const mutationOptions =
    getAdminServiceHibernateProjectMutationOptions(options);

  return createMutation(mutationOptions, queryClient);
};
/**
 * @summary GetIFrame returns the iframe URL for the given project
 */
export const adminServiceGetIFrame = (
  organization: string,
  project: string,
  adminServiceGetIFrameBody: AdminServiceGetIFrameBody,
  signal?: AbortSignal,
) => {
  return httpClient<V1GetIFrameResponse>({
    url: `/v1/organizations/${organization}/projects/${project}/iframe`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: adminServiceGetIFrameBody,
    signal,
  });
};

export const getAdminServiceGetIFrameMutationOptions = <
  TError = RpcStatus,
  TContext = unknown,
>(options?: {
  mutation?: CreateMutationOptions<
    Awaited<ReturnType<typeof adminServiceGetIFrame>>,
    TError,
    { organization: string; project: string; data: AdminServiceGetIFrameBody },
    TContext
  >;
}): CreateMutationOptions<
  Awaited<ReturnType<typeof adminServiceGetIFrame>>,
  TError,
  { organization: string; project: string; data: AdminServiceGetIFrameBody },
  TContext
> => {
  const mutationKey = ["adminServiceGetIFrame"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof adminServiceGetIFrame>>,
    { organization: string; project: string; data: AdminServiceGetIFrameBody }
  > = (props) => {
    const { organization, project, data } = props ?? {};

    return adminServiceGetIFrame(organization, project, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type AdminServiceGetIFrameMutationResult = NonNullable<
  Awaited<ReturnType<typeof adminServiceGetIFrame>>
>;
export type AdminServiceGetIFrameMutationBody = AdminServiceGetIFrameBody;
export type AdminServiceGetIFrameMutationError = RpcStatus;

/**
 * @summary GetIFrame returns the iframe URL for the given project
 */
export const createAdminServiceGetIFrame = <
  TError = RpcStatus,
  TContext = unknown,
>(
  options?: {
    mutation?: CreateMutationOptions<
      Awaited<ReturnType<typeof adminServiceGetIFrame>>,
      TError,
      {
        organization: string;
        project: string;
        data: AdminServiceGetIFrameBody;
      },
      TContext
    >;
  },
  queryClient?: QueryClient,
): CreateMutationResult<
  Awaited<ReturnType<typeof adminServiceGetIFrame>>,
  TError,
  { organization: string; project: string; data: AdminServiceGetIFrameBody },
  TContext
> => {
  const mutationOptions = getAdminServiceGetIFrameMutationOptions(options);

  return createMutation(mutationOptions, queryClient);
};
/**
 * @summary ListProjectInvites lists all the project invites
 */
export const adminServiceListProjectInvites = (
  organization: string,
  project: string,
  params?: AdminServiceListProjectInvitesParams,
  signal?: AbortSignal,
) => {
  return httpClient<V1ListProjectInvitesResponse>({
    url: `/v1/organizations/${organization}/projects/${project}/invites`,
    method: "GET",
    params,
    signal,
  });
};

export const getAdminServiceListProjectInvitesQueryKey = (
  organization: string,
  project: string,
  params?: AdminServiceListProjectInvitesParams,
) => {
  return [
    `/v1/organizations/${organization}/projects/${project}/invites`,
    ...(params ? [params] : []),
  ] as const;
};

export const getAdminServiceListProjectInvitesQueryOptions = <
  TData = Awaited<ReturnType<typeof adminServiceListProjectInvites>>,
  TError = RpcStatus,
>(
  organization: string,
  project: string,
  params?: AdminServiceListProjectInvitesParams,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof adminServiceListProjectInvites>>,
        TError,
        TData
      >
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getAdminServiceListProjectInvitesQueryKey(organization, project, params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof adminServiceListProjectInvites>>
  > = ({ signal }) =>
    adminServiceListProjectInvites(organization, project, params, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!(organization && project),
    ...queryOptions,
  } as CreateQueryOptions<
    Awaited<ReturnType<typeof adminServiceListProjectInvites>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type AdminServiceListProjectInvitesQueryResult = NonNullable<
  Awaited<ReturnType<typeof adminServiceListProjectInvites>>
>;
export type AdminServiceListProjectInvitesQueryError = RpcStatus;

/**
 * @summary ListProjectInvites lists all the project invites
 */

export function createAdminServiceListProjectInvites<
  TData = Awaited<ReturnType<typeof adminServiceListProjectInvites>>,
  TError = RpcStatus,
>(
  organization: string,
  project: string,
  params?: AdminServiceListProjectInvitesParams,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof adminServiceListProjectInvites>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): CreateQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getAdminServiceListProjectInvitesQueryOptions(
    organization,
    project,
    params,
    options,
  );

  const query = createQuery(queryOptions, queryClient) as CreateQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary ListProjectMemberUsers lists all the project members
 */
export const adminServiceListProjectMemberUsers = (
  organization: string,
  project: string,
  params?: AdminServiceListProjectMemberUsersParams,
  signal?: AbortSignal,
) => {
  return httpClient<V1ListProjectMemberUsersResponse>({
    url: `/v1/organizations/${organization}/projects/${project}/members`,
    method: "GET",
    params,
    signal,
  });
};

export const getAdminServiceListProjectMemberUsersQueryKey = (
  organization: string,
  project: string,
  params?: AdminServiceListProjectMemberUsersParams,
) => {
  return [
    `/v1/organizations/${organization}/projects/${project}/members`,
    ...(params ? [params] : []),
  ] as const;
};

export const getAdminServiceListProjectMemberUsersQueryOptions = <
  TData = Awaited<ReturnType<typeof adminServiceListProjectMemberUsers>>,
  TError = RpcStatus,
>(
  organization: string,
  project: string,
  params?: AdminServiceListProjectMemberUsersParams,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof adminServiceListProjectMemberUsers>>,
        TError,
        TData
      >
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getAdminServiceListProjectMemberUsersQueryKey(
      organization,
      project,
      params,
    );

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof adminServiceListProjectMemberUsers>>
  > = ({ signal }) =>
    adminServiceListProjectMemberUsers(organization, project, params, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!(organization && project),
    ...queryOptions,
  } as CreateQueryOptions<
    Awaited<ReturnType<typeof adminServiceListProjectMemberUsers>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type AdminServiceListProjectMemberUsersQueryResult = NonNullable<
  Awaited<ReturnType<typeof adminServiceListProjectMemberUsers>>
>;
export type AdminServiceListProjectMemberUsersQueryError = RpcStatus;

/**
 * @summary ListProjectMemberUsers lists all the project members
 */

export function createAdminServiceListProjectMemberUsers<
  TData = Awaited<ReturnType<typeof adminServiceListProjectMemberUsers>>,
  TError = RpcStatus,
>(
  organization: string,
  project: string,
  params?: AdminServiceListProjectMemberUsersParams,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof adminServiceListProjectMemberUsers>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): CreateQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getAdminServiceListProjectMemberUsersQueryOptions(
    organization,
    project,
    params,
    options,
  );

  const query = createQuery(queryOptions, queryClient) as CreateQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary AddProjectMemberUser adds a member to the project
 */
export const adminServiceAddProjectMemberUser = (
  organization: string,
  project: string,
  adminServiceAddProjectMemberUserBody: AdminServiceAddProjectMemberUserBody,
  signal?: AbortSignal,
) => {
  return httpClient<V1AddProjectMemberUserResponse>({
    url: `/v1/organizations/${organization}/projects/${project}/members`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: adminServiceAddProjectMemberUserBody,
    signal,
  });
};

export const getAdminServiceAddProjectMemberUserMutationOptions = <
  TError = RpcStatus,
  TContext = unknown,
>(options?: {
  mutation?: CreateMutationOptions<
    Awaited<ReturnType<typeof adminServiceAddProjectMemberUser>>,
    TError,
    {
      organization: string;
      project: string;
      data: AdminServiceAddProjectMemberUserBody;
    },
    TContext
  >;
}): CreateMutationOptions<
  Awaited<ReturnType<typeof adminServiceAddProjectMemberUser>>,
  TError,
  {
    organization: string;
    project: string;
    data: AdminServiceAddProjectMemberUserBody;
  },
  TContext
> => {
  const mutationKey = ["adminServiceAddProjectMemberUser"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof adminServiceAddProjectMemberUser>>,
    {
      organization: string;
      project: string;
      data: AdminServiceAddProjectMemberUserBody;
    }
  > = (props) => {
    const { organization, project, data } = props ?? {};

    return adminServiceAddProjectMemberUser(organization, project, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type AdminServiceAddProjectMemberUserMutationResult = NonNullable<
  Awaited<ReturnType<typeof adminServiceAddProjectMemberUser>>
>;
export type AdminServiceAddProjectMemberUserMutationBody =
  AdminServiceAddProjectMemberUserBody;
export type AdminServiceAddProjectMemberUserMutationError = RpcStatus;

/**
 * @summary AddProjectMemberUser adds a member to the project
 */
export const createAdminServiceAddProjectMemberUser = <
  TError = RpcStatus,
  TContext = unknown,
>(
  options?: {
    mutation?: CreateMutationOptions<
      Awaited<ReturnType<typeof adminServiceAddProjectMemberUser>>,
      TError,
      {
        organization: string;
        project: string;
        data: AdminServiceAddProjectMemberUserBody;
      },
      TContext
    >;
  },
  queryClient?: QueryClient,
): CreateMutationResult<
  Awaited<ReturnType<typeof adminServiceAddProjectMemberUser>>,
  TError,
  {
    organization: string;
    project: string;
    data: AdminServiceAddProjectMemberUserBody;
  },
  TContext
> => {
  const mutationOptions =
    getAdminServiceAddProjectMemberUserMutationOptions(options);

  return createMutation(mutationOptions, queryClient);
};
/**
 * @summary RemoveProjectMemberUser removes member from the project
 */
export const adminServiceRemoveProjectMemberUser = (
  organization: string,
  project: string,
  email: string,
) => {
  return httpClient<V1RemoveProjectMemberUserResponse>({
    url: `/v1/organizations/${organization}/projects/${project}/members/${email}`,
    method: "DELETE",
  });
};

export const getAdminServiceRemoveProjectMemberUserMutationOptions = <
  TError = RpcStatus,
  TContext = unknown,
>(options?: {
  mutation?: CreateMutationOptions<
    Awaited<ReturnType<typeof adminServiceRemoveProjectMemberUser>>,
    TError,
    { organization: string; project: string; email: string },
    TContext
  >;
}): CreateMutationOptions<
  Awaited<ReturnType<typeof adminServiceRemoveProjectMemberUser>>,
  TError,
  { organization: string; project: string; email: string },
  TContext
> => {
  const mutationKey = ["adminServiceRemoveProjectMemberUser"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof adminServiceRemoveProjectMemberUser>>,
    { organization: string; project: string; email: string }
  > = (props) => {
    const { organization, project, email } = props ?? {};

    return adminServiceRemoveProjectMemberUser(organization, project, email);
  };

  return { mutationFn, ...mutationOptions };
};

export type AdminServiceRemoveProjectMemberUserMutationResult = NonNullable<
  Awaited<ReturnType<typeof adminServiceRemoveProjectMemberUser>>
>;

export type AdminServiceRemoveProjectMemberUserMutationError = RpcStatus;

/**
 * @summary RemoveProjectMemberUser removes member from the project
 */
export const createAdminServiceRemoveProjectMemberUser = <
  TError = RpcStatus,
  TContext = unknown,
>(
  options?: {
    mutation?: CreateMutationOptions<
      Awaited<ReturnType<typeof adminServiceRemoveProjectMemberUser>>,
      TError,
      { organization: string; project: string; email: string },
      TContext
    >;
  },
  queryClient?: QueryClient,
): CreateMutationResult<
  Awaited<ReturnType<typeof adminServiceRemoveProjectMemberUser>>,
  TError,
  { organization: string; project: string; email: string },
  TContext
> => {
  const mutationOptions =
    getAdminServiceRemoveProjectMemberUserMutationOptions(options);

  return createMutation(mutationOptions, queryClient);
};
/**
 * @summary SetProjectMemberUserRole sets the role for the member
 */
export const adminServiceSetProjectMemberUserRole = (
  organization: string,
  project: string,
  email: string,
  adminServiceSetProjectMemberUserRoleBodyBody: AdminServiceSetProjectMemberUserRoleBodyBody,
) => {
  return httpClient<V1SetProjectMemberUserRoleResponse>({
    url: `/v1/organizations/${organization}/projects/${project}/members/${email}`,
    method: "PUT",
    headers: { "Content-Type": "application/json" },
    data: adminServiceSetProjectMemberUserRoleBodyBody,
  });
};

export const getAdminServiceSetProjectMemberUserRoleMutationOptions = <
  TError = RpcStatus,
  TContext = unknown,
>(options?: {
  mutation?: CreateMutationOptions<
    Awaited<ReturnType<typeof adminServiceSetProjectMemberUserRole>>,
    TError,
    {
      organization: string;
      project: string;
      email: string;
      data: AdminServiceSetProjectMemberUserRoleBodyBody;
    },
    TContext
  >;
}): CreateMutationOptions<
  Awaited<ReturnType<typeof adminServiceSetProjectMemberUserRole>>,
  TError,
  {
    organization: string;
    project: string;
    email: string;
    data: AdminServiceSetProjectMemberUserRoleBodyBody;
  },
  TContext
> => {
  const mutationKey = ["adminServiceSetProjectMemberUserRole"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof adminServiceSetProjectMemberUserRole>>,
    {
      organization: string;
      project: string;
      email: string;
      data: AdminServiceSetProjectMemberUserRoleBodyBody;
    }
  > = (props) => {
    const { organization, project, email, data } = props ?? {};

    return adminServiceSetProjectMemberUserRole(
      organization,
      project,
      email,
      data,
    );
  };

  return { mutationFn, ...mutationOptions };
};

export type AdminServiceSetProjectMemberUserRoleMutationResult = NonNullable<
  Awaited<ReturnType<typeof adminServiceSetProjectMemberUserRole>>
>;
export type AdminServiceSetProjectMemberUserRoleMutationBody =
  AdminServiceSetProjectMemberUserRoleBodyBody;
export type AdminServiceSetProjectMemberUserRoleMutationError = RpcStatus;

/**
 * @summary SetProjectMemberUserRole sets the role for the member
 */
export const createAdminServiceSetProjectMemberUserRole = <
  TError = RpcStatus,
  TContext = unknown,
>(
  options?: {
    mutation?: CreateMutationOptions<
      Awaited<ReturnType<typeof adminServiceSetProjectMemberUserRole>>,
      TError,
      {
        organization: string;
        project: string;
        email: string;
        data: AdminServiceSetProjectMemberUserRoleBodyBody;
      },
      TContext
    >;
  },
  queryClient?: QueryClient,
): CreateMutationResult<
  Awaited<ReturnType<typeof adminServiceSetProjectMemberUserRole>>,
  TError,
  {
    organization: string;
    project: string;
    email: string;
    data: AdminServiceSetProjectMemberUserRoleBodyBody;
  },
  TContext
> => {
  const mutationOptions =
    getAdminServiceSetProjectMemberUserRoleMutationOptions(options);

  return createMutation(mutationOptions, queryClient);
};
/**
 * @summary RedeployProject creates a new production deployment for a project.
If the project currently has another production deployment, the old deployment will be deprovisioned.
This RPC can be used to redeploy a project that has been hibernated.
 */
export const adminServiceRedeployProject = (
  organization: string,
  project: string,
  params?: AdminServiceRedeployProjectParams,
  signal?: AbortSignal,
) => {
  return httpClient<V1RedeployProjectResponse>({
    url: `/v1/organizations/${organization}/projects/${project}/redeploy`,
    method: "POST",
    params,
    signal,
  });
};

export const getAdminServiceRedeployProjectMutationOptions = <
  TError = RpcStatus,
  TContext = unknown,
>(options?: {
  mutation?: CreateMutationOptions<
    Awaited<ReturnType<typeof adminServiceRedeployProject>>,
    TError,
    {
      organization: string;
      project: string;
      params?: AdminServiceRedeployProjectParams;
    },
    TContext
  >;
}): CreateMutationOptions<
  Awaited<ReturnType<typeof adminServiceRedeployProject>>,
  TError,
  {
    organization: string;
    project: string;
    params?: AdminServiceRedeployProjectParams;
  },
  TContext
> => {
  const mutationKey = ["adminServiceRedeployProject"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof adminServiceRedeployProject>>,
    {
      organization: string;
      project: string;
      params?: AdminServiceRedeployProjectParams;
    }
  > = (props) => {
    const { organization, project, params } = props ?? {};

    return adminServiceRedeployProject(organization, project, params);
  };

  return { mutationFn, ...mutationOptions };
};

export type AdminServiceRedeployProjectMutationResult = NonNullable<
  Awaited<ReturnType<typeof adminServiceRedeployProject>>
>;

export type AdminServiceRedeployProjectMutationError = RpcStatus;

/**
 * @summary RedeployProject creates a new production deployment for a project.
If the project currently has another production deployment, the old deployment will be deprovisioned.
This RPC can be used to redeploy a project that has been hibernated.
 */
export const createAdminServiceRedeployProject = <
  TError = RpcStatus,
  TContext = unknown,
>(
  options?: {
    mutation?: CreateMutationOptions<
      Awaited<ReturnType<typeof adminServiceRedeployProject>>,
      TError,
      {
        organization: string;
        project: string;
        params?: AdminServiceRedeployProjectParams;
      },
      TContext
    >;
  },
  queryClient?: QueryClient,
): CreateMutationResult<
  Awaited<ReturnType<typeof adminServiceRedeployProject>>,
  TError,
  {
    organization: string;
    project: string;
    params?: AdminServiceRedeployProjectParams;
  },
  TContext
> => {
  const mutationOptions =
    getAdminServiceRedeployProjectMutationOptions(options);

  return createMutation(mutationOptions, queryClient);
};
/**
 * @summary CreateReport adds a virtual file for a report, triggers a reconcile, and waits for the report to be added to the runtime catalog
 */
export const adminServiceCreateReport = (
  organization: string,
  project: string,
  adminServiceCreateReportBodyBody: AdminServiceCreateReportBodyBody,
  signal?: AbortSignal,
) => {
  return httpClient<V1CreateReportResponse>({
    url: `/v1/organizations/${organization}/projects/${project}/reports`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: adminServiceCreateReportBodyBody,
    signal,
  });
};

export const getAdminServiceCreateReportMutationOptions = <
  TError = RpcStatus,
  TContext = unknown,
>(options?: {
  mutation?: CreateMutationOptions<
    Awaited<ReturnType<typeof adminServiceCreateReport>>,
    TError,
    {
      organization: string;
      project: string;
      data: AdminServiceCreateReportBodyBody;
    },
    TContext
  >;
}): CreateMutationOptions<
  Awaited<ReturnType<typeof adminServiceCreateReport>>,
  TError,
  {
    organization: string;
    project: string;
    data: AdminServiceCreateReportBodyBody;
  },
  TContext
> => {
  const mutationKey = ["adminServiceCreateReport"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof adminServiceCreateReport>>,
    {
      organization: string;
      project: string;
      data: AdminServiceCreateReportBodyBody;
    }
  > = (props) => {
    const { organization, project, data } = props ?? {};

    return adminServiceCreateReport(organization, project, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type AdminServiceCreateReportMutationResult = NonNullable<
  Awaited<ReturnType<typeof adminServiceCreateReport>>
>;
export type AdminServiceCreateReportMutationBody =
  AdminServiceCreateReportBodyBody;
export type AdminServiceCreateReportMutationError = RpcStatus;

/**
 * @summary CreateReport adds a virtual file for a report, triggers a reconcile, and waits for the report to be added to the runtime catalog
 */
export const createAdminServiceCreateReport = <
  TError = RpcStatus,
  TContext = unknown,
>(
  options?: {
    mutation?: CreateMutationOptions<
      Awaited<ReturnType<typeof adminServiceCreateReport>>,
      TError,
      {
        organization: string;
        project: string;
        data: AdminServiceCreateReportBodyBody;
      },
      TContext
    >;
  },
  queryClient?: QueryClient,
): CreateMutationResult<
  Awaited<ReturnType<typeof adminServiceCreateReport>>,
  TError,
  {
    organization: string;
    project: string;
    data: AdminServiceCreateReportBodyBody;
  },
  TContext
> => {
  const mutationOptions = getAdminServiceCreateReportMutationOptions(options);

  return createMutation(mutationOptions, queryClient);
};
/**
 * @summary GenerateReportYAML generates YAML for a scheduled report to be copied into a project's Git repository
 */
export const adminServiceGenerateReportYAML = (
  organization: string,
  project: string,
  adminServiceCreateReportBodyBody: AdminServiceCreateReportBodyBody,
  signal?: AbortSignal,
) => {
  return httpClient<V1GenerateReportYAMLResponse>({
    url: `/v1/organizations/${organization}/projects/${project}/reports/-/yaml`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: adminServiceCreateReportBodyBody,
    signal,
  });
};

export const getAdminServiceGenerateReportYAMLQueryKey = (
  organization: string,
  project: string,
  adminServiceCreateReportBodyBody: AdminServiceCreateReportBodyBody,
) => {
  return [
    `/v1/organizations/${organization}/projects/${project}/reports/-/yaml`,
    adminServiceCreateReportBodyBody,
  ] as const;
};

export const getAdminServiceGenerateReportYAMLQueryOptions = <
  TData = Awaited<ReturnType<typeof adminServiceGenerateReportYAML>>,
  TError = RpcStatus,
>(
  organization: string,
  project: string,
  adminServiceCreateReportBodyBody: AdminServiceCreateReportBodyBody,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof adminServiceGenerateReportYAML>>,
        TError,
        TData
      >
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getAdminServiceGenerateReportYAMLQueryKey(
      organization,
      project,
      adminServiceCreateReportBodyBody,
    );

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof adminServiceGenerateReportYAML>>
  > = ({ signal }) =>
    adminServiceGenerateReportYAML(
      organization,
      project,
      adminServiceCreateReportBodyBody,
      signal,
    );

  return {
    queryKey,
    queryFn,
    enabled: !!(organization && project),
    ...queryOptions,
  } as CreateQueryOptions<
    Awaited<ReturnType<typeof adminServiceGenerateReportYAML>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type AdminServiceGenerateReportYAMLQueryResult = NonNullable<
  Awaited<ReturnType<typeof adminServiceGenerateReportYAML>>
>;
export type AdminServiceGenerateReportYAMLQueryError = RpcStatus;

/**
 * @summary GenerateReportYAML generates YAML for a scheduled report to be copied into a project's Git repository
 */

export function createAdminServiceGenerateReportYAML<
  TData = Awaited<ReturnType<typeof adminServiceGenerateReportYAML>>,
  TError = RpcStatus,
>(
  organization: string,
  project: string,
  adminServiceCreateReportBodyBody: AdminServiceCreateReportBodyBody,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof adminServiceGenerateReportYAML>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): CreateQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getAdminServiceGenerateReportYAMLQueryOptions(
    organization,
    project,
    adminServiceCreateReportBodyBody,
    options,
  );

  const query = createQuery(queryOptions, queryClient) as CreateQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary DeleteReport deletes the virtual file for a UI-managed report, triggers a reconcile, and waits for the report to be deleted in the runtime
 */
export const adminServiceDeleteReport = (
  organization: string,
  project: string,
  name: string,
) => {
  return httpClient<V1DeleteReportResponse>({
    url: `/v1/organizations/${organization}/projects/${project}/reports/${name}`,
    method: "DELETE",
  });
};

export const getAdminServiceDeleteReportMutationOptions = <
  TError = RpcStatus,
  TContext = unknown,
>(options?: {
  mutation?: CreateMutationOptions<
    Awaited<ReturnType<typeof adminServiceDeleteReport>>,
    TError,
    { organization: string; project: string; name: string },
    TContext
  >;
}): CreateMutationOptions<
  Awaited<ReturnType<typeof adminServiceDeleteReport>>,
  TError,
  { organization: string; project: string; name: string },
  TContext
> => {
  const mutationKey = ["adminServiceDeleteReport"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof adminServiceDeleteReport>>,
    { organization: string; project: string; name: string }
  > = (props) => {
    const { organization, project, name } = props ?? {};

    return adminServiceDeleteReport(organization, project, name);
  };

  return { mutationFn, ...mutationOptions };
};

export type AdminServiceDeleteReportMutationResult = NonNullable<
  Awaited<ReturnType<typeof adminServiceDeleteReport>>
>;

export type AdminServiceDeleteReportMutationError = RpcStatus;

/**
 * @summary DeleteReport deletes the virtual file for a UI-managed report, triggers a reconcile, and waits for the report to be deleted in the runtime
 */
export const createAdminServiceDeleteReport = <
  TError = RpcStatus,
  TContext = unknown,
>(
  options?: {
    mutation?: CreateMutationOptions<
      Awaited<ReturnType<typeof adminServiceDeleteReport>>,
      TError,
      { organization: string; project: string; name: string },
      TContext
    >;
  },
  queryClient?: QueryClient,
): CreateMutationResult<
  Awaited<ReturnType<typeof adminServiceDeleteReport>>,
  TError,
  { organization: string; project: string; name: string },
  TContext
> => {
  const mutationOptions = getAdminServiceDeleteReportMutationOptions(options);

  return createMutation(mutationOptions, queryClient);
};
/**
 * @summary EditReport edits a virtual file for a UI-managed report, triggers a reconcile, and waits for the report to be updated in the runtime
 */
export const adminServiceEditReport = (
  organization: string,
  project: string,
  name: string,
  adminServiceCreateReportBodyBody: AdminServiceCreateReportBodyBody,
) => {
  return httpClient<V1EditReportResponse>({
    url: `/v1/organizations/${organization}/projects/${project}/reports/${name}`,
    method: "PUT",
    headers: { "Content-Type": "application/json" },
    data: adminServiceCreateReportBodyBody,
  });
};

export const getAdminServiceEditReportMutationOptions = <
  TError = RpcStatus,
  TContext = unknown,
>(options?: {
  mutation?: CreateMutationOptions<
    Awaited<ReturnType<typeof adminServiceEditReport>>,
    TError,
    {
      organization: string;
      project: string;
      name: string;
      data: AdminServiceCreateReportBodyBody;
    },
    TContext
  >;
}): CreateMutationOptions<
  Awaited<ReturnType<typeof adminServiceEditReport>>,
  TError,
  {
    organization: string;
    project: string;
    name: string;
    data: AdminServiceCreateReportBodyBody;
  },
  TContext
> => {
  const mutationKey = ["adminServiceEditReport"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof adminServiceEditReport>>,
    {
      organization: string;
      project: string;
      name: string;
      data: AdminServiceCreateReportBodyBody;
    }
  > = (props) => {
    const { organization, project, name, data } = props ?? {};

    return adminServiceEditReport(organization, project, name, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type AdminServiceEditReportMutationResult = NonNullable<
  Awaited<ReturnType<typeof adminServiceEditReport>>
>;
export type AdminServiceEditReportMutationBody =
  AdminServiceCreateReportBodyBody;
export type AdminServiceEditReportMutationError = RpcStatus;

/**
 * @summary EditReport edits a virtual file for a UI-managed report, triggers a reconcile, and waits for the report to be updated in the runtime
 */
export const createAdminServiceEditReport = <
  TError = RpcStatus,
  TContext = unknown,
>(
  options?: {
    mutation?: CreateMutationOptions<
      Awaited<ReturnType<typeof adminServiceEditReport>>,
      TError,
      {
        organization: string;
        project: string;
        name: string;
        data: AdminServiceCreateReportBodyBody;
      },
      TContext
    >;
  },
  queryClient?: QueryClient,
): CreateMutationResult<
  Awaited<ReturnType<typeof adminServiceEditReport>>,
  TError,
  {
    organization: string;
    project: string;
    name: string;
    data: AdminServiceCreateReportBodyBody;
  },
  TContext
> => {
  const mutationOptions = getAdminServiceEditReportMutationOptions(options);

  return createMutation(mutationOptions, queryClient);
};
/**
 * @summary TriggerReport triggers an ad-hoc report run
 */
export const adminServiceTriggerReport = (
  organization: string,
  project: string,
  name: string,
  adminServiceTriggerReconcileBodyBody: AdminServiceTriggerReconcileBodyBody,
  signal?: AbortSignal,
) => {
  return httpClient<V1TriggerReportResponse>({
    url: `/v1/organizations/${organization}/projects/${project}/reports/${name}/trigger`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: adminServiceTriggerReconcileBodyBody,
    signal,
  });
};

export const getAdminServiceTriggerReportMutationOptions = <
  TError = RpcStatus,
  TContext = unknown,
>(options?: {
  mutation?: CreateMutationOptions<
    Awaited<ReturnType<typeof adminServiceTriggerReport>>,
    TError,
    {
      organization: string;
      project: string;
      name: string;
      data: AdminServiceTriggerReconcileBodyBody;
    },
    TContext
  >;
}): CreateMutationOptions<
  Awaited<ReturnType<typeof adminServiceTriggerReport>>,
  TError,
  {
    organization: string;
    project: string;
    name: string;
    data: AdminServiceTriggerReconcileBodyBody;
  },
  TContext
> => {
  const mutationKey = ["adminServiceTriggerReport"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof adminServiceTriggerReport>>,
    {
      organization: string;
      project: string;
      name: string;
      data: AdminServiceTriggerReconcileBodyBody;
    }
  > = (props) => {
    const { organization, project, name, data } = props ?? {};

    return adminServiceTriggerReport(organization, project, name, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type AdminServiceTriggerReportMutationResult = NonNullable<
  Awaited<ReturnType<typeof adminServiceTriggerReport>>
>;
export type AdminServiceTriggerReportMutationBody =
  AdminServiceTriggerReconcileBodyBody;
export type AdminServiceTriggerReportMutationError = RpcStatus;

/**
 * @summary TriggerReport triggers an ad-hoc report run
 */
export const createAdminServiceTriggerReport = <
  TError = RpcStatus,
  TContext = unknown,
>(
  options?: {
    mutation?: CreateMutationOptions<
      Awaited<ReturnType<typeof adminServiceTriggerReport>>,
      TError,
      {
        organization: string;
        project: string;
        name: string;
        data: AdminServiceTriggerReconcileBodyBody;
      },
      TContext
    >;
  },
  queryClient?: QueryClient,
): CreateMutationResult<
  Awaited<ReturnType<typeof adminServiceTriggerReport>>,
  TError,
  {
    organization: string;
    project: string;
    name: string;
    data: AdminServiceTriggerReconcileBodyBody;
  },
  TContext
> => {
  const mutationOptions = getAdminServiceTriggerReportMutationOptions(options);

  return createMutation(mutationOptions, queryClient);
};
/**
 * @summary UnsubscribeReport removes the calling user from a reports recipients list
 */
export const adminServiceUnsubscribeReport = (
  organization: string,
  project: string,
  name: string,
  adminServiceUnsubscribeReportBody: AdminServiceUnsubscribeReportBody,
  signal?: AbortSignal,
) => {
  return httpClient<V1UnsubscribeReportResponse>({
    url: `/v1/organizations/${organization}/projects/${project}/reports/${name}/unsubscribe`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: adminServiceUnsubscribeReportBody,
    signal,
  });
};

export const getAdminServiceUnsubscribeReportMutationOptions = <
  TError = RpcStatus,
  TContext = unknown,
>(options?: {
  mutation?: CreateMutationOptions<
    Awaited<ReturnType<typeof adminServiceUnsubscribeReport>>,
    TError,
    {
      organization: string;
      project: string;
      name: string;
      data: AdminServiceUnsubscribeReportBody;
    },
    TContext
  >;
}): CreateMutationOptions<
  Awaited<ReturnType<typeof adminServiceUnsubscribeReport>>,
  TError,
  {
    organization: string;
    project: string;
    name: string;
    data: AdminServiceUnsubscribeReportBody;
  },
  TContext
> => {
  const mutationKey = ["adminServiceUnsubscribeReport"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof adminServiceUnsubscribeReport>>,
    {
      organization: string;
      project: string;
      name: string;
      data: AdminServiceUnsubscribeReportBody;
    }
  > = (props) => {
    const { organization, project, name, data } = props ?? {};

    return adminServiceUnsubscribeReport(organization, project, name, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type AdminServiceUnsubscribeReportMutationResult = NonNullable<
  Awaited<ReturnType<typeof adminServiceUnsubscribeReport>>
>;
export type AdminServiceUnsubscribeReportMutationBody =
  AdminServiceUnsubscribeReportBody;
export type AdminServiceUnsubscribeReportMutationError = RpcStatus;

/**
 * @summary UnsubscribeReport removes the calling user from a reports recipients list
 */
export const createAdminServiceUnsubscribeReport = <
  TError = RpcStatus,
  TContext = unknown,
>(
  options?: {
    mutation?: CreateMutationOptions<
      Awaited<ReturnType<typeof adminServiceUnsubscribeReport>>,
      TError,
      {
        organization: string;
        project: string;
        name: string;
        data: AdminServiceUnsubscribeReportBody;
      },
      TContext
    >;
  },
  queryClient?: QueryClient,
): CreateMutationResult<
  Awaited<ReturnType<typeof adminServiceUnsubscribeReport>>,
  TError,
  {
    organization: string;
    project: string;
    name: string;
    data: AdminServiceUnsubscribeReportBody;
  },
  TContext
> => {
  const mutationOptions =
    getAdminServiceUnsubscribeReportMutationOptions(options);

  return createMutation(mutationOptions, queryClient);
};
export const adminServiceRequestProjectAccess = (
  organization: string,
  project: string,
  adminServiceSetProjectMemberUserRoleBodyBody: AdminServiceSetProjectMemberUserRoleBodyBody,
  signal?: AbortSignal,
) => {
  return httpClient<V1RequestProjectAccessResponse>({
    url: `/v1/organizations/${organization}/projects/${project}/request-access`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: adminServiceSetProjectMemberUserRoleBodyBody,
    signal,
  });
};

export const getAdminServiceRequestProjectAccessMutationOptions = <
  TError = RpcStatus,
  TContext = unknown,
>(options?: {
  mutation?: CreateMutationOptions<
    Awaited<ReturnType<typeof adminServiceRequestProjectAccess>>,
    TError,
    {
      organization: string;
      project: string;
      data: AdminServiceSetProjectMemberUserRoleBodyBody;
    },
    TContext
  >;
}): CreateMutationOptions<
  Awaited<ReturnType<typeof adminServiceRequestProjectAccess>>,
  TError,
  {
    organization: string;
    project: string;
    data: AdminServiceSetProjectMemberUserRoleBodyBody;
  },
  TContext
> => {
  const mutationKey = ["adminServiceRequestProjectAccess"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof adminServiceRequestProjectAccess>>,
    {
      organization: string;
      project: string;
      data: AdminServiceSetProjectMemberUserRoleBodyBody;
    }
  > = (props) => {
    const { organization, project, data } = props ?? {};

    return adminServiceRequestProjectAccess(organization, project, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type AdminServiceRequestProjectAccessMutationResult = NonNullable<
  Awaited<ReturnType<typeof adminServiceRequestProjectAccess>>
>;
export type AdminServiceRequestProjectAccessMutationBody =
  AdminServiceSetProjectMemberUserRoleBodyBody;
export type AdminServiceRequestProjectAccessMutationError = RpcStatus;

export const createAdminServiceRequestProjectAccess = <
  TError = RpcStatus,
  TContext = unknown,
>(
  options?: {
    mutation?: CreateMutationOptions<
      Awaited<ReturnType<typeof adminServiceRequestProjectAccess>>,
      TError,
      {
        organization: string;
        project: string;
        data: AdminServiceSetProjectMemberUserRoleBodyBody;
      },
      TContext
    >;
  },
  queryClient?: QueryClient,
): CreateMutationResult<
  Awaited<ReturnType<typeof adminServiceRequestProjectAccess>>,
  TError,
  {
    organization: string;
    project: string;
    data: AdminServiceSetProjectMemberUserRoleBodyBody;
  },
  TContext
> => {
  const mutationOptions =
    getAdminServiceRequestProjectAccessMutationOptions(options);

  return createMutation(mutationOptions, queryClient);
};
/**
 * @summary ListMagicAuthTokens lists all the magic auth tokens for a specific project.
 */
export const adminServiceListMagicAuthTokens = (
  organization: string,
  project: string,
  params?: AdminServiceListMagicAuthTokensParams,
  signal?: AbortSignal,
) => {
  return httpClient<V1ListMagicAuthTokensResponse>({
    url: `/v1/organizations/${organization}/projects/${project}/tokens/magic`,
    method: "GET",
    params,
    signal,
  });
};

export const getAdminServiceListMagicAuthTokensQueryKey = (
  organization: string,
  project: string,
  params?: AdminServiceListMagicAuthTokensParams,
) => {
  return [
    `/v1/organizations/${organization}/projects/${project}/tokens/magic`,
    ...(params ? [params] : []),
  ] as const;
};

export const getAdminServiceListMagicAuthTokensInfiniteQueryOptions = <
  TData = InfiniteData<
    Awaited<ReturnType<typeof adminServiceListMagicAuthTokens>>,
    AdminServiceListMagicAuthTokensParams["pageToken"]
  >,
  TError = RpcStatus,
>(
  organization: string,
  project: string,
  params?: AdminServiceListMagicAuthTokensParams,
  options?: {
    query?: Partial<
      CreateInfiniteQueryOptions<
        Awaited<ReturnType<typeof adminServiceListMagicAuthTokens>>,
        TError,
        TData,
        Awaited<ReturnType<typeof adminServiceListMagicAuthTokens>>,
        QueryKey,
        AdminServiceListMagicAuthTokensParams["pageToken"]
      >
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getAdminServiceListMagicAuthTokensQueryKey(organization, project, params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof adminServiceListMagicAuthTokens>>,
    QueryKey,
    AdminServiceListMagicAuthTokensParams["pageToken"]
  > = ({ signal, pageParam }) =>
    adminServiceListMagicAuthTokens(
      organization,
      project,
      { ...params, pageToken: pageParam || params?.["pageToken"] },
      signal,
    );

  return {
    queryKey,
    queryFn,
    enabled: !!(organization && project),
    ...queryOptions,
  } as CreateInfiniteQueryOptions<
    Awaited<ReturnType<typeof adminServiceListMagicAuthTokens>>,
    TError,
    TData,
    Awaited<ReturnType<typeof adminServiceListMagicAuthTokens>>,
    QueryKey,
    AdminServiceListMagicAuthTokensParams["pageToken"]
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type AdminServiceListMagicAuthTokensInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof adminServiceListMagicAuthTokens>>
>;
export type AdminServiceListMagicAuthTokensInfiniteQueryError = RpcStatus;

/**
 * @summary ListMagicAuthTokens lists all the magic auth tokens for a specific project.
 */

export function createAdminServiceListMagicAuthTokensInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof adminServiceListMagicAuthTokens>>,
    AdminServiceListMagicAuthTokensParams["pageToken"]
  >,
  TError = RpcStatus,
>(
  organization: string,
  project: string,
  params?: AdminServiceListMagicAuthTokensParams,
  options?: {
    query?: Partial<
      CreateInfiniteQueryOptions<
        Awaited<ReturnType<typeof adminServiceListMagicAuthTokens>>,
        TError,
        TData,
        Awaited<ReturnType<typeof adminServiceListMagicAuthTokens>>,
        QueryKey,
        AdminServiceListMagicAuthTokensParams["pageToken"]
      >
    >;
  },
  queryClient?: QueryClient,
): CreateInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getAdminServiceListMagicAuthTokensInfiniteQueryOptions(
    organization,
    project,
    params,
    options,
  );

  const query = createInfiniteQuery(
    queryOptions,
    queryClient,
  ) as CreateInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getAdminServiceListMagicAuthTokensQueryOptions = <
  TData = Awaited<ReturnType<typeof adminServiceListMagicAuthTokens>>,
  TError = RpcStatus,
>(
  organization: string,
  project: string,
  params?: AdminServiceListMagicAuthTokensParams,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof adminServiceListMagicAuthTokens>>,
        TError,
        TData
      >
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getAdminServiceListMagicAuthTokensQueryKey(organization, project, params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof adminServiceListMagicAuthTokens>>
  > = ({ signal }) =>
    adminServiceListMagicAuthTokens(organization, project, params, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!(organization && project),
    ...queryOptions,
  } as CreateQueryOptions<
    Awaited<ReturnType<typeof adminServiceListMagicAuthTokens>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type AdminServiceListMagicAuthTokensQueryResult = NonNullable<
  Awaited<ReturnType<typeof adminServiceListMagicAuthTokens>>
>;
export type AdminServiceListMagicAuthTokensQueryError = RpcStatus;

/**
 * @summary ListMagicAuthTokens lists all the magic auth tokens for a specific project.
 */

export function createAdminServiceListMagicAuthTokens<
  TData = Awaited<ReturnType<typeof adminServiceListMagicAuthTokens>>,
  TError = RpcStatus,
>(
  organization: string,
  project: string,
  params?: AdminServiceListMagicAuthTokensParams,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof adminServiceListMagicAuthTokens>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): CreateQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getAdminServiceListMagicAuthTokensQueryOptions(
    organization,
    project,
    params,
    options,
  );

  const query = createQuery(queryOptions, queryClient) as CreateQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary IssueMagicAuthToken creates a "magic" auth token that provides limited access to a specific filtered dashboard in a specific project.
 */
export const adminServiceIssueMagicAuthToken = (
  organization: string,
  project: string,
  adminServiceIssueMagicAuthTokenBody: AdminServiceIssueMagicAuthTokenBody,
  signal?: AbortSignal,
) => {
  return httpClient<V1IssueMagicAuthTokenResponse>({
    url: `/v1/organizations/${organization}/projects/${project}/tokens/magic`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: adminServiceIssueMagicAuthTokenBody,
    signal,
  });
};

export const getAdminServiceIssueMagicAuthTokenMutationOptions = <
  TError = RpcStatus,
  TContext = unknown,
>(options?: {
  mutation?: CreateMutationOptions<
    Awaited<ReturnType<typeof adminServiceIssueMagicAuthToken>>,
    TError,
    {
      organization: string;
      project: string;
      data: AdminServiceIssueMagicAuthTokenBody;
    },
    TContext
  >;
}): CreateMutationOptions<
  Awaited<ReturnType<typeof adminServiceIssueMagicAuthToken>>,
  TError,
  {
    organization: string;
    project: string;
    data: AdminServiceIssueMagicAuthTokenBody;
  },
  TContext
> => {
  const mutationKey = ["adminServiceIssueMagicAuthToken"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof adminServiceIssueMagicAuthToken>>,
    {
      organization: string;
      project: string;
      data: AdminServiceIssueMagicAuthTokenBody;
    }
  > = (props) => {
    const { organization, project, data } = props ?? {};

    return adminServiceIssueMagicAuthToken(organization, project, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type AdminServiceIssueMagicAuthTokenMutationResult = NonNullable<
  Awaited<ReturnType<typeof adminServiceIssueMagicAuthToken>>
>;
export type AdminServiceIssueMagicAuthTokenMutationBody =
  AdminServiceIssueMagicAuthTokenBody;
export type AdminServiceIssueMagicAuthTokenMutationError = RpcStatus;

/**
 * @summary IssueMagicAuthToken creates a "magic" auth token that provides limited access to a specific filtered dashboard in a specific project.
 */
export const createAdminServiceIssueMagicAuthToken = <
  TError = RpcStatus,
  TContext = unknown,
>(
  options?: {
    mutation?: CreateMutationOptions<
      Awaited<ReturnType<typeof adminServiceIssueMagicAuthToken>>,
      TError,
      {
        organization: string;
        project: string;
        data: AdminServiceIssueMagicAuthTokenBody;
      },
      TContext
    >;
  },
  queryClient?: QueryClient,
): CreateMutationResult<
  Awaited<ReturnType<typeof adminServiceIssueMagicAuthToken>>,
  TError,
  {
    organization: string;
    project: string;
    data: AdminServiceIssueMagicAuthTokenBody;
  },
  TContext
> => {
  const mutationOptions =
    getAdminServiceIssueMagicAuthTokenMutationOptions(options);

  return createMutation(mutationOptions, queryClient);
};
/**
 * @summary Converts a project connected to github to a rill managed project.
 */
export const adminServiceDisconnectProjectFromGithub = (
  organization: string,
  project: string,
  adminServiceTriggerReconcileBodyBody: AdminServiceTriggerReconcileBodyBody,
  signal?: AbortSignal,
) => {
  return httpClient<V1DisconnectProjectFromGithubResponse>({
    url: `/v1/organizations/${organization}/projects/${project}/upload-assets`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: adminServiceTriggerReconcileBodyBody,
    signal,
  });
};

export const getAdminServiceDisconnectProjectFromGithubMutationOptions = <
  TError = RpcStatus,
  TContext = unknown,
>(options?: {
  mutation?: CreateMutationOptions<
    Awaited<ReturnType<typeof adminServiceDisconnectProjectFromGithub>>,
    TError,
    {
      organization: string;
      project: string;
      data: AdminServiceTriggerReconcileBodyBody;
    },
    TContext
  >;
}): CreateMutationOptions<
  Awaited<ReturnType<typeof adminServiceDisconnectProjectFromGithub>>,
  TError,
  {
    organization: string;
    project: string;
    data: AdminServiceTriggerReconcileBodyBody;
  },
  TContext
> => {
  const mutationKey = ["adminServiceDisconnectProjectFromGithub"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof adminServiceDisconnectProjectFromGithub>>,
    {
      organization: string;
      project: string;
      data: AdminServiceTriggerReconcileBodyBody;
    }
  > = (props) => {
    const { organization, project, data } = props ?? {};

    return adminServiceDisconnectProjectFromGithub(organization, project, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type AdminServiceDisconnectProjectFromGithubMutationResult = NonNullable<
  Awaited<ReturnType<typeof adminServiceDisconnectProjectFromGithub>>
>;
export type AdminServiceDisconnectProjectFromGithubMutationBody =
  AdminServiceTriggerReconcileBodyBody;
export type AdminServiceDisconnectProjectFromGithubMutationError = RpcStatus;

/**
 * @summary Converts a project connected to github to a rill managed project.
 */
export const createAdminServiceDisconnectProjectFromGithub = <
  TError = RpcStatus,
  TContext = unknown,
>(
  options?: {
    mutation?: CreateMutationOptions<
      Awaited<ReturnType<typeof adminServiceDisconnectProjectFromGithub>>,
      TError,
      {
        organization: string;
        project: string;
        data: AdminServiceTriggerReconcileBodyBody;
      },
      TContext
    >;
  },
  queryClient?: QueryClient,
): CreateMutationResult<
  Awaited<ReturnType<typeof adminServiceDisconnectProjectFromGithub>>,
  TError,
  {
    organization: string;
    project: string;
    data: AdminServiceTriggerReconcileBodyBody;
  },
  TContext
> => {
  const mutationOptions =
    getAdminServiceDisconnectProjectFromGithubMutationOptions(options);

  return createMutation(mutationOptions, queryClient);
};
/**
 * @summary RemoveProjectMemberUsergroup revokes the project-level role for the user group
 */
export const adminServiceRemoveProjectMemberUsergroup = (
  organization: string,
  project: string,
  usergroup: string,
) => {
  return httpClient<V1RemoveProjectMemberUsergroupResponse>({
    url: `/v1/organizations/${organization}/projects/${project}/usergroups/${usergroup}/roles`,
    method: "DELETE",
  });
};

export const getAdminServiceRemoveProjectMemberUsergroupMutationOptions = <
  TError = RpcStatus,
  TContext = unknown,
>(options?: {
  mutation?: CreateMutationOptions<
    Awaited<ReturnType<typeof adminServiceRemoveProjectMemberUsergroup>>,
    TError,
    { organization: string; project: string; usergroup: string },
    TContext
  >;
}): CreateMutationOptions<
  Awaited<ReturnType<typeof adminServiceRemoveProjectMemberUsergroup>>,
  TError,
  { organization: string; project: string; usergroup: string },
  TContext
> => {
  const mutationKey = ["adminServiceRemoveProjectMemberUsergroup"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof adminServiceRemoveProjectMemberUsergroup>>,
    { organization: string; project: string; usergroup: string }
  > = (props) => {
    const { organization, project, usergroup } = props ?? {};

    return adminServiceRemoveProjectMemberUsergroup(
      organization,
      project,
      usergroup,
    );
  };

  return { mutationFn, ...mutationOptions };
};

export type AdminServiceRemoveProjectMemberUsergroupMutationResult =
  NonNullable<
    Awaited<ReturnType<typeof adminServiceRemoveProjectMemberUsergroup>>
  >;

export type AdminServiceRemoveProjectMemberUsergroupMutationError = RpcStatus;

/**
 * @summary RemoveProjectMemberUsergroup revokes the project-level role for the user group
 */
export const createAdminServiceRemoveProjectMemberUsergroup = <
  TError = RpcStatus,
  TContext = unknown,
>(
  options?: {
    mutation?: CreateMutationOptions<
      Awaited<ReturnType<typeof adminServiceRemoveProjectMemberUsergroup>>,
      TError,
      { organization: string; project: string; usergroup: string },
      TContext
    >;
  },
  queryClient?: QueryClient,
): CreateMutationResult<
  Awaited<ReturnType<typeof adminServiceRemoveProjectMemberUsergroup>>,
  TError,
  { organization: string; project: string; usergroup: string },
  TContext
> => {
  const mutationOptions =
    getAdminServiceRemoveProjectMemberUsergroupMutationOptions(options);

  return createMutation(mutationOptions, queryClient);
};
/**
 * @summary AddProjectMemberUsergroupRole adds the role for the user group
 */
export const adminServiceAddProjectMemberUsergroup = (
  organization: string,
  project: string,
  usergroup: string,
  adminServiceSetProjectMemberUserRoleBodyBody: AdminServiceSetProjectMemberUserRoleBodyBody,
  signal?: AbortSignal,
) => {
  return httpClient<V1AddProjectMemberUsergroupResponse>({
    url: `/v1/organizations/${organization}/projects/${project}/usergroups/${usergroup}/roles`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: adminServiceSetProjectMemberUserRoleBodyBody,
    signal,
  });
};

export const getAdminServiceAddProjectMemberUsergroupMutationOptions = <
  TError = RpcStatus,
  TContext = unknown,
>(options?: {
  mutation?: CreateMutationOptions<
    Awaited<ReturnType<typeof adminServiceAddProjectMemberUsergroup>>,
    TError,
    {
      organization: string;
      project: string;
      usergroup: string;
      data: AdminServiceSetProjectMemberUserRoleBodyBody;
    },
    TContext
  >;
}): CreateMutationOptions<
  Awaited<ReturnType<typeof adminServiceAddProjectMemberUsergroup>>,
  TError,
  {
    organization: string;
    project: string;
    usergroup: string;
    data: AdminServiceSetProjectMemberUserRoleBodyBody;
  },
  TContext
> => {
  const mutationKey = ["adminServiceAddProjectMemberUsergroup"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof adminServiceAddProjectMemberUsergroup>>,
    {
      organization: string;
      project: string;
      usergroup: string;
      data: AdminServiceSetProjectMemberUserRoleBodyBody;
    }
  > = (props) => {
    const { organization, project, usergroup, data } = props ?? {};

    return adminServiceAddProjectMemberUsergroup(
      organization,
      project,
      usergroup,
      data,
    );
  };

  return { mutationFn, ...mutationOptions };
};

export type AdminServiceAddProjectMemberUsergroupMutationResult = NonNullable<
  Awaited<ReturnType<typeof adminServiceAddProjectMemberUsergroup>>
>;
export type AdminServiceAddProjectMemberUsergroupMutationBody =
  AdminServiceSetProjectMemberUserRoleBodyBody;
export type AdminServiceAddProjectMemberUsergroupMutationError = RpcStatus;

/**
 * @summary AddProjectMemberUsergroupRole adds the role for the user group
 */
export const createAdminServiceAddProjectMemberUsergroup = <
  TError = RpcStatus,
  TContext = unknown,
>(
  options?: {
    mutation?: CreateMutationOptions<
      Awaited<ReturnType<typeof adminServiceAddProjectMemberUsergroup>>,
      TError,
      {
        organization: string;
        project: string;
        usergroup: string;
        data: AdminServiceSetProjectMemberUserRoleBodyBody;
      },
      TContext
    >;
  },
  queryClient?: QueryClient,
): CreateMutationResult<
  Awaited<ReturnType<typeof adminServiceAddProjectMemberUsergroup>>,
  TError,
  {
    organization: string;
    project: string;
    usergroup: string;
    data: AdminServiceSetProjectMemberUserRoleBodyBody;
  },
  TContext
> => {
  const mutationOptions =
    getAdminServiceAddProjectMemberUsergroupMutationOptions(options);

  return createMutation(mutationOptions, queryClient);
};
/**
 * @summary SetProjectMemberUsergroupRole sets the role for the user group
 */
export const adminServiceSetProjectMemberUsergroupRole = (
  organization: string,
  project: string,
  usergroup: string,
  adminServiceSetProjectMemberUserRoleBodyBody: AdminServiceSetProjectMemberUserRoleBodyBody,
) => {
  return httpClient<V1SetProjectMemberUsergroupRoleResponse>({
    url: `/v1/organizations/${organization}/projects/${project}/usergroups/${usergroup}/roles`,
    method: "PUT",
    headers: { "Content-Type": "application/json" },
    data: adminServiceSetProjectMemberUserRoleBodyBody,
  });
};

export const getAdminServiceSetProjectMemberUsergroupRoleMutationOptions = <
  TError = RpcStatus,
  TContext = unknown,
>(options?: {
  mutation?: CreateMutationOptions<
    Awaited<ReturnType<typeof adminServiceSetProjectMemberUsergroupRole>>,
    TError,
    {
      organization: string;
      project: string;
      usergroup: string;
      data: AdminServiceSetProjectMemberUserRoleBodyBody;
    },
    TContext
  >;
}): CreateMutationOptions<
  Awaited<ReturnType<typeof adminServiceSetProjectMemberUsergroupRole>>,
  TError,
  {
    organization: string;
    project: string;
    usergroup: string;
    data: AdminServiceSetProjectMemberUserRoleBodyBody;
  },
  TContext
> => {
  const mutationKey = ["adminServiceSetProjectMemberUsergroupRole"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof adminServiceSetProjectMemberUsergroupRole>>,
    {
      organization: string;
      project: string;
      usergroup: string;
      data: AdminServiceSetProjectMemberUserRoleBodyBody;
    }
  > = (props) => {
    const { organization, project, usergroup, data } = props ?? {};

    return adminServiceSetProjectMemberUsergroupRole(
      organization,
      project,
      usergroup,
      data,
    );
  };

  return { mutationFn, ...mutationOptions };
};

export type AdminServiceSetProjectMemberUsergroupRoleMutationResult =
  NonNullable<
    Awaited<ReturnType<typeof adminServiceSetProjectMemberUsergroupRole>>
  >;
export type AdminServiceSetProjectMemberUsergroupRoleMutationBody =
  AdminServiceSetProjectMemberUserRoleBodyBody;
export type AdminServiceSetProjectMemberUsergroupRoleMutationError = RpcStatus;

/**
 * @summary SetProjectMemberUsergroupRole sets the role for the user group
 */
export const createAdminServiceSetProjectMemberUsergroupRole = <
  TError = RpcStatus,
  TContext = unknown,
>(
  options?: {
    mutation?: CreateMutationOptions<
      Awaited<ReturnType<typeof adminServiceSetProjectMemberUsergroupRole>>,
      TError,
      {
        organization: string;
        project: string;
        usergroup: string;
        data: AdminServiceSetProjectMemberUserRoleBodyBody;
      },
      TContext
    >;
  },
  queryClient?: QueryClient,
): CreateMutationResult<
  Awaited<ReturnType<typeof adminServiceSetProjectMemberUsergroupRole>>,
  TError,
  {
    organization: string;
    project: string;
    usergroup: string;
    data: AdminServiceSetProjectMemberUserRoleBodyBody;
  },
  TContext
> => {
  const mutationOptions =
    getAdminServiceSetProjectMemberUsergroupRoleMutationOptions(options);

  return createMutation(mutationOptions, queryClient);
};
/**
 * @summary SearchProjectUsers returns users who has access to to a project (including org members that have access through a usergroup)
 */
export const adminServiceSearchProjectUsers = (
  organization: string,
  project: string,
  params?: AdminServiceSearchProjectUsersParams,
  signal?: AbortSignal,
) => {
  return httpClient<V1SearchProjectUsersResponse>({
    url: `/v1/organizations/${organization}/projects/${project}/users/search`,
    method: "GET",
    params,
    signal,
  });
};

export const getAdminServiceSearchProjectUsersQueryKey = (
  organization: string,
  project: string,
  params?: AdminServiceSearchProjectUsersParams,
) => {
  return [
    `/v1/organizations/${organization}/projects/${project}/users/search`,
    ...(params ? [params] : []),
  ] as const;
};

export const getAdminServiceSearchProjectUsersQueryOptions = <
  TData = Awaited<ReturnType<typeof adminServiceSearchProjectUsers>>,
  TError = RpcStatus,
>(
  organization: string,
  project: string,
  params?: AdminServiceSearchProjectUsersParams,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof adminServiceSearchProjectUsers>>,
        TError,
        TData
      >
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getAdminServiceSearchProjectUsersQueryKey(organization, project, params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof adminServiceSearchProjectUsers>>
  > = ({ signal }) =>
    adminServiceSearchProjectUsers(organization, project, params, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!(organization && project),
    ...queryOptions,
  } as CreateQueryOptions<
    Awaited<ReturnType<typeof adminServiceSearchProjectUsers>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type AdminServiceSearchProjectUsersQueryResult = NonNullable<
  Awaited<ReturnType<typeof adminServiceSearchProjectUsers>>
>;
export type AdminServiceSearchProjectUsersQueryError = RpcStatus;

/**
 * @summary SearchProjectUsers returns users who has access to to a project (including org members that have access through a usergroup)
 */

export function createAdminServiceSearchProjectUsers<
  TData = Awaited<ReturnType<typeof adminServiceSearchProjectUsers>>,
  TError = RpcStatus,
>(
  organization: string,
  project: string,
  params?: AdminServiceSearchProjectUsersParams,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof adminServiceSearchProjectUsers>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): CreateQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getAdminServiceSearchProjectUsersQueryOptions(
    organization,
    project,
    params,
    options,
  );

  const query = createQuery(queryOptions, queryClient) as CreateQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary GetProjectVariables returns project variables.
 */
export const adminServiceGetProjectVariables = (
  organization: string,
  project: string,
  params?: AdminServiceGetProjectVariablesParams,
  signal?: AbortSignal,
) => {
  return httpClient<V1GetProjectVariablesResponse>({
    url: `/v1/organizations/${organization}/projects/${project}/variables`,
    method: "GET",
    params,
    signal,
  });
};

export const getAdminServiceGetProjectVariablesQueryKey = (
  organization: string,
  project: string,
  params?: AdminServiceGetProjectVariablesParams,
) => {
  return [
    `/v1/organizations/${organization}/projects/${project}/variables`,
    ...(params ? [params] : []),
  ] as const;
};

export const getAdminServiceGetProjectVariablesQueryOptions = <
  TData = Awaited<ReturnType<typeof adminServiceGetProjectVariables>>,
  TError = RpcStatus,
>(
  organization: string,
  project: string,
  params?: AdminServiceGetProjectVariablesParams,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof adminServiceGetProjectVariables>>,
        TError,
        TData
      >
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getAdminServiceGetProjectVariablesQueryKey(organization, project, params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof adminServiceGetProjectVariables>>
  > = ({ signal }) =>
    adminServiceGetProjectVariables(organization, project, params, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!(organization && project),
    ...queryOptions,
  } as CreateQueryOptions<
    Awaited<ReturnType<typeof adminServiceGetProjectVariables>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type AdminServiceGetProjectVariablesQueryResult = NonNullable<
  Awaited<ReturnType<typeof adminServiceGetProjectVariables>>
>;
export type AdminServiceGetProjectVariablesQueryError = RpcStatus;

/**
 * @summary GetProjectVariables returns project variables.
 */

export function createAdminServiceGetProjectVariables<
  TData = Awaited<ReturnType<typeof adminServiceGetProjectVariables>>,
  TError = RpcStatus,
>(
  organization: string,
  project: string,
  params?: AdminServiceGetProjectVariablesParams,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof adminServiceGetProjectVariables>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): CreateQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getAdminServiceGetProjectVariablesQueryOptions(
    organization,
    project,
    params,
    options,
  );

  const query = createQuery(queryOptions, queryClient) as CreateQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary UpdateProjectVariables updates variables for a project.
 */
export const adminServiceUpdateProjectVariables = (
  organization: string,
  project: string,
  adminServiceUpdateProjectVariablesBody: AdminServiceUpdateProjectVariablesBody,
) => {
  return httpClient<V1UpdateProjectVariablesResponse>({
    url: `/v1/organizations/${organization}/projects/${project}/variables`,
    method: "PUT",
    headers: { "Content-Type": "application/json" },
    data: adminServiceUpdateProjectVariablesBody,
  });
};

export const getAdminServiceUpdateProjectVariablesMutationOptions = <
  TError = RpcStatus,
  TContext = unknown,
>(options?: {
  mutation?: CreateMutationOptions<
    Awaited<ReturnType<typeof adminServiceUpdateProjectVariables>>,
    TError,
    {
      organization: string;
      project: string;
      data: AdminServiceUpdateProjectVariablesBody;
    },
    TContext
  >;
}): CreateMutationOptions<
  Awaited<ReturnType<typeof adminServiceUpdateProjectVariables>>,
  TError,
  {
    organization: string;
    project: string;
    data: AdminServiceUpdateProjectVariablesBody;
  },
  TContext
> => {
  const mutationKey = ["adminServiceUpdateProjectVariables"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof adminServiceUpdateProjectVariables>>,
    {
      organization: string;
      project: string;
      data: AdminServiceUpdateProjectVariablesBody;
    }
  > = (props) => {
    const { organization, project, data } = props ?? {};

    return adminServiceUpdateProjectVariables(organization, project, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type AdminServiceUpdateProjectVariablesMutationResult = NonNullable<
  Awaited<ReturnType<typeof adminServiceUpdateProjectVariables>>
>;
export type AdminServiceUpdateProjectVariablesMutationBody =
  AdminServiceUpdateProjectVariablesBody;
export type AdminServiceUpdateProjectVariablesMutationError = RpcStatus;

/**
 * @summary UpdateProjectVariables updates variables for a project.
 */
export const createAdminServiceUpdateProjectVariables = <
  TError = RpcStatus,
  TContext = unknown,
>(
  options?: {
    mutation?: CreateMutationOptions<
      Awaited<ReturnType<typeof adminServiceUpdateProjectVariables>>,
      TError,
      {
        organization: string;
        project: string;
        data: AdminServiceUpdateProjectVariablesBody;
      },
      TContext
    >;
  },
  queryClient?: QueryClient,
): CreateMutationResult<
  Awaited<ReturnType<typeof adminServiceUpdateProjectVariables>>,
  TError,
  {
    organization: string;
    project: string;
    data: AdminServiceUpdateProjectVariablesBody;
  },
  TContext
> => {
  const mutationOptions =
    getAdminServiceUpdateProjectVariablesMutationOptions(options);

  return createMutation(mutationOptions, queryClient);
};
/**
 * @summary ListWhitelistedDomains lists all the whitelisted domains of the project
 */
export const adminServiceListProjectWhitelistedDomains = (
  organization: string,
  project: string,
  signal?: AbortSignal,
) => {
  return httpClient<V1ListProjectWhitelistedDomainsResponse>({
    url: `/v1/organizations/${organization}/projects/${project}/whitelisted`,
    method: "GET",
    signal,
  });
};

export const getAdminServiceListProjectWhitelistedDomainsQueryKey = (
  organization: string,
  project: string,
) => {
  return [
    `/v1/organizations/${organization}/projects/${project}/whitelisted`,
  ] as const;
};

export const getAdminServiceListProjectWhitelistedDomainsQueryOptions = <
  TData = Awaited<ReturnType<typeof adminServiceListProjectWhitelistedDomains>>,
  TError = RpcStatus,
>(
  organization: string,
  project: string,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof adminServiceListProjectWhitelistedDomains>>,
        TError,
        TData
      >
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getAdminServiceListProjectWhitelistedDomainsQueryKey(organization, project);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof adminServiceListProjectWhitelistedDomains>>
  > = ({ signal }) =>
    adminServiceListProjectWhitelistedDomains(organization, project, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!(organization && project),
    ...queryOptions,
  } as CreateQueryOptions<
    Awaited<ReturnType<typeof adminServiceListProjectWhitelistedDomains>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type AdminServiceListProjectWhitelistedDomainsQueryResult = NonNullable<
  Awaited<ReturnType<typeof adminServiceListProjectWhitelistedDomains>>
>;
export type AdminServiceListProjectWhitelistedDomainsQueryError = RpcStatus;

/**
 * @summary ListWhitelistedDomains lists all the whitelisted domains of the project
 */

export function createAdminServiceListProjectWhitelistedDomains<
  TData = Awaited<ReturnType<typeof adminServiceListProjectWhitelistedDomains>>,
  TError = RpcStatus,
>(
  organization: string,
  project: string,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof adminServiceListProjectWhitelistedDomains>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): CreateQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getAdminServiceListProjectWhitelistedDomainsQueryOptions(
    organization,
    project,
    options,
  );

  const query = createQuery(queryOptions, queryClient) as CreateQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary CreateProjectWhitelistedDomain adds a domain to the project's whitelisted
 */
export const adminServiceCreateProjectWhitelistedDomain = (
  organization: string,
  project: string,
  adminServiceCreateProjectWhitelistedDomainBodyBody: AdminServiceCreateProjectWhitelistedDomainBodyBody,
  signal?: AbortSignal,
) => {
  return httpClient<V1CreateProjectWhitelistedDomainResponse>({
    url: `/v1/organizations/${organization}/projects/${project}/whitelisted`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: adminServiceCreateProjectWhitelistedDomainBodyBody,
    signal,
  });
};

export const getAdminServiceCreateProjectWhitelistedDomainMutationOptions = <
  TError = RpcStatus,
  TContext = unknown,
>(options?: {
  mutation?: CreateMutationOptions<
    Awaited<ReturnType<typeof adminServiceCreateProjectWhitelistedDomain>>,
    TError,
    {
      organization: string;
      project: string;
      data: AdminServiceCreateProjectWhitelistedDomainBodyBody;
    },
    TContext
  >;
}): CreateMutationOptions<
  Awaited<ReturnType<typeof adminServiceCreateProjectWhitelistedDomain>>,
  TError,
  {
    organization: string;
    project: string;
    data: AdminServiceCreateProjectWhitelistedDomainBodyBody;
  },
  TContext
> => {
  const mutationKey = ["adminServiceCreateProjectWhitelistedDomain"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof adminServiceCreateProjectWhitelistedDomain>>,
    {
      organization: string;
      project: string;
      data: AdminServiceCreateProjectWhitelistedDomainBodyBody;
    }
  > = (props) => {
    const { organization, project, data } = props ?? {};

    return adminServiceCreateProjectWhitelistedDomain(
      organization,
      project,
      data,
    );
  };

  return { mutationFn, ...mutationOptions };
};

export type AdminServiceCreateProjectWhitelistedDomainMutationResult =
  NonNullable<
    Awaited<ReturnType<typeof adminServiceCreateProjectWhitelistedDomain>>
  >;
export type AdminServiceCreateProjectWhitelistedDomainMutationBody =
  AdminServiceCreateProjectWhitelistedDomainBodyBody;
export type AdminServiceCreateProjectWhitelistedDomainMutationError = RpcStatus;

/**
 * @summary CreateProjectWhitelistedDomain adds a domain to the project's whitelisted
 */
export const createAdminServiceCreateProjectWhitelistedDomain = <
  TError = RpcStatus,
  TContext = unknown,
>(
  options?: {
    mutation?: CreateMutationOptions<
      Awaited<ReturnType<typeof adminServiceCreateProjectWhitelistedDomain>>,
      TError,
      {
        organization: string;
        project: string;
        data: AdminServiceCreateProjectWhitelistedDomainBodyBody;
      },
      TContext
    >;
  },
  queryClient?: QueryClient,
): CreateMutationResult<
  Awaited<ReturnType<typeof adminServiceCreateProjectWhitelistedDomain>>,
  TError,
  {
    organization: string;
    project: string;
    data: AdminServiceCreateProjectWhitelistedDomainBodyBody;
  },
  TContext
> => {
  const mutationOptions =
    getAdminServiceCreateProjectWhitelistedDomainMutationOptions(options);

  return createMutation(mutationOptions, queryClient);
};
/**
 * @summary RemoveProjectWhitelistedDomain removes a domain from the project's whitelisted
 */
export const adminServiceRemoveProjectWhitelistedDomain = (
  organization: string,
  project: string,
  domain: string,
) => {
  return httpClient<V1RemoveProjectWhitelistedDomainResponse>({
    url: `/v1/organizations/${organization}/projects/${project}/whitelisted/${domain}`,
    method: "DELETE",
  });
};

export const getAdminServiceRemoveProjectWhitelistedDomainMutationOptions = <
  TError = RpcStatus,
  TContext = unknown,
>(options?: {
  mutation?: CreateMutationOptions<
    Awaited<ReturnType<typeof adminServiceRemoveProjectWhitelistedDomain>>,
    TError,
    { organization: string; project: string; domain: string },
    TContext
  >;
}): CreateMutationOptions<
  Awaited<ReturnType<typeof adminServiceRemoveProjectWhitelistedDomain>>,
  TError,
  { organization: string; project: string; domain: string },
  TContext
> => {
  const mutationKey = ["adminServiceRemoveProjectWhitelistedDomain"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof adminServiceRemoveProjectWhitelistedDomain>>,
    { organization: string; project: string; domain: string }
  > = (props) => {
    const { organization, project, domain } = props ?? {};

    return adminServiceRemoveProjectWhitelistedDomain(
      organization,
      project,
      domain,
    );
  };

  return { mutationFn, ...mutationOptions };
};

export type AdminServiceRemoveProjectWhitelistedDomainMutationResult =
  NonNullable<
    Awaited<ReturnType<typeof adminServiceRemoveProjectWhitelistedDomain>>
  >;

export type AdminServiceRemoveProjectWhitelistedDomainMutationError = RpcStatus;

/**
 * @summary RemoveProjectWhitelistedDomain removes a domain from the project's whitelisted
 */
export const createAdminServiceRemoveProjectWhitelistedDomain = <
  TError = RpcStatus,
  TContext = unknown,
>(
  options?: {
    mutation?: CreateMutationOptions<
      Awaited<ReturnType<typeof adminServiceRemoveProjectWhitelistedDomain>>,
      TError,
      { organization: string; project: string; domain: string },
      TContext
    >;
  },
  queryClient?: QueryClient,
): CreateMutationResult<
  Awaited<ReturnType<typeof adminServiceRemoveProjectWhitelistedDomain>>,
  TError,
  { organization: string; project: string; domain: string },
  TContext
> => {
  const mutationOptions =
    getAdminServiceRemoveProjectWhitelistedDomainMutationOptions(options);

  return createMutation(mutationOptions, queryClient);
};
/**
 * @summary ListOrganizationMemberUsergroups lists the org's user groups
 */
export const adminServiceListOrganizationMemberUsergroups = (
  organization: string,
  params?: AdminServiceListOrganizationMemberUsergroupsParams,
  signal?: AbortSignal,
) => {
  return httpClient<V1ListOrganizationMemberUsergroupsResponse>({
    url: `/v1/organizations/${organization}/usergroups`,
    method: "GET",
    params,
    signal,
  });
};

export const getAdminServiceListOrganizationMemberUsergroupsQueryKey = (
  organization: string,
  params?: AdminServiceListOrganizationMemberUsergroupsParams,
) => {
  return [
    `/v1/organizations/${organization}/usergroups`,
    ...(params ? [params] : []),
  ] as const;
};

export const getAdminServiceListOrganizationMemberUsergroupsQueryOptions = <
  TData = Awaited<
    ReturnType<typeof adminServiceListOrganizationMemberUsergroups>
  >,
  TError = RpcStatus,
>(
  organization: string,
  params?: AdminServiceListOrganizationMemberUsergroupsParams,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<
          ReturnType<typeof adminServiceListOrganizationMemberUsergroups>
        >,
        TError,
        TData
      >
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getAdminServiceListOrganizationMemberUsergroupsQueryKey(
      organization,
      params,
    );

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof adminServiceListOrganizationMemberUsergroups>>
  > = ({ signal }) =>
    adminServiceListOrganizationMemberUsergroups(organization, params, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!organization,
    ...queryOptions,
  } as CreateQueryOptions<
    Awaited<ReturnType<typeof adminServiceListOrganizationMemberUsergroups>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type AdminServiceListOrganizationMemberUsergroupsQueryResult =
  NonNullable<
    Awaited<ReturnType<typeof adminServiceListOrganizationMemberUsergroups>>
  >;
export type AdminServiceListOrganizationMemberUsergroupsQueryError = RpcStatus;

/**
 * @summary ListOrganizationMemberUsergroups lists the org's user groups
 */

export function createAdminServiceListOrganizationMemberUsergroups<
  TData = Awaited<
    ReturnType<typeof adminServiceListOrganizationMemberUsergroups>
  >,
  TError = RpcStatus,
>(
  organization: string,
  params?: AdminServiceListOrganizationMemberUsergroupsParams,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<
          ReturnType<typeof adminServiceListOrganizationMemberUsergroups>
        >,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): CreateQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions =
    getAdminServiceListOrganizationMemberUsergroupsQueryOptions(
      organization,
      params,
      options,
    );

  const query = createQuery(queryOptions, queryClient) as CreateQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary CreateUsergroup creates a user group in the organization
 */
export const adminServiceCreateUsergroup = (
  organization: string,
  adminServiceCreateUsergroupBodyBody: AdminServiceCreateUsergroupBodyBody,
  signal?: AbortSignal,
) => {
  return httpClient<V1CreateUsergroupResponse>({
    url: `/v1/organizations/${organization}/usergroups`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: adminServiceCreateUsergroupBodyBody,
    signal,
  });
};

export const getAdminServiceCreateUsergroupMutationOptions = <
  TError = RpcStatus,
  TContext = unknown,
>(options?: {
  mutation?: CreateMutationOptions<
    Awaited<ReturnType<typeof adminServiceCreateUsergroup>>,
    TError,
    { organization: string; data: AdminServiceCreateUsergroupBodyBody },
    TContext
  >;
}): CreateMutationOptions<
  Awaited<ReturnType<typeof adminServiceCreateUsergroup>>,
  TError,
  { organization: string; data: AdminServiceCreateUsergroupBodyBody },
  TContext
> => {
  const mutationKey = ["adminServiceCreateUsergroup"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof adminServiceCreateUsergroup>>,
    { organization: string; data: AdminServiceCreateUsergroupBodyBody }
  > = (props) => {
    const { organization, data } = props ?? {};

    return adminServiceCreateUsergroup(organization, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type AdminServiceCreateUsergroupMutationResult = NonNullable<
  Awaited<ReturnType<typeof adminServiceCreateUsergroup>>
>;
export type AdminServiceCreateUsergroupMutationBody =
  AdminServiceCreateUsergroupBodyBody;
export type AdminServiceCreateUsergroupMutationError = RpcStatus;

/**
 * @summary CreateUsergroup creates a user group in the organization
 */
export const createAdminServiceCreateUsergroup = <
  TError = RpcStatus,
  TContext = unknown,
>(
  options?: {
    mutation?: CreateMutationOptions<
      Awaited<ReturnType<typeof adminServiceCreateUsergroup>>,
      TError,
      { organization: string; data: AdminServiceCreateUsergroupBodyBody },
      TContext
    >;
  },
  queryClient?: QueryClient,
): CreateMutationResult<
  Awaited<ReturnType<typeof adminServiceCreateUsergroup>>,
  TError,
  { organization: string; data: AdminServiceCreateUsergroupBodyBody },
  TContext
> => {
  const mutationOptions =
    getAdminServiceCreateUsergroupMutationOptions(options);

  return createMutation(mutationOptions, queryClient);
};
/**
 * @summary ListUsergroupsForOrganizationAndUser lists the user groups that an organization member user has access to.
 */
export const adminServiceListUsergroupsForOrganizationAndUser = (
  organization: string,
  params?: AdminServiceListUsergroupsForOrganizationAndUserParams,
  signal?: AbortSignal,
) => {
  return httpClient<V1ListUsergroupsForOrganizationAndUserResponse>({
    url: `/v1/organizations/${organization}/usergroups-for-user`,
    method: "GET",
    params,
    signal,
  });
};

export const getAdminServiceListUsergroupsForOrganizationAndUserQueryKey = (
  organization: string,
  params?: AdminServiceListUsergroupsForOrganizationAndUserParams,
) => {
  return [
    `/v1/organizations/${organization}/usergroups-for-user`,
    ...(params ? [params] : []),
  ] as const;
};

export const getAdminServiceListUsergroupsForOrganizationAndUserQueryOptions = <
  TData = Awaited<
    ReturnType<typeof adminServiceListUsergroupsForOrganizationAndUser>
  >,
  TError = RpcStatus,
>(
  organization: string,
  params?: AdminServiceListUsergroupsForOrganizationAndUserParams,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<
          ReturnType<typeof adminServiceListUsergroupsForOrganizationAndUser>
        >,
        TError,
        TData
      >
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getAdminServiceListUsergroupsForOrganizationAndUserQueryKey(
      organization,
      params,
    );

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof adminServiceListUsergroupsForOrganizationAndUser>>
  > = ({ signal }) =>
    adminServiceListUsergroupsForOrganizationAndUser(
      organization,
      params,
      signal,
    );

  return {
    queryKey,
    queryFn,
    enabled: !!organization,
    ...queryOptions,
  } as CreateQueryOptions<
    Awaited<
      ReturnType<typeof adminServiceListUsergroupsForOrganizationAndUser>
    >,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type AdminServiceListUsergroupsForOrganizationAndUserQueryResult =
  NonNullable<
    Awaited<ReturnType<typeof adminServiceListUsergroupsForOrganizationAndUser>>
  >;
export type AdminServiceListUsergroupsForOrganizationAndUserQueryError =
  RpcStatus;

/**
 * @summary ListUsergroupsForOrganizationAndUser lists the user groups that an organization member user has access to.
 */

export function createAdminServiceListUsergroupsForOrganizationAndUser<
  TData = Awaited<
    ReturnType<typeof adminServiceListUsergroupsForOrganizationAndUser>
  >,
  TError = RpcStatus,
>(
  organization: string,
  params?: AdminServiceListUsergroupsForOrganizationAndUserParams,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<
          ReturnType<typeof adminServiceListUsergroupsForOrganizationAndUser>
        >,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): CreateQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions =
    getAdminServiceListUsergroupsForOrganizationAndUserQueryOptions(
      organization,
      params,
      options,
    );

  const query = createQuery(queryOptions, queryClient) as CreateQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary GetUsergroups returns the user group details
 */
export const adminServiceGetUsergroup = (
  organization: string,
  usergroup: string,
  params?: AdminServiceGetUsergroupParams,
  signal?: AbortSignal,
) => {
  return httpClient<V1GetUsergroupResponse>({
    url: `/v1/organizations/${organization}/usergroups/${usergroup}`,
    method: "GET",
    params,
    signal,
  });
};

export const getAdminServiceGetUsergroupQueryKey = (
  organization: string,
  usergroup: string,
  params?: AdminServiceGetUsergroupParams,
) => {
  return [
    `/v1/organizations/${organization}/usergroups/${usergroup}`,
    ...(params ? [params] : []),
  ] as const;
};

export const getAdminServiceGetUsergroupQueryOptions = <
  TData = Awaited<ReturnType<typeof adminServiceGetUsergroup>>,
  TError = RpcStatus,
>(
  organization: string,
  usergroup: string,
  params?: AdminServiceGetUsergroupParams,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof adminServiceGetUsergroup>>,
        TError,
        TData
      >
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getAdminServiceGetUsergroupQueryKey(organization, usergroup, params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof adminServiceGetUsergroup>>
  > = ({ signal }) =>
    adminServiceGetUsergroup(organization, usergroup, params, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!(organization && usergroup),
    ...queryOptions,
  } as CreateQueryOptions<
    Awaited<ReturnType<typeof adminServiceGetUsergroup>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type AdminServiceGetUsergroupQueryResult = NonNullable<
  Awaited<ReturnType<typeof adminServiceGetUsergroup>>
>;
export type AdminServiceGetUsergroupQueryError = RpcStatus;

/**
 * @summary GetUsergroups returns the user group details
 */

export function createAdminServiceGetUsergroup<
  TData = Awaited<ReturnType<typeof adminServiceGetUsergroup>>,
  TError = RpcStatus,
>(
  organization: string,
  usergroup: string,
  params?: AdminServiceGetUsergroupParams,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof adminServiceGetUsergroup>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): CreateQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getAdminServiceGetUsergroupQueryOptions(
    organization,
    usergroup,
    params,
    options,
  );

  const query = createQuery(queryOptions, queryClient) as CreateQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary DeleteUsergroup deletes the user group from the organization
 */
export const adminServiceDeleteUsergroup = (
  organization: string,
  usergroup: string,
) => {
  return httpClient<V1DeleteUsergroupResponse>({
    url: `/v1/organizations/${organization}/usergroups/${usergroup}`,
    method: "DELETE",
  });
};

export const getAdminServiceDeleteUsergroupMutationOptions = <
  TError = RpcStatus,
  TContext = unknown,
>(options?: {
  mutation?: CreateMutationOptions<
    Awaited<ReturnType<typeof adminServiceDeleteUsergroup>>,
    TError,
    { organization: string; usergroup: string },
    TContext
  >;
}): CreateMutationOptions<
  Awaited<ReturnType<typeof adminServiceDeleteUsergroup>>,
  TError,
  { organization: string; usergroup: string },
  TContext
> => {
  const mutationKey = ["adminServiceDeleteUsergroup"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof adminServiceDeleteUsergroup>>,
    { organization: string; usergroup: string }
  > = (props) => {
    const { organization, usergroup } = props ?? {};

    return adminServiceDeleteUsergroup(organization, usergroup);
  };

  return { mutationFn, ...mutationOptions };
};

export type AdminServiceDeleteUsergroupMutationResult = NonNullable<
  Awaited<ReturnType<typeof adminServiceDeleteUsergroup>>
>;

export type AdminServiceDeleteUsergroupMutationError = RpcStatus;

/**
 * @summary DeleteUsergroup deletes the user group from the organization
 */
export const createAdminServiceDeleteUsergroup = <
  TError = RpcStatus,
  TContext = unknown,
>(
  options?: {
    mutation?: CreateMutationOptions<
      Awaited<ReturnType<typeof adminServiceDeleteUsergroup>>,
      TError,
      { organization: string; usergroup: string },
      TContext
    >;
  },
  queryClient?: QueryClient,
): CreateMutationResult<
  Awaited<ReturnType<typeof adminServiceDeleteUsergroup>>,
  TError,
  { organization: string; usergroup: string },
  TContext
> => {
  const mutationOptions =
    getAdminServiceDeleteUsergroupMutationOptions(options);

  return createMutation(mutationOptions, queryClient);
};
/**
 * @summary RenameUsergroup renames the user group
 */
export const adminServiceRenameUsergroup = (
  organization: string,
  usergroup: string,
  adminServiceCreateUsergroupBodyBody: AdminServiceCreateUsergroupBodyBody,
  signal?: AbortSignal,
) => {
  return httpClient<V1RenameUsergroupResponse>({
    url: `/v1/organizations/${organization}/usergroups/${usergroup}`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: adminServiceCreateUsergroupBodyBody,
    signal,
  });
};

export const getAdminServiceRenameUsergroupMutationOptions = <
  TError = RpcStatus,
  TContext = unknown,
>(options?: {
  mutation?: CreateMutationOptions<
    Awaited<ReturnType<typeof adminServiceRenameUsergroup>>,
    TError,
    {
      organization: string;
      usergroup: string;
      data: AdminServiceCreateUsergroupBodyBody;
    },
    TContext
  >;
}): CreateMutationOptions<
  Awaited<ReturnType<typeof adminServiceRenameUsergroup>>,
  TError,
  {
    organization: string;
    usergroup: string;
    data: AdminServiceCreateUsergroupBodyBody;
  },
  TContext
> => {
  const mutationKey = ["adminServiceRenameUsergroup"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof adminServiceRenameUsergroup>>,
    {
      organization: string;
      usergroup: string;
      data: AdminServiceCreateUsergroupBodyBody;
    }
  > = (props) => {
    const { organization, usergroup, data } = props ?? {};

    return adminServiceRenameUsergroup(organization, usergroup, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type AdminServiceRenameUsergroupMutationResult = NonNullable<
  Awaited<ReturnType<typeof adminServiceRenameUsergroup>>
>;
export type AdminServiceRenameUsergroupMutationBody =
  AdminServiceCreateUsergroupBodyBody;
export type AdminServiceRenameUsergroupMutationError = RpcStatus;

/**
 * @summary RenameUsergroup renames the user group
 */
export const createAdminServiceRenameUsergroup = <
  TError = RpcStatus,
  TContext = unknown,
>(
  options?: {
    mutation?: CreateMutationOptions<
      Awaited<ReturnType<typeof adminServiceRenameUsergroup>>,
      TError,
      {
        organization: string;
        usergroup: string;
        data: AdminServiceCreateUsergroupBodyBody;
      },
      TContext
    >;
  },
  queryClient?: QueryClient,
): CreateMutationResult<
  Awaited<ReturnType<typeof adminServiceRenameUsergroup>>,
  TError,
  {
    organization: string;
    usergroup: string;
    data: AdminServiceCreateUsergroupBodyBody;
  },
  TContext
> => {
  const mutationOptions =
    getAdminServiceRenameUsergroupMutationOptions(options);

  return createMutation(mutationOptions, queryClient);
};
/**
 * @summary EditUsergroup renames the user group
 */
export const adminServiceEditUsergroup = (
  organization: string,
  usergroup: string,
  adminServiceEditUsergroupBody: AdminServiceEditUsergroupBody,
) => {
  return httpClient<V1EditUsergroupResponse>({
    url: `/v1/organizations/${organization}/usergroups/${usergroup}`,
    method: "PUT",
    headers: { "Content-Type": "application/json" },
    data: adminServiceEditUsergroupBody,
  });
};

export const getAdminServiceEditUsergroupMutationOptions = <
  TError = RpcStatus,
  TContext = unknown,
>(options?: {
  mutation?: CreateMutationOptions<
    Awaited<ReturnType<typeof adminServiceEditUsergroup>>,
    TError,
    {
      organization: string;
      usergroup: string;
      data: AdminServiceEditUsergroupBody;
    },
    TContext
  >;
}): CreateMutationOptions<
  Awaited<ReturnType<typeof adminServiceEditUsergroup>>,
  TError,
  {
    organization: string;
    usergroup: string;
    data: AdminServiceEditUsergroupBody;
  },
  TContext
> => {
  const mutationKey = ["adminServiceEditUsergroup"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof adminServiceEditUsergroup>>,
    {
      organization: string;
      usergroup: string;
      data: AdminServiceEditUsergroupBody;
    }
  > = (props) => {
    const { organization, usergroup, data } = props ?? {};

    return adminServiceEditUsergroup(organization, usergroup, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type AdminServiceEditUsergroupMutationResult = NonNullable<
  Awaited<ReturnType<typeof adminServiceEditUsergroup>>
>;
export type AdminServiceEditUsergroupMutationBody =
  AdminServiceEditUsergroupBody;
export type AdminServiceEditUsergroupMutationError = RpcStatus;

/**
 * @summary EditUsergroup renames the user group
 */
export const createAdminServiceEditUsergroup = <
  TError = RpcStatus,
  TContext = unknown,
>(
  options?: {
    mutation?: CreateMutationOptions<
      Awaited<ReturnType<typeof adminServiceEditUsergroup>>,
      TError,
      {
        organization: string;
        usergroup: string;
        data: AdminServiceEditUsergroupBody;
      },
      TContext
    >;
  },
  queryClient?: QueryClient,
): CreateMutationResult<
  Awaited<ReturnType<typeof adminServiceEditUsergroup>>,
  TError,
  {
    organization: string;
    usergroup: string;
    data: AdminServiceEditUsergroupBody;
  },
  TContext
> => {
  const mutationOptions = getAdminServiceEditUsergroupMutationOptions(options);

  return createMutation(mutationOptions, queryClient);
};
/**
 * @summary ListUsergroupMemberUsers lists all the user group members
 */
export const adminServiceListUsergroupMemberUsers = (
  organization: string,
  usergroup: string,
  params?: AdminServiceListUsergroupMemberUsersParams,
  signal?: AbortSignal,
) => {
  return httpClient<V1ListUsergroupMemberUsersResponse>({
    url: `/v1/organizations/${organization}/usergroups/${usergroup}/members`,
    method: "GET",
    params,
    signal,
  });
};

export const getAdminServiceListUsergroupMemberUsersQueryKey = (
  organization: string,
  usergroup: string,
  params?: AdminServiceListUsergroupMemberUsersParams,
) => {
  return [
    `/v1/organizations/${organization}/usergroups/${usergroup}/members`,
    ...(params ? [params] : []),
  ] as const;
};

export const getAdminServiceListUsergroupMemberUsersQueryOptions = <
  TData = Awaited<ReturnType<typeof adminServiceListUsergroupMemberUsers>>,
  TError = RpcStatus,
>(
  organization: string,
  usergroup: string,
  params?: AdminServiceListUsergroupMemberUsersParams,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof adminServiceListUsergroupMemberUsers>>,
        TError,
        TData
      >
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getAdminServiceListUsergroupMemberUsersQueryKey(
      organization,
      usergroup,
      params,
    );

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof adminServiceListUsergroupMemberUsers>>
  > = ({ signal }) =>
    adminServiceListUsergroupMemberUsers(
      organization,
      usergroup,
      params,
      signal,
    );

  return {
    queryKey,
    queryFn,
    enabled: !!(organization && usergroup),
    ...queryOptions,
  } as CreateQueryOptions<
    Awaited<ReturnType<typeof adminServiceListUsergroupMemberUsers>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type AdminServiceListUsergroupMemberUsersQueryResult = NonNullable<
  Awaited<ReturnType<typeof adminServiceListUsergroupMemberUsers>>
>;
export type AdminServiceListUsergroupMemberUsersQueryError = RpcStatus;

/**
 * @summary ListUsergroupMemberUsers lists all the user group members
 */

export function createAdminServiceListUsergroupMemberUsers<
  TData = Awaited<ReturnType<typeof adminServiceListUsergroupMemberUsers>>,
  TError = RpcStatus,
>(
  organization: string,
  usergroup: string,
  params?: AdminServiceListUsergroupMemberUsersParams,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof adminServiceListUsergroupMemberUsers>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): CreateQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getAdminServiceListUsergroupMemberUsersQueryOptions(
    organization,
    usergroup,
    params,
    options,
  );

  const query = createQuery(queryOptions, queryClient) as CreateQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary RemoveUsergroupMemberUser removes member from the user group
 */
export const adminServiceRemoveUsergroupMemberUser = (
  organization: string,
  usergroup: string,
  email: string,
) => {
  return httpClient<V1RemoveUsergroupMemberUserResponse>({
    url: `/v1/organizations/${organization}/usergroups/${usergroup}/members/${email}`,
    method: "DELETE",
  });
};

export const getAdminServiceRemoveUsergroupMemberUserMutationOptions = <
  TError = RpcStatus,
  TContext = unknown,
>(options?: {
  mutation?: CreateMutationOptions<
    Awaited<ReturnType<typeof adminServiceRemoveUsergroupMemberUser>>,
    TError,
    { organization: string; usergroup: string; email: string },
    TContext
  >;
}): CreateMutationOptions<
  Awaited<ReturnType<typeof adminServiceRemoveUsergroupMemberUser>>,
  TError,
  { organization: string; usergroup: string; email: string },
  TContext
> => {
  const mutationKey = ["adminServiceRemoveUsergroupMemberUser"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof adminServiceRemoveUsergroupMemberUser>>,
    { organization: string; usergroup: string; email: string }
  > = (props) => {
    const { organization, usergroup, email } = props ?? {};

    return adminServiceRemoveUsergroupMemberUser(
      organization,
      usergroup,
      email,
    );
  };

  return { mutationFn, ...mutationOptions };
};

export type AdminServiceRemoveUsergroupMemberUserMutationResult = NonNullable<
  Awaited<ReturnType<typeof adminServiceRemoveUsergroupMemberUser>>
>;

export type AdminServiceRemoveUsergroupMemberUserMutationError = RpcStatus;

/**
 * @summary RemoveUsergroupMemberUser removes member from the user group
 */
export const createAdminServiceRemoveUsergroupMemberUser = <
  TError = RpcStatus,
  TContext = unknown,
>(
  options?: {
    mutation?: CreateMutationOptions<
      Awaited<ReturnType<typeof adminServiceRemoveUsergroupMemberUser>>,
      TError,
      { organization: string; usergroup: string; email: string },
      TContext
    >;
  },
  queryClient?: QueryClient,
): CreateMutationResult<
  Awaited<ReturnType<typeof adminServiceRemoveUsergroupMemberUser>>,
  TError,
  { organization: string; usergroup: string; email: string },
  TContext
> => {
  const mutationOptions =
    getAdminServiceRemoveUsergroupMemberUserMutationOptions(options);

  return createMutation(mutationOptions, queryClient);
};
/**
 * @summary AddUsergroupMemberUser adds a member to the user group
 */
export const adminServiceAddUsergroupMemberUser = (
  organization: string,
  usergroup: string,
  email: string,
  adminServiceTriggerReconcileBodyBody: AdminServiceTriggerReconcileBodyBody,
) => {
  return httpClient<V1AddUsergroupMemberUserResponse>({
    url: `/v1/organizations/${organization}/usergroups/${usergroup}/members/${email}`,
    method: "PUT",
    headers: { "Content-Type": "application/json" },
    data: adminServiceTriggerReconcileBodyBody,
  });
};

export const getAdminServiceAddUsergroupMemberUserMutationOptions = <
  TError = RpcStatus,
  TContext = unknown,
>(options?: {
  mutation?: CreateMutationOptions<
    Awaited<ReturnType<typeof adminServiceAddUsergroupMemberUser>>,
    TError,
    {
      organization: string;
      usergroup: string;
      email: string;
      data: AdminServiceTriggerReconcileBodyBody;
    },
    TContext
  >;
}): CreateMutationOptions<
  Awaited<ReturnType<typeof adminServiceAddUsergroupMemberUser>>,
  TError,
  {
    organization: string;
    usergroup: string;
    email: string;
    data: AdminServiceTriggerReconcileBodyBody;
  },
  TContext
> => {
  const mutationKey = ["adminServiceAddUsergroupMemberUser"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof adminServiceAddUsergroupMemberUser>>,
    {
      organization: string;
      usergroup: string;
      email: string;
      data: AdminServiceTriggerReconcileBodyBody;
    }
  > = (props) => {
    const { organization, usergroup, email, data } = props ?? {};

    return adminServiceAddUsergroupMemberUser(
      organization,
      usergroup,
      email,
      data,
    );
  };

  return { mutationFn, ...mutationOptions };
};

export type AdminServiceAddUsergroupMemberUserMutationResult = NonNullable<
  Awaited<ReturnType<typeof adminServiceAddUsergroupMemberUser>>
>;
export type AdminServiceAddUsergroupMemberUserMutationBody =
  AdminServiceTriggerReconcileBodyBody;
export type AdminServiceAddUsergroupMemberUserMutationError = RpcStatus;

/**
 * @summary AddUsergroupMemberUser adds a member to the user group
 */
export const createAdminServiceAddUsergroupMemberUser = <
  TError = RpcStatus,
  TContext = unknown,
>(
  options?: {
    mutation?: CreateMutationOptions<
      Awaited<ReturnType<typeof adminServiceAddUsergroupMemberUser>>,
      TError,
      {
        organization: string;
        usergroup: string;
        email: string;
        data: AdminServiceTriggerReconcileBodyBody;
      },
      TContext
    >;
  },
  queryClient?: QueryClient,
): CreateMutationResult<
  Awaited<ReturnType<typeof adminServiceAddUsergroupMemberUser>>,
  TError,
  {
    organization: string;
    usergroup: string;
    email: string;
    data: AdminServiceTriggerReconcileBodyBody;
  },
  TContext
> => {
  const mutationOptions =
    getAdminServiceAddUsergroupMemberUserMutationOptions(options);

  return createMutation(mutationOptions, queryClient);
};
/**
 * @summary RemoveOrganizationMemberUsergroup revokes the organization-level role for the user group
 */
export const adminServiceRemoveOrganizationMemberUsergroup = (
  organization: string,
  usergroup: string,
) => {
  return httpClient<V1RemoveOrganizationMemberUsergroupResponse>({
    url: `/v1/organizations/${organization}/usergroups/${usergroup}/role`,
    method: "DELETE",
  });
};

export const getAdminServiceRemoveOrganizationMemberUsergroupMutationOptions = <
  TError = RpcStatus,
  TContext = unknown,
>(options?: {
  mutation?: CreateMutationOptions<
    Awaited<ReturnType<typeof adminServiceRemoveOrganizationMemberUsergroup>>,
    TError,
    { organization: string; usergroup: string },
    TContext
  >;
}): CreateMutationOptions<
  Awaited<ReturnType<typeof adminServiceRemoveOrganizationMemberUsergroup>>,
  TError,
  { organization: string; usergroup: string },
  TContext
> => {
  const mutationKey = ["adminServiceRemoveOrganizationMemberUsergroup"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof adminServiceRemoveOrganizationMemberUsergroup>>,
    { organization: string; usergroup: string }
  > = (props) => {
    const { organization, usergroup } = props ?? {};

    return adminServiceRemoveOrganizationMemberUsergroup(
      organization,
      usergroup,
    );
  };

  return { mutationFn, ...mutationOptions };
};

export type AdminServiceRemoveOrganizationMemberUsergroupMutationResult =
  NonNullable<
    Awaited<ReturnType<typeof adminServiceRemoveOrganizationMemberUsergroup>>
  >;

export type AdminServiceRemoveOrganizationMemberUsergroupMutationError =
  RpcStatus;

/**
 * @summary RemoveOrganizationMemberUsergroup revokes the organization-level role for the user group
 */
export const createAdminServiceRemoveOrganizationMemberUsergroup = <
  TError = RpcStatus,
  TContext = unknown,
>(
  options?: {
    mutation?: CreateMutationOptions<
      Awaited<ReturnType<typeof adminServiceRemoveOrganizationMemberUsergroup>>,
      TError,
      { organization: string; usergroup: string },
      TContext
    >;
  },
  queryClient?: QueryClient,
): CreateMutationResult<
  Awaited<ReturnType<typeof adminServiceRemoveOrganizationMemberUsergroup>>,
  TError,
  { organization: string; usergroup: string },
  TContext
> => {
  const mutationOptions =
    getAdminServiceRemoveOrganizationMemberUsergroupMutationOptions(options);

  return createMutation(mutationOptions, queryClient);
};
/**
 * @summary AddOrganizationMemberUsergroupRole adds the role for the user group
 */
export const adminServiceAddOrganizationMemberUsergroup = (
  organization: string,
  usergroup: string,
  adminServiceSetProjectMemberUserRoleBodyBody: AdminServiceSetProjectMemberUserRoleBodyBody,
  signal?: AbortSignal,
) => {
  return httpClient<V1AddOrganizationMemberUsergroupResponse>({
    url: `/v1/organizations/${organization}/usergroups/${usergroup}/role`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: adminServiceSetProjectMemberUserRoleBodyBody,
    signal,
  });
};

export const getAdminServiceAddOrganizationMemberUsergroupMutationOptions = <
  TError = RpcStatus,
  TContext = unknown,
>(options?: {
  mutation?: CreateMutationOptions<
    Awaited<ReturnType<typeof adminServiceAddOrganizationMemberUsergroup>>,
    TError,
    {
      organization: string;
      usergroup: string;
      data: AdminServiceSetProjectMemberUserRoleBodyBody;
    },
    TContext
  >;
}): CreateMutationOptions<
  Awaited<ReturnType<typeof adminServiceAddOrganizationMemberUsergroup>>,
  TError,
  {
    organization: string;
    usergroup: string;
    data: AdminServiceSetProjectMemberUserRoleBodyBody;
  },
  TContext
> => {
  const mutationKey = ["adminServiceAddOrganizationMemberUsergroup"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof adminServiceAddOrganizationMemberUsergroup>>,
    {
      organization: string;
      usergroup: string;
      data: AdminServiceSetProjectMemberUserRoleBodyBody;
    }
  > = (props) => {
    const { organization, usergroup, data } = props ?? {};

    return adminServiceAddOrganizationMemberUsergroup(
      organization,
      usergroup,
      data,
    );
  };

  return { mutationFn, ...mutationOptions };
};

export type AdminServiceAddOrganizationMemberUsergroupMutationResult =
  NonNullable<
    Awaited<ReturnType<typeof adminServiceAddOrganizationMemberUsergroup>>
  >;
export type AdminServiceAddOrganizationMemberUsergroupMutationBody =
  AdminServiceSetProjectMemberUserRoleBodyBody;
export type AdminServiceAddOrganizationMemberUsergroupMutationError = RpcStatus;

/**
 * @summary AddOrganizationMemberUsergroupRole adds the role for the user group
 */
export const createAdminServiceAddOrganizationMemberUsergroup = <
  TError = RpcStatus,
  TContext = unknown,
>(
  options?: {
    mutation?: CreateMutationOptions<
      Awaited<ReturnType<typeof adminServiceAddOrganizationMemberUsergroup>>,
      TError,
      {
        organization: string;
        usergroup: string;
        data: AdminServiceSetProjectMemberUserRoleBodyBody;
      },
      TContext
    >;
  },
  queryClient?: QueryClient,
): CreateMutationResult<
  Awaited<ReturnType<typeof adminServiceAddOrganizationMemberUsergroup>>,
  TError,
  {
    organization: string;
    usergroup: string;
    data: AdminServiceSetProjectMemberUserRoleBodyBody;
  },
  TContext
> => {
  const mutationOptions =
    getAdminServiceAddOrganizationMemberUsergroupMutationOptions(options);

  return createMutation(mutationOptions, queryClient);
};
/**
 * @summary SetOrganizationMemberUsergroupRole sets the role for the user group
 */
export const adminServiceSetOrganizationMemberUsergroupRole = (
  organization: string,
  usergroup: string,
  adminServiceSetProjectMemberUserRoleBodyBody: AdminServiceSetProjectMemberUserRoleBodyBody,
) => {
  return httpClient<V1SetOrganizationMemberUsergroupRoleResponse>({
    url: `/v1/organizations/${organization}/usergroups/${usergroup}/role`,
    method: "PUT",
    headers: { "Content-Type": "application/json" },
    data: adminServiceSetProjectMemberUserRoleBodyBody,
  });
};

export const getAdminServiceSetOrganizationMemberUsergroupRoleMutationOptions =
  <TError = RpcStatus, TContext = unknown>(options?: {
    mutation?: CreateMutationOptions<
      Awaited<
        ReturnType<typeof adminServiceSetOrganizationMemberUsergroupRole>
      >,
      TError,
      {
        organization: string;
        usergroup: string;
        data: AdminServiceSetProjectMemberUserRoleBodyBody;
      },
      TContext
    >;
  }): CreateMutationOptions<
    Awaited<ReturnType<typeof adminServiceSetOrganizationMemberUsergroupRole>>,
    TError,
    {
      organization: string;
      usergroup: string;
      data: AdminServiceSetProjectMemberUserRoleBodyBody;
    },
    TContext
  > => {
    const mutationKey = ["adminServiceSetOrganizationMemberUsergroupRole"];
    const { mutation: mutationOptions } = options
      ? options.mutation &&
        "mutationKey" in options.mutation &&
        options.mutation.mutationKey
        ? options
        : { ...options, mutation: { ...options.mutation, mutationKey } }
      : { mutation: { mutationKey } };

    const mutationFn: MutationFunction<
      Awaited<
        ReturnType<typeof adminServiceSetOrganizationMemberUsergroupRole>
      >,
      {
        organization: string;
        usergroup: string;
        data: AdminServiceSetProjectMemberUserRoleBodyBody;
      }
    > = (props) => {
      const { organization, usergroup, data } = props ?? {};

      return adminServiceSetOrganizationMemberUsergroupRole(
        organization,
        usergroup,
        data,
      );
    };

    return { mutationFn, ...mutationOptions };
  };

export type AdminServiceSetOrganizationMemberUsergroupRoleMutationResult =
  NonNullable<
    Awaited<ReturnType<typeof adminServiceSetOrganizationMemberUsergroupRole>>
  >;
export type AdminServiceSetOrganizationMemberUsergroupRoleMutationBody =
  AdminServiceSetProjectMemberUserRoleBodyBody;
export type AdminServiceSetOrganizationMemberUsergroupRoleMutationError =
  RpcStatus;

/**
 * @summary SetOrganizationMemberUsergroupRole sets the role for the user group
 */
export const createAdminServiceSetOrganizationMemberUsergroupRole = <
  TError = RpcStatus,
  TContext = unknown,
>(
  options?: {
    mutation?: CreateMutationOptions<
      Awaited<
        ReturnType<typeof adminServiceSetOrganizationMemberUsergroupRole>
      >,
      TError,
      {
        organization: string;
        usergroup: string;
        data: AdminServiceSetProjectMemberUserRoleBodyBody;
      },
      TContext
    >;
  },
  queryClient?: QueryClient,
): CreateMutationResult<
  Awaited<ReturnType<typeof adminServiceSetOrganizationMemberUsergroupRole>>,
  TError,
  {
    organization: string;
    usergroup: string;
    data: AdminServiceSetProjectMemberUserRoleBodyBody;
  },
  TContext
> => {
  const mutationOptions =
    getAdminServiceSetOrganizationMemberUsergroupRoleMutationOptions(options);

  return createMutation(mutationOptions, queryClient);
};
/**
 * @summary ListWhitelistedDomains lists all the whitelisted domains for the organization
 */
export const adminServiceListWhitelistedDomains = (
  organization: string,
  signal?: AbortSignal,
) => {
  return httpClient<V1ListWhitelistedDomainsResponse>({
    url: `/v1/organizations/${organization}/whitelisted`,
    method: "GET",
    signal,
  });
};

export const getAdminServiceListWhitelistedDomainsQueryKey = (
  organization: string,
) => {
  return [`/v1/organizations/${organization}/whitelisted`] as const;
};

export const getAdminServiceListWhitelistedDomainsQueryOptions = <
  TData = Awaited<ReturnType<typeof adminServiceListWhitelistedDomains>>,
  TError = RpcStatus,
>(
  organization: string,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof adminServiceListWhitelistedDomains>>,
        TError,
        TData
      >
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getAdminServiceListWhitelistedDomainsQueryKey(organization);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof adminServiceListWhitelistedDomains>>
  > = ({ signal }) => adminServiceListWhitelistedDomains(organization, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!organization,
    ...queryOptions,
  } as CreateQueryOptions<
    Awaited<ReturnType<typeof adminServiceListWhitelistedDomains>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type AdminServiceListWhitelistedDomainsQueryResult = NonNullable<
  Awaited<ReturnType<typeof adminServiceListWhitelistedDomains>>
>;
export type AdminServiceListWhitelistedDomainsQueryError = RpcStatus;

/**
 * @summary ListWhitelistedDomains lists all the whitelisted domains for the organization
 */

export function createAdminServiceListWhitelistedDomains<
  TData = Awaited<ReturnType<typeof adminServiceListWhitelistedDomains>>,
  TError = RpcStatus,
>(
  organization: string,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof adminServiceListWhitelistedDomains>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): CreateQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getAdminServiceListWhitelistedDomainsQueryOptions(
    organization,
    options,
  );

  const query = createQuery(queryOptions, queryClient) as CreateQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary CreateWhitelistedDomain adds a domain to the whitelist
 */
export const adminServiceCreateWhitelistedDomain = (
  organization: string,
  adminServiceCreateProjectWhitelistedDomainBodyBody: AdminServiceCreateProjectWhitelistedDomainBodyBody,
  signal?: AbortSignal,
) => {
  return httpClient<V1CreateWhitelistedDomainResponse>({
    url: `/v1/organizations/${organization}/whitelisted`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: adminServiceCreateProjectWhitelistedDomainBodyBody,
    signal,
  });
};

export const getAdminServiceCreateWhitelistedDomainMutationOptions = <
  TError = RpcStatus,
  TContext = unknown,
>(options?: {
  mutation?: CreateMutationOptions<
    Awaited<ReturnType<typeof adminServiceCreateWhitelistedDomain>>,
    TError,
    {
      organization: string;
      data: AdminServiceCreateProjectWhitelistedDomainBodyBody;
    },
    TContext
  >;
}): CreateMutationOptions<
  Awaited<ReturnType<typeof adminServiceCreateWhitelistedDomain>>,
  TError,
  {
    organization: string;
    data: AdminServiceCreateProjectWhitelistedDomainBodyBody;
  },
  TContext
> => {
  const mutationKey = ["adminServiceCreateWhitelistedDomain"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof adminServiceCreateWhitelistedDomain>>,
    {
      organization: string;
      data: AdminServiceCreateProjectWhitelistedDomainBodyBody;
    }
  > = (props) => {
    const { organization, data } = props ?? {};

    return adminServiceCreateWhitelistedDomain(organization, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type AdminServiceCreateWhitelistedDomainMutationResult = NonNullable<
  Awaited<ReturnType<typeof adminServiceCreateWhitelistedDomain>>
>;
export type AdminServiceCreateWhitelistedDomainMutationBody =
  AdminServiceCreateProjectWhitelistedDomainBodyBody;
export type AdminServiceCreateWhitelistedDomainMutationError = RpcStatus;

/**
 * @summary CreateWhitelistedDomain adds a domain to the whitelist
 */
export const createAdminServiceCreateWhitelistedDomain = <
  TError = RpcStatus,
  TContext = unknown,
>(
  options?: {
    mutation?: CreateMutationOptions<
      Awaited<ReturnType<typeof adminServiceCreateWhitelistedDomain>>,
      TError,
      {
        organization: string;
        data: AdminServiceCreateProjectWhitelistedDomainBodyBody;
      },
      TContext
    >;
  },
  queryClient?: QueryClient,
): CreateMutationResult<
  Awaited<ReturnType<typeof adminServiceCreateWhitelistedDomain>>,
  TError,
  {
    organization: string;
    data: AdminServiceCreateProjectWhitelistedDomainBodyBody;
  },
  TContext
> => {
  const mutationOptions =
    getAdminServiceCreateWhitelistedDomainMutationOptions(options);

  return createMutation(mutationOptions, queryClient);
};
/**
 * @summary RemoveWhitelistedDomain removes a domain from the whitelist list
 */
export const adminServiceRemoveWhitelistedDomain = (
  organization: string,
  domain: string,
) => {
  return httpClient<V1RemoveWhitelistedDomainResponse>({
    url: `/v1/organizations/${organization}/whitelisted/${domain}`,
    method: "DELETE",
  });
};

export const getAdminServiceRemoveWhitelistedDomainMutationOptions = <
  TError = RpcStatus,
  TContext = unknown,
>(options?: {
  mutation?: CreateMutationOptions<
    Awaited<ReturnType<typeof adminServiceRemoveWhitelistedDomain>>,
    TError,
    { organization: string; domain: string },
    TContext
  >;
}): CreateMutationOptions<
  Awaited<ReturnType<typeof adminServiceRemoveWhitelistedDomain>>,
  TError,
  { organization: string; domain: string },
  TContext
> => {
  const mutationKey = ["adminServiceRemoveWhitelistedDomain"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof adminServiceRemoveWhitelistedDomain>>,
    { organization: string; domain: string }
  > = (props) => {
    const { organization, domain } = props ?? {};

    return adminServiceRemoveWhitelistedDomain(organization, domain);
  };

  return { mutationFn, ...mutationOptions };
};

export type AdminServiceRemoveWhitelistedDomainMutationResult = NonNullable<
  Awaited<ReturnType<typeof adminServiceRemoveWhitelistedDomain>>
>;

export type AdminServiceRemoveWhitelistedDomainMutationError = RpcStatus;

/**
 * @summary RemoveWhitelistedDomain removes a domain from the whitelist list
 */
export const createAdminServiceRemoveWhitelistedDomain = <
  TError = RpcStatus,
  TContext = unknown,
>(
  options?: {
    mutation?: CreateMutationOptions<
      Awaited<ReturnType<typeof adminServiceRemoveWhitelistedDomain>>,
      TError,
      { organization: string; domain: string },
      TContext
    >;
  },
  queryClient?: QueryClient,
): CreateMutationResult<
  Awaited<ReturnType<typeof adminServiceRemoveWhitelistedDomain>>,
  TError,
  { organization: string; domain: string },
  TContext
> => {
  const mutationOptions =
    getAdminServiceRemoveWhitelistedDomainMutationOptions(options);

  return createMutation(mutationOptions, queryClient);
};
/**
 * @summary CreateAsset returns a one time signed URL using which any asset can be uploaded.
 */
export const adminServiceCreateAsset = (
  organizationName: string,
  adminServiceCreateAssetBody: AdminServiceCreateAssetBody,
  signal?: AbortSignal,
) => {
  return httpClient<V1CreateAssetResponse>({
    url: `/v1/organizations/${organizationName}/create_asset`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: adminServiceCreateAssetBody,
    signal,
  });
};

export const getAdminServiceCreateAssetMutationOptions = <
  TError = RpcStatus,
  TContext = unknown,
>(options?: {
  mutation?: CreateMutationOptions<
    Awaited<ReturnType<typeof adminServiceCreateAsset>>,
    TError,
    { organizationName: string; data: AdminServiceCreateAssetBody },
    TContext
  >;
}): CreateMutationOptions<
  Awaited<ReturnType<typeof adminServiceCreateAsset>>,
  TError,
  { organizationName: string; data: AdminServiceCreateAssetBody },
  TContext
> => {
  const mutationKey = ["adminServiceCreateAsset"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof adminServiceCreateAsset>>,
    { organizationName: string; data: AdminServiceCreateAssetBody }
  > = (props) => {
    const { organizationName, data } = props ?? {};

    return adminServiceCreateAsset(organizationName, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type AdminServiceCreateAssetMutationResult = NonNullable<
  Awaited<ReturnType<typeof adminServiceCreateAsset>>
>;
export type AdminServiceCreateAssetMutationBody = AdminServiceCreateAssetBody;
export type AdminServiceCreateAssetMutationError = RpcStatus;

/**
 * @summary CreateAsset returns a one time signed URL using which any asset can be uploaded.
 */
export const createAdminServiceCreateAsset = <
  TError = RpcStatus,
  TContext = unknown,
>(
  options?: {
    mutation?: CreateMutationOptions<
      Awaited<ReturnType<typeof adminServiceCreateAsset>>,
      TError,
      { organizationName: string; data: AdminServiceCreateAssetBody },
      TContext
    >;
  },
  queryClient?: QueryClient,
): CreateMutationResult<
  Awaited<ReturnType<typeof adminServiceCreateAsset>>,
  TError,
  { organizationName: string; data: AdminServiceCreateAssetBody },
  TContext
> => {
  const mutationOptions = getAdminServiceCreateAssetMutationOptions(options);

  return createMutation(mutationOptions, queryClient);
};
/**
 * @summary ListProjectsForOrganization lists all the projects currently available for given organizations.
 */
export const adminServiceListProjectsForOrganization = (
  organizationName: string,
  params?: AdminServiceListProjectsForOrganizationParams,
  signal?: AbortSignal,
) => {
  return httpClient<V1ListProjectsForOrganizationResponse>({
    url: `/v1/organizations/${organizationName}/projects`,
    method: "GET",
    params,
    signal,
  });
};

export const getAdminServiceListProjectsForOrganizationQueryKey = (
  organizationName: string,
  params?: AdminServiceListProjectsForOrganizationParams,
) => {
  return [
    `/v1/organizations/${organizationName}/projects`,
    ...(params ? [params] : []),
  ] as const;
};

export const getAdminServiceListProjectsForOrganizationQueryOptions = <
  TData = Awaited<ReturnType<typeof adminServiceListProjectsForOrganization>>,
  TError = RpcStatus,
>(
  organizationName: string,
  params?: AdminServiceListProjectsForOrganizationParams,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof adminServiceListProjectsForOrganization>>,
        TError,
        TData
      >
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getAdminServiceListProjectsForOrganizationQueryKey(
      organizationName,
      params,
    );

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof adminServiceListProjectsForOrganization>>
  > = ({ signal }) =>
    adminServiceListProjectsForOrganization(organizationName, params, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!organizationName,
    ...queryOptions,
  } as CreateQueryOptions<
    Awaited<ReturnType<typeof adminServiceListProjectsForOrganization>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type AdminServiceListProjectsForOrganizationQueryResult = NonNullable<
  Awaited<ReturnType<typeof adminServiceListProjectsForOrganization>>
>;
export type AdminServiceListProjectsForOrganizationQueryError = RpcStatus;

/**
 * @summary ListProjectsForOrganization lists all the projects currently available for given organizations.
 */

export function createAdminServiceListProjectsForOrganization<
  TData = Awaited<ReturnType<typeof adminServiceListProjectsForOrganization>>,
  TError = RpcStatus,
>(
  organizationName: string,
  params?: AdminServiceListProjectsForOrganizationParams,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof adminServiceListProjectsForOrganization>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): CreateQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getAdminServiceListProjectsForOrganizationQueryOptions(
    organizationName,
    params,
    options,
  );

  const query = createQuery(queryOptions, queryClient) as CreateQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary CreateProject creates a new project
 */
export const adminServiceCreateProject = (
  organizationName: string,
  adminServiceCreateProjectBody: AdminServiceCreateProjectBody,
  signal?: AbortSignal,
) => {
  return httpClient<V1CreateProjectResponse>({
    url: `/v1/organizations/${organizationName}/projects`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: adminServiceCreateProjectBody,
    signal,
  });
};

export const getAdminServiceCreateProjectMutationOptions = <
  TError = RpcStatus,
  TContext = unknown,
>(options?: {
  mutation?: CreateMutationOptions<
    Awaited<ReturnType<typeof adminServiceCreateProject>>,
    TError,
    { organizationName: string; data: AdminServiceCreateProjectBody },
    TContext
  >;
}): CreateMutationOptions<
  Awaited<ReturnType<typeof adminServiceCreateProject>>,
  TError,
  { organizationName: string; data: AdminServiceCreateProjectBody },
  TContext
> => {
  const mutationKey = ["adminServiceCreateProject"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof adminServiceCreateProject>>,
    { organizationName: string; data: AdminServiceCreateProjectBody }
  > = (props) => {
    const { organizationName, data } = props ?? {};

    return adminServiceCreateProject(organizationName, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type AdminServiceCreateProjectMutationResult = NonNullable<
  Awaited<ReturnType<typeof adminServiceCreateProject>>
>;
export type AdminServiceCreateProjectMutationBody =
  AdminServiceCreateProjectBody;
export type AdminServiceCreateProjectMutationError = RpcStatus;

/**
 * @summary CreateProject creates a new project
 */
export const createAdminServiceCreateProject = <
  TError = RpcStatus,
  TContext = unknown,
>(
  options?: {
    mutation?: CreateMutationOptions<
      Awaited<ReturnType<typeof adminServiceCreateProject>>,
      TError,
      { organizationName: string; data: AdminServiceCreateProjectBody },
      TContext
    >;
  },
  queryClient?: QueryClient,
): CreateMutationResult<
  Awaited<ReturnType<typeof adminServiceCreateProject>>,
  TError,
  { organizationName: string; data: AdminServiceCreateProjectBody },
  TContext
> => {
  const mutationOptions = getAdminServiceCreateProjectMutationOptions(options);

  return createMutation(mutationOptions, queryClient);
};
/**
 * @summary GetProject returns information about a specific project
 */
export const adminServiceGetProject = (
  organizationName: string,
  name: string,
  params?: AdminServiceGetProjectParams,
  signal?: AbortSignal,
) => {
  return httpClient<V1GetProjectResponse>({
    url: `/v1/organizations/${organizationName}/projects/${name}`,
    method: "GET",
    params,
    signal,
  });
};

export const getAdminServiceGetProjectQueryKey = (
  organizationName: string,
  name: string,
  params?: AdminServiceGetProjectParams,
) => {
  return [
    `/v1/organizations/${organizationName}/projects/${name}`,
    ...(params ? [params] : []),
  ] as const;
};

export const getAdminServiceGetProjectQueryOptions = <
  TData = Awaited<ReturnType<typeof adminServiceGetProject>>,
  TError = RpcStatus,
>(
  organizationName: string,
  name: string,
  params?: AdminServiceGetProjectParams,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof adminServiceGetProject>>,
        TError,
        TData
      >
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getAdminServiceGetProjectQueryKey(organizationName, name, params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof adminServiceGetProject>>
  > = ({ signal }) =>
    adminServiceGetProject(organizationName, name, params, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!(organizationName && name),
    ...queryOptions,
  } as CreateQueryOptions<
    Awaited<ReturnType<typeof adminServiceGetProject>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type AdminServiceGetProjectQueryResult = NonNullable<
  Awaited<ReturnType<typeof adminServiceGetProject>>
>;
export type AdminServiceGetProjectQueryError = RpcStatus;

/**
 * @summary GetProject returns information about a specific project
 */

export function createAdminServiceGetProject<
  TData = Awaited<ReturnType<typeof adminServiceGetProject>>,
  TError = RpcStatus,
>(
  organizationName: string,
  name: string,
  params?: AdminServiceGetProjectParams,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof adminServiceGetProject>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): CreateQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getAdminServiceGetProjectQueryOptions(
    organizationName,
    name,
    params,
    options,
  );

  const query = createQuery(queryOptions, queryClient) as CreateQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary DeleteProject deletes an project
 */
export const adminServiceDeleteProject = (
  organizationName: string,
  name: string,
) => {
  return httpClient<V1DeleteProjectResponse>({
    url: `/v1/organizations/${organizationName}/projects/${name}`,
    method: "DELETE",
  });
};

export const getAdminServiceDeleteProjectMutationOptions = <
  TError = RpcStatus,
  TContext = unknown,
>(options?: {
  mutation?: CreateMutationOptions<
    Awaited<ReturnType<typeof adminServiceDeleteProject>>,
    TError,
    { organizationName: string; name: string },
    TContext
  >;
}): CreateMutationOptions<
  Awaited<ReturnType<typeof adminServiceDeleteProject>>,
  TError,
  { organizationName: string; name: string },
  TContext
> => {
  const mutationKey = ["adminServiceDeleteProject"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof adminServiceDeleteProject>>,
    { organizationName: string; name: string }
  > = (props) => {
    const { organizationName, name } = props ?? {};

    return adminServiceDeleteProject(organizationName, name);
  };

  return { mutationFn, ...mutationOptions };
};

export type AdminServiceDeleteProjectMutationResult = NonNullable<
  Awaited<ReturnType<typeof adminServiceDeleteProject>>
>;

export type AdminServiceDeleteProjectMutationError = RpcStatus;

/**
 * @summary DeleteProject deletes an project
 */
export const createAdminServiceDeleteProject = <
  TError = RpcStatus,
  TContext = unknown,
>(
  options?: {
    mutation?: CreateMutationOptions<
      Awaited<ReturnType<typeof adminServiceDeleteProject>>,
      TError,
      { organizationName: string; name: string },
      TContext
    >;
  },
  queryClient?: QueryClient,
): CreateMutationResult<
  Awaited<ReturnType<typeof adminServiceDeleteProject>>,
  TError,
  { organizationName: string; name: string },
  TContext
> => {
  const mutationOptions = getAdminServiceDeleteProjectMutationOptions(options);

  return createMutation(mutationOptions, queryClient);
};
/**
 * @summary UpdateProject updates a project
 */
export const adminServiceUpdateProject = (
  organizationName: string,
  name: string,
  adminServiceUpdateProjectBody: AdminServiceUpdateProjectBody,
) => {
  return httpClient<V1UpdateProjectResponse>({
    url: `/v1/organizations/${organizationName}/projects/${name}`,
    method: "PATCH",
    headers: { "Content-Type": "application/json" },
    data: adminServiceUpdateProjectBody,
  });
};

export const getAdminServiceUpdateProjectMutationOptions = <
  TError = RpcStatus,
  TContext = unknown,
>(options?: {
  mutation?: CreateMutationOptions<
    Awaited<ReturnType<typeof adminServiceUpdateProject>>,
    TError,
    {
      organizationName: string;
      name: string;
      data: AdminServiceUpdateProjectBody;
    },
    TContext
  >;
}): CreateMutationOptions<
  Awaited<ReturnType<typeof adminServiceUpdateProject>>,
  TError,
  {
    organizationName: string;
    name: string;
    data: AdminServiceUpdateProjectBody;
  },
  TContext
> => {
  const mutationKey = ["adminServiceUpdateProject"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof adminServiceUpdateProject>>,
    {
      organizationName: string;
      name: string;
      data: AdminServiceUpdateProjectBody;
    }
  > = (props) => {
    const { organizationName, name, data } = props ?? {};

    return adminServiceUpdateProject(organizationName, name, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type AdminServiceUpdateProjectMutationResult = NonNullable<
  Awaited<ReturnType<typeof adminServiceUpdateProject>>
>;
export type AdminServiceUpdateProjectMutationBody =
  AdminServiceUpdateProjectBody;
export type AdminServiceUpdateProjectMutationError = RpcStatus;

/**
 * @summary UpdateProject updates a project
 */
export const createAdminServiceUpdateProject = <
  TError = RpcStatus,
  TContext = unknown,
>(
  options?: {
    mutation?: CreateMutationOptions<
      Awaited<ReturnType<typeof adminServiceUpdateProject>>,
      TError,
      {
        organizationName: string;
        name: string;
        data: AdminServiceUpdateProjectBody;
      },
      TContext
    >;
  },
  queryClient?: QueryClient,
): CreateMutationResult<
  Awaited<ReturnType<typeof adminServiceUpdateProject>>,
  TError,
  {
    organizationName: string;
    name: string;
    data: AdminServiceUpdateProjectBody;
  },
  TContext
> => {
  const mutationOptions = getAdminServiceUpdateProjectMutationOptions(options);

  return createMutation(mutationOptions, queryClient);
};
/**
 * @summary ListDeployments lists deployments for a project.
 */
export const adminServiceListDeployments = (
  organizationName: string,
  projectName: string,
  params?: AdminServiceListDeploymentsParams,
  signal?: AbortSignal,
) => {
  return httpClient<V1ListDeploymentsResponse>({
    url: `/v1/organizations/${organizationName}/projects/${projectName}/deployments`,
    method: "GET",
    params,
    signal,
  });
};

export const getAdminServiceListDeploymentsQueryKey = (
  organizationName: string,
  projectName: string,
  params?: AdminServiceListDeploymentsParams,
) => {
  return [
    `/v1/organizations/${organizationName}/projects/${projectName}/deployments`,
    ...(params ? [params] : []),
  ] as const;
};

export const getAdminServiceListDeploymentsQueryOptions = <
  TData = Awaited<ReturnType<typeof adminServiceListDeployments>>,
  TError = RpcStatus,
>(
  organizationName: string,
  projectName: string,
  params?: AdminServiceListDeploymentsParams,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof adminServiceListDeployments>>,
        TError,
        TData
      >
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getAdminServiceListDeploymentsQueryKey(
      organizationName,
      projectName,
      params,
    );

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof adminServiceListDeployments>>
  > = ({ signal }) =>
    adminServiceListDeployments(organizationName, projectName, params, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!(organizationName && projectName),
    ...queryOptions,
  } as CreateQueryOptions<
    Awaited<ReturnType<typeof adminServiceListDeployments>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type AdminServiceListDeploymentsQueryResult = NonNullable<
  Awaited<ReturnType<typeof adminServiceListDeployments>>
>;
export type AdminServiceListDeploymentsQueryError = RpcStatus;

/**
 * @summary ListDeployments lists deployments for a project.
 */

export function createAdminServiceListDeployments<
  TData = Awaited<ReturnType<typeof adminServiceListDeployments>>,
  TError = RpcStatus,
>(
  organizationName: string,
  projectName: string,
  params?: AdminServiceListDeploymentsParams,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof adminServiceListDeployments>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): CreateQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getAdminServiceListDeploymentsQueryOptions(
    organizationName,
    projectName,
    params,
    options,
  );

  const query = createQuery(queryOptions, queryClient) as CreateQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary CreateDeployment creates a new deployment for a project.
 */
export const adminServiceCreateDeployment = (
  organizationName: string,
  projectName: string,
  adminServiceCreateDeploymentBody: AdminServiceCreateDeploymentBody,
  signal?: AbortSignal,
) => {
  return httpClient<V1CreateDeploymentResponse>({
    url: `/v1/organizations/${organizationName}/projects/${projectName}/deployments`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: adminServiceCreateDeploymentBody,
    signal,
  });
};

export const getAdminServiceCreateDeploymentMutationOptions = <
  TError = RpcStatus,
  TContext = unknown,
>(options?: {
  mutation?: CreateMutationOptions<
    Awaited<ReturnType<typeof adminServiceCreateDeployment>>,
    TError,
    {
      organizationName: string;
      projectName: string;
      data: AdminServiceCreateDeploymentBody;
    },
    TContext
  >;
}): CreateMutationOptions<
  Awaited<ReturnType<typeof adminServiceCreateDeployment>>,
  TError,
  {
    organizationName: string;
    projectName: string;
    data: AdminServiceCreateDeploymentBody;
  },
  TContext
> => {
  const mutationKey = ["adminServiceCreateDeployment"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof adminServiceCreateDeployment>>,
    {
      organizationName: string;
      projectName: string;
      data: AdminServiceCreateDeploymentBody;
    }
  > = (props) => {
    const { organizationName, projectName, data } = props ?? {};

    return adminServiceCreateDeployment(organizationName, projectName, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type AdminServiceCreateDeploymentMutationResult = NonNullable<
  Awaited<ReturnType<typeof adminServiceCreateDeployment>>
>;
export type AdminServiceCreateDeploymentMutationBody =
  AdminServiceCreateDeploymentBody;
export type AdminServiceCreateDeploymentMutationError = RpcStatus;

/**
 * @summary CreateDeployment creates a new deployment for a project.
 */
export const createAdminServiceCreateDeployment = <
  TError = RpcStatus,
  TContext = unknown,
>(
  options?: {
    mutation?: CreateMutationOptions<
      Awaited<ReturnType<typeof adminServiceCreateDeployment>>,
      TError,
      {
        organizationName: string;
        projectName: string;
        data: AdminServiceCreateDeploymentBody;
      },
      TContext
    >;
  },
  queryClient?: QueryClient,
): CreateMutationResult<
  Awaited<ReturnType<typeof adminServiceCreateDeployment>>,
  TError,
  {
    organizationName: string;
    projectName: string;
    data: AdminServiceCreateDeploymentBody;
  },
  TContext
> => {
  const mutationOptions =
    getAdminServiceCreateDeploymentMutationOptions(options);

  return createMutation(mutationOptions, queryClient);
};
/**
 * @summary ListProjectMemberServices returns all the services for the project for an organization
 */
export const adminServiceListProjectMemberServices = (
  organizationName: string,
  projectName: string,
  signal?: AbortSignal,
) => {
  return httpClient<V1ListProjectMemberServicesResponse>({
    url: `/v1/organizations/${organizationName}/projects/${projectName}/services`,
    method: "GET",
    signal,
  });
};

export const getAdminServiceListProjectMemberServicesQueryKey = (
  organizationName: string,
  projectName: string,
) => {
  return [
    `/v1/organizations/${organizationName}/projects/${projectName}/services`,
  ] as const;
};

export const getAdminServiceListProjectMemberServicesQueryOptions = <
  TData = Awaited<ReturnType<typeof adminServiceListProjectMemberServices>>,
  TError = RpcStatus,
>(
  organizationName: string,
  projectName: string,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof adminServiceListProjectMemberServices>>,
        TError,
        TData
      >
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getAdminServiceListProjectMemberServicesQueryKey(
      organizationName,
      projectName,
    );

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof adminServiceListProjectMemberServices>>
  > = ({ signal }) =>
    adminServiceListProjectMemberServices(
      organizationName,
      projectName,
      signal,
    );

  return {
    queryKey,
    queryFn,
    enabled: !!(organizationName && projectName),
    ...queryOptions,
  } as CreateQueryOptions<
    Awaited<ReturnType<typeof adminServiceListProjectMemberServices>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type AdminServiceListProjectMemberServicesQueryResult = NonNullable<
  Awaited<ReturnType<typeof adminServiceListProjectMemberServices>>
>;
export type AdminServiceListProjectMemberServicesQueryError = RpcStatus;

/**
 * @summary ListProjectMemberServices returns all the services for the project for an organization
 */

export function createAdminServiceListProjectMemberServices<
  TData = Awaited<ReturnType<typeof adminServiceListProjectMemberServices>>,
  TError = RpcStatus,
>(
  organizationName: string,
  projectName: string,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof adminServiceListProjectMemberServices>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): CreateQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getAdminServiceListProjectMemberServicesQueryOptions(
    organizationName,
    projectName,
    options,
  );

  const query = createQuery(queryOptions, queryClient) as CreateQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary RemoveProjectMemberService removes the service from the project
 */
export const adminServiceRemoveProjectMemberService = (
  organizationName: string,
  projectName: string,
  name: string,
) => {
  return httpClient<V1RemoveProjectMemberServiceResponse>({
    url: `/v1/organizations/${organizationName}/projects/${projectName}/services/${name}`,
    method: "DELETE",
  });
};

export const getAdminServiceRemoveProjectMemberServiceMutationOptions = <
  TError = RpcStatus,
  TContext = unknown,
>(options?: {
  mutation?: CreateMutationOptions<
    Awaited<ReturnType<typeof adminServiceRemoveProjectMemberService>>,
    TError,
    { organizationName: string; projectName: string; name: string },
    TContext
  >;
}): CreateMutationOptions<
  Awaited<ReturnType<typeof adminServiceRemoveProjectMemberService>>,
  TError,
  { organizationName: string; projectName: string; name: string },
  TContext
> => {
  const mutationKey = ["adminServiceRemoveProjectMemberService"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof adminServiceRemoveProjectMemberService>>,
    { organizationName: string; projectName: string; name: string }
  > = (props) => {
    const { organizationName, projectName, name } = props ?? {};

    return adminServiceRemoveProjectMemberService(
      organizationName,
      projectName,
      name,
    );
  };

  return { mutationFn, ...mutationOptions };
};

export type AdminServiceRemoveProjectMemberServiceMutationResult = NonNullable<
  Awaited<ReturnType<typeof adminServiceRemoveProjectMemberService>>
>;

export type AdminServiceRemoveProjectMemberServiceMutationError = RpcStatus;

/**
 * @summary RemoveProjectMemberService removes the service from the project
 */
export const createAdminServiceRemoveProjectMemberService = <
  TError = RpcStatus,
  TContext = unknown,
>(
  options?: {
    mutation?: CreateMutationOptions<
      Awaited<ReturnType<typeof adminServiceRemoveProjectMemberService>>,
      TError,
      { organizationName: string; projectName: string; name: string },
      TContext
    >;
  },
  queryClient?: QueryClient,
): CreateMutationResult<
  Awaited<ReturnType<typeof adminServiceRemoveProjectMemberService>>,
  TError,
  { organizationName: string; projectName: string; name: string },
  TContext
> => {
  const mutationOptions =
    getAdminServiceRemoveProjectMemberServiceMutationOptions(options);

  return createMutation(mutationOptions, queryClient);
};
/**
 * @summary SetProjectMemberServiceRole updates the project role for the service
 */
export const adminServiceSetProjectMemberServiceRole = (
  organizationName: string,
  projectName: string,
  name: string,
  adminServiceSetProjectMemberUserRoleBodyBody: AdminServiceSetProjectMemberUserRoleBodyBody,
) => {
  return httpClient<V1SetProjectMemberServiceRoleResponse>({
    url: `/v1/organizations/${organizationName}/projects/${projectName}/services/${name}/role`,
    method: "PUT",
    headers: { "Content-Type": "application/json" },
    data: adminServiceSetProjectMemberUserRoleBodyBody,
  });
};

export const getAdminServiceSetProjectMemberServiceRoleMutationOptions = <
  TError = RpcStatus,
  TContext = unknown,
>(options?: {
  mutation?: CreateMutationOptions<
    Awaited<ReturnType<typeof adminServiceSetProjectMemberServiceRole>>,
    TError,
    {
      organizationName: string;
      projectName: string;
      name: string;
      data: AdminServiceSetProjectMemberUserRoleBodyBody;
    },
    TContext
  >;
}): CreateMutationOptions<
  Awaited<ReturnType<typeof adminServiceSetProjectMemberServiceRole>>,
  TError,
  {
    organizationName: string;
    projectName: string;
    name: string;
    data: AdminServiceSetProjectMemberUserRoleBodyBody;
  },
  TContext
> => {
  const mutationKey = ["adminServiceSetProjectMemberServiceRole"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof adminServiceSetProjectMemberServiceRole>>,
    {
      organizationName: string;
      projectName: string;
      name: string;
      data: AdminServiceSetProjectMemberUserRoleBodyBody;
    }
  > = (props) => {
    const { organizationName, projectName, name, data } = props ?? {};

    return adminServiceSetProjectMemberServiceRole(
      organizationName,
      projectName,
      name,
      data,
    );
  };

  return { mutationFn, ...mutationOptions };
};

export type AdminServiceSetProjectMemberServiceRoleMutationResult = NonNullable<
  Awaited<ReturnType<typeof adminServiceSetProjectMemberServiceRole>>
>;
export type AdminServiceSetProjectMemberServiceRoleMutationBody =
  AdminServiceSetProjectMemberUserRoleBodyBody;
export type AdminServiceSetProjectMemberServiceRoleMutationError = RpcStatus;

/**
 * @summary SetProjectMemberServiceRole updates the project role for the service
 */
export const createAdminServiceSetProjectMemberServiceRole = <
  TError = RpcStatus,
  TContext = unknown,
>(
  options?: {
    mutation?: CreateMutationOptions<
      Awaited<ReturnType<typeof adminServiceSetProjectMemberServiceRole>>,
      TError,
      {
        organizationName: string;
        projectName: string;
        name: string;
        data: AdminServiceSetProjectMemberUserRoleBodyBody;
      },
      TContext
    >;
  },
  queryClient?: QueryClient,
): CreateMutationResult<
  Awaited<ReturnType<typeof adminServiceSetProjectMemberServiceRole>>,
  TError,
  {
    organizationName: string;
    projectName: string;
    name: string;
    data: AdminServiceSetProjectMemberUserRoleBodyBody;
  },
  TContext
> => {
  const mutationOptions =
    getAdminServiceSetProjectMemberServiceRoleMutationOptions(options);

  return createMutation(mutationOptions, queryClient);
};
/**
 * @summary ListService returns all the services per organization
 */
export const adminServiceListServices = (
  organizationName: string,
  signal?: AbortSignal,
) => {
  return httpClient<V1ListServicesResponse>({
    url: `/v1/organizations/${organizationName}/services`,
    method: "GET",
    signal,
  });
};

export const getAdminServiceListServicesQueryKey = (
  organizationName: string,
) => {
  return [`/v1/organizations/${organizationName}/services`] as const;
};

export const getAdminServiceListServicesQueryOptions = <
  TData = Awaited<ReturnType<typeof adminServiceListServices>>,
  TError = RpcStatus,
>(
  organizationName: string,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof adminServiceListServices>>,
        TError,
        TData
      >
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getAdminServiceListServicesQueryKey(organizationName);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof adminServiceListServices>>
  > = ({ signal }) => adminServiceListServices(organizationName, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!organizationName,
    ...queryOptions,
  } as CreateQueryOptions<
    Awaited<ReturnType<typeof adminServiceListServices>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type AdminServiceListServicesQueryResult = NonNullable<
  Awaited<ReturnType<typeof adminServiceListServices>>
>;
export type AdminServiceListServicesQueryError = RpcStatus;

/**
 * @summary ListService returns all the services per organization
 */

export function createAdminServiceListServices<
  TData = Awaited<ReturnType<typeof adminServiceListServices>>,
  TError = RpcStatus,
>(
  organizationName: string,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof adminServiceListServices>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): CreateQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getAdminServiceListServicesQueryOptions(
    organizationName,
    options,
  );

  const query = createQuery(queryOptions, queryClient) as CreateQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary CreateService creates a new service per organization
 */
export const adminServiceCreateService = (
  organizationName: string,
  adminServiceCreateServiceBody: AdminServiceCreateServiceBody,
  signal?: AbortSignal,
) => {
  return httpClient<V1CreateServiceResponse>({
    url: `/v1/organizations/${organizationName}/services`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: adminServiceCreateServiceBody,
    signal,
  });
};

export const getAdminServiceCreateServiceMutationOptions = <
  TError = RpcStatus,
  TContext = unknown,
>(options?: {
  mutation?: CreateMutationOptions<
    Awaited<ReturnType<typeof adminServiceCreateService>>,
    TError,
    { organizationName: string; data: AdminServiceCreateServiceBody },
    TContext
  >;
}): CreateMutationOptions<
  Awaited<ReturnType<typeof adminServiceCreateService>>,
  TError,
  { organizationName: string; data: AdminServiceCreateServiceBody },
  TContext
> => {
  const mutationKey = ["adminServiceCreateService"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof adminServiceCreateService>>,
    { organizationName: string; data: AdminServiceCreateServiceBody }
  > = (props) => {
    const { organizationName, data } = props ?? {};

    return adminServiceCreateService(organizationName, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type AdminServiceCreateServiceMutationResult = NonNullable<
  Awaited<ReturnType<typeof adminServiceCreateService>>
>;
export type AdminServiceCreateServiceMutationBody =
  AdminServiceCreateServiceBody;
export type AdminServiceCreateServiceMutationError = RpcStatus;

/**
 * @summary CreateService creates a new service per organization
 */
export const createAdminServiceCreateService = <
  TError = RpcStatus,
  TContext = unknown,
>(
  options?: {
    mutation?: CreateMutationOptions<
      Awaited<ReturnType<typeof adminServiceCreateService>>,
      TError,
      { organizationName: string; data: AdminServiceCreateServiceBody },
      TContext
    >;
  },
  queryClient?: QueryClient,
): CreateMutationResult<
  Awaited<ReturnType<typeof adminServiceCreateService>>,
  TError,
  { organizationName: string; data: AdminServiceCreateServiceBody },
  TContext
> => {
  const mutationOptions = getAdminServiceCreateServiceMutationOptions(options);

  return createMutation(mutationOptions, queryClient);
};
/**
 * @summary GetService returns information about a specific service
 */
export const adminServiceGetService = (
  organizationName: string,
  name: string,
  signal?: AbortSignal,
) => {
  return httpClient<V1GetServiceResponse>({
    url: `/v1/organizations/${organizationName}/services/${name}`,
    method: "GET",
    signal,
  });
};

export const getAdminServiceGetServiceQueryKey = (
  organizationName: string,
  name: string,
) => {
  return [`/v1/organizations/${organizationName}/services/${name}`] as const;
};

export const getAdminServiceGetServiceQueryOptions = <
  TData = Awaited<ReturnType<typeof adminServiceGetService>>,
  TError = RpcStatus,
>(
  organizationName: string,
  name: string,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof adminServiceGetService>>,
        TError,
        TData
      >
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getAdminServiceGetServiceQueryKey(organizationName, name);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof adminServiceGetService>>
  > = ({ signal }) => adminServiceGetService(organizationName, name, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!(organizationName && name),
    ...queryOptions,
  } as CreateQueryOptions<
    Awaited<ReturnType<typeof adminServiceGetService>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type AdminServiceGetServiceQueryResult = NonNullable<
  Awaited<ReturnType<typeof adminServiceGetService>>
>;
export type AdminServiceGetServiceQueryError = RpcStatus;

/**
 * @summary GetService returns information about a specific service
 */

export function createAdminServiceGetService<
  TData = Awaited<ReturnType<typeof adminServiceGetService>>,
  TError = RpcStatus,
>(
  organizationName: string,
  name: string,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof adminServiceGetService>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): CreateQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getAdminServiceGetServiceQueryOptions(
    organizationName,
    name,
    options,
  );

  const query = createQuery(queryOptions, queryClient) as CreateQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary DeleteService deletes a service per organization
 */
export const adminServiceDeleteService = (
  organizationName: string,
  name: string,
) => {
  return httpClient<V1DeleteServiceResponse>({
    url: `/v1/organizations/${organizationName}/services/${name}`,
    method: "DELETE",
  });
};

export const getAdminServiceDeleteServiceMutationOptions = <
  TError = RpcStatus,
  TContext = unknown,
>(options?: {
  mutation?: CreateMutationOptions<
    Awaited<ReturnType<typeof adminServiceDeleteService>>,
    TError,
    { organizationName: string; name: string },
    TContext
  >;
}): CreateMutationOptions<
  Awaited<ReturnType<typeof adminServiceDeleteService>>,
  TError,
  { organizationName: string; name: string },
  TContext
> => {
  const mutationKey = ["adminServiceDeleteService"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof adminServiceDeleteService>>,
    { organizationName: string; name: string }
  > = (props) => {
    const { organizationName, name } = props ?? {};

    return adminServiceDeleteService(organizationName, name);
  };

  return { mutationFn, ...mutationOptions };
};

export type AdminServiceDeleteServiceMutationResult = NonNullable<
  Awaited<ReturnType<typeof adminServiceDeleteService>>
>;

export type AdminServiceDeleteServiceMutationError = RpcStatus;

/**
 * @summary DeleteService deletes a service per organization
 */
export const createAdminServiceDeleteService = <
  TError = RpcStatus,
  TContext = unknown,
>(
  options?: {
    mutation?: CreateMutationOptions<
      Awaited<ReturnType<typeof adminServiceDeleteService>>,
      TError,
      { organizationName: string; name: string },
      TContext
    >;
  },
  queryClient?: QueryClient,
): CreateMutationResult<
  Awaited<ReturnType<typeof adminServiceDeleteService>>,
  TError,
  { organizationName: string; name: string },
  TContext
> => {
  const mutationOptions = getAdminServiceDeleteServiceMutationOptions(options);

  return createMutation(mutationOptions, queryClient);
};
/**
 * @summary UpdateService updates a service per organization
 */
export const adminServiceUpdateService = (
  organizationName: string,
  name: string,
  adminServiceUpdateServiceBody: AdminServiceUpdateServiceBody,
) => {
  return httpClient<V1UpdateServiceResponse>({
    url: `/v1/organizations/${organizationName}/services/${name}`,
    method: "PATCH",
    headers: { "Content-Type": "application/json" },
    data: adminServiceUpdateServiceBody,
  });
};

export const getAdminServiceUpdateServiceMutationOptions = <
  TError = RpcStatus,
  TContext = unknown,
>(options?: {
  mutation?: CreateMutationOptions<
    Awaited<ReturnType<typeof adminServiceUpdateService>>,
    TError,
    {
      organizationName: string;
      name: string;
      data: AdminServiceUpdateServiceBody;
    },
    TContext
  >;
}): CreateMutationOptions<
  Awaited<ReturnType<typeof adminServiceUpdateService>>,
  TError,
  {
    organizationName: string;
    name: string;
    data: AdminServiceUpdateServiceBody;
  },
  TContext
> => {
  const mutationKey = ["adminServiceUpdateService"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof adminServiceUpdateService>>,
    {
      organizationName: string;
      name: string;
      data: AdminServiceUpdateServiceBody;
    }
  > = (props) => {
    const { organizationName, name, data } = props ?? {};

    return adminServiceUpdateService(organizationName, name, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type AdminServiceUpdateServiceMutationResult = NonNullable<
  Awaited<ReturnType<typeof adminServiceUpdateService>>
>;
export type AdminServiceUpdateServiceMutationBody =
  AdminServiceUpdateServiceBody;
export type AdminServiceUpdateServiceMutationError = RpcStatus;

/**
 * @summary UpdateService updates a service per organization
 */
export const createAdminServiceUpdateService = <
  TError = RpcStatus,
  TContext = unknown,
>(
  options?: {
    mutation?: CreateMutationOptions<
      Awaited<ReturnType<typeof adminServiceUpdateService>>,
      TError,
      {
        organizationName: string;
        name: string;
        data: AdminServiceUpdateServiceBody;
      },
      TContext
    >;
  },
  queryClient?: QueryClient,
): CreateMutationResult<
  Awaited<ReturnType<typeof adminServiceUpdateService>>,
  TError,
  {
    organizationName: string;
    name: string;
    data: AdminServiceUpdateServiceBody;
  },
  TContext
> => {
  const mutationOptions = getAdminServiceUpdateServiceMutationOptions(options);

  return createMutation(mutationOptions, queryClient);
};
/**
 * @summary RemoveOrganizationMemberService removes the organization role for the service
 */
export const adminServiceRemoveOrganizationMemberService = (
  organizationName: string,
  name: string,
) => {
  return httpClient<V1RemoveOrganizationMemberServiceResponse>({
    url: `/v1/organizations/${organizationName}/services/${name}/role`,
    method: "DELETE",
  });
};

export const getAdminServiceRemoveOrganizationMemberServiceMutationOptions = <
  TError = RpcStatus,
  TContext = unknown,
>(options?: {
  mutation?: CreateMutationOptions<
    Awaited<ReturnType<typeof adminServiceRemoveOrganizationMemberService>>,
    TError,
    { organizationName: string; name: string },
    TContext
  >;
}): CreateMutationOptions<
  Awaited<ReturnType<typeof adminServiceRemoveOrganizationMemberService>>,
  TError,
  { organizationName: string; name: string },
  TContext
> => {
  const mutationKey = ["adminServiceRemoveOrganizationMemberService"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof adminServiceRemoveOrganizationMemberService>>,
    { organizationName: string; name: string }
  > = (props) => {
    const { organizationName, name } = props ?? {};

    return adminServiceRemoveOrganizationMemberService(organizationName, name);
  };

  return { mutationFn, ...mutationOptions };
};

export type AdminServiceRemoveOrganizationMemberServiceMutationResult =
  NonNullable<
    Awaited<ReturnType<typeof adminServiceRemoveOrganizationMemberService>>
  >;

export type AdminServiceRemoveOrganizationMemberServiceMutationError =
  RpcStatus;

/**
 * @summary RemoveOrganizationMemberService removes the organization role for the service
 */
export const createAdminServiceRemoveOrganizationMemberService = <
  TError = RpcStatus,
  TContext = unknown,
>(
  options?: {
    mutation?: CreateMutationOptions<
      Awaited<ReturnType<typeof adminServiceRemoveOrganizationMemberService>>,
      TError,
      { organizationName: string; name: string },
      TContext
    >;
  },
  queryClient?: QueryClient,
): CreateMutationResult<
  Awaited<ReturnType<typeof adminServiceRemoveOrganizationMemberService>>,
  TError,
  { organizationName: string; name: string },
  TContext
> => {
  const mutationOptions =
    getAdminServiceRemoveOrganizationMemberServiceMutationOptions(options);

  return createMutation(mutationOptions, queryClient);
};
/**
 * @summary SetOrganizationMemberServiceRole sets or updates the role of the service in the organization
 */
export const adminServiceSetOrganizationMemberServiceRole = (
  organizationName: string,
  name: string,
  adminServiceSetProjectMemberUserRoleBodyBody: AdminServiceSetProjectMemberUserRoleBodyBody,
) => {
  return httpClient<V1SetOrganizationMemberServiceRoleResponse>({
    url: `/v1/organizations/${organizationName}/services/${name}/role`,
    method: "PUT",
    headers: { "Content-Type": "application/json" },
    data: adminServiceSetProjectMemberUserRoleBodyBody,
  });
};

export const getAdminServiceSetOrganizationMemberServiceRoleMutationOptions = <
  TError = RpcStatus,
  TContext = unknown,
>(options?: {
  mutation?: CreateMutationOptions<
    Awaited<ReturnType<typeof adminServiceSetOrganizationMemberServiceRole>>,
    TError,
    {
      organizationName: string;
      name: string;
      data: AdminServiceSetProjectMemberUserRoleBodyBody;
    },
    TContext
  >;
}): CreateMutationOptions<
  Awaited<ReturnType<typeof adminServiceSetOrganizationMemberServiceRole>>,
  TError,
  {
    organizationName: string;
    name: string;
    data: AdminServiceSetProjectMemberUserRoleBodyBody;
  },
  TContext
> => {
  const mutationKey = ["adminServiceSetOrganizationMemberServiceRole"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof adminServiceSetOrganizationMemberServiceRole>>,
    {
      organizationName: string;
      name: string;
      data: AdminServiceSetProjectMemberUserRoleBodyBody;
    }
  > = (props) => {
    const { organizationName, name, data } = props ?? {};

    return adminServiceSetOrganizationMemberServiceRole(
      organizationName,
      name,
      data,
    );
  };

  return { mutationFn, ...mutationOptions };
};

export type AdminServiceSetOrganizationMemberServiceRoleMutationResult =
  NonNullable<
    Awaited<ReturnType<typeof adminServiceSetOrganizationMemberServiceRole>>
  >;
export type AdminServiceSetOrganizationMemberServiceRoleMutationBody =
  AdminServiceSetProjectMemberUserRoleBodyBody;
export type AdminServiceSetOrganizationMemberServiceRoleMutationError =
  RpcStatus;

/**
 * @summary SetOrganizationMemberServiceRole sets or updates the role of the service in the organization
 */
export const createAdminServiceSetOrganizationMemberServiceRole = <
  TError = RpcStatus,
  TContext = unknown,
>(
  options?: {
    mutation?: CreateMutationOptions<
      Awaited<ReturnType<typeof adminServiceSetOrganizationMemberServiceRole>>,
      TError,
      {
        organizationName: string;
        name: string;
        data: AdminServiceSetProjectMemberUserRoleBodyBody;
      },
      TContext
    >;
  },
  queryClient?: QueryClient,
): CreateMutationResult<
  Awaited<ReturnType<typeof adminServiceSetOrganizationMemberServiceRole>>,
  TError,
  {
    organizationName: string;
    name: string;
    data: AdminServiceSetProjectMemberUserRoleBodyBody;
  },
  TContext
> => {
  const mutationOptions =
    getAdminServiceSetOrganizationMemberServiceRoleMutationOptions(options);

  return createMutation(mutationOptions, queryClient);
};
/**
 * @summary ListServiceAuthTokens lists all the service auth tokens
 */
export const adminServiceListServiceAuthTokens = (
  organizationName: string,
  serviceName: string,
  signal?: AbortSignal,
) => {
  return httpClient<V1ListServiceAuthTokensResponse>({
    url: `/v1/organizations/${organizationName}/services/${serviceName}/tokens`,
    method: "GET",
    signal,
  });
};

export const getAdminServiceListServiceAuthTokensQueryKey = (
  organizationName: string,
  serviceName: string,
) => {
  return [
    `/v1/organizations/${organizationName}/services/${serviceName}/tokens`,
  ] as const;
};

export const getAdminServiceListServiceAuthTokensQueryOptions = <
  TData = Awaited<ReturnType<typeof adminServiceListServiceAuthTokens>>,
  TError = RpcStatus,
>(
  organizationName: string,
  serviceName: string,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof adminServiceListServiceAuthTokens>>,
        TError,
        TData
      >
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getAdminServiceListServiceAuthTokensQueryKey(organizationName, serviceName);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof adminServiceListServiceAuthTokens>>
  > = ({ signal }) =>
    adminServiceListServiceAuthTokens(organizationName, serviceName, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!(organizationName && serviceName),
    ...queryOptions,
  } as CreateQueryOptions<
    Awaited<ReturnType<typeof adminServiceListServiceAuthTokens>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type AdminServiceListServiceAuthTokensQueryResult = NonNullable<
  Awaited<ReturnType<typeof adminServiceListServiceAuthTokens>>
>;
export type AdminServiceListServiceAuthTokensQueryError = RpcStatus;

/**
 * @summary ListServiceAuthTokens lists all the service auth tokens
 */

export function createAdminServiceListServiceAuthTokens<
  TData = Awaited<ReturnType<typeof adminServiceListServiceAuthTokens>>,
  TError = RpcStatus,
>(
  organizationName: string,
  serviceName: string,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof adminServiceListServiceAuthTokens>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): CreateQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getAdminServiceListServiceAuthTokensQueryOptions(
    organizationName,
    serviceName,
    options,
  );

  const query = createQuery(queryOptions, queryClient) as CreateQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary IssueServiceAuthToken issues an access token for a service
 */
export const adminServiceIssueServiceAuthToken = (
  organizationName: string,
  serviceName: string,
  adminServiceTriggerReconcileBodyBody: AdminServiceTriggerReconcileBodyBody,
  signal?: AbortSignal,
) => {
  return httpClient<V1IssueServiceAuthTokenResponse>({
    url: `/v1/organizations/${organizationName}/services/${serviceName}/tokens`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: adminServiceTriggerReconcileBodyBody,
    signal,
  });
};

export const getAdminServiceIssueServiceAuthTokenMutationOptions = <
  TError = RpcStatus,
  TContext = unknown,
>(options?: {
  mutation?: CreateMutationOptions<
    Awaited<ReturnType<typeof adminServiceIssueServiceAuthToken>>,
    TError,
    {
      organizationName: string;
      serviceName: string;
      data: AdminServiceTriggerReconcileBodyBody;
    },
    TContext
  >;
}): CreateMutationOptions<
  Awaited<ReturnType<typeof adminServiceIssueServiceAuthToken>>,
  TError,
  {
    organizationName: string;
    serviceName: string;
    data: AdminServiceTriggerReconcileBodyBody;
  },
  TContext
> => {
  const mutationKey = ["adminServiceIssueServiceAuthToken"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof adminServiceIssueServiceAuthToken>>,
    {
      organizationName: string;
      serviceName: string;
      data: AdminServiceTriggerReconcileBodyBody;
    }
  > = (props) => {
    const { organizationName, serviceName, data } = props ?? {};

    return adminServiceIssueServiceAuthToken(
      organizationName,
      serviceName,
      data,
    );
  };

  return { mutationFn, ...mutationOptions };
};

export type AdminServiceIssueServiceAuthTokenMutationResult = NonNullable<
  Awaited<ReturnType<typeof adminServiceIssueServiceAuthToken>>
>;
export type AdminServiceIssueServiceAuthTokenMutationBody =
  AdminServiceTriggerReconcileBodyBody;
export type AdminServiceIssueServiceAuthTokenMutationError = RpcStatus;

/**
 * @summary IssueServiceAuthToken issues an access token for a service
 */
export const createAdminServiceIssueServiceAuthToken = <
  TError = RpcStatus,
  TContext = unknown,
>(
  options?: {
    mutation?: CreateMutationOptions<
      Awaited<ReturnType<typeof adminServiceIssueServiceAuthToken>>,
      TError,
      {
        organizationName: string;
        serviceName: string;
        data: AdminServiceTriggerReconcileBodyBody;
      },
      TContext
    >;
  },
  queryClient?: QueryClient,
): CreateMutationResult<
  Awaited<ReturnType<typeof adminServiceIssueServiceAuthToken>>,
  TError,
  {
    organizationName: string;
    serviceName: string;
    data: AdminServiceTriggerReconcileBodyBody;
  },
  TContext
> => {
  const mutationOptions =
    getAdminServiceIssueServiceAuthTokenMutationOptions(options);

  return createMutation(mutationOptions, queryClient);
};
/**
 * @summary Ping returns information about the server
 */
export const adminServicePing = (signal?: AbortSignal) => {
  return httpClient<V1PingResponse>({ url: `/v1/ping`, method: "GET", signal });
};

export const getAdminServicePingQueryKey = () => {
  return [`/v1/ping`] as const;
};

export const getAdminServicePingQueryOptions = <
  TData = Awaited<ReturnType<typeof adminServicePing>>,
  TError = RpcStatus,
>(options?: {
  query?: Partial<
    CreateQueryOptions<
      Awaited<ReturnType<typeof adminServicePing>>,
      TError,
      TData
    >
  >;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getAdminServicePingQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof adminServicePing>>
  > = ({ signal }) => adminServicePing(signal);

  return { queryKey, queryFn, ...queryOptions } as CreateQueryOptions<
    Awaited<ReturnType<typeof adminServicePing>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type AdminServicePingQueryResult = NonNullable<
  Awaited<ReturnType<typeof adminServicePing>>
>;
export type AdminServicePingQueryError = RpcStatus;

/**
 * @summary Ping returns information about the server
 */

export function createAdminServicePing<
  TData = Awaited<ReturnType<typeof adminServicePing>>,
  TError = RpcStatus,
>(
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof adminServicePing>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): CreateQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getAdminServicePingQueryOptions(options);

  const query = createQuery(queryOptions, queryClient) as CreateQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const adminServiceGetProjectAccessRequest = (
  id: string,
  signal?: AbortSignal,
) => {
  return httpClient<V1GetProjectAccessRequestResponse>({
    url: `/v1/project-access-request/${id}`,
    method: "GET",
    signal,
  });
};

export const getAdminServiceGetProjectAccessRequestQueryKey = (id: string) => {
  return [`/v1/project-access-request/${id}`] as const;
};

export const getAdminServiceGetProjectAccessRequestQueryOptions = <
  TData = Awaited<ReturnType<typeof adminServiceGetProjectAccessRequest>>,
  TError = RpcStatus,
>(
  id: string,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof adminServiceGetProjectAccessRequest>>,
        TError,
        TData
      >
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getAdminServiceGetProjectAccessRequestQueryKey(id);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof adminServiceGetProjectAccessRequest>>
  > = ({ signal }) => adminServiceGetProjectAccessRequest(id, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!id,
    ...queryOptions,
  } as CreateQueryOptions<
    Awaited<ReturnType<typeof adminServiceGetProjectAccessRequest>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type AdminServiceGetProjectAccessRequestQueryResult = NonNullable<
  Awaited<ReturnType<typeof adminServiceGetProjectAccessRequest>>
>;
export type AdminServiceGetProjectAccessRequestQueryError = RpcStatus;

export function createAdminServiceGetProjectAccessRequest<
  TData = Awaited<ReturnType<typeof adminServiceGetProjectAccessRequest>>,
  TError = RpcStatus,
>(
  id: string,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof adminServiceGetProjectAccessRequest>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): CreateQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getAdminServiceGetProjectAccessRequestQueryOptions(
    id,
    options,
  );

  const query = createQuery(queryOptions, queryClient) as CreateQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const adminServiceApproveProjectAccess = (
  id: string,
  adminServiceSetProjectMemberUserRoleBodyBody: AdminServiceSetProjectMemberUserRoleBodyBody,
  signal?: AbortSignal,
) => {
  return httpClient<V1ApproveProjectAccessResponse>({
    url: `/v1/project-access-request/${id}/approve`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: adminServiceSetProjectMemberUserRoleBodyBody,
    signal,
  });
};

export const getAdminServiceApproveProjectAccessMutationOptions = <
  TError = RpcStatus,
  TContext = unknown,
>(options?: {
  mutation?: CreateMutationOptions<
    Awaited<ReturnType<typeof adminServiceApproveProjectAccess>>,
    TError,
    { id: string; data: AdminServiceSetProjectMemberUserRoleBodyBody },
    TContext
  >;
}): CreateMutationOptions<
  Awaited<ReturnType<typeof adminServiceApproveProjectAccess>>,
  TError,
  { id: string; data: AdminServiceSetProjectMemberUserRoleBodyBody },
  TContext
> => {
  const mutationKey = ["adminServiceApproveProjectAccess"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof adminServiceApproveProjectAccess>>,
    { id: string; data: AdminServiceSetProjectMemberUserRoleBodyBody }
  > = (props) => {
    const { id, data } = props ?? {};

    return adminServiceApproveProjectAccess(id, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type AdminServiceApproveProjectAccessMutationResult = NonNullable<
  Awaited<ReturnType<typeof adminServiceApproveProjectAccess>>
>;
export type AdminServiceApproveProjectAccessMutationBody =
  AdminServiceSetProjectMemberUserRoleBodyBody;
export type AdminServiceApproveProjectAccessMutationError = RpcStatus;

export const createAdminServiceApproveProjectAccess = <
  TError = RpcStatus,
  TContext = unknown,
>(
  options?: {
    mutation?: CreateMutationOptions<
      Awaited<ReturnType<typeof adminServiceApproveProjectAccess>>,
      TError,
      { id: string; data: AdminServiceSetProjectMemberUserRoleBodyBody },
      TContext
    >;
  },
  queryClient?: QueryClient,
): CreateMutationResult<
  Awaited<ReturnType<typeof adminServiceApproveProjectAccess>>,
  TError,
  { id: string; data: AdminServiceSetProjectMemberUserRoleBodyBody },
  TContext
> => {
  const mutationOptions =
    getAdminServiceApproveProjectAccessMutationOptions(options);

  return createMutation(mutationOptions, queryClient);
};
export const adminServiceDenyProjectAccess = (
  id: string,
  adminServiceTriggerReconcileBodyBody: AdminServiceTriggerReconcileBodyBody,
  signal?: AbortSignal,
) => {
  return httpClient<V1DenyProjectAccessResponse>({
    url: `/v1/project-access-request/${id}/deny`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: adminServiceTriggerReconcileBodyBody,
    signal,
  });
};

export const getAdminServiceDenyProjectAccessMutationOptions = <
  TError = RpcStatus,
  TContext = unknown,
>(options?: {
  mutation?: CreateMutationOptions<
    Awaited<ReturnType<typeof adminServiceDenyProjectAccess>>,
    TError,
    { id: string; data: AdminServiceTriggerReconcileBodyBody },
    TContext
  >;
}): CreateMutationOptions<
  Awaited<ReturnType<typeof adminServiceDenyProjectAccess>>,
  TError,
  { id: string; data: AdminServiceTriggerReconcileBodyBody },
  TContext
> => {
  const mutationKey = ["adminServiceDenyProjectAccess"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof adminServiceDenyProjectAccess>>,
    { id: string; data: AdminServiceTriggerReconcileBodyBody }
  > = (props) => {
    const { id, data } = props ?? {};

    return adminServiceDenyProjectAccess(id, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type AdminServiceDenyProjectAccessMutationResult = NonNullable<
  Awaited<ReturnType<typeof adminServiceDenyProjectAccess>>
>;
export type AdminServiceDenyProjectAccessMutationBody =
  AdminServiceTriggerReconcileBodyBody;
export type AdminServiceDenyProjectAccessMutationError = RpcStatus;

export const createAdminServiceDenyProjectAccess = <
  TError = RpcStatus,
  TContext = unknown,
>(
  options?: {
    mutation?: CreateMutationOptions<
      Awaited<ReturnType<typeof adminServiceDenyProjectAccess>>,
      TError,
      { id: string; data: AdminServiceTriggerReconcileBodyBody },
      TContext
    >;
  },
  queryClient?: QueryClient,
): CreateMutationResult<
  Awaited<ReturnType<typeof adminServiceDenyProjectAccess>>,
  TError,
  { id: string; data: AdminServiceTriggerReconcileBodyBody },
  TContext
> => {
  const mutationOptions =
    getAdminServiceDenyProjectAccessMutationOptions(options);

  return createMutation(mutationOptions, queryClient);
};
/**
 * @summary ListProjectsForUserByName returns projects matching a name accessible by the logged in user
 */
export const adminServiceListProjectsForUserByName = (
  params?: AdminServiceListProjectsForUserByNameParams,
  signal?: AbortSignal,
) => {
  return httpClient<V1ListProjectsForUserByNameResponse>({
    url: `/v1/projects`,
    method: "GET",
    params,
    signal,
  });
};

export const getAdminServiceListProjectsForUserByNameQueryKey = (
  params?: AdminServiceListProjectsForUserByNameParams,
) => {
  return [`/v1/projects`, ...(params ? [params] : [])] as const;
};

export const getAdminServiceListProjectsForUserByNameQueryOptions = <
  TData = Awaited<ReturnType<typeof adminServiceListProjectsForUserByName>>,
  TError = RpcStatus,
>(
  params?: AdminServiceListProjectsForUserByNameParams,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof adminServiceListProjectsForUserByName>>,
        TError,
        TData
      >
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getAdminServiceListProjectsForUserByNameQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof adminServiceListProjectsForUserByName>>
  > = ({ signal }) => adminServiceListProjectsForUserByName(params, signal);

  return { queryKey, queryFn, ...queryOptions } as CreateQueryOptions<
    Awaited<ReturnType<typeof adminServiceListProjectsForUserByName>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type AdminServiceListProjectsForUserByNameQueryResult = NonNullable<
  Awaited<ReturnType<typeof adminServiceListProjectsForUserByName>>
>;
export type AdminServiceListProjectsForUserByNameQueryError = RpcStatus;

/**
 * @summary ListProjectsForUserByName returns projects matching a name accessible by the logged in user
 */

export function createAdminServiceListProjectsForUserByName<
  TData = Awaited<ReturnType<typeof adminServiceListProjectsForUserByName>>,
  TError = RpcStatus,
>(
  params?: AdminServiceListProjectsForUserByNameParams,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof adminServiceListProjectsForUserByName>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): CreateQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getAdminServiceListProjectsForUserByNameQueryOptions(
    params,
    options,
  );

  const query = createQuery(queryOptions, queryClient) as CreateQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary ListProjectsForFingerprint lists all projects the current user has access to that match the provided local project details.
This can be used to produce a short list of cloud projects that are likely to have been deployed from a local project.
 */
export const adminServiceListProjectsForFingerprint = (
  params?: AdminServiceListProjectsForFingerprintParams,
  signal?: AbortSignal,
) => {
  return httpClient<V1ListProjectsForFingerprintResponse>({
    url: `/v1/projects-for-fingerprint`,
    method: "GET",
    params,
    signal,
  });
};

export const getAdminServiceListProjectsForFingerprintQueryKey = (
  params?: AdminServiceListProjectsForFingerprintParams,
) => {
  return [`/v1/projects-for-fingerprint`, ...(params ? [params] : [])] as const;
};

export const getAdminServiceListProjectsForFingerprintQueryOptions = <
  TData = Awaited<ReturnType<typeof adminServiceListProjectsForFingerprint>>,
  TError = RpcStatus,
>(
  params?: AdminServiceListProjectsForFingerprintParams,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof adminServiceListProjectsForFingerprint>>,
        TError,
        TData
      >
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getAdminServiceListProjectsForFingerprintQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof adminServiceListProjectsForFingerprint>>
  > = ({ signal }) => adminServiceListProjectsForFingerprint(params, signal);

  return { queryKey, queryFn, ...queryOptions } as CreateQueryOptions<
    Awaited<ReturnType<typeof adminServiceListProjectsForFingerprint>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type AdminServiceListProjectsForFingerprintQueryResult = NonNullable<
  Awaited<ReturnType<typeof adminServiceListProjectsForFingerprint>>
>;
export type AdminServiceListProjectsForFingerprintQueryError = RpcStatus;

/**
 * @summary ListProjectsForFingerprint lists all projects the current user has access to that match the provided local project details.
This can be used to produce a short list of cloud projects that are likely to have been deployed from a local project.
 */

export function createAdminServiceListProjectsForFingerprint<
  TData = Awaited<ReturnType<typeof adminServiceListProjectsForFingerprint>>,
  TError = RpcStatus,
>(
  params?: AdminServiceListProjectsForFingerprintParams,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof adminServiceListProjectsForFingerprint>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): CreateQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getAdminServiceListProjectsForFingerprintQueryOptions(
    params,
    options,
  );

  const query = createQuery(queryOptions, queryClient) as CreateQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary TriggerRedeploy is similar to RedeployProject.
DEPRECATED: Use RedeployProject instead.
 */
export const adminServiceTriggerRedeploy = (
  v1TriggerRedeployRequest: V1TriggerRedeployRequest,
  signal?: AbortSignal,
) => {
  return httpClient<V1TriggerRedeployResponse>({
    url: `/v1/projects/-/redeploy`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: v1TriggerRedeployRequest,
    signal,
  });
};

export const getAdminServiceTriggerRedeployMutationOptions = <
  TError = RpcStatus,
  TContext = unknown,
>(options?: {
  mutation?: CreateMutationOptions<
    Awaited<ReturnType<typeof adminServiceTriggerRedeploy>>,
    TError,
    { data: V1TriggerRedeployRequest },
    TContext
  >;
}): CreateMutationOptions<
  Awaited<ReturnType<typeof adminServiceTriggerRedeploy>>,
  TError,
  { data: V1TriggerRedeployRequest },
  TContext
> => {
  const mutationKey = ["adminServiceTriggerRedeploy"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof adminServiceTriggerRedeploy>>,
    { data: V1TriggerRedeployRequest }
  > = (props) => {
    const { data } = props ?? {};

    return adminServiceTriggerRedeploy(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type AdminServiceTriggerRedeployMutationResult = NonNullable<
  Awaited<ReturnType<typeof adminServiceTriggerRedeploy>>
>;
export type AdminServiceTriggerRedeployMutationBody = V1TriggerRedeployRequest;
export type AdminServiceTriggerRedeployMutationError = RpcStatus;

/**
 * @summary TriggerRedeploy is similar to RedeployProject.
DEPRECATED: Use RedeployProject instead.
 */
export const createAdminServiceTriggerRedeploy = <
  TError = RpcStatus,
  TContext = unknown,
>(
  options?: {
    mutation?: CreateMutationOptions<
      Awaited<ReturnType<typeof adminServiceTriggerRedeploy>>,
      TError,
      { data: V1TriggerRedeployRequest },
      TContext
    >;
  },
  queryClient?: QueryClient,
): CreateMutationResult<
  Awaited<ReturnType<typeof adminServiceTriggerRedeploy>>,
  TError,
  { data: V1TriggerRedeployRequest },
  TContext
> => {
  const mutationOptions =
    getAdminServiceTriggerRedeployMutationOptions(options);

  return createMutation(mutationOptions, queryClient);
};
/**
 * @summary GetProject returns information about a specific project
 */
export const adminServiceGetProjectByID = (
  id: string,
  signal?: AbortSignal,
) => {
  return httpClient<V1GetProjectByIDResponse>({
    url: `/v1/projects/${id}`,
    method: "GET",
    signal,
  });
};

export const getAdminServiceGetProjectByIDQueryKey = (id: string) => {
  return [`/v1/projects/${id}`] as const;
};

export const getAdminServiceGetProjectByIDQueryOptions = <
  TData = Awaited<ReturnType<typeof adminServiceGetProjectByID>>,
  TError = RpcStatus,
>(
  id: string,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof adminServiceGetProjectByID>>,
        TError,
        TData
      >
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getAdminServiceGetProjectByIDQueryKey(id);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof adminServiceGetProjectByID>>
  > = ({ signal }) => adminServiceGetProjectByID(id, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!id,
    ...queryOptions,
  } as CreateQueryOptions<
    Awaited<ReturnType<typeof adminServiceGetProjectByID>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type AdminServiceGetProjectByIDQueryResult = NonNullable<
  Awaited<ReturnType<typeof adminServiceGetProjectByID>>
>;
export type AdminServiceGetProjectByIDQueryError = RpcStatus;

/**
 * @summary GetProject returns information about a specific project
 */

export function createAdminServiceGetProjectByID<
  TData = Awaited<ReturnType<typeof adminServiceGetProjectByID>>,
  TError = RpcStatus,
>(
  id: string,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof adminServiceGetProjectByID>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): CreateQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getAdminServiceGetProjectByIDQueryOptions(id, options);

  const query = createQuery(queryOptions, queryClient) as CreateQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary GetAlertMeta returns metadata for checking an alert. It's currently only called by the alert reconciler in the runtime.
 */
export const adminServiceGetAlertMeta = (
  projectId: string,
  adminServiceGetAlertMetaBody: AdminServiceGetAlertMetaBody,
  signal?: AbortSignal,
) => {
  return httpClient<V1GetAlertMetaResponse>({
    url: `/v1/projects/${projectId}/alerts/meta`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: adminServiceGetAlertMetaBody,
    signal,
  });
};

export const getAdminServiceGetAlertMetaMutationOptions = <
  TError = RpcStatus,
  TContext = unknown,
>(options?: {
  mutation?: CreateMutationOptions<
    Awaited<ReturnType<typeof adminServiceGetAlertMeta>>,
    TError,
    { projectId: string; data: AdminServiceGetAlertMetaBody },
    TContext
  >;
}): CreateMutationOptions<
  Awaited<ReturnType<typeof adminServiceGetAlertMeta>>,
  TError,
  { projectId: string; data: AdminServiceGetAlertMetaBody },
  TContext
> => {
  const mutationKey = ["adminServiceGetAlertMeta"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof adminServiceGetAlertMeta>>,
    { projectId: string; data: AdminServiceGetAlertMetaBody }
  > = (props) => {
    const { projectId, data } = props ?? {};

    return adminServiceGetAlertMeta(projectId, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type AdminServiceGetAlertMetaMutationResult = NonNullable<
  Awaited<ReturnType<typeof adminServiceGetAlertMeta>>
>;
export type AdminServiceGetAlertMetaMutationBody = AdminServiceGetAlertMetaBody;
export type AdminServiceGetAlertMetaMutationError = RpcStatus;

/**
 * @summary GetAlertMeta returns metadata for checking an alert. It's currently only called by the alert reconciler in the runtime.
 */
export const createAdminServiceGetAlertMeta = <
  TError = RpcStatus,
  TContext = unknown,
>(
  options?: {
    mutation?: CreateMutationOptions<
      Awaited<ReturnType<typeof adminServiceGetAlertMeta>>,
      TError,
      { projectId: string; data: AdminServiceGetAlertMetaBody },
      TContext
    >;
  },
  queryClient?: QueryClient,
): CreateMutationResult<
  Awaited<ReturnType<typeof adminServiceGetAlertMeta>>,
  TError,
  { projectId: string; data: AdminServiceGetAlertMetaBody },
  TContext
> => {
  const mutationOptions = getAdminServiceGetAlertMetaMutationOptions(options);

  return createMutation(mutationOptions, queryClient);
};
/**
 * @summary GetRepoMeta returns credentials and other metadata for accessing a project's repo
 */
export const adminServiceGetRepoMeta = (
  projectId: string,
  signal?: AbortSignal,
) => {
  return httpClient<V1GetRepoMetaResponse>({
    url: `/v1/projects/${projectId}/repo/meta`,
    method: "GET",
    signal,
  });
};

export const getAdminServiceGetRepoMetaQueryKey = (projectId: string) => {
  return [`/v1/projects/${projectId}/repo/meta`] as const;
};

export const getAdminServiceGetRepoMetaQueryOptions = <
  TData = Awaited<ReturnType<typeof adminServiceGetRepoMeta>>,
  TError = RpcStatus,
>(
  projectId: string,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof adminServiceGetRepoMeta>>,
        TError,
        TData
      >
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getAdminServiceGetRepoMetaQueryKey(projectId);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof adminServiceGetRepoMeta>>
  > = ({ signal }) => adminServiceGetRepoMeta(projectId, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!projectId,
    ...queryOptions,
  } as CreateQueryOptions<
    Awaited<ReturnType<typeof adminServiceGetRepoMeta>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type AdminServiceGetRepoMetaQueryResult = NonNullable<
  Awaited<ReturnType<typeof adminServiceGetRepoMeta>>
>;
export type AdminServiceGetRepoMetaQueryError = RpcStatus;

/**
 * @summary GetRepoMeta returns credentials and other metadata for accessing a project's repo
 */

export function createAdminServiceGetRepoMeta<
  TData = Awaited<ReturnType<typeof adminServiceGetRepoMeta>>,
  TError = RpcStatus,
>(
  projectId: string,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof adminServiceGetRepoMeta>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): CreateQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getAdminServiceGetRepoMetaQueryOptions(
    projectId,
    options,
  );

  const query = createQuery(queryOptions, queryClient) as CreateQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary PullVirtualRepo fetches files from a project's virtual repo
 */
export const adminServicePullVirtualRepo = (
  projectId: string,
  params?: AdminServicePullVirtualRepoParams,
  signal?: AbortSignal,
) => {
  return httpClient<V1PullVirtualRepoResponse>({
    url: `/v1/projects/${projectId}/repo/virtual`,
    method: "GET",
    params,
    signal,
  });
};

export const getAdminServicePullVirtualRepoQueryKey = (
  projectId: string,
  params?: AdminServicePullVirtualRepoParams,
) => {
  return [
    `/v1/projects/${projectId}/repo/virtual`,
    ...(params ? [params] : []),
  ] as const;
};

export const getAdminServicePullVirtualRepoQueryOptions = <
  TData = Awaited<ReturnType<typeof adminServicePullVirtualRepo>>,
  TError = RpcStatus,
>(
  projectId: string,
  params?: AdminServicePullVirtualRepoParams,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof adminServicePullVirtualRepo>>,
        TError,
        TData
      >
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getAdminServicePullVirtualRepoQueryKey(projectId, params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof adminServicePullVirtualRepo>>
  > = ({ signal }) => adminServicePullVirtualRepo(projectId, params, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!projectId,
    ...queryOptions,
  } as CreateQueryOptions<
    Awaited<ReturnType<typeof adminServicePullVirtualRepo>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type AdminServicePullVirtualRepoQueryResult = NonNullable<
  Awaited<ReturnType<typeof adminServicePullVirtualRepo>>
>;
export type AdminServicePullVirtualRepoQueryError = RpcStatus;

/**
 * @summary PullVirtualRepo fetches files from a project's virtual repo
 */

export function createAdminServicePullVirtualRepo<
  TData = Awaited<ReturnType<typeof adminServicePullVirtualRepo>>,
  TError = RpcStatus,
>(
  projectId: string,
  params?: AdminServicePullVirtualRepoParams,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof adminServicePullVirtualRepo>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): CreateQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getAdminServicePullVirtualRepoQueryOptions(
    projectId,
    params,
    options,
  );

  const query = createQuery(queryOptions, queryClient) as CreateQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary GetReportMeta returns metadata for generating a report. It's currently only called by the report reconciler in the runtime.
 */
export const adminServiceGetReportMeta = (
  projectId: string,
  adminServiceGetReportMetaBody: AdminServiceGetReportMetaBody,
  signal?: AbortSignal,
) => {
  return httpClient<V1GetReportMetaResponse>({
    url: `/v1/projects/${projectId}/reports/meta`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: adminServiceGetReportMetaBody,
    signal,
  });
};

export const getAdminServiceGetReportMetaMutationOptions = <
  TError = RpcStatus,
  TContext = unknown,
>(options?: {
  mutation?: CreateMutationOptions<
    Awaited<ReturnType<typeof adminServiceGetReportMeta>>,
    TError,
    { projectId: string; data: AdminServiceGetReportMetaBody },
    TContext
  >;
}): CreateMutationOptions<
  Awaited<ReturnType<typeof adminServiceGetReportMeta>>,
  TError,
  { projectId: string; data: AdminServiceGetReportMetaBody },
  TContext
> => {
  const mutationKey = ["adminServiceGetReportMeta"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof adminServiceGetReportMeta>>,
    { projectId: string; data: AdminServiceGetReportMetaBody }
  > = (props) => {
    const { projectId, data } = props ?? {};

    return adminServiceGetReportMeta(projectId, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type AdminServiceGetReportMetaMutationResult = NonNullable<
  Awaited<ReturnType<typeof adminServiceGetReportMeta>>
>;
export type AdminServiceGetReportMetaMutationBody =
  AdminServiceGetReportMetaBody;
export type AdminServiceGetReportMetaMutationError = RpcStatus;

/**
 * @summary GetReportMeta returns metadata for generating a report. It's currently only called by the report reconciler in the runtime.
 */
export const createAdminServiceGetReportMeta = <
  TError = RpcStatus,
  TContext = unknown,
>(
  options?: {
    mutation?: CreateMutationOptions<
      Awaited<ReturnType<typeof adminServiceGetReportMeta>>,
      TError,
      { projectId: string; data: AdminServiceGetReportMetaBody },
      TContext
    >;
  },
  queryClient?: QueryClient,
): CreateMutationResult<
  Awaited<ReturnType<typeof adminServiceGetReportMeta>>,
  TError,
  { projectId: string; data: AdminServiceGetReportMetaBody },
  TContext
> => {
  const mutationOptions = getAdminServiceGetReportMetaMutationOptions(options);

  return createMutation(mutationOptions, queryClient);
};
/**
 * @summary ListRoles lists all the roles available for orgs and projects.
 */
export const adminServiceListRoles = (signal?: AbortSignal) => {
  return httpClient<V1ListRolesResponse>({
    url: `/v1/roles`,
    method: "GET",
    signal,
  });
};

export const getAdminServiceListRolesQueryKey = () => {
  return [`/v1/roles`] as const;
};

export const getAdminServiceListRolesQueryOptions = <
  TData = Awaited<ReturnType<typeof adminServiceListRoles>>,
  TError = RpcStatus,
>(options?: {
  query?: Partial<
    CreateQueryOptions<
      Awaited<ReturnType<typeof adminServiceListRoles>>,
      TError,
      TData
    >
  >;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getAdminServiceListRolesQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof adminServiceListRoles>>
  > = ({ signal }) => adminServiceListRoles(signal);

  return { queryKey, queryFn, ...queryOptions } as CreateQueryOptions<
    Awaited<ReturnType<typeof adminServiceListRoles>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type AdminServiceListRolesQueryResult = NonNullable<
  Awaited<ReturnType<typeof adminServiceListRoles>>
>;
export type AdminServiceListRolesQueryError = RpcStatus;

/**
 * @summary ListRoles lists all the roles available for orgs and projects.
 */

export function createAdminServiceListRoles<
  TData = Awaited<ReturnType<typeof adminServiceListRoles>>,
  TError = RpcStatus,
>(
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof adminServiceListRoles>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): CreateQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getAdminServiceListRolesQueryOptions(options);

  const query = createQuery(queryOptions, queryClient) as CreateQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary RevokeServiceAuthToken revoke a service's access token
 */
export const adminServiceRevokeServiceAuthToken = (tokenId: string) => {
  return httpClient<V1RevokeServiceAuthTokenResponse>({
    url: `/v1/services/tokens/${tokenId}`,
    method: "DELETE",
  });
};

export const getAdminServiceRevokeServiceAuthTokenMutationOptions = <
  TError = RpcStatus,
  TContext = unknown,
>(options?: {
  mutation?: CreateMutationOptions<
    Awaited<ReturnType<typeof adminServiceRevokeServiceAuthToken>>,
    TError,
    { tokenId: string },
    TContext
  >;
}): CreateMutationOptions<
  Awaited<ReturnType<typeof adminServiceRevokeServiceAuthToken>>,
  TError,
  { tokenId: string },
  TContext
> => {
  const mutationKey = ["adminServiceRevokeServiceAuthToken"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof adminServiceRevokeServiceAuthToken>>,
    { tokenId: string }
  > = (props) => {
    const { tokenId } = props ?? {};

    return adminServiceRevokeServiceAuthToken(tokenId);
  };

  return { mutationFn, ...mutationOptions };
};

export type AdminServiceRevokeServiceAuthTokenMutationResult = NonNullable<
  Awaited<ReturnType<typeof adminServiceRevokeServiceAuthToken>>
>;

export type AdminServiceRevokeServiceAuthTokenMutationError = RpcStatus;

/**
 * @summary RevokeServiceAuthToken revoke a service's access token
 */
export const createAdminServiceRevokeServiceAuthToken = <
  TError = RpcStatus,
  TContext = unknown,
>(
  options?: {
    mutation?: CreateMutationOptions<
      Awaited<ReturnType<typeof adminServiceRevokeServiceAuthToken>>,
      TError,
      { tokenId: string },
      TContext
    >;
  },
  queryClient?: QueryClient,
): CreateMutationResult<
  Awaited<ReturnType<typeof adminServiceRevokeServiceAuthToken>>,
  TError,
  { tokenId: string },
  TContext
> => {
  const mutationOptions =
    getAdminServiceRevokeServiceAuthTokenMutationOptions(options);

  return createMutation(mutationOptions, queryClient);
};
/**
 * @summary SudoTriggerBillingRepair triggers billing repair jobs for orgs that doesn't have billing info and puts them on trial
 */
export const adminServiceSudoTriggerBillingRepair = (
  v1SudoTriggerBillingRepairRequest: V1SudoTriggerBillingRepairRequest,
  signal?: AbortSignal,
) => {
  return httpClient<V1SudoTriggerBillingRepairResponse>({
    url: `/v1/superuser/billing/repair`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: v1SudoTriggerBillingRepairRequest,
    signal,
  });
};

export const getAdminServiceSudoTriggerBillingRepairMutationOptions = <
  TError = RpcStatus,
  TContext = unknown,
>(options?: {
  mutation?: CreateMutationOptions<
    Awaited<ReturnType<typeof adminServiceSudoTriggerBillingRepair>>,
    TError,
    { data: V1SudoTriggerBillingRepairRequest },
    TContext
  >;
}): CreateMutationOptions<
  Awaited<ReturnType<typeof adminServiceSudoTriggerBillingRepair>>,
  TError,
  { data: V1SudoTriggerBillingRepairRequest },
  TContext
> => {
  const mutationKey = ["adminServiceSudoTriggerBillingRepair"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof adminServiceSudoTriggerBillingRepair>>,
    { data: V1SudoTriggerBillingRepairRequest }
  > = (props) => {
    const { data } = props ?? {};

    return adminServiceSudoTriggerBillingRepair(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type AdminServiceSudoTriggerBillingRepairMutationResult = NonNullable<
  Awaited<ReturnType<typeof adminServiceSudoTriggerBillingRepair>>
>;
export type AdminServiceSudoTriggerBillingRepairMutationBody =
  V1SudoTriggerBillingRepairRequest;
export type AdminServiceSudoTriggerBillingRepairMutationError = RpcStatus;

/**
 * @summary SudoTriggerBillingRepair triggers billing repair jobs for orgs that doesn't have billing info and puts them on trial
 */
export const createAdminServiceSudoTriggerBillingRepair = <
  TError = RpcStatus,
  TContext = unknown,
>(
  options?: {
    mutation?: CreateMutationOptions<
      Awaited<ReturnType<typeof adminServiceSudoTriggerBillingRepair>>,
      TError,
      { data: V1SudoTriggerBillingRepairRequest },
      TContext
    >;
  },
  queryClient?: QueryClient,
): CreateMutationResult<
  Awaited<ReturnType<typeof adminServiceSudoTriggerBillingRepair>>,
  TError,
  { data: V1SudoTriggerBillingRepairRequest },
  TContext
> => {
  const mutationOptions =
    getAdminServiceSudoTriggerBillingRepairMutationOptions(options);

  return createMutation(mutationOptions, queryClient);
};
/**
 * @summary SudoIssueRuntimeManagerToken returns a runtime JWT with full manager permissions for a runtime.
 */
export const adminServiceSudoIssueRuntimeManagerToken = (
  v1SudoIssueRuntimeManagerTokenRequest: V1SudoIssueRuntimeManagerTokenRequest,
  signal?: AbortSignal,
) => {
  return httpClient<V1SudoIssueRuntimeManagerTokenResponse>({
    url: `/v1/superuser/deployments/manager-token`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: v1SudoIssueRuntimeManagerTokenRequest,
    signal,
  });
};

export const getAdminServiceSudoIssueRuntimeManagerTokenMutationOptions = <
  TError = RpcStatus,
  TContext = unknown,
>(options?: {
  mutation?: CreateMutationOptions<
    Awaited<ReturnType<typeof adminServiceSudoIssueRuntimeManagerToken>>,
    TError,
    { data: V1SudoIssueRuntimeManagerTokenRequest },
    TContext
  >;
}): CreateMutationOptions<
  Awaited<ReturnType<typeof adminServiceSudoIssueRuntimeManagerToken>>,
  TError,
  { data: V1SudoIssueRuntimeManagerTokenRequest },
  TContext
> => {
  const mutationKey = ["adminServiceSudoIssueRuntimeManagerToken"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof adminServiceSudoIssueRuntimeManagerToken>>,
    { data: V1SudoIssueRuntimeManagerTokenRequest }
  > = (props) => {
    const { data } = props ?? {};

    return adminServiceSudoIssueRuntimeManagerToken(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type AdminServiceSudoIssueRuntimeManagerTokenMutationResult =
  NonNullable<
    Awaited<ReturnType<typeof adminServiceSudoIssueRuntimeManagerToken>>
  >;
export type AdminServiceSudoIssueRuntimeManagerTokenMutationBody =
  V1SudoIssueRuntimeManagerTokenRequest;
export type AdminServiceSudoIssueRuntimeManagerTokenMutationError = RpcStatus;

/**
 * @summary SudoIssueRuntimeManagerToken returns a runtime JWT with full manager permissions for a runtime.
 */
export const createAdminServiceSudoIssueRuntimeManagerToken = <
  TError = RpcStatus,
  TContext = unknown,
>(
  options?: {
    mutation?: CreateMutationOptions<
      Awaited<ReturnType<typeof adminServiceSudoIssueRuntimeManagerToken>>,
      TError,
      { data: V1SudoIssueRuntimeManagerTokenRequest },
      TContext
    >;
  },
  queryClient?: QueryClient,
): CreateMutationResult<
  Awaited<ReturnType<typeof adminServiceSudoIssueRuntimeManagerToken>>,
  TError,
  { data: V1SudoIssueRuntimeManagerTokenRequest },
  TContext
> => {
  const mutationOptions =
    getAdminServiceSudoIssueRuntimeManagerTokenMutationOptions(options);

  return createMutation(mutationOptions, queryClient);
};
/**
 * @summary ListSuperusers lists all the superusers
 */
export const adminServiceListSuperusers = (signal?: AbortSignal) => {
  return httpClient<V1ListSuperusersResponse>({
    url: `/v1/superuser/members`,
    method: "GET",
    signal,
  });
};

export const getAdminServiceListSuperusersQueryKey = () => {
  return [`/v1/superuser/members`] as const;
};

export const getAdminServiceListSuperusersQueryOptions = <
  TData = Awaited<ReturnType<typeof adminServiceListSuperusers>>,
  TError = RpcStatus,
>(options?: {
  query?: Partial<
    CreateQueryOptions<
      Awaited<ReturnType<typeof adminServiceListSuperusers>>,
      TError,
      TData
    >
  >;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getAdminServiceListSuperusersQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof adminServiceListSuperusers>>
  > = ({ signal }) => adminServiceListSuperusers(signal);

  return { queryKey, queryFn, ...queryOptions } as CreateQueryOptions<
    Awaited<ReturnType<typeof adminServiceListSuperusers>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type AdminServiceListSuperusersQueryResult = NonNullable<
  Awaited<ReturnType<typeof adminServiceListSuperusers>>
>;
export type AdminServiceListSuperusersQueryError = RpcStatus;

/**
 * @summary ListSuperusers lists all the superusers
 */

export function createAdminServiceListSuperusers<
  TData = Awaited<ReturnType<typeof adminServiceListSuperusers>>,
  TError = RpcStatus,
>(
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof adminServiceListSuperusers>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): CreateQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getAdminServiceListSuperusersQueryOptions(options);

  const query = createQuery(queryOptions, queryClient) as CreateQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary SetSuperuser adds/remove a superuser
 */
export const adminServiceSetSuperuser = (
  v1SetSuperuserRequest: V1SetSuperuserRequest,
  signal?: AbortSignal,
) => {
  return httpClient<V1SetSuperuserResponse>({
    url: `/v1/superuser/members`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: v1SetSuperuserRequest,
    signal,
  });
};

export const getAdminServiceSetSuperuserMutationOptions = <
  TError = RpcStatus,
  TContext = unknown,
>(options?: {
  mutation?: CreateMutationOptions<
    Awaited<ReturnType<typeof adminServiceSetSuperuser>>,
    TError,
    { data: V1SetSuperuserRequest },
    TContext
  >;
}): CreateMutationOptions<
  Awaited<ReturnType<typeof adminServiceSetSuperuser>>,
  TError,
  { data: V1SetSuperuserRequest },
  TContext
> => {
  const mutationKey = ["adminServiceSetSuperuser"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof adminServiceSetSuperuser>>,
    { data: V1SetSuperuserRequest }
  > = (props) => {
    const { data } = props ?? {};

    return adminServiceSetSuperuser(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type AdminServiceSetSuperuserMutationResult = NonNullable<
  Awaited<ReturnType<typeof adminServiceSetSuperuser>>
>;
export type AdminServiceSetSuperuserMutationBody = V1SetSuperuserRequest;
export type AdminServiceSetSuperuserMutationError = RpcStatus;

/**
 * @summary SetSuperuser adds/remove a superuser
 */
export const createAdminServiceSetSuperuser = <
  TError = RpcStatus,
  TContext = unknown,
>(
  options?: {
    mutation?: CreateMutationOptions<
      Awaited<ReturnType<typeof adminServiceSetSuperuser>>,
      TError,
      { data: V1SetSuperuserRequest },
      TContext
    >;
  },
  queryClient?: QueryClient,
): CreateMutationResult<
  Awaited<ReturnType<typeof adminServiceSetSuperuser>>,
  TError,
  { data: V1SetSuperuserRequest },
  TContext
> => {
  const mutationOptions = getAdminServiceSetSuperuserMutationOptions(options);

  return createMutation(mutationOptions, queryClient);
};
/**
 * @summary SudoUpdateOrganizationBillingCustomer update the billing customer for the organization
 */
export const adminServiceSudoUpdateOrganizationBillingCustomer = (
  v1SudoUpdateOrganizationBillingCustomerRequest: V1SudoUpdateOrganizationBillingCustomerRequest,
) => {
  return httpClient<V1SudoUpdateOrganizationBillingCustomerResponse>({
    url: `/v1/superuser/organization/billing/customer_id`,
    method: "PATCH",
    headers: { "Content-Type": "application/json" },
    data: v1SudoUpdateOrganizationBillingCustomerRequest,
  });
};

export const getAdminServiceSudoUpdateOrganizationBillingCustomerMutationOptions =
  <TError = RpcStatus, TContext = unknown>(options?: {
    mutation?: CreateMutationOptions<
      Awaited<
        ReturnType<typeof adminServiceSudoUpdateOrganizationBillingCustomer>
      >,
      TError,
      { data: V1SudoUpdateOrganizationBillingCustomerRequest },
      TContext
    >;
  }): CreateMutationOptions<
    Awaited<
      ReturnType<typeof adminServiceSudoUpdateOrganizationBillingCustomer>
    >,
    TError,
    { data: V1SudoUpdateOrganizationBillingCustomerRequest },
    TContext
  > => {
    const mutationKey = ["adminServiceSudoUpdateOrganizationBillingCustomer"];
    const { mutation: mutationOptions } = options
      ? options.mutation &&
        "mutationKey" in options.mutation &&
        options.mutation.mutationKey
        ? options
        : { ...options, mutation: { ...options.mutation, mutationKey } }
      : { mutation: { mutationKey } };

    const mutationFn: MutationFunction<
      Awaited<
        ReturnType<typeof adminServiceSudoUpdateOrganizationBillingCustomer>
      >,
      { data: V1SudoUpdateOrganizationBillingCustomerRequest }
    > = (props) => {
      const { data } = props ?? {};

      return adminServiceSudoUpdateOrganizationBillingCustomer(data);
    };

    return { mutationFn, ...mutationOptions };
  };

export type AdminServiceSudoUpdateOrganizationBillingCustomerMutationResult =
  NonNullable<
    Awaited<
      ReturnType<typeof adminServiceSudoUpdateOrganizationBillingCustomer>
    >
  >;
export type AdminServiceSudoUpdateOrganizationBillingCustomerMutationBody =
  V1SudoUpdateOrganizationBillingCustomerRequest;
export type AdminServiceSudoUpdateOrganizationBillingCustomerMutationError =
  RpcStatus;

/**
 * @summary SudoUpdateOrganizationBillingCustomer update the billing customer for the organization
 */
export const createAdminServiceSudoUpdateOrganizationBillingCustomer = <
  TError = RpcStatus,
  TContext = unknown,
>(
  options?: {
    mutation?: CreateMutationOptions<
      Awaited<
        ReturnType<typeof adminServiceSudoUpdateOrganizationBillingCustomer>
      >,
      TError,
      { data: V1SudoUpdateOrganizationBillingCustomerRequest },
      TContext
    >;
  },
  queryClient?: QueryClient,
): CreateMutationResult<
  Awaited<ReturnType<typeof adminServiceSudoUpdateOrganizationBillingCustomer>>,
  TError,
  { data: V1SudoUpdateOrganizationBillingCustomerRequest },
  TContext
> => {
  const mutationOptions =
    getAdminServiceSudoUpdateOrganizationBillingCustomerMutationOptions(
      options,
    );

  return createMutation(mutationOptions, queryClient);
};
/**
 * @summary SudoUpdateOrganizationCustomDomain updates the custom domain for an organization.
It only updates the custom domain in the database, which is used to ensure correct redirects.
The DNS records and ingress TLS must be configured separately.
 */
export const adminServiceSudoUpdateOrganizationCustomDomain = (
  v1SudoUpdateOrganizationCustomDomainRequest: V1SudoUpdateOrganizationCustomDomainRequest,
) => {
  return httpClient<V1SudoUpdateOrganizationCustomDomainResponse>({
    url: `/v1/superuser/organization/custom-domain`,
    method: "PATCH",
    headers: { "Content-Type": "application/json" },
    data: v1SudoUpdateOrganizationCustomDomainRequest,
  });
};

export const getAdminServiceSudoUpdateOrganizationCustomDomainMutationOptions =
  <TError = RpcStatus, TContext = unknown>(options?: {
    mutation?: CreateMutationOptions<
      Awaited<
        ReturnType<typeof adminServiceSudoUpdateOrganizationCustomDomain>
      >,
      TError,
      { data: V1SudoUpdateOrganizationCustomDomainRequest },
      TContext
    >;
  }): CreateMutationOptions<
    Awaited<ReturnType<typeof adminServiceSudoUpdateOrganizationCustomDomain>>,
    TError,
    { data: V1SudoUpdateOrganizationCustomDomainRequest },
    TContext
  > => {
    const mutationKey = ["adminServiceSudoUpdateOrganizationCustomDomain"];
    const { mutation: mutationOptions } = options
      ? options.mutation &&
        "mutationKey" in options.mutation &&
        options.mutation.mutationKey
        ? options
        : { ...options, mutation: { ...options.mutation, mutationKey } }
      : { mutation: { mutationKey } };

    const mutationFn: MutationFunction<
      Awaited<
        ReturnType<typeof adminServiceSudoUpdateOrganizationCustomDomain>
      >,
      { data: V1SudoUpdateOrganizationCustomDomainRequest }
    > = (props) => {
      const { data } = props ?? {};

      return adminServiceSudoUpdateOrganizationCustomDomain(data);
    };

    return { mutationFn, ...mutationOptions };
  };

export type AdminServiceSudoUpdateOrganizationCustomDomainMutationResult =
  NonNullable<
    Awaited<ReturnType<typeof adminServiceSudoUpdateOrganizationCustomDomain>>
  >;
export type AdminServiceSudoUpdateOrganizationCustomDomainMutationBody =
  V1SudoUpdateOrganizationCustomDomainRequest;
export type AdminServiceSudoUpdateOrganizationCustomDomainMutationError =
  RpcStatus;

/**
 * @summary SudoUpdateOrganizationCustomDomain updates the custom domain for an organization.
It only updates the custom domain in the database, which is used to ensure correct redirects.
The DNS records and ingress TLS must be configured separately.
 */
export const createAdminServiceSudoUpdateOrganizationCustomDomain = <
  TError = RpcStatus,
  TContext = unknown,
>(
  options?: {
    mutation?: CreateMutationOptions<
      Awaited<
        ReturnType<typeof adminServiceSudoUpdateOrganizationCustomDomain>
      >,
      TError,
      { data: V1SudoUpdateOrganizationCustomDomainRequest },
      TContext
    >;
  },
  queryClient?: QueryClient,
): CreateMutationResult<
  Awaited<ReturnType<typeof adminServiceSudoUpdateOrganizationCustomDomain>>,
  TError,
  { data: V1SudoUpdateOrganizationCustomDomainRequest },
  TContext
> => {
  const mutationOptions =
    getAdminServiceSudoUpdateOrganizationCustomDomainMutationOptions(options);

  return createMutation(mutationOptions, queryClient);
};
/**
 * @summary SudoExtendTrial extends the trial period for an organization
 */
export const adminServiceSudoExtendTrial = (
  v1SudoExtendTrialRequest: V1SudoExtendTrialRequest,
  signal?: AbortSignal,
) => {
  return httpClient<V1SudoExtendTrialResponse>({
    url: `/v1/superuser/organization/trial/extend`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: v1SudoExtendTrialRequest,
    signal,
  });
};

export const getAdminServiceSudoExtendTrialMutationOptions = <
  TError = RpcStatus,
  TContext = unknown,
>(options?: {
  mutation?: CreateMutationOptions<
    Awaited<ReturnType<typeof adminServiceSudoExtendTrial>>,
    TError,
    { data: V1SudoExtendTrialRequest },
    TContext
  >;
}): CreateMutationOptions<
  Awaited<ReturnType<typeof adminServiceSudoExtendTrial>>,
  TError,
  { data: V1SudoExtendTrialRequest },
  TContext
> => {
  const mutationKey = ["adminServiceSudoExtendTrial"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof adminServiceSudoExtendTrial>>,
    { data: V1SudoExtendTrialRequest }
  > = (props) => {
    const { data } = props ?? {};

    return adminServiceSudoExtendTrial(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type AdminServiceSudoExtendTrialMutationResult = NonNullable<
  Awaited<ReturnType<typeof adminServiceSudoExtendTrial>>
>;
export type AdminServiceSudoExtendTrialMutationBody = V1SudoExtendTrialRequest;
export type AdminServiceSudoExtendTrialMutationError = RpcStatus;

/**
 * @summary SudoExtendTrial extends the trial period for an organization
 */
export const createAdminServiceSudoExtendTrial = <
  TError = RpcStatus,
  TContext = unknown,
>(
  options?: {
    mutation?: CreateMutationOptions<
      Awaited<ReturnType<typeof adminServiceSudoExtendTrial>>,
      TError,
      { data: V1SudoExtendTrialRequest },
      TContext
    >;
  },
  queryClient?: QueryClient,
): CreateMutationResult<
  Awaited<ReturnType<typeof adminServiceSudoExtendTrial>>,
  TError,
  { data: V1SudoExtendTrialRequest },
  TContext
> => {
  const mutationOptions =
    getAdminServiceSudoExtendTrialMutationOptions(options);

  return createMutation(mutationOptions, queryClient);
};
/**
 * @summary SudoDeleteOrganizationBillingIssue deletes a billing issue of a type for the organization
 */
export const adminServiceSudoDeleteOrganizationBillingIssue = (
  organization: string,
  type:
    | "BILLING_ISSUE_TYPE_UNSPECIFIED"
    | "BILLING_ISSUE_TYPE_ON_TRIAL"
    | "BILLING_ISSUE_TYPE_TRIAL_ENDED"
    | "BILLING_ISSUE_TYPE_NO_PAYMENT_METHOD"
    | "BILLING_ISSUE_TYPE_NO_BILLABLE_ADDRESS"
    | "BILLING_ISSUE_TYPE_PAYMENT_FAILED"
    | "BILLING_ISSUE_TYPE_SUBSCRIPTION_CANCELLED"
    | "BILLING_ISSUE_TYPE_NEVER_SUBSCRIBED",
) => {
  return httpClient<V1SudoDeleteOrganizationBillingIssueResponse>({
    url: `/v1/superuser/organizations/${organization}/billing/issues/${type}`,
    method: "DELETE",
  });
};

export const getAdminServiceSudoDeleteOrganizationBillingIssueMutationOptions =
  <TError = RpcStatus, TContext = unknown>(options?: {
    mutation?: CreateMutationOptions<
      Awaited<
        ReturnType<typeof adminServiceSudoDeleteOrganizationBillingIssue>
      >,
      TError,
      {
        organization: string;
        type:
          | "BILLING_ISSUE_TYPE_UNSPECIFIED"
          | "BILLING_ISSUE_TYPE_ON_TRIAL"
          | "BILLING_ISSUE_TYPE_TRIAL_ENDED"
          | "BILLING_ISSUE_TYPE_NO_PAYMENT_METHOD"
          | "BILLING_ISSUE_TYPE_NO_BILLABLE_ADDRESS"
          | "BILLING_ISSUE_TYPE_PAYMENT_FAILED"
          | "BILLING_ISSUE_TYPE_SUBSCRIPTION_CANCELLED"
          | "BILLING_ISSUE_TYPE_NEVER_SUBSCRIBED";
      },
      TContext
    >;
  }): CreateMutationOptions<
    Awaited<ReturnType<typeof adminServiceSudoDeleteOrganizationBillingIssue>>,
    TError,
    {
      organization: string;
      type:
        | "BILLING_ISSUE_TYPE_UNSPECIFIED"
        | "BILLING_ISSUE_TYPE_ON_TRIAL"
        | "BILLING_ISSUE_TYPE_TRIAL_ENDED"
        | "BILLING_ISSUE_TYPE_NO_PAYMENT_METHOD"
        | "BILLING_ISSUE_TYPE_NO_BILLABLE_ADDRESS"
        | "BILLING_ISSUE_TYPE_PAYMENT_FAILED"
        | "BILLING_ISSUE_TYPE_SUBSCRIPTION_CANCELLED"
        | "BILLING_ISSUE_TYPE_NEVER_SUBSCRIBED";
    },
    TContext
  > => {
    const mutationKey = ["adminServiceSudoDeleteOrganizationBillingIssue"];
    const { mutation: mutationOptions } = options
      ? options.mutation &&
        "mutationKey" in options.mutation &&
        options.mutation.mutationKey
        ? options
        : { ...options, mutation: { ...options.mutation, mutationKey } }
      : { mutation: { mutationKey } };

    const mutationFn: MutationFunction<
      Awaited<
        ReturnType<typeof adminServiceSudoDeleteOrganizationBillingIssue>
      >,
      {
        organization: string;
        type:
          | "BILLING_ISSUE_TYPE_UNSPECIFIED"
          | "BILLING_ISSUE_TYPE_ON_TRIAL"
          | "BILLING_ISSUE_TYPE_TRIAL_ENDED"
          | "BILLING_ISSUE_TYPE_NO_PAYMENT_METHOD"
          | "BILLING_ISSUE_TYPE_NO_BILLABLE_ADDRESS"
          | "BILLING_ISSUE_TYPE_PAYMENT_FAILED"
          | "BILLING_ISSUE_TYPE_SUBSCRIPTION_CANCELLED"
          | "BILLING_ISSUE_TYPE_NEVER_SUBSCRIBED";
      }
    > = (props) => {
      const { organization, type } = props ?? {};

      return adminServiceSudoDeleteOrganizationBillingIssue(organization, type);
    };

    return { mutationFn, ...mutationOptions };
  };

export type AdminServiceSudoDeleteOrganizationBillingIssueMutationResult =
  NonNullable<
    Awaited<ReturnType<typeof adminServiceSudoDeleteOrganizationBillingIssue>>
  >;

export type AdminServiceSudoDeleteOrganizationBillingIssueMutationError =
  RpcStatus;

/**
 * @summary SudoDeleteOrganizationBillingIssue deletes a billing issue of a type for the organization
 */
export const createAdminServiceSudoDeleteOrganizationBillingIssue = <
  TError = RpcStatus,
  TContext = unknown,
>(
  options?: {
    mutation?: CreateMutationOptions<
      Awaited<
        ReturnType<typeof adminServiceSudoDeleteOrganizationBillingIssue>
      >,
      TError,
      {
        organization: string;
        type:
          | "BILLING_ISSUE_TYPE_UNSPECIFIED"
          | "BILLING_ISSUE_TYPE_ON_TRIAL"
          | "BILLING_ISSUE_TYPE_TRIAL_ENDED"
          | "BILLING_ISSUE_TYPE_NO_PAYMENT_METHOD"
          | "BILLING_ISSUE_TYPE_NO_BILLABLE_ADDRESS"
          | "BILLING_ISSUE_TYPE_PAYMENT_FAILED"
          | "BILLING_ISSUE_TYPE_SUBSCRIPTION_CANCELLED"
          | "BILLING_ISSUE_TYPE_NEVER_SUBSCRIBED";
      },
      TContext
    >;
  },
  queryClient?: QueryClient,
): CreateMutationResult<
  Awaited<ReturnType<typeof adminServiceSudoDeleteOrganizationBillingIssue>>,
  TError,
  {
    organization: string;
    type:
      | "BILLING_ISSUE_TYPE_UNSPECIFIED"
      | "BILLING_ISSUE_TYPE_ON_TRIAL"
      | "BILLING_ISSUE_TYPE_TRIAL_ENDED"
      | "BILLING_ISSUE_TYPE_NO_PAYMENT_METHOD"
      | "BILLING_ISSUE_TYPE_NO_BILLABLE_ADDRESS"
      | "BILLING_ISSUE_TYPE_PAYMENT_FAILED"
      | "BILLING_ISSUE_TYPE_SUBSCRIPTION_CANCELLED"
      | "BILLING_ISSUE_TYPE_NEVER_SUBSCRIBED";
  },
  TContext
> => {
  const mutationOptions =
    getAdminServiceSudoDeleteOrganizationBillingIssueMutationOptions(options);

  return createMutation(mutationOptions, queryClient);
};
/**
 * @summary SudoUpdateAnnotations endpoint for superusers to update project annotations
 */
export const adminServiceSudoUpdateAnnotations = (
  v1SudoUpdateAnnotationsRequest: V1SudoUpdateAnnotationsRequest,
) => {
  return httpClient<V1SudoUpdateAnnotationsResponse>({
    url: `/v1/superuser/projects/annotations`,
    method: "PATCH",
    headers: { "Content-Type": "application/json" },
    data: v1SudoUpdateAnnotationsRequest,
  });
};

export const getAdminServiceSudoUpdateAnnotationsMutationOptions = <
  TError = RpcStatus,
  TContext = unknown,
>(options?: {
  mutation?: CreateMutationOptions<
    Awaited<ReturnType<typeof adminServiceSudoUpdateAnnotations>>,
    TError,
    { data: V1SudoUpdateAnnotationsRequest },
    TContext
  >;
}): CreateMutationOptions<
  Awaited<ReturnType<typeof adminServiceSudoUpdateAnnotations>>,
  TError,
  { data: V1SudoUpdateAnnotationsRequest },
  TContext
> => {
  const mutationKey = ["adminServiceSudoUpdateAnnotations"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof adminServiceSudoUpdateAnnotations>>,
    { data: V1SudoUpdateAnnotationsRequest }
  > = (props) => {
    const { data } = props ?? {};

    return adminServiceSudoUpdateAnnotations(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type AdminServiceSudoUpdateAnnotationsMutationResult = NonNullable<
  Awaited<ReturnType<typeof adminServiceSudoUpdateAnnotations>>
>;
export type AdminServiceSudoUpdateAnnotationsMutationBody =
  V1SudoUpdateAnnotationsRequest;
export type AdminServiceSudoUpdateAnnotationsMutationError = RpcStatus;

/**
 * @summary SudoUpdateAnnotations endpoint for superusers to update project annotations
 */
export const createAdminServiceSudoUpdateAnnotations = <
  TError = RpcStatus,
  TContext = unknown,
>(
  options?: {
    mutation?: CreateMutationOptions<
      Awaited<ReturnType<typeof adminServiceSudoUpdateAnnotations>>,
      TError,
      { data: V1SudoUpdateAnnotationsRequest },
      TContext
    >;
  },
  queryClient?: QueryClient,
): CreateMutationResult<
  Awaited<ReturnType<typeof adminServiceSudoUpdateAnnotations>>,
  TError,
  { data: V1SudoUpdateAnnotationsRequest },
  TContext
> => {
  const mutationOptions =
    getAdminServiceSudoUpdateAnnotationsMutationOptions(options);

  return createMutation(mutationOptions, queryClient);
};
/**
 * @summary SearchProjectNames returns project names matching the pattern
 */
export const adminServiceSearchProjectNames = (
  params?: AdminServiceSearchProjectNamesParams,
  signal?: AbortSignal,
) => {
  return httpClient<V1SearchProjectNamesResponse>({
    url: `/v1/superuser/projects/search`,
    method: "GET",
    params,
    signal,
  });
};

export const getAdminServiceSearchProjectNamesQueryKey = (
  params?: AdminServiceSearchProjectNamesParams,
) => {
  return [
    `/v1/superuser/projects/search`,
    ...(params ? [params] : []),
  ] as const;
};

export const getAdminServiceSearchProjectNamesQueryOptions = <
  TData = Awaited<ReturnType<typeof adminServiceSearchProjectNames>>,
  TError = RpcStatus,
>(
  params?: AdminServiceSearchProjectNamesParams,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof adminServiceSearchProjectNames>>,
        TError,
        TData
      >
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getAdminServiceSearchProjectNamesQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof adminServiceSearchProjectNames>>
  > = ({ signal }) => adminServiceSearchProjectNames(params, signal);

  return { queryKey, queryFn, ...queryOptions } as CreateQueryOptions<
    Awaited<ReturnType<typeof adminServiceSearchProjectNames>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type AdminServiceSearchProjectNamesQueryResult = NonNullable<
  Awaited<ReturnType<typeof adminServiceSearchProjectNames>>
>;
export type AdminServiceSearchProjectNamesQueryError = RpcStatus;

/**
 * @summary SearchProjectNames returns project names matching the pattern
 */

export function createAdminServiceSearchProjectNames<
  TData = Awaited<ReturnType<typeof adminServiceSearchProjectNames>>,
  TError = RpcStatus,
>(
  params?: AdminServiceSearchProjectNamesParams,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof adminServiceSearchProjectNames>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): CreateQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getAdminServiceSearchProjectNamesQueryOptions(
    params,
    options,
  );

  const query = createQuery(queryOptions, queryClient) as CreateQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary SudoUpdateOrganizationQuotas update the quotas available for orgs
 */
export const adminServiceSudoUpdateOrganizationQuotas = (
  v1SudoUpdateOrganizationQuotasRequest: V1SudoUpdateOrganizationQuotasRequest,
) => {
  return httpClient<V1SudoUpdateOrganizationQuotasResponse>({
    url: `/v1/superuser/quotas/organization`,
    method: "PATCH",
    headers: { "Content-Type": "application/json" },
    data: v1SudoUpdateOrganizationQuotasRequest,
  });
};

export const getAdminServiceSudoUpdateOrganizationQuotasMutationOptions = <
  TError = RpcStatus,
  TContext = unknown,
>(options?: {
  mutation?: CreateMutationOptions<
    Awaited<ReturnType<typeof adminServiceSudoUpdateOrganizationQuotas>>,
    TError,
    { data: V1SudoUpdateOrganizationQuotasRequest },
    TContext
  >;
}): CreateMutationOptions<
  Awaited<ReturnType<typeof adminServiceSudoUpdateOrganizationQuotas>>,
  TError,
  { data: V1SudoUpdateOrganizationQuotasRequest },
  TContext
> => {
  const mutationKey = ["adminServiceSudoUpdateOrganizationQuotas"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof adminServiceSudoUpdateOrganizationQuotas>>,
    { data: V1SudoUpdateOrganizationQuotasRequest }
  > = (props) => {
    const { data } = props ?? {};

    return adminServiceSudoUpdateOrganizationQuotas(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type AdminServiceSudoUpdateOrganizationQuotasMutationResult =
  NonNullable<
    Awaited<ReturnType<typeof adminServiceSudoUpdateOrganizationQuotas>>
  >;
export type AdminServiceSudoUpdateOrganizationQuotasMutationBody =
  V1SudoUpdateOrganizationQuotasRequest;
export type AdminServiceSudoUpdateOrganizationQuotasMutationError = RpcStatus;

/**
 * @summary SudoUpdateOrganizationQuotas update the quotas available for orgs
 */
export const createAdminServiceSudoUpdateOrganizationQuotas = <
  TError = RpcStatus,
  TContext = unknown,
>(
  options?: {
    mutation?: CreateMutationOptions<
      Awaited<ReturnType<typeof adminServiceSudoUpdateOrganizationQuotas>>,
      TError,
      { data: V1SudoUpdateOrganizationQuotasRequest },
      TContext
    >;
  },
  queryClient?: QueryClient,
): CreateMutationResult<
  Awaited<ReturnType<typeof adminServiceSudoUpdateOrganizationQuotas>>,
  TError,
  { data: V1SudoUpdateOrganizationQuotasRequest },
  TContext
> => {
  const mutationOptions =
    getAdminServiceSudoUpdateOrganizationQuotasMutationOptions(options);

  return createMutation(mutationOptions, queryClient);
};
/**
 * @summary SudoUpdateUserQuotas update the quotas for users
 */
export const adminServiceSudoUpdateUserQuotas = (
  v1SudoUpdateUserQuotasRequest: V1SudoUpdateUserQuotasRequest,
) => {
  return httpClient<V1SudoUpdateUserQuotasResponse>({
    url: `/v1/superuser/quotas/user`,
    method: "PATCH",
    headers: { "Content-Type": "application/json" },
    data: v1SudoUpdateUserQuotasRequest,
  });
};

export const getAdminServiceSudoUpdateUserQuotasMutationOptions = <
  TError = RpcStatus,
  TContext = unknown,
>(options?: {
  mutation?: CreateMutationOptions<
    Awaited<ReturnType<typeof adminServiceSudoUpdateUserQuotas>>,
    TError,
    { data: V1SudoUpdateUserQuotasRequest },
    TContext
  >;
}): CreateMutationOptions<
  Awaited<ReturnType<typeof adminServiceSudoUpdateUserQuotas>>,
  TError,
  { data: V1SudoUpdateUserQuotasRequest },
  TContext
> => {
  const mutationKey = ["adminServiceSudoUpdateUserQuotas"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof adminServiceSudoUpdateUserQuotas>>,
    { data: V1SudoUpdateUserQuotasRequest }
  > = (props) => {
    const { data } = props ?? {};

    return adminServiceSudoUpdateUserQuotas(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type AdminServiceSudoUpdateUserQuotasMutationResult = NonNullable<
  Awaited<ReturnType<typeof adminServiceSudoUpdateUserQuotas>>
>;
export type AdminServiceSudoUpdateUserQuotasMutationBody =
  V1SudoUpdateUserQuotasRequest;
export type AdminServiceSudoUpdateUserQuotasMutationError = RpcStatus;

/**
 * @summary SudoUpdateUserQuotas update the quotas for users
 */
export const createAdminServiceSudoUpdateUserQuotas = <
  TError = RpcStatus,
  TContext = unknown,
>(
  options?: {
    mutation?: CreateMutationOptions<
      Awaited<ReturnType<typeof adminServiceSudoUpdateUserQuotas>>,
      TError,
      { data: V1SudoUpdateUserQuotasRequest },
      TContext
    >;
  },
  queryClient?: QueryClient,
): CreateMutationResult<
  Awaited<ReturnType<typeof adminServiceSudoUpdateUserQuotas>>,
  TError,
  { data: V1SudoUpdateUserQuotasRequest },
  TContext
> => {
  const mutationOptions =
    getAdminServiceSudoUpdateUserQuotasMutationOptions(options);

  return createMutation(mutationOptions, queryClient);
};
/**
 * @summary SudoGetResource returns details about a resource by ID lookup
 */
export const adminServiceSudoGetResource = (
  params?: AdminServiceSudoGetResourceParams,
  signal?: AbortSignal,
) => {
  return httpClient<V1SudoGetResourceResponse>({
    url: `/v1/superuser/resource`,
    method: "GET",
    params,
    signal,
  });
};

export const getAdminServiceSudoGetResourceQueryKey = (
  params?: AdminServiceSudoGetResourceParams,
) => {
  return [`/v1/superuser/resource`, ...(params ? [params] : [])] as const;
};

export const getAdminServiceSudoGetResourceQueryOptions = <
  TData = Awaited<ReturnType<typeof adminServiceSudoGetResource>>,
  TError = RpcStatus,
>(
  params?: AdminServiceSudoGetResourceParams,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof adminServiceSudoGetResource>>,
        TError,
        TData
      >
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getAdminServiceSudoGetResourceQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof adminServiceSudoGetResource>>
  > = ({ signal }) => adminServiceSudoGetResource(params, signal);

  return { queryKey, queryFn, ...queryOptions } as CreateQueryOptions<
    Awaited<ReturnType<typeof adminServiceSudoGetResource>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type AdminServiceSudoGetResourceQueryResult = NonNullable<
  Awaited<ReturnType<typeof adminServiceSudoGetResource>>
>;
export type AdminServiceSudoGetResourceQueryError = RpcStatus;

/**
 * @summary SudoGetResource returns details about a resource by ID lookup
 */

export function createAdminServiceSudoGetResource<
  TData = Awaited<ReturnType<typeof adminServiceSudoGetResource>>,
  TError = RpcStatus,
>(
  params?: AdminServiceSudoGetResourceParams,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof adminServiceSudoGetResource>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): CreateQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getAdminServiceSudoGetResourceQueryOptions(
    params,
    options,
  );

  const query = createQuery(queryOptions, queryClient) as CreateQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary RevokeCurrentAuthToken revoke the current auth token.
Deprecated: Use RevokeUserAuthToken with ID set to "current" instead.
 */
export const adminServiceRevokeCurrentAuthToken = () => {
  return httpClient<V1RevokeCurrentAuthTokenResponse>({
    url: `/v1/tokens/current`,
    method: "DELETE",
  });
};

export const getAdminServiceRevokeCurrentAuthTokenMutationOptions = <
  TError = RpcStatus,
  TContext = unknown,
>(options?: {
  mutation?: CreateMutationOptions<
    Awaited<ReturnType<typeof adminServiceRevokeCurrentAuthToken>>,
    TError,
    void,
    TContext
  >;
}): CreateMutationOptions<
  Awaited<ReturnType<typeof adminServiceRevokeCurrentAuthToken>>,
  TError,
  void,
  TContext
> => {
  const mutationKey = ["adminServiceRevokeCurrentAuthToken"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof adminServiceRevokeCurrentAuthToken>>,
    void
  > = () => {
    return adminServiceRevokeCurrentAuthToken();
  };

  return { mutationFn, ...mutationOptions };
};

export type AdminServiceRevokeCurrentAuthTokenMutationResult = NonNullable<
  Awaited<ReturnType<typeof adminServiceRevokeCurrentAuthToken>>
>;

export type AdminServiceRevokeCurrentAuthTokenMutationError = RpcStatus;

/**
 * @summary RevokeCurrentAuthToken revoke the current auth token.
Deprecated: Use RevokeUserAuthToken with ID set to "current" instead.
 */
export const createAdminServiceRevokeCurrentAuthToken = <
  TError = RpcStatus,
  TContext = unknown,
>(
  options?: {
    mutation?: CreateMutationOptions<
      Awaited<ReturnType<typeof adminServiceRevokeCurrentAuthToken>>,
      TError,
      void,
      TContext
    >;
  },
  queryClient?: QueryClient,
): CreateMutationResult<
  Awaited<ReturnType<typeof adminServiceRevokeCurrentAuthToken>>,
  TError,
  void,
  TContext
> => {
  const mutationOptions =
    getAdminServiceRevokeCurrentAuthTokenMutationOptions(options);

  return createMutation(mutationOptions, queryClient);
};
/**
 * @summary IssueRepresentativeAuthToken returns the temporary token for given email.
Deprecated: Use IssueUserAuthToken with the represent_email option instead.
 */
export const adminServiceIssueRepresentativeAuthToken = (
  v1IssueRepresentativeAuthTokenRequest: V1IssueRepresentativeAuthTokenRequest,
  signal?: AbortSignal,
) => {
  return httpClient<V1IssueRepresentativeAuthTokenResponse>({
    url: `/v1/tokens/represent`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: v1IssueRepresentativeAuthTokenRequest,
    signal,
  });
};

export const getAdminServiceIssueRepresentativeAuthTokenMutationOptions = <
  TError = RpcStatus,
  TContext = unknown,
>(options?: {
  mutation?: CreateMutationOptions<
    Awaited<ReturnType<typeof adminServiceIssueRepresentativeAuthToken>>,
    TError,
    { data: V1IssueRepresentativeAuthTokenRequest },
    TContext
  >;
}): CreateMutationOptions<
  Awaited<ReturnType<typeof adminServiceIssueRepresentativeAuthToken>>,
  TError,
  { data: V1IssueRepresentativeAuthTokenRequest },
  TContext
> => {
  const mutationKey = ["adminServiceIssueRepresentativeAuthToken"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof adminServiceIssueRepresentativeAuthToken>>,
    { data: V1IssueRepresentativeAuthTokenRequest }
  > = (props) => {
    const { data } = props ?? {};

    return adminServiceIssueRepresentativeAuthToken(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type AdminServiceIssueRepresentativeAuthTokenMutationResult =
  NonNullable<
    Awaited<ReturnType<typeof adminServiceIssueRepresentativeAuthToken>>
  >;
export type AdminServiceIssueRepresentativeAuthTokenMutationBody =
  V1IssueRepresentativeAuthTokenRequest;
export type AdminServiceIssueRepresentativeAuthTokenMutationError = RpcStatus;

/**
 * @summary IssueRepresentativeAuthToken returns the temporary token for given email.
Deprecated: Use IssueUserAuthToken with the represent_email option instead.
 */
export const createAdminServiceIssueRepresentativeAuthToken = <
  TError = RpcStatus,
  TContext = unknown,
>(
  options?: {
    mutation?: CreateMutationOptions<
      Awaited<ReturnType<typeof adminServiceIssueRepresentativeAuthToken>>,
      TError,
      { data: V1IssueRepresentativeAuthTokenRequest },
      TContext
    >;
  },
  queryClient?: QueryClient,
): CreateMutationResult<
  Awaited<ReturnType<typeof adminServiceIssueRepresentativeAuthToken>>,
  TError,
  { data: V1IssueRepresentativeAuthTokenRequest },
  TContext
> => {
  const mutationOptions =
    getAdminServiceIssueRepresentativeAuthTokenMutationOptions(options);

  return createMutation(mutationOptions, queryClient);
};
/**
 * @summary GetUser returns user by email
 */
export const adminServiceGetUser = (
  params?: AdminServiceGetUserParams,
  signal?: AbortSignal,
) => {
  return httpClient<V1GetUserResponse>({
    url: `/v1/users`,
    method: "GET",
    params,
    signal,
  });
};

export const getAdminServiceGetUserQueryKey = (
  params?: AdminServiceGetUserParams,
) => {
  return [`/v1/users`, ...(params ? [params] : [])] as const;
};

export const getAdminServiceGetUserQueryOptions = <
  TData = Awaited<ReturnType<typeof adminServiceGetUser>>,
  TError = RpcStatus,
>(
  params?: AdminServiceGetUserParams,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof adminServiceGetUser>>,
        TError,
        TData
      >
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getAdminServiceGetUserQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof adminServiceGetUser>>
  > = ({ signal }) => adminServiceGetUser(params, signal);

  return { queryKey, queryFn, ...queryOptions } as CreateQueryOptions<
    Awaited<ReturnType<typeof adminServiceGetUser>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type AdminServiceGetUserQueryResult = NonNullable<
  Awaited<ReturnType<typeof adminServiceGetUser>>
>;
export type AdminServiceGetUserQueryError = RpcStatus;

/**
 * @summary GetUser returns user by email
 */

export function createAdminServiceGetUser<
  TData = Awaited<ReturnType<typeof adminServiceGetUser>>,
  TError = RpcStatus,
>(
  params?: AdminServiceGetUserParams,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof adminServiceGetUser>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): CreateQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getAdminServiceGetUserQueryOptions(params, options);

  const query = createQuery(queryOptions, queryClient) as CreateQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary RevokeUserAuthToken revokes a user access token.
You can optionally pass "current" instead of the token ID to revoke the current token.
 */
export const adminServiceRevokeUserAuthToken = (
  tokenId: string,
  params?: AdminServiceRevokeUserAuthTokenParams,
) => {
  return httpClient<V1RevokeUserAuthTokenResponse>({
    url: `/v1/users/-/tokens/${tokenId}`,
    method: "DELETE",
    params,
  });
};

export const getAdminServiceRevokeUserAuthTokenMutationOptions = <
  TError = RpcStatus,
  TContext = unknown,
>(options?: {
  mutation?: CreateMutationOptions<
    Awaited<ReturnType<typeof adminServiceRevokeUserAuthToken>>,
    TError,
    { tokenId: string; params?: AdminServiceRevokeUserAuthTokenParams },
    TContext
  >;
}): CreateMutationOptions<
  Awaited<ReturnType<typeof adminServiceRevokeUserAuthToken>>,
  TError,
  { tokenId: string; params?: AdminServiceRevokeUserAuthTokenParams },
  TContext
> => {
  const mutationKey = ["adminServiceRevokeUserAuthToken"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof adminServiceRevokeUserAuthToken>>,
    { tokenId: string; params?: AdminServiceRevokeUserAuthTokenParams }
  > = (props) => {
    const { tokenId, params } = props ?? {};

    return adminServiceRevokeUserAuthToken(tokenId, params);
  };

  return { mutationFn, ...mutationOptions };
};

export type AdminServiceRevokeUserAuthTokenMutationResult = NonNullable<
  Awaited<ReturnType<typeof adminServiceRevokeUserAuthToken>>
>;

export type AdminServiceRevokeUserAuthTokenMutationError = RpcStatus;

/**
 * @summary RevokeUserAuthToken revokes a user access token.
You can optionally pass "current" instead of the token ID to revoke the current token.
 */
export const createAdminServiceRevokeUserAuthToken = <
  TError = RpcStatus,
  TContext = unknown,
>(
  options?: {
    mutation?: CreateMutationOptions<
      Awaited<ReturnType<typeof adminServiceRevokeUserAuthToken>>,
      TError,
      { tokenId: string; params?: AdminServiceRevokeUserAuthTokenParams },
      TContext
    >;
  },
  queryClient?: QueryClient,
): CreateMutationResult<
  Awaited<ReturnType<typeof adminServiceRevokeUserAuthToken>>,
  TError,
  { tokenId: string; params?: AdminServiceRevokeUserAuthTokenParams },
  TContext
> => {
  const mutationOptions =
    getAdminServiceRevokeUserAuthTokenMutationOptions(options);

  return createMutation(mutationOptions, queryClient);
};
/**
 * @summary DeleteUser deletes the user from the organization by email
 */
export const adminServiceDeleteUser = (
  email: string,
  params?: AdminServiceDeleteUserParams,
) => {
  return httpClient<V1DeleteUserResponse>({
    url: `/v1/users/${email}`,
    method: "DELETE",
    params,
  });
};

export const getAdminServiceDeleteUserMutationOptions = <
  TError = RpcStatus,
  TContext = unknown,
>(options?: {
  mutation?: CreateMutationOptions<
    Awaited<ReturnType<typeof adminServiceDeleteUser>>,
    TError,
    { email: string; params?: AdminServiceDeleteUserParams },
    TContext
  >;
}): CreateMutationOptions<
  Awaited<ReturnType<typeof adminServiceDeleteUser>>,
  TError,
  { email: string; params?: AdminServiceDeleteUserParams },
  TContext
> => {
  const mutationKey = ["adminServiceDeleteUser"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof adminServiceDeleteUser>>,
    { email: string; params?: AdminServiceDeleteUserParams }
  > = (props) => {
    const { email, params } = props ?? {};

    return adminServiceDeleteUser(email, params);
  };

  return { mutationFn, ...mutationOptions };
};

export type AdminServiceDeleteUserMutationResult = NonNullable<
  Awaited<ReturnType<typeof adminServiceDeleteUser>>
>;

export type AdminServiceDeleteUserMutationError = RpcStatus;

/**
 * @summary DeleteUser deletes the user from the organization by email
 */
export const createAdminServiceDeleteUser = <
  TError = RpcStatus,
  TContext = unknown,
>(
  options?: {
    mutation?: CreateMutationOptions<
      Awaited<ReturnType<typeof adminServiceDeleteUser>>,
      TError,
      { email: string; params?: AdminServiceDeleteUserParams },
      TContext
    >;
  },
  queryClient?: QueryClient,
): CreateMutationResult<
  Awaited<ReturnType<typeof adminServiceDeleteUser>>,
  TError,
  { email: string; params?: AdminServiceDeleteUserParams },
  TContext
> => {
  const mutationOptions = getAdminServiceDeleteUserMutationOptions(options);

  return createMutation(mutationOptions, queryClient);
};
/**
 * @summary ListUserAuthTokens lists the current user's auth tokens.
You can optionally pass "current" instead of the user ID to list the current user's tokens.
 */
export const adminServiceListUserAuthTokens = (
  userId: string,
  params?: AdminServiceListUserAuthTokensParams,
  signal?: AbortSignal,
) => {
  return httpClient<V1ListUserAuthTokensResponse>({
    url: `/v1/users/${userId}/tokens`,
    method: "GET",
    params,
    signal,
  });
};

export const getAdminServiceListUserAuthTokensQueryKey = (
  userId: string,
  params?: AdminServiceListUserAuthTokensParams,
) => {
  return [`/v1/users/${userId}/tokens`, ...(params ? [params] : [])] as const;
};

export const getAdminServiceListUserAuthTokensQueryOptions = <
  TData = Awaited<ReturnType<typeof adminServiceListUserAuthTokens>>,
  TError = RpcStatus,
>(
  userId: string,
  params?: AdminServiceListUserAuthTokensParams,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof adminServiceListUserAuthTokens>>,
        TError,
        TData
      >
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getAdminServiceListUserAuthTokensQueryKey(userId, params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof adminServiceListUserAuthTokens>>
  > = ({ signal }) => adminServiceListUserAuthTokens(userId, params, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!userId,
    ...queryOptions,
  } as CreateQueryOptions<
    Awaited<ReturnType<typeof adminServiceListUserAuthTokens>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type AdminServiceListUserAuthTokensQueryResult = NonNullable<
  Awaited<ReturnType<typeof adminServiceListUserAuthTokens>>
>;
export type AdminServiceListUserAuthTokensQueryError = RpcStatus;

/**
 * @summary ListUserAuthTokens lists the current user's auth tokens.
You can optionally pass "current" instead of the user ID to list the current user's tokens.
 */

export function createAdminServiceListUserAuthTokens<
  TData = Awaited<ReturnType<typeof adminServiceListUserAuthTokens>>,
  TError = RpcStatus,
>(
  userId: string,
  params?: AdminServiceListUserAuthTokensParams,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof adminServiceListUserAuthTokens>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): CreateQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getAdminServiceListUserAuthTokensQueryOptions(
    userId,
    params,
    options,
  );

  const query = createQuery(queryOptions, queryClient) as CreateQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary IssueUserAuthToken issues an access token for the current user.
You can optionally pass "current" instead of the user ID to issue a token for the current user.
 */
export const adminServiceIssueUserAuthToken = (
  userId: string,
  adminServiceIssueUserAuthTokenBody: AdminServiceIssueUserAuthTokenBody,
  signal?: AbortSignal,
) => {
  return httpClient<V1IssueUserAuthTokenResponse>({
    url: `/v1/users/${userId}/tokens`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: adminServiceIssueUserAuthTokenBody,
    signal,
  });
};

export const getAdminServiceIssueUserAuthTokenMutationOptions = <
  TError = RpcStatus,
  TContext = unknown,
>(options?: {
  mutation?: CreateMutationOptions<
    Awaited<ReturnType<typeof adminServiceIssueUserAuthToken>>,
    TError,
    { userId: string; data: AdminServiceIssueUserAuthTokenBody },
    TContext
  >;
}): CreateMutationOptions<
  Awaited<ReturnType<typeof adminServiceIssueUserAuthToken>>,
  TError,
  { userId: string; data: AdminServiceIssueUserAuthTokenBody },
  TContext
> => {
  const mutationKey = ["adminServiceIssueUserAuthToken"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof adminServiceIssueUserAuthToken>>,
    { userId: string; data: AdminServiceIssueUserAuthTokenBody }
  > = (props) => {
    const { userId, data } = props ?? {};

    return adminServiceIssueUserAuthToken(userId, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type AdminServiceIssueUserAuthTokenMutationResult = NonNullable<
  Awaited<ReturnType<typeof adminServiceIssueUserAuthToken>>
>;
export type AdminServiceIssueUserAuthTokenMutationBody =
  AdminServiceIssueUserAuthTokenBody;
export type AdminServiceIssueUserAuthTokenMutationError = RpcStatus;

/**
 * @summary IssueUserAuthToken issues an access token for the current user.
You can optionally pass "current" instead of the user ID to issue a token for the current user.
 */
export const createAdminServiceIssueUserAuthToken = <
  TError = RpcStatus,
  TContext = unknown,
>(
  options?: {
    mutation?: CreateMutationOptions<
      Awaited<ReturnType<typeof adminServiceIssueUserAuthToken>>,
      TError,
      { userId: string; data: AdminServiceIssueUserAuthTokenBody },
      TContext
    >;
  },
  queryClient?: QueryClient,
): CreateMutationResult<
  Awaited<ReturnType<typeof adminServiceIssueUserAuthToken>>,
  TError,
  { userId: string; data: AdminServiceIssueUserAuthTokenBody },
  TContext
> => {
  const mutationOptions =
    getAdminServiceIssueUserAuthTokenMutationOptions(options);

  return createMutation(mutationOptions, queryClient);
};
/**
 * @summary ListBookmarks lists all the bookmarks for the user and global ones for dashboard
 */
export const adminServiceListBookmarks = (
  params?: AdminServiceListBookmarksParams,
  signal?: AbortSignal,
) => {
  return httpClient<V1ListBookmarksResponse>({
    url: `/v1/users/bookmarks`,
    method: "GET",
    params,
    signal,
  });
};

export const getAdminServiceListBookmarksQueryKey = (
  params?: AdminServiceListBookmarksParams,
) => {
  return [`/v1/users/bookmarks`, ...(params ? [params] : [])] as const;
};

export const getAdminServiceListBookmarksQueryOptions = <
  TData = Awaited<ReturnType<typeof adminServiceListBookmarks>>,
  TError = RpcStatus,
>(
  params?: AdminServiceListBookmarksParams,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof adminServiceListBookmarks>>,
        TError,
        TData
      >
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getAdminServiceListBookmarksQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof adminServiceListBookmarks>>
  > = ({ signal }) => adminServiceListBookmarks(params, signal);

  return { queryKey, queryFn, ...queryOptions } as CreateQueryOptions<
    Awaited<ReturnType<typeof adminServiceListBookmarks>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type AdminServiceListBookmarksQueryResult = NonNullable<
  Awaited<ReturnType<typeof adminServiceListBookmarks>>
>;
export type AdminServiceListBookmarksQueryError = RpcStatus;

/**
 * @summary ListBookmarks lists all the bookmarks for the user and global ones for dashboard
 */

export function createAdminServiceListBookmarks<
  TData = Awaited<ReturnType<typeof adminServiceListBookmarks>>,
  TError = RpcStatus,
>(
  params?: AdminServiceListBookmarksParams,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof adminServiceListBookmarks>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): CreateQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getAdminServiceListBookmarksQueryOptions(
    params,
    options,
  );

  const query = createQuery(queryOptions, queryClient) as CreateQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary CreateBookmark creates a bookmark for the given user or for all users for the dashboard
 */
export const adminServiceCreateBookmark = (
  v1CreateBookmarkRequest: V1CreateBookmarkRequest,
  signal?: AbortSignal,
) => {
  return httpClient<V1CreateBookmarkResponse>({
    url: `/v1/users/bookmarks`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: v1CreateBookmarkRequest,
    signal,
  });
};

export const getAdminServiceCreateBookmarkMutationOptions = <
  TError = RpcStatus,
  TContext = unknown,
>(options?: {
  mutation?: CreateMutationOptions<
    Awaited<ReturnType<typeof adminServiceCreateBookmark>>,
    TError,
    { data: V1CreateBookmarkRequest },
    TContext
  >;
}): CreateMutationOptions<
  Awaited<ReturnType<typeof adminServiceCreateBookmark>>,
  TError,
  { data: V1CreateBookmarkRequest },
  TContext
> => {
  const mutationKey = ["adminServiceCreateBookmark"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof adminServiceCreateBookmark>>,
    { data: V1CreateBookmarkRequest }
  > = (props) => {
    const { data } = props ?? {};

    return adminServiceCreateBookmark(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type AdminServiceCreateBookmarkMutationResult = NonNullable<
  Awaited<ReturnType<typeof adminServiceCreateBookmark>>
>;
export type AdminServiceCreateBookmarkMutationBody = V1CreateBookmarkRequest;
export type AdminServiceCreateBookmarkMutationError = RpcStatus;

/**
 * @summary CreateBookmark creates a bookmark for the given user or for all users for the dashboard
 */
export const createAdminServiceCreateBookmark = <
  TError = RpcStatus,
  TContext = unknown,
>(
  options?: {
    mutation?: CreateMutationOptions<
      Awaited<ReturnType<typeof adminServiceCreateBookmark>>,
      TError,
      { data: V1CreateBookmarkRequest },
      TContext
    >;
  },
  queryClient?: QueryClient,
): CreateMutationResult<
  Awaited<ReturnType<typeof adminServiceCreateBookmark>>,
  TError,
  { data: V1CreateBookmarkRequest },
  TContext
> => {
  const mutationOptions = getAdminServiceCreateBookmarkMutationOptions(options);

  return createMutation(mutationOptions, queryClient);
};
/**
 * @summary UpdateBookmark updates a bookmark for the given user for the given project
 */
export const adminServiceUpdateBookmark = (
  v1UpdateBookmarkRequest: V1UpdateBookmarkRequest,
) => {
  return httpClient<V1UpdateBookmarkResponse>({
    url: `/v1/users/bookmarks`,
    method: "PUT",
    headers: { "Content-Type": "application/json" },
    data: v1UpdateBookmarkRequest,
  });
};

export const getAdminServiceUpdateBookmarkMutationOptions = <
  TError = RpcStatus,
  TContext = unknown,
>(options?: {
  mutation?: CreateMutationOptions<
    Awaited<ReturnType<typeof adminServiceUpdateBookmark>>,
    TError,
    { data: V1UpdateBookmarkRequest },
    TContext
  >;
}): CreateMutationOptions<
  Awaited<ReturnType<typeof adminServiceUpdateBookmark>>,
  TError,
  { data: V1UpdateBookmarkRequest },
  TContext
> => {
  const mutationKey = ["adminServiceUpdateBookmark"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof adminServiceUpdateBookmark>>,
    { data: V1UpdateBookmarkRequest }
  > = (props) => {
    const { data } = props ?? {};

    return adminServiceUpdateBookmark(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type AdminServiceUpdateBookmarkMutationResult = NonNullable<
  Awaited<ReturnType<typeof adminServiceUpdateBookmark>>
>;
export type AdminServiceUpdateBookmarkMutationBody = V1UpdateBookmarkRequest;
export type AdminServiceUpdateBookmarkMutationError = RpcStatus;

/**
 * @summary UpdateBookmark updates a bookmark for the given user for the given project
 */
export const createAdminServiceUpdateBookmark = <
  TError = RpcStatus,
  TContext = unknown,
>(
  options?: {
    mutation?: CreateMutationOptions<
      Awaited<ReturnType<typeof adminServiceUpdateBookmark>>,
      TError,
      { data: V1UpdateBookmarkRequest },
      TContext
    >;
  },
  queryClient?: QueryClient,
): CreateMutationResult<
  Awaited<ReturnType<typeof adminServiceUpdateBookmark>>,
  TError,
  { data: V1UpdateBookmarkRequest },
  TContext
> => {
  const mutationOptions = getAdminServiceUpdateBookmarkMutationOptions(options);

  return createMutation(mutationOptions, queryClient);
};
/**
 * @summary GetBookmark returns the bookmark for the given user for the given project
 */
export const adminServiceGetBookmark = (
  bookmarkId: string,
  signal?: AbortSignal,
) => {
  return httpClient<V1GetBookmarkResponse>({
    url: `/v1/users/bookmarks/${bookmarkId}`,
    method: "GET",
    signal,
  });
};

export const getAdminServiceGetBookmarkQueryKey = (bookmarkId: string) => {
  return [`/v1/users/bookmarks/${bookmarkId}`] as const;
};

export const getAdminServiceGetBookmarkQueryOptions = <
  TData = Awaited<ReturnType<typeof adminServiceGetBookmark>>,
  TError = RpcStatus,
>(
  bookmarkId: string,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof adminServiceGetBookmark>>,
        TError,
        TData
      >
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getAdminServiceGetBookmarkQueryKey(bookmarkId);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof adminServiceGetBookmark>>
  > = ({ signal }) => adminServiceGetBookmark(bookmarkId, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!bookmarkId,
    ...queryOptions,
  } as CreateQueryOptions<
    Awaited<ReturnType<typeof adminServiceGetBookmark>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type AdminServiceGetBookmarkQueryResult = NonNullable<
  Awaited<ReturnType<typeof adminServiceGetBookmark>>
>;
export type AdminServiceGetBookmarkQueryError = RpcStatus;

/**
 * @summary GetBookmark returns the bookmark for the given user for the given project
 */

export function createAdminServiceGetBookmark<
  TData = Awaited<ReturnType<typeof adminServiceGetBookmark>>,
  TError = RpcStatus,
>(
  bookmarkId: string,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof adminServiceGetBookmark>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): CreateQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getAdminServiceGetBookmarkQueryOptions(
    bookmarkId,
    options,
  );

  const query = createQuery(queryOptions, queryClient) as CreateQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary RemoveBookmark removes the bookmark for the given user or all users
 */
export const adminServiceRemoveBookmark = (bookmarkId: string) => {
  return httpClient<V1RemoveBookmarkResponse>({
    url: `/v1/users/bookmarks/${bookmarkId}`,
    method: "DELETE",
  });
};

export const getAdminServiceRemoveBookmarkMutationOptions = <
  TError = RpcStatus,
  TContext = unknown,
>(options?: {
  mutation?: CreateMutationOptions<
    Awaited<ReturnType<typeof adminServiceRemoveBookmark>>,
    TError,
    { bookmarkId: string },
    TContext
  >;
}): CreateMutationOptions<
  Awaited<ReturnType<typeof adminServiceRemoveBookmark>>,
  TError,
  { bookmarkId: string },
  TContext
> => {
  const mutationKey = ["adminServiceRemoveBookmark"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof adminServiceRemoveBookmark>>,
    { bookmarkId: string }
  > = (props) => {
    const { bookmarkId } = props ?? {};

    return adminServiceRemoveBookmark(bookmarkId);
  };

  return { mutationFn, ...mutationOptions };
};

export type AdminServiceRemoveBookmarkMutationResult = NonNullable<
  Awaited<ReturnType<typeof adminServiceRemoveBookmark>>
>;

export type AdminServiceRemoveBookmarkMutationError = RpcStatus;

/**
 * @summary RemoveBookmark removes the bookmark for the given user or all users
 */
export const createAdminServiceRemoveBookmark = <
  TError = RpcStatus,
  TContext = unknown,
>(
  options?: {
    mutation?: CreateMutationOptions<
      Awaited<ReturnType<typeof adminServiceRemoveBookmark>>,
      TError,
      { bookmarkId: string },
      TContext
    >;
  },
  queryClient?: QueryClient,
): CreateMutationResult<
  Awaited<ReturnType<typeof adminServiceRemoveBookmark>>,
  TError,
  { bookmarkId: string },
  TContext
> => {
  const mutationOptions = getAdminServiceRemoveBookmarkMutationOptions(options);

  return createMutation(mutationOptions, queryClient);
};
/**
 * @summary GetCurrentUser returns the currently authenticated user (if any)
 */
export const adminServiceGetCurrentUser = (signal?: AbortSignal) => {
  return httpClient<V1GetCurrentUserResponse>({
    url: `/v1/users/current`,
    method: "GET",
    signal,
  });
};

export const getAdminServiceGetCurrentUserQueryKey = () => {
  return [`/v1/users/current`] as const;
};

export const getAdminServiceGetCurrentUserQueryOptions = <
  TData = Awaited<ReturnType<typeof adminServiceGetCurrentUser>>,
  TError = RpcStatus,
>(options?: {
  query?: Partial<
    CreateQueryOptions<
      Awaited<ReturnType<typeof adminServiceGetCurrentUser>>,
      TError,
      TData
    >
  >;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getAdminServiceGetCurrentUserQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof adminServiceGetCurrentUser>>
  > = ({ signal }) => adminServiceGetCurrentUser(signal);

  return { queryKey, queryFn, ...queryOptions } as CreateQueryOptions<
    Awaited<ReturnType<typeof adminServiceGetCurrentUser>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type AdminServiceGetCurrentUserQueryResult = NonNullable<
  Awaited<ReturnType<typeof adminServiceGetCurrentUser>>
>;
export type AdminServiceGetCurrentUserQueryError = RpcStatus;

/**
 * @summary GetCurrentUser returns the currently authenticated user (if any)
 */

export function createAdminServiceGetCurrentUser<
  TData = Awaited<ReturnType<typeof adminServiceGetCurrentUser>>,
  TError = RpcStatus,
>(
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof adminServiceGetCurrentUser>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): CreateQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getAdminServiceGetCurrentUserQueryOptions(options);

  const query = createQuery(queryOptions, queryClient) as CreateQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary UpdateUserPreferences updates the preferences for the user
 */
export const adminServiceUpdateUserPreferences = (
  v1UpdateUserPreferencesRequest: V1UpdateUserPreferencesRequest,
) => {
  return httpClient<V1UpdateUserPreferencesResponse>({
    url: `/v1/users/preferences`,
    method: "PUT",
    headers: { "Content-Type": "application/json" },
    data: v1UpdateUserPreferencesRequest,
  });
};

export const getAdminServiceUpdateUserPreferencesMutationOptions = <
  TError = RpcStatus,
  TContext = unknown,
>(options?: {
  mutation?: CreateMutationOptions<
    Awaited<ReturnType<typeof adminServiceUpdateUserPreferences>>,
    TError,
    { data: V1UpdateUserPreferencesRequest },
    TContext
  >;
}): CreateMutationOptions<
  Awaited<ReturnType<typeof adminServiceUpdateUserPreferences>>,
  TError,
  { data: V1UpdateUserPreferencesRequest },
  TContext
> => {
  const mutationKey = ["adminServiceUpdateUserPreferences"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof adminServiceUpdateUserPreferences>>,
    { data: V1UpdateUserPreferencesRequest }
  > = (props) => {
    const { data } = props ?? {};

    return adminServiceUpdateUserPreferences(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type AdminServiceUpdateUserPreferencesMutationResult = NonNullable<
  Awaited<ReturnType<typeof adminServiceUpdateUserPreferences>>
>;
export type AdminServiceUpdateUserPreferencesMutationBody =
  V1UpdateUserPreferencesRequest;
export type AdminServiceUpdateUserPreferencesMutationError = RpcStatus;

/**
 * @summary UpdateUserPreferences updates the preferences for the user
 */
export const createAdminServiceUpdateUserPreferences = <
  TError = RpcStatus,
  TContext = unknown,
>(
  options?: {
    mutation?: CreateMutationOptions<
      Awaited<ReturnType<typeof adminServiceUpdateUserPreferences>>,
      TError,
      { data: V1UpdateUserPreferencesRequest },
      TContext
    >;
  },
  queryClient?: QueryClient,
): CreateMutationResult<
  Awaited<ReturnType<typeof adminServiceUpdateUserPreferences>>,
  TError,
  { data: V1UpdateUserPreferencesRequest },
  TContext
> => {
  const mutationOptions =
    getAdminServiceUpdateUserPreferencesMutationOptions(options);

  return createMutation(mutationOptions, queryClient);
};
/**
 * @summary GetUsersByEmail returns users by email
 */
export const adminServiceSearchUsers = (
  params?: AdminServiceSearchUsersParams,
  signal?: AbortSignal,
) => {
  return httpClient<V1SearchUsersResponse>({
    url: `/v1/users/search`,
    method: "GET",
    params,
    signal,
  });
};

export const getAdminServiceSearchUsersQueryKey = (
  params?: AdminServiceSearchUsersParams,
) => {
  return [`/v1/users/search`, ...(params ? [params] : [])] as const;
};

export const getAdminServiceSearchUsersQueryOptions = <
  TData = Awaited<ReturnType<typeof adminServiceSearchUsers>>,
  TError = RpcStatus,
>(
  params?: AdminServiceSearchUsersParams,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof adminServiceSearchUsers>>,
        TError,
        TData
      >
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getAdminServiceSearchUsersQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof adminServiceSearchUsers>>
  > = ({ signal }) => adminServiceSearchUsers(params, signal);

  return { queryKey, queryFn, ...queryOptions } as CreateQueryOptions<
    Awaited<ReturnType<typeof adminServiceSearchUsers>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type AdminServiceSearchUsersQueryResult = NonNullable<
  Awaited<ReturnType<typeof adminServiceSearchUsers>>
>;
export type AdminServiceSearchUsersQueryError = RpcStatus;

/**
 * @summary GetUsersByEmail returns users by email
 */

export function createAdminServiceSearchUsers<
  TData = Awaited<ReturnType<typeof adminServiceSearchUsers>>,
  TError = RpcStatus,
>(
  params?: AdminServiceSearchUsersParams,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof adminServiceSearchUsers>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): CreateQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getAdminServiceSearchUsersQueryOptions(params, options);

  const query = createQuery(queryOptions, queryClient) as CreateQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

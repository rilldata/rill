/**
 * Generated by orval v6.12.0 üç∫
 * Do not edit manually.
 * rill/admin/v1/ai.proto
 * OpenAPI spec version: version not set
 */
import { createQuery, createMutation } from "@tanstack/svelte-query";
import type {
  CreateQueryOptions,
  CreateMutationOptions,
  QueryFunction,
  MutationFunction,
  CreateQueryResult,
  QueryKey,
} from "@tanstack/svelte-query";
import type {
  V1ListPublicBillingPlansResponse,
  RpcStatus,
  V1TriggerReconcileResponse,
  AdminServiceTriggerReconcileBodyBody,
  V1TriggerRefreshSourcesResponse,
  AdminServiceTriggerRefreshSourcesBody,
  V1GetGithubRepoStatusResponse,
  AdminServiceGetGithubRepoStatusParams,
  V1GetGithubUserStatusResponse,
  V1ListGithubUserReposResponse,
  V1RevokeMagicAuthTokenResponse,
  V1GetCurrentMagicAuthTokenResponse,
  V1GetOrganizationNameForDomainResponse,
  V1ListOrganizationsResponse,
  AdminServiceListOrganizationsParams,
  V1CreateOrganizationResponse,
  V1CreateOrganizationRequest,
  V1GetOrganizationResponse,
  V1DeleteOrganizationResponse,
  V1UpdateOrganizationResponse,
  AdminServiceUpdateOrganizationBody,
  V1ListOrganizationBillingIssuesResponse,
  V1GetPaymentsPortalURLResponse,
  AdminServiceGetPaymentsPortalURLParams,
  V1GetBillingSubscriptionResponse,
  V1CancelBillingSubscriptionResponse,
  V1UpdateBillingSubscriptionResponse,
  AdminServiceUpdateBillingSubscriptionBodyBody,
  V1RenewBillingSubscriptionResponse,
  V1ListOrganizationInvitesResponse,
  AdminServiceListOrganizationInvitesParams,
  V1ListOrganizationMemberUsersResponse,
  AdminServiceListOrganizationMemberUsersParams,
  V1AddOrganizationMemberUserResponse,
  AdminServiceAddOrganizationMemberUserBody,
  V1RemoveOrganizationMemberUserResponse,
  AdminServiceRemoveOrganizationMemberUserParams,
  V1SetOrganizationMemberUserRoleResponse,
  AdminServiceSetOrganizationMemberUserRoleBodyBody,
  V1LeaveOrganizationResponse,
  V1ListProjectMemberUsergroupsResponse,
  AdminServiceListProjectMemberUsergroupsParams,
  V1CreateAlertResponse,
  AdminServiceCreateAlertBodyBody,
  V1GenerateAlertYAMLResponse,
  V1DeleteAlertResponse,
  V1EditAlertResponse,
  V1UnsubscribeAlertResponse,
  V1GetAlertYAMLResponse,
  V1GetCloneCredentialsResponse,
  V1ConnectProjectToGithubResponse,
  AdminServiceConnectProjectToGithubBody,
  V1GetDeploymentCredentialsResponse,
  AdminServiceGetDeploymentCredentialsBody,
  V1HibernateProjectResponse,
  V1GetIFrameResponse,
  AdminServiceGetIFrameBody,
  V1ListProjectInvitesResponse,
  AdminServiceListProjectInvitesParams,
  V1ListProjectMemberUsersResponse,
  AdminServiceListProjectMemberUsersParams,
  V1AddProjectMemberUserResponse,
  AdminServiceAddProjectMemberUserBody,
  V1RemoveProjectMemberUserResponse,
  V1SetProjectMemberUserRoleResponse,
  V1RedeployProjectResponse,
  V1CreateReportResponse,
  AdminServiceCreateReportBodyBody,
  V1GenerateReportYAMLResponse,
  V1DeleteReportResponse,
  V1EditReportResponse,
  V1TriggerReportResponse,
  V1UnsubscribeReportResponse,
  V1RequestProjectAccessResponse,
  V1ListMagicAuthTokensResponse,
  AdminServiceListMagicAuthTokensParams,
  V1IssueMagicAuthTokenResponse,
  AdminServiceIssueMagicAuthTokenBody,
  V1UploadProjectAssetsResponse,
  V1RemoveProjectMemberUsergroupResponse,
  V1AddProjectMemberUsergroupResponse,
  V1SetProjectMemberUsergroupRoleResponse,
  V1SearchProjectUsersResponse,
  AdminServiceSearchProjectUsersParams,
  V1GetProjectVariablesResponse,
  AdminServiceGetProjectVariablesParams,
  V1UpdateProjectVariablesResponse,
  AdminServiceUpdateProjectVariablesBody,
  V1ListProjectWhitelistedDomainsResponse,
  V1CreateProjectWhitelistedDomainResponse,
  AdminServiceCreateProjectWhitelistedDomainBodyBody,
  V1RemoveProjectWhitelistedDomainResponse,
  V1ListOrganizationMemberUsergroupsResponse,
  AdminServiceListOrganizationMemberUsergroupsParams,
  V1CreateUsergroupResponse,
  AdminServiceCreateUsergroupBodyBody,
  V1GetUsergroupResponse,
  AdminServiceGetUsergroupParams,
  V1DeleteUsergroupResponse,
  V1RenameUsergroupResponse,
  V1EditUsergroupResponse,
  AdminServiceEditUsergroupBody,
  V1ListUsergroupMemberUsersResponse,
  AdminServiceListUsergroupMemberUsersParams,
  V1RemoveUsergroupMemberUserResponse,
  V1AddUsergroupMemberUserResponse,
  V1RemoveOrganizationMemberUsergroupResponse,
  V1AddOrganizationMemberUsergroupResponse,
  V1SetOrganizationMemberUsergroupRoleResponse,
  V1ListWhitelistedDomainsResponse,
  V1CreateWhitelistedDomainResponse,
  V1RemoveWhitelistedDomainResponse,
  V1CreateAssetResponse,
  AdminServiceCreateAssetBody,
  V1ListProjectsForOrganizationResponse,
  AdminServiceListProjectsForOrganizationParams,
  V1CreateProjectResponse,
  AdminServiceCreateProjectBody,
  V1GetProjectResponse,
  AdminServiceGetProjectParams,
  V1DeleteProjectResponse,
  V1UpdateProjectResponse,
  AdminServiceUpdateProjectBody,
  V1ListServicesResponse,
  V1CreateServiceResponse,
  AdminServiceCreateServiceParams,
  V1DeleteServiceResponse,
  V1UpdateServiceResponse,
  AdminServiceUpdateServiceBody,
  V1ListServiceAuthTokensResponse,
  V1IssueServiceAuthTokenResponse,
  V1PingResponse,
  V1GetProjectAccessRequestResponse,
  V1ApproveProjectAccessResponse,
  V1DenyProjectAccessResponse,
  V1TriggerRedeployResponse,
  V1TriggerRedeployRequest,
  V1GetProjectByIDResponse,
  V1GetAlertMetaResponse,
  AdminServiceGetAlertMetaBody,
  V1GetRepoMetaResponse,
  AdminServiceGetRepoMetaParams,
  V1PullVirtualRepoResponse,
  AdminServicePullVirtualRepoParams,
  V1GetReportMetaResponse,
  AdminServiceGetReportMetaBody,
  V1RevokeServiceAuthTokenResponse,
  V1SudoIssueRuntimeManagerTokenResponse,
  V1SudoIssueRuntimeManagerTokenRequest,
  V1ListSuperusersResponse,
  V1SetSuperuserResponse,
  V1SetSuperuserRequest,
  V1SudoUpdateOrganizationBillingCustomerResponse,
  V1SudoUpdateOrganizationBillingCustomerRequest,
  V1SudoUpdateOrganizationCustomDomainResponse,
  V1SudoUpdateOrganizationCustomDomainRequest,
  V1SudoDeleteOrganizationBillingIssueResponse,
  V1SudoUpdateAnnotationsResponse,
  V1SudoUpdateAnnotationsRequest,
  V1SearchProjectNamesResponse,
  AdminServiceSearchProjectNamesParams,
  V1SudoUpdateOrganizationQuotasResponse,
  V1SudoUpdateOrganizationQuotasRequest,
  V1SudoUpdateUserQuotasResponse,
  V1SudoUpdateUserQuotasRequest,
  V1SudoGetResourceResponse,
  AdminServiceSudoGetResourceParams,
  V1RevokeCurrentAuthTokenResponse,
  V1IssueRepresentativeAuthTokenResponse,
  V1IssueRepresentativeAuthTokenRequest,
  V1GetUserResponse,
  AdminServiceGetUserParams,
  V1ListBookmarksResponse,
  AdminServiceListBookmarksParams,
  V1CreateBookmarkResponse,
  V1CreateBookmarkRequest,
  V1UpdateBookmarkResponse,
  V1UpdateBookmarkRequest,
  V1GetBookmarkResponse,
  V1RemoveBookmarkResponse,
  V1GetCurrentUserResponse,
  V1UpdateUserPreferencesResponse,
  V1UpdateUserPreferencesRequest,
  V1SearchUsersResponse,
  AdminServiceSearchUsersParams,
} from "../index.schemas";
import { httpClient } from "../../http-client";

type AwaitedInput<T> = PromiseLike<T> | T;

type Awaited<O> = O extends AwaitedInput<infer T> ? T : never;

/**
 * @summary ListPublicBillingPlans lists all public billing plans
 */
export const adminServiceListPublicBillingPlans = (signal?: AbortSignal) => {
  return httpClient<V1ListPublicBillingPlansResponse>({
    url: `/v1/billing/plans`,
    method: "get",
    signal,
  });
};

export const getAdminServiceListPublicBillingPlansQueryKey = () => [
  `/v1/billing/plans`,
];

export type AdminServiceListPublicBillingPlansQueryResult = NonNullable<
  Awaited<ReturnType<typeof adminServiceListPublicBillingPlans>>
>;
export type AdminServiceListPublicBillingPlansQueryError = RpcStatus;

export const createAdminServiceListPublicBillingPlans = <
  TData = Awaited<ReturnType<typeof adminServiceListPublicBillingPlans>>,
  TError = RpcStatus,
>(options?: {
  query?: CreateQueryOptions<
    Awaited<ReturnType<typeof adminServiceListPublicBillingPlans>>,
    TError,
    TData
  >;
}): CreateQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getAdminServiceListPublicBillingPlansQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof adminServiceListPublicBillingPlans>>
  > = ({ signal }) => adminServiceListPublicBillingPlans(signal);

  const query = createQuery<
    Awaited<ReturnType<typeof adminServiceListPublicBillingPlans>>,
    TError,
    TData
  >({ queryKey, queryFn, ...queryOptions }) as CreateQueryResult<
    TData,
    TError
  > & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
};

/**
 * @summary TriggerReconcile triggers reconcile for the project's prod deployment.
DEPRECATED: Clients should call CreateTrigger directly on the deployed runtime instead.
 */
export const adminServiceTriggerReconcile = (
  deploymentId: string,
  adminServiceTriggerReconcileBodyBody: AdminServiceTriggerReconcileBodyBody,
) => {
  return httpClient<V1TriggerReconcileResponse>({
    url: `/v1/deployments/${deploymentId}/reconcile`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: adminServiceTriggerReconcileBodyBody,
  });
};

export type AdminServiceTriggerReconcileMutationResult = NonNullable<
  Awaited<ReturnType<typeof adminServiceTriggerReconcile>>
>;
export type AdminServiceTriggerReconcileMutationBody =
  AdminServiceTriggerReconcileBodyBody;
export type AdminServiceTriggerReconcileMutationError = RpcStatus;

export const createAdminServiceTriggerReconcile = <
  TError = RpcStatus,
  TContext = unknown,
>(options?: {
  mutation?: CreateMutationOptions<
    Awaited<ReturnType<typeof adminServiceTriggerReconcile>>,
    TError,
    { deploymentId: string; data: AdminServiceTriggerReconcileBodyBody },
    TContext
  >;
}) => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof adminServiceTriggerReconcile>>,
    { deploymentId: string; data: AdminServiceTriggerReconcileBodyBody }
  > = (props) => {
    const { deploymentId, data } = props ?? {};

    return adminServiceTriggerReconcile(deploymentId, data);
  };

  return createMutation<
    Awaited<ReturnType<typeof adminServiceTriggerReconcile>>,
    TError,
    { deploymentId: string; data: AdminServiceTriggerReconcileBodyBody },
    TContext
  >(mutationFn, mutationOptions);
};
/**
 * @summary TriggerRefreshSources refresh the source for production deployment.
DEPRECATED: Clients should call CreateTrigger directly on the deployed runtime instead.
 */
export const adminServiceTriggerRefreshSources = (
  deploymentId: string,
  adminServiceTriggerRefreshSourcesBody: AdminServiceTriggerRefreshSourcesBody,
) => {
  return httpClient<V1TriggerRefreshSourcesResponse>({
    url: `/v1/deployments/${deploymentId}/refresh`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: adminServiceTriggerRefreshSourcesBody,
  });
};

export type AdminServiceTriggerRefreshSourcesMutationResult = NonNullable<
  Awaited<ReturnType<typeof adminServiceTriggerRefreshSources>>
>;
export type AdminServiceTriggerRefreshSourcesMutationBody =
  AdminServiceTriggerRefreshSourcesBody;
export type AdminServiceTriggerRefreshSourcesMutationError = RpcStatus;

export const createAdminServiceTriggerRefreshSources = <
  TError = RpcStatus,
  TContext = unknown,
>(options?: {
  mutation?: CreateMutationOptions<
    Awaited<ReturnType<typeof adminServiceTriggerRefreshSources>>,
    TError,
    { deploymentId: string; data: AdminServiceTriggerRefreshSourcesBody },
    TContext
  >;
}) => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof adminServiceTriggerRefreshSources>>,
    { deploymentId: string; data: AdminServiceTriggerRefreshSourcesBody }
  > = (props) => {
    const { deploymentId, data } = props ?? {};

    return adminServiceTriggerRefreshSources(deploymentId, data);
  };

  return createMutation<
    Awaited<ReturnType<typeof adminServiceTriggerRefreshSources>>,
    TError,
    { deploymentId: string; data: AdminServiceTriggerRefreshSourcesBody },
    TContext
  >(mutationFn, mutationOptions);
};
/**
 * @summary GetGithubRepoRequest returns info about a Github repo based on the caller's installations.
If the caller has not granted access to the repository, instructions for granting access are returned.
 */
export const adminServiceGetGithubRepoStatus = (
  params?: AdminServiceGetGithubRepoStatusParams,
  signal?: AbortSignal,
) => {
  return httpClient<V1GetGithubRepoStatusResponse>({
    url: `/v1/github/repositories`,
    method: "get",
    params,
    signal,
  });
};

export const getAdminServiceGetGithubRepoStatusQueryKey = (
  params?: AdminServiceGetGithubRepoStatusParams,
) => [`/v1/github/repositories`, ...(params ? [params] : [])];

export type AdminServiceGetGithubRepoStatusQueryResult = NonNullable<
  Awaited<ReturnType<typeof adminServiceGetGithubRepoStatus>>
>;
export type AdminServiceGetGithubRepoStatusQueryError = RpcStatus;

export const createAdminServiceGetGithubRepoStatus = <
  TData = Awaited<ReturnType<typeof adminServiceGetGithubRepoStatus>>,
  TError = RpcStatus,
>(
  params?: AdminServiceGetGithubRepoStatusParams,
  options?: {
    query?: CreateQueryOptions<
      Awaited<ReturnType<typeof adminServiceGetGithubRepoStatus>>,
      TError,
      TData
    >;
  },
): CreateQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getAdminServiceGetGithubRepoStatusQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof adminServiceGetGithubRepoStatus>>
  > = ({ signal }) => adminServiceGetGithubRepoStatus(params, signal);

  const query = createQuery<
    Awaited<ReturnType<typeof adminServiceGetGithubRepoStatus>>,
    TError,
    TData
  >({ queryKey, queryFn, ...queryOptions }) as CreateQueryResult<
    TData,
    TError
  > & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
};

/**
 * @summary GetGithubUserStatus returns info about a Github user account based on the caller's installations.
If we don't have access to user's personal account tokens or it is expired, instructions for granting access are returned.
 */
export const adminServiceGetGithubUserStatus = (signal?: AbortSignal) => {
  return httpClient<V1GetGithubUserStatusResponse>({
    url: `/v1/github/user`,
    method: "get",
    signal,
  });
};

export const getAdminServiceGetGithubUserStatusQueryKey = () => [
  `/v1/github/user`,
];

export type AdminServiceGetGithubUserStatusQueryResult = NonNullable<
  Awaited<ReturnType<typeof adminServiceGetGithubUserStatus>>
>;
export type AdminServiceGetGithubUserStatusQueryError = RpcStatus;

export const createAdminServiceGetGithubUserStatus = <
  TData = Awaited<ReturnType<typeof adminServiceGetGithubUserStatus>>,
  TError = RpcStatus,
>(options?: {
  query?: CreateQueryOptions<
    Awaited<ReturnType<typeof adminServiceGetGithubUserStatus>>,
    TError,
    TData
  >;
}): CreateQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getAdminServiceGetGithubUserStatusQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof adminServiceGetGithubUserStatus>>
  > = ({ signal }) => adminServiceGetGithubUserStatus(signal);

  const query = createQuery<
    Awaited<ReturnType<typeof adminServiceGetGithubUserStatus>>,
    TError,
    TData
  >({ queryKey, queryFn, ...queryOptions }) as CreateQueryResult<
    TData,
    TError
  > & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
};

export const adminServiceListGithubUserRepos = (signal?: AbortSignal) => {
  return httpClient<V1ListGithubUserReposResponse>({
    url: `/v1/github/user/repositories`,
    method: "get",
    signal,
  });
};

export const getAdminServiceListGithubUserReposQueryKey = () => [
  `/v1/github/user/repositories`,
];

export type AdminServiceListGithubUserReposQueryResult = NonNullable<
  Awaited<ReturnType<typeof adminServiceListGithubUserRepos>>
>;
export type AdminServiceListGithubUserReposQueryError = RpcStatus;

export const createAdminServiceListGithubUserRepos = <
  TData = Awaited<ReturnType<typeof adminServiceListGithubUserRepos>>,
  TError = RpcStatus,
>(options?: {
  query?: CreateQueryOptions<
    Awaited<ReturnType<typeof adminServiceListGithubUserRepos>>,
    TError,
    TData
  >;
}): CreateQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getAdminServiceListGithubUserReposQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof adminServiceListGithubUserRepos>>
  > = ({ signal }) => adminServiceListGithubUserRepos(signal);

  const query = createQuery<
    Awaited<ReturnType<typeof adminServiceListGithubUserRepos>>,
    TError,
    TData
  >({ queryKey, queryFn, ...queryOptions }) as CreateQueryResult<
    TData,
    TError
  > & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
};

/**
 * @summary RevokeMagicAuthToken revokes a magic auth token.
 */
export const adminServiceRevokeMagicAuthToken = (tokenId: string) => {
  return httpClient<V1RevokeMagicAuthTokenResponse>({
    url: `/v1/magic-tokens/${tokenId}`,
    method: "delete",
  });
};

export type AdminServiceRevokeMagicAuthTokenMutationResult = NonNullable<
  Awaited<ReturnType<typeof adminServiceRevokeMagicAuthToken>>
>;

export type AdminServiceRevokeMagicAuthTokenMutationError = RpcStatus;

export const createAdminServiceRevokeMagicAuthToken = <
  TError = RpcStatus,
  TContext = unknown,
>(options?: {
  mutation?: CreateMutationOptions<
    Awaited<ReturnType<typeof adminServiceRevokeMagicAuthToken>>,
    TError,
    { tokenId: string },
    TContext
  >;
}) => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof adminServiceRevokeMagicAuthToken>>,
    { tokenId: string }
  > = (props) => {
    const { tokenId } = props ?? {};

    return adminServiceRevokeMagicAuthToken(tokenId);
  };

  return createMutation<
    Awaited<ReturnType<typeof adminServiceRevokeMagicAuthToken>>,
    TError,
    { tokenId: string },
    TContext
  >(mutationFn, mutationOptions);
};
/**
 * @summary GetCurrentMagicAuthToken returns information about the current magic auth token.
 */
export const adminServiceGetCurrentMagicAuthToken = (signal?: AbortSignal) => {
  return httpClient<V1GetCurrentMagicAuthTokenResponse>({
    url: `/v1/magic-tokens/current`,
    method: "get",
    signal,
  });
};

export const getAdminServiceGetCurrentMagicAuthTokenQueryKey = () => [
  `/v1/magic-tokens/current`,
];

export type AdminServiceGetCurrentMagicAuthTokenQueryResult = NonNullable<
  Awaited<ReturnType<typeof adminServiceGetCurrentMagicAuthToken>>
>;
export type AdminServiceGetCurrentMagicAuthTokenQueryError = RpcStatus;

export const createAdminServiceGetCurrentMagicAuthToken = <
  TData = Awaited<ReturnType<typeof adminServiceGetCurrentMagicAuthToken>>,
  TError = RpcStatus,
>(options?: {
  query?: CreateQueryOptions<
    Awaited<ReturnType<typeof adminServiceGetCurrentMagicAuthToken>>,
    TError,
    TData
  >;
}): CreateQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getAdminServiceGetCurrentMagicAuthTokenQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof adminServiceGetCurrentMagicAuthToken>>
  > = ({ signal }) => adminServiceGetCurrentMagicAuthToken(signal);

  const query = createQuery<
    Awaited<ReturnType<typeof adminServiceGetCurrentMagicAuthToken>>,
    TError,
    TData
  >({ queryKey, queryFn, ...queryOptions }) as CreateQueryResult<
    TData,
    TError
  > & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
};

/**
 * @summary GetOrganizationNameForDomain finds the org name for a custom domain.
If the application detects it is running on a non-default domain, it can use this to find the org to present.
It can be called without being authenticated.
 */
export const adminServiceGetOrganizationNameForDomain = (
  domain: string,
  signal?: AbortSignal,
) => {
  return httpClient<V1GetOrganizationNameForDomainResponse>({
    url: `/v1/organization-for-domain/${domain}`,
    method: "get",
    signal,
  });
};

export const getAdminServiceGetOrganizationNameForDomainQueryKey = (
  domain: string,
) => [`/v1/organization-for-domain/${domain}`];

export type AdminServiceGetOrganizationNameForDomainQueryResult = NonNullable<
  Awaited<ReturnType<typeof adminServiceGetOrganizationNameForDomain>>
>;
export type AdminServiceGetOrganizationNameForDomainQueryError = RpcStatus;

export const createAdminServiceGetOrganizationNameForDomain = <
  TData = Awaited<ReturnType<typeof adminServiceGetOrganizationNameForDomain>>,
  TError = RpcStatus,
>(
  domain: string,
  options?: {
    query?: CreateQueryOptions<
      Awaited<ReturnType<typeof adminServiceGetOrganizationNameForDomain>>,
      TError,
      TData
    >;
  },
): CreateQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getAdminServiceGetOrganizationNameForDomainQueryKey(domain);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof adminServiceGetOrganizationNameForDomain>>
  > = ({ signal }) => adminServiceGetOrganizationNameForDomain(domain, signal);

  const query = createQuery<
    Awaited<ReturnType<typeof adminServiceGetOrganizationNameForDomain>>,
    TError,
    TData
  >({
    queryKey,
    queryFn,
    enabled: !!domain,
    ...queryOptions,
  }) as CreateQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
};

/**
 * @summary ListOrganizations lists all the organizations currently managed by the admin
 */
export const adminServiceListOrganizations = (
  params?: AdminServiceListOrganizationsParams,
  signal?: AbortSignal,
) => {
  return httpClient<V1ListOrganizationsResponse>({
    url: `/v1/organizations`,
    method: "get",
    params,
    signal,
  });
};

export const getAdminServiceListOrganizationsQueryKey = (
  params?: AdminServiceListOrganizationsParams,
) => [`/v1/organizations`, ...(params ? [params] : [])];

export type AdminServiceListOrganizationsQueryResult = NonNullable<
  Awaited<ReturnType<typeof adminServiceListOrganizations>>
>;
export type AdminServiceListOrganizationsQueryError = RpcStatus;

export const createAdminServiceListOrganizations = <
  TData = Awaited<ReturnType<typeof adminServiceListOrganizations>>,
  TError = RpcStatus,
>(
  params?: AdminServiceListOrganizationsParams,
  options?: {
    query?: CreateQueryOptions<
      Awaited<ReturnType<typeof adminServiceListOrganizations>>,
      TError,
      TData
    >;
  },
): CreateQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getAdminServiceListOrganizationsQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof adminServiceListOrganizations>>
  > = ({ signal }) => adminServiceListOrganizations(params, signal);

  const query = createQuery<
    Awaited<ReturnType<typeof adminServiceListOrganizations>>,
    TError,
    TData
  >({ queryKey, queryFn, ...queryOptions }) as CreateQueryResult<
    TData,
    TError
  > & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
};

/**
 * @summary CreateOrganization creates a new organization
 */
export const adminServiceCreateOrganization = (
  v1CreateOrganizationRequest: V1CreateOrganizationRequest,
) => {
  return httpClient<V1CreateOrganizationResponse>({
    url: `/v1/organizations`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: v1CreateOrganizationRequest,
  });
};

export type AdminServiceCreateOrganizationMutationResult = NonNullable<
  Awaited<ReturnType<typeof adminServiceCreateOrganization>>
>;
export type AdminServiceCreateOrganizationMutationBody =
  V1CreateOrganizationRequest;
export type AdminServiceCreateOrganizationMutationError = RpcStatus;

export const createAdminServiceCreateOrganization = <
  TError = RpcStatus,
  TContext = unknown,
>(options?: {
  mutation?: CreateMutationOptions<
    Awaited<ReturnType<typeof adminServiceCreateOrganization>>,
    TError,
    { data: V1CreateOrganizationRequest },
    TContext
  >;
}) => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof adminServiceCreateOrganization>>,
    { data: V1CreateOrganizationRequest }
  > = (props) => {
    const { data } = props ?? {};

    return adminServiceCreateOrganization(data);
  };

  return createMutation<
    Awaited<ReturnType<typeof adminServiceCreateOrganization>>,
    TError,
    { data: V1CreateOrganizationRequest },
    TContext
  >(mutationFn, mutationOptions);
};
/**
 * @summary GetOrganization returns information about a specific organization
 */
export const adminServiceGetOrganization = (
  name: string,
  signal?: AbortSignal,
) => {
  return httpClient<V1GetOrganizationResponse>({
    url: `/v1/organizations/${name}`,
    method: "get",
    signal,
  });
};

export const getAdminServiceGetOrganizationQueryKey = (name: string) => [
  `/v1/organizations/${name}`,
];

export type AdminServiceGetOrganizationQueryResult = NonNullable<
  Awaited<ReturnType<typeof adminServiceGetOrganization>>
>;
export type AdminServiceGetOrganizationQueryError = RpcStatus;

export const createAdminServiceGetOrganization = <
  TData = Awaited<ReturnType<typeof adminServiceGetOrganization>>,
  TError = RpcStatus,
>(
  name: string,
  options?: {
    query?: CreateQueryOptions<
      Awaited<ReturnType<typeof adminServiceGetOrganization>>,
      TError,
      TData
    >;
  },
): CreateQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getAdminServiceGetOrganizationQueryKey(name);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof adminServiceGetOrganization>>
  > = ({ signal }) => adminServiceGetOrganization(name, signal);

  const query = createQuery<
    Awaited<ReturnType<typeof adminServiceGetOrganization>>,
    TError,
    TData
  >({
    queryKey,
    queryFn,
    enabled: !!name,
    ...queryOptions,
  }) as CreateQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
};

/**
 * @summary DeleteOrganization deletes an organizations
 */
export const adminServiceDeleteOrganization = (name: string) => {
  return httpClient<V1DeleteOrganizationResponse>({
    url: `/v1/organizations/${name}`,
    method: "delete",
  });
};

export type AdminServiceDeleteOrganizationMutationResult = NonNullable<
  Awaited<ReturnType<typeof adminServiceDeleteOrganization>>
>;

export type AdminServiceDeleteOrganizationMutationError = RpcStatus;

export const createAdminServiceDeleteOrganization = <
  TError = RpcStatus,
  TContext = unknown,
>(options?: {
  mutation?: CreateMutationOptions<
    Awaited<ReturnType<typeof adminServiceDeleteOrganization>>,
    TError,
    { name: string },
    TContext
  >;
}) => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof adminServiceDeleteOrganization>>,
    { name: string }
  > = (props) => {
    const { name } = props ?? {};

    return adminServiceDeleteOrganization(name);
  };

  return createMutation<
    Awaited<ReturnType<typeof adminServiceDeleteOrganization>>,
    TError,
    { name: string },
    TContext
  >(mutationFn, mutationOptions);
};
/**
 * @summary UpdateOrganization deletes an organizations
 */
export const adminServiceUpdateOrganization = (
  name: string,
  adminServiceUpdateOrganizationBody: AdminServiceUpdateOrganizationBody,
) => {
  return httpClient<V1UpdateOrganizationResponse>({
    url: `/v1/organizations/${name}`,
    method: "patch",
    headers: { "Content-Type": "application/json" },
    data: adminServiceUpdateOrganizationBody,
  });
};

export type AdminServiceUpdateOrganizationMutationResult = NonNullable<
  Awaited<ReturnType<typeof adminServiceUpdateOrganization>>
>;
export type AdminServiceUpdateOrganizationMutationBody =
  AdminServiceUpdateOrganizationBody;
export type AdminServiceUpdateOrganizationMutationError = RpcStatus;

export const createAdminServiceUpdateOrganization = <
  TError = RpcStatus,
  TContext = unknown,
>(options?: {
  mutation?: CreateMutationOptions<
    Awaited<ReturnType<typeof adminServiceUpdateOrganization>>,
    TError,
    { name: string; data: AdminServiceUpdateOrganizationBody },
    TContext
  >;
}) => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof adminServiceUpdateOrganization>>,
    { name: string; data: AdminServiceUpdateOrganizationBody }
  > = (props) => {
    const { name, data } = props ?? {};

    return adminServiceUpdateOrganization(name, data);
  };

  return createMutation<
    Awaited<ReturnType<typeof adminServiceUpdateOrganization>>,
    TError,
    { name: string; data: AdminServiceUpdateOrganizationBody },
    TContext
  >(mutationFn, mutationOptions);
};
/**
 * @summary ListOrganizationBillingIssues lists all the billing issues for the organization
 */
export const adminServiceListOrganizationBillingIssues = (
  organization: string,
  signal?: AbortSignal,
) => {
  return httpClient<V1ListOrganizationBillingIssuesResponse>({
    url: `/v1/organizations/${organization}/billing/issues`,
    method: "get",
    signal,
  });
};

export const getAdminServiceListOrganizationBillingIssuesQueryKey = (
  organization: string,
) => [`/v1/organizations/${organization}/billing/issues`];

export type AdminServiceListOrganizationBillingIssuesQueryResult = NonNullable<
  Awaited<ReturnType<typeof adminServiceListOrganizationBillingIssues>>
>;
export type AdminServiceListOrganizationBillingIssuesQueryError = RpcStatus;

export const createAdminServiceListOrganizationBillingIssues = <
  TData = Awaited<ReturnType<typeof adminServiceListOrganizationBillingIssues>>,
  TError = RpcStatus,
>(
  organization: string,
  options?: {
    query?: CreateQueryOptions<
      Awaited<ReturnType<typeof adminServiceListOrganizationBillingIssues>>,
      TError,
      TData
    >;
  },
): CreateQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getAdminServiceListOrganizationBillingIssuesQueryKey(organization);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof adminServiceListOrganizationBillingIssues>>
  > = ({ signal }) =>
    adminServiceListOrganizationBillingIssues(organization, signal);

  const query = createQuery<
    Awaited<ReturnType<typeof adminServiceListOrganizationBillingIssues>>,
    TError,
    TData
  >({
    queryKey,
    queryFn,
    enabled: !!organization,
    ...queryOptions,
  }) as CreateQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
};

/**
 * @summary GetPaymentsPortalURL returns the URL for the billing session to collect payment method
 */
export const adminServiceGetPaymentsPortalURL = (
  organization: string,
  params?: AdminServiceGetPaymentsPortalURLParams,
  signal?: AbortSignal,
) => {
  return httpClient<V1GetPaymentsPortalURLResponse>({
    url: `/v1/organizations/${organization}/billing/payments/portal-url`,
    method: "get",
    params,
    signal,
  });
};

export const getAdminServiceGetPaymentsPortalURLQueryKey = (
  organization: string,
  params?: AdminServiceGetPaymentsPortalURLParams,
) => [
  `/v1/organizations/${organization}/billing/payments/portal-url`,
  ...(params ? [params] : []),
];

export type AdminServiceGetPaymentsPortalURLQueryResult = NonNullable<
  Awaited<ReturnType<typeof adminServiceGetPaymentsPortalURL>>
>;
export type AdminServiceGetPaymentsPortalURLQueryError = RpcStatus;

export const createAdminServiceGetPaymentsPortalURL = <
  TData = Awaited<ReturnType<typeof adminServiceGetPaymentsPortalURL>>,
  TError = RpcStatus,
>(
  organization: string,
  params?: AdminServiceGetPaymentsPortalURLParams,
  options?: {
    query?: CreateQueryOptions<
      Awaited<ReturnType<typeof adminServiceGetPaymentsPortalURL>>,
      TError,
      TData
    >;
  },
): CreateQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getAdminServiceGetPaymentsPortalURLQueryKey(organization, params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof adminServiceGetPaymentsPortalURL>>
  > = ({ signal }) =>
    adminServiceGetPaymentsPortalURL(organization, params, signal);

  const query = createQuery<
    Awaited<ReturnType<typeof adminServiceGetPaymentsPortalURL>>,
    TError,
    TData
  >({
    queryKey,
    queryFn,
    enabled: !!organization,
    ...queryOptions,
  }) as CreateQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
};

/**
 * @summary GetBillingSubscription lists the subscription for the organization
 */
export const adminServiceGetBillingSubscription = (
  organization: string,
  signal?: AbortSignal,
) => {
  return httpClient<V1GetBillingSubscriptionResponse>({
    url: `/v1/organizations/${organization}/billing/subscriptions`,
    method: "get",
    signal,
  });
};

export const getAdminServiceGetBillingSubscriptionQueryKey = (
  organization: string,
) => [`/v1/organizations/${organization}/billing/subscriptions`];

export type AdminServiceGetBillingSubscriptionQueryResult = NonNullable<
  Awaited<ReturnType<typeof adminServiceGetBillingSubscription>>
>;
export type AdminServiceGetBillingSubscriptionQueryError = RpcStatus;

export const createAdminServiceGetBillingSubscription = <
  TData = Awaited<ReturnType<typeof adminServiceGetBillingSubscription>>,
  TError = RpcStatus,
>(
  organization: string,
  options?: {
    query?: CreateQueryOptions<
      Awaited<ReturnType<typeof adminServiceGetBillingSubscription>>,
      TError,
      TData
    >;
  },
): CreateQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getAdminServiceGetBillingSubscriptionQueryKey(organization);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof adminServiceGetBillingSubscription>>
  > = ({ signal }) => adminServiceGetBillingSubscription(organization, signal);

  const query = createQuery<
    Awaited<ReturnType<typeof adminServiceGetBillingSubscription>>,
    TError,
    TData
  >({
    queryKey,
    queryFn,
    enabled: !!organization,
    ...queryOptions,
  }) as CreateQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
};

/**
 * @summary CancelBillingSubscription cancels the billing subscription for the organization and puts them on default plan
 */
export const adminServiceCancelBillingSubscription = (organization: string) => {
  return httpClient<V1CancelBillingSubscriptionResponse>({
    url: `/v1/organizations/${organization}/billing/subscriptions`,
    method: "delete",
  });
};

export type AdminServiceCancelBillingSubscriptionMutationResult = NonNullable<
  Awaited<ReturnType<typeof adminServiceCancelBillingSubscription>>
>;

export type AdminServiceCancelBillingSubscriptionMutationError = RpcStatus;

export const createAdminServiceCancelBillingSubscription = <
  TError = RpcStatus,
  TContext = unknown,
>(options?: {
  mutation?: CreateMutationOptions<
    Awaited<ReturnType<typeof adminServiceCancelBillingSubscription>>,
    TError,
    { organization: string },
    TContext
  >;
}) => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof adminServiceCancelBillingSubscription>>,
    { organization: string }
  > = (props) => {
    const { organization } = props ?? {};

    return adminServiceCancelBillingSubscription(organization);
  };

  return createMutation<
    Awaited<ReturnType<typeof adminServiceCancelBillingSubscription>>,
    TError,
    { organization: string },
    TContext
  >(mutationFn, mutationOptions);
};
/**
 * @summary UpdateBillingSubscription updates the billing plan for the organization
 */
export const adminServiceUpdateBillingSubscription = (
  organization: string,
  adminServiceUpdateBillingSubscriptionBodyBody: AdminServiceUpdateBillingSubscriptionBodyBody,
) => {
  return httpClient<V1UpdateBillingSubscriptionResponse>({
    url: `/v1/organizations/${organization}/billing/subscriptions`,
    method: "patch",
    headers: { "Content-Type": "application/json" },
    data: adminServiceUpdateBillingSubscriptionBodyBody,
  });
};

export type AdminServiceUpdateBillingSubscriptionMutationResult = NonNullable<
  Awaited<ReturnType<typeof adminServiceUpdateBillingSubscription>>
>;
export type AdminServiceUpdateBillingSubscriptionMutationBody =
  AdminServiceUpdateBillingSubscriptionBodyBody;
export type AdminServiceUpdateBillingSubscriptionMutationError = RpcStatus;

export const createAdminServiceUpdateBillingSubscription = <
  TError = RpcStatus,
  TContext = unknown,
>(options?: {
  mutation?: CreateMutationOptions<
    Awaited<ReturnType<typeof adminServiceUpdateBillingSubscription>>,
    TError,
    {
      organization: string;
      data: AdminServiceUpdateBillingSubscriptionBodyBody;
    },
    TContext
  >;
}) => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof adminServiceUpdateBillingSubscription>>,
    {
      organization: string;
      data: AdminServiceUpdateBillingSubscriptionBodyBody;
    }
  > = (props) => {
    const { organization, data } = props ?? {};

    return adminServiceUpdateBillingSubscription(organization, data);
  };

  return createMutation<
    Awaited<ReturnType<typeof adminServiceUpdateBillingSubscription>>,
    TError,
    {
      organization: string;
      data: AdminServiceUpdateBillingSubscriptionBodyBody;
    },
    TContext
  >(mutationFn, mutationOptions);
};
/**
 * @summary RenewBillingSubscription renews the billing plan for the organization once cancelled
 */
export const adminServiceRenewBillingSubscription = (
  organization: string,
  adminServiceUpdateBillingSubscriptionBodyBody: AdminServiceUpdateBillingSubscriptionBodyBody,
) => {
  return httpClient<V1RenewBillingSubscriptionResponse>({
    url: `/v1/organizations/${organization}/billing/subscriptions/renew`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: adminServiceUpdateBillingSubscriptionBodyBody,
  });
};

export type AdminServiceRenewBillingSubscriptionMutationResult = NonNullable<
  Awaited<ReturnType<typeof adminServiceRenewBillingSubscription>>
>;
export type AdminServiceRenewBillingSubscriptionMutationBody =
  AdminServiceUpdateBillingSubscriptionBodyBody;
export type AdminServiceRenewBillingSubscriptionMutationError = RpcStatus;

export const createAdminServiceRenewBillingSubscription = <
  TError = RpcStatus,
  TContext = unknown,
>(options?: {
  mutation?: CreateMutationOptions<
    Awaited<ReturnType<typeof adminServiceRenewBillingSubscription>>,
    TError,
    {
      organization: string;
      data: AdminServiceUpdateBillingSubscriptionBodyBody;
    },
    TContext
  >;
}) => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof adminServiceRenewBillingSubscription>>,
    {
      organization: string;
      data: AdminServiceUpdateBillingSubscriptionBodyBody;
    }
  > = (props) => {
    const { organization, data } = props ?? {};

    return adminServiceRenewBillingSubscription(organization, data);
  };

  return createMutation<
    Awaited<ReturnType<typeof adminServiceRenewBillingSubscription>>,
    TError,
    {
      organization: string;
      data: AdminServiceUpdateBillingSubscriptionBodyBody;
    },
    TContext
  >(mutationFn, mutationOptions);
};
/**
 * @summary ListOrganizationInvites lists all the org invites
 */
export const adminServiceListOrganizationInvites = (
  organization: string,
  params?: AdminServiceListOrganizationInvitesParams,
  signal?: AbortSignal,
) => {
  return httpClient<V1ListOrganizationInvitesResponse>({
    url: `/v1/organizations/${organization}/invites`,
    method: "get",
    params,
    signal,
  });
};

export const getAdminServiceListOrganizationInvitesQueryKey = (
  organization: string,
  params?: AdminServiceListOrganizationInvitesParams,
) => [`/v1/organizations/${organization}/invites`, ...(params ? [params] : [])];

export type AdminServiceListOrganizationInvitesQueryResult = NonNullable<
  Awaited<ReturnType<typeof adminServiceListOrganizationInvites>>
>;
export type AdminServiceListOrganizationInvitesQueryError = RpcStatus;

export const createAdminServiceListOrganizationInvites = <
  TData = Awaited<ReturnType<typeof adminServiceListOrganizationInvites>>,
  TError = RpcStatus,
>(
  organization: string,
  params?: AdminServiceListOrganizationInvitesParams,
  options?: {
    query?: CreateQueryOptions<
      Awaited<ReturnType<typeof adminServiceListOrganizationInvites>>,
      TError,
      TData
    >;
  },
): CreateQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getAdminServiceListOrganizationInvitesQueryKey(organization, params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof adminServiceListOrganizationInvites>>
  > = ({ signal }) =>
    adminServiceListOrganizationInvites(organization, params, signal);

  const query = createQuery<
    Awaited<ReturnType<typeof adminServiceListOrganizationInvites>>,
    TError,
    TData
  >({
    queryKey,
    queryFn,
    enabled: !!organization,
    ...queryOptions,
  }) as CreateQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
};

/**
 * @summary ListOrganizationMemberUsers lists all the org members
 */
export const adminServiceListOrganizationMemberUsers = (
  organization: string,
  params?: AdminServiceListOrganizationMemberUsersParams,
  signal?: AbortSignal,
) => {
  return httpClient<V1ListOrganizationMemberUsersResponse>({
    url: `/v1/organizations/${organization}/members`,
    method: "get",
    params,
    signal,
  });
};

export const getAdminServiceListOrganizationMemberUsersQueryKey = (
  organization: string,
  params?: AdminServiceListOrganizationMemberUsersParams,
) => [`/v1/organizations/${organization}/members`, ...(params ? [params] : [])];

export type AdminServiceListOrganizationMemberUsersQueryResult = NonNullable<
  Awaited<ReturnType<typeof adminServiceListOrganizationMemberUsers>>
>;
export type AdminServiceListOrganizationMemberUsersQueryError = RpcStatus;

export const createAdminServiceListOrganizationMemberUsers = <
  TData = Awaited<ReturnType<typeof adminServiceListOrganizationMemberUsers>>,
  TError = RpcStatus,
>(
  organization: string,
  params?: AdminServiceListOrganizationMemberUsersParams,
  options?: {
    query?: CreateQueryOptions<
      Awaited<ReturnType<typeof adminServiceListOrganizationMemberUsers>>,
      TError,
      TData
    >;
  },
): CreateQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getAdminServiceListOrganizationMemberUsersQueryKey(organization, params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof adminServiceListOrganizationMemberUsers>>
  > = ({ signal }) =>
    adminServiceListOrganizationMemberUsers(organization, params, signal);

  const query = createQuery<
    Awaited<ReturnType<typeof adminServiceListOrganizationMemberUsers>>,
    TError,
    TData
  >({
    queryKey,
    queryFn,
    enabled: !!organization,
    ...queryOptions,
  }) as CreateQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
};

/**
 * @summary AddOrganizationMemberUser adds a user to the organization
 */
export const adminServiceAddOrganizationMemberUser = (
  organization: string,
  adminServiceAddOrganizationMemberUserBody: AdminServiceAddOrganizationMemberUserBody,
) => {
  return httpClient<V1AddOrganizationMemberUserResponse>({
    url: `/v1/organizations/${organization}/members`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: adminServiceAddOrganizationMemberUserBody,
  });
};

export type AdminServiceAddOrganizationMemberUserMutationResult = NonNullable<
  Awaited<ReturnType<typeof adminServiceAddOrganizationMemberUser>>
>;
export type AdminServiceAddOrganizationMemberUserMutationBody =
  AdminServiceAddOrganizationMemberUserBody;
export type AdminServiceAddOrganizationMemberUserMutationError = RpcStatus;

export const createAdminServiceAddOrganizationMemberUser = <
  TError = RpcStatus,
  TContext = unknown,
>(options?: {
  mutation?: CreateMutationOptions<
    Awaited<ReturnType<typeof adminServiceAddOrganizationMemberUser>>,
    TError,
    { organization: string; data: AdminServiceAddOrganizationMemberUserBody },
    TContext
  >;
}) => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof adminServiceAddOrganizationMemberUser>>,
    { organization: string; data: AdminServiceAddOrganizationMemberUserBody }
  > = (props) => {
    const { organization, data } = props ?? {};

    return adminServiceAddOrganizationMemberUser(organization, data);
  };

  return createMutation<
    Awaited<ReturnType<typeof adminServiceAddOrganizationMemberUser>>,
    TError,
    { organization: string; data: AdminServiceAddOrganizationMemberUserBody },
    TContext
  >(mutationFn, mutationOptions);
};
/**
 * @summary RemoveOrganizationMemberUser removes member from the organization
 */
export const adminServiceRemoveOrganizationMemberUser = (
  organization: string,
  email: string,
  params?: AdminServiceRemoveOrganizationMemberUserParams,
) => {
  return httpClient<V1RemoveOrganizationMemberUserResponse>({
    url: `/v1/organizations/${organization}/members/${email}`,
    method: "delete",
    params,
  });
};

export type AdminServiceRemoveOrganizationMemberUserMutationResult =
  NonNullable<
    Awaited<ReturnType<typeof adminServiceRemoveOrganizationMemberUser>>
  >;

export type AdminServiceRemoveOrganizationMemberUserMutationError = RpcStatus;

export const createAdminServiceRemoveOrganizationMemberUser = <
  TError = RpcStatus,
  TContext = unknown,
>(options?: {
  mutation?: CreateMutationOptions<
    Awaited<ReturnType<typeof adminServiceRemoveOrganizationMemberUser>>,
    TError,
    {
      organization: string;
      email: string;
      params?: AdminServiceRemoveOrganizationMemberUserParams;
    },
    TContext
  >;
}) => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof adminServiceRemoveOrganizationMemberUser>>,
    {
      organization: string;
      email: string;
      params?: AdminServiceRemoveOrganizationMemberUserParams;
    }
  > = (props) => {
    const { organization, email, params } = props ?? {};

    return adminServiceRemoveOrganizationMemberUser(
      organization,
      email,
      params,
    );
  };

  return createMutation<
    Awaited<ReturnType<typeof adminServiceRemoveOrganizationMemberUser>>,
    TError,
    {
      organization: string;
      email: string;
      params?: AdminServiceRemoveOrganizationMemberUserParams;
    },
    TContext
  >(mutationFn, mutationOptions);
};
/**
 * @summary SetOrganizationMemberUserRole sets the role for the member
 */
export const adminServiceSetOrganizationMemberUserRole = (
  organization: string,
  email: string,
  adminServiceSetOrganizationMemberUserRoleBodyBody: AdminServiceSetOrganizationMemberUserRoleBodyBody,
) => {
  return httpClient<V1SetOrganizationMemberUserRoleResponse>({
    url: `/v1/organizations/${organization}/members/${email}`,
    method: "put",
    headers: { "Content-Type": "application/json" },
    data: adminServiceSetOrganizationMemberUserRoleBodyBody,
  });
};

export type AdminServiceSetOrganizationMemberUserRoleMutationResult =
  NonNullable<
    Awaited<ReturnType<typeof adminServiceSetOrganizationMemberUserRole>>
  >;
export type AdminServiceSetOrganizationMemberUserRoleMutationBody =
  AdminServiceSetOrganizationMemberUserRoleBodyBody;
export type AdminServiceSetOrganizationMemberUserRoleMutationError = RpcStatus;

export const createAdminServiceSetOrganizationMemberUserRole = <
  TError = RpcStatus,
  TContext = unknown,
>(options?: {
  mutation?: CreateMutationOptions<
    Awaited<ReturnType<typeof adminServiceSetOrganizationMemberUserRole>>,
    TError,
    {
      organization: string;
      email: string;
      data: AdminServiceSetOrganizationMemberUserRoleBodyBody;
    },
    TContext
  >;
}) => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof adminServiceSetOrganizationMemberUserRole>>,
    {
      organization: string;
      email: string;
      data: AdminServiceSetOrganizationMemberUserRoleBodyBody;
    }
  > = (props) => {
    const { organization, email, data } = props ?? {};

    return adminServiceSetOrganizationMemberUserRole(organization, email, data);
  };

  return createMutation<
    Awaited<ReturnType<typeof adminServiceSetOrganizationMemberUserRole>>,
    TError,
    {
      organization: string;
      email: string;
      data: AdminServiceSetOrganizationMemberUserRoleBodyBody;
    },
    TContext
  >(mutationFn, mutationOptions);
};
/**
 * @summary LeaveOrganization removes the current user from the organization
 */
export const adminServiceLeaveOrganization = (organization: string) => {
  return httpClient<V1LeaveOrganizationResponse>({
    url: `/v1/organizations/${organization}/members/current`,
    method: "delete",
  });
};

export type AdminServiceLeaveOrganizationMutationResult = NonNullable<
  Awaited<ReturnType<typeof adminServiceLeaveOrganization>>
>;

export type AdminServiceLeaveOrganizationMutationError = RpcStatus;

export const createAdminServiceLeaveOrganization = <
  TError = RpcStatus,
  TContext = unknown,
>(options?: {
  mutation?: CreateMutationOptions<
    Awaited<ReturnType<typeof adminServiceLeaveOrganization>>,
    TError,
    { organization: string },
    TContext
  >;
}) => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof adminServiceLeaveOrganization>>,
    { organization: string }
  > = (props) => {
    const { organization } = props ?? {};

    return adminServiceLeaveOrganization(organization);
  };

  return createMutation<
    Awaited<ReturnType<typeof adminServiceLeaveOrganization>>,
    TError,
    { organization: string },
    TContext
  >(mutationFn, mutationOptions);
};
/**
 * @summary ListProjectMemberUsergroups lists the org's user groups
 */
export const adminServiceListProjectMemberUsergroups = (
  organization: string,
  project: string,
  params?: AdminServiceListProjectMemberUsergroupsParams,
  signal?: AbortSignal,
) => {
  return httpClient<V1ListProjectMemberUsergroupsResponse>({
    url: `/v1/organizations/${organization}/project/${project}/usergroups`,
    method: "get",
    params,
    signal,
  });
};

export const getAdminServiceListProjectMemberUsergroupsQueryKey = (
  organization: string,
  project: string,
  params?: AdminServiceListProjectMemberUsergroupsParams,
) => [
  `/v1/organizations/${organization}/project/${project}/usergroups`,
  ...(params ? [params] : []),
];

export type AdminServiceListProjectMemberUsergroupsQueryResult = NonNullable<
  Awaited<ReturnType<typeof adminServiceListProjectMemberUsergroups>>
>;
export type AdminServiceListProjectMemberUsergroupsQueryError = RpcStatus;

export const createAdminServiceListProjectMemberUsergroups = <
  TData = Awaited<ReturnType<typeof adminServiceListProjectMemberUsergroups>>,
  TError = RpcStatus,
>(
  organization: string,
  project: string,
  params?: AdminServiceListProjectMemberUsergroupsParams,
  options?: {
    query?: CreateQueryOptions<
      Awaited<ReturnType<typeof adminServiceListProjectMemberUsergroups>>,
      TError,
      TData
    >;
  },
): CreateQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getAdminServiceListProjectMemberUsergroupsQueryKey(
      organization,
      project,
      params,
    );

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof adminServiceListProjectMemberUsergroups>>
  > = ({ signal }) =>
    adminServiceListProjectMemberUsergroups(
      organization,
      project,
      params,
      signal,
    );

  const query = createQuery<
    Awaited<ReturnType<typeof adminServiceListProjectMemberUsergroups>>,
    TError,
    TData
  >({
    queryKey,
    queryFn,
    enabled: !!(organization && project),
    ...queryOptions,
  }) as CreateQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
};

/**
 * @summary CreateAlert adds a virtual file for an alert, triggers a reconcile, and waits for the alert to be added to the runtime catalog
 */
export const adminServiceCreateAlert = (
  organization: string,
  project: string,
  adminServiceCreateAlertBodyBody: AdminServiceCreateAlertBodyBody,
) => {
  return httpClient<V1CreateAlertResponse>({
    url: `/v1/organizations/${organization}/projects/${project}/alerts`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: adminServiceCreateAlertBodyBody,
  });
};

export type AdminServiceCreateAlertMutationResult = NonNullable<
  Awaited<ReturnType<typeof adminServiceCreateAlert>>
>;
export type AdminServiceCreateAlertMutationBody =
  AdminServiceCreateAlertBodyBody;
export type AdminServiceCreateAlertMutationError = RpcStatus;

export const createAdminServiceCreateAlert = <
  TError = RpcStatus,
  TContext = unknown,
>(options?: {
  mutation?: CreateMutationOptions<
    Awaited<ReturnType<typeof adminServiceCreateAlert>>,
    TError,
    {
      organization: string;
      project: string;
      data: AdminServiceCreateAlertBodyBody;
    },
    TContext
  >;
}) => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof adminServiceCreateAlert>>,
    {
      organization: string;
      project: string;
      data: AdminServiceCreateAlertBodyBody;
    }
  > = (props) => {
    const { organization, project, data } = props ?? {};

    return adminServiceCreateAlert(organization, project, data);
  };

  return createMutation<
    Awaited<ReturnType<typeof adminServiceCreateAlert>>,
    TError,
    {
      organization: string;
      project: string;
      data: AdminServiceCreateAlertBodyBody;
    },
    TContext
  >(mutationFn, mutationOptions);
};
/**
 * @summary GenerateAlertYAML generates YAML for an alert to be copied into a project's Git repository
 */
export const adminServiceGenerateAlertYAML = (
  organization: string,
  project: string,
  adminServiceCreateAlertBodyBody: AdminServiceCreateAlertBodyBody,
) => {
  return httpClient<V1GenerateAlertYAMLResponse>({
    url: `/v1/organizations/${organization}/projects/${project}/alerts/-/yaml`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: adminServiceCreateAlertBodyBody,
  });
};

export type AdminServiceGenerateAlertYAMLMutationResult = NonNullable<
  Awaited<ReturnType<typeof adminServiceGenerateAlertYAML>>
>;
export type AdminServiceGenerateAlertYAMLMutationBody =
  AdminServiceCreateAlertBodyBody;
export type AdminServiceGenerateAlertYAMLMutationError = RpcStatus;

export const createAdminServiceGenerateAlertYAML = <
  TError = RpcStatus,
  TContext = unknown,
>(options?: {
  mutation?: CreateMutationOptions<
    Awaited<ReturnType<typeof adminServiceGenerateAlertYAML>>,
    TError,
    {
      organization: string;
      project: string;
      data: AdminServiceCreateAlertBodyBody;
    },
    TContext
  >;
}) => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof adminServiceGenerateAlertYAML>>,
    {
      organization: string;
      project: string;
      data: AdminServiceCreateAlertBodyBody;
    }
  > = (props) => {
    const { organization, project, data } = props ?? {};

    return adminServiceGenerateAlertYAML(organization, project, data);
  };

  return createMutation<
    Awaited<ReturnType<typeof adminServiceGenerateAlertYAML>>,
    TError,
    {
      organization: string;
      project: string;
      data: AdminServiceCreateAlertBodyBody;
    },
    TContext
  >(mutationFn, mutationOptions);
};
/**
 * @summary DeleteAlert deletes the virtual file for a UI-managed alert, triggers a reconcile, and waits for the alert to be deleted in the runtime
 */
export const adminServiceDeleteAlert = (
  organization: string,
  project: string,
  name: string,
) => {
  return httpClient<V1DeleteAlertResponse>({
    url: `/v1/organizations/${organization}/projects/${project}/alerts/${name}`,
    method: "delete",
  });
};

export type AdminServiceDeleteAlertMutationResult = NonNullable<
  Awaited<ReturnType<typeof adminServiceDeleteAlert>>
>;

export type AdminServiceDeleteAlertMutationError = RpcStatus;

export const createAdminServiceDeleteAlert = <
  TError = RpcStatus,
  TContext = unknown,
>(options?: {
  mutation?: CreateMutationOptions<
    Awaited<ReturnType<typeof adminServiceDeleteAlert>>,
    TError,
    { organization: string; project: string; name: string },
    TContext
  >;
}) => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof adminServiceDeleteAlert>>,
    { organization: string; project: string; name: string }
  > = (props) => {
    const { organization, project, name } = props ?? {};

    return adminServiceDeleteAlert(organization, project, name);
  };

  return createMutation<
    Awaited<ReturnType<typeof adminServiceDeleteAlert>>,
    TError,
    { organization: string; project: string; name: string },
    TContext
  >(mutationFn, mutationOptions);
};
/**
 * @summary EditAlert edits a virtual file for a UI-managed alert, triggers a reconcile, and waits for the alert to be updated in the runtime
 */
export const adminServiceEditAlert = (
  organization: string,
  project: string,
  name: string,
  adminServiceCreateAlertBodyBody: AdminServiceCreateAlertBodyBody,
) => {
  return httpClient<V1EditAlertResponse>({
    url: `/v1/organizations/${organization}/projects/${project}/alerts/${name}`,
    method: "put",
    headers: { "Content-Type": "application/json" },
    data: adminServiceCreateAlertBodyBody,
  });
};

export type AdminServiceEditAlertMutationResult = NonNullable<
  Awaited<ReturnType<typeof adminServiceEditAlert>>
>;
export type AdminServiceEditAlertMutationBody = AdminServiceCreateAlertBodyBody;
export type AdminServiceEditAlertMutationError = RpcStatus;

export const createAdminServiceEditAlert = <
  TError = RpcStatus,
  TContext = unknown,
>(options?: {
  mutation?: CreateMutationOptions<
    Awaited<ReturnType<typeof adminServiceEditAlert>>,
    TError,
    {
      organization: string;
      project: string;
      name: string;
      data: AdminServiceCreateAlertBodyBody;
    },
    TContext
  >;
}) => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof adminServiceEditAlert>>,
    {
      organization: string;
      project: string;
      name: string;
      data: AdminServiceCreateAlertBodyBody;
    }
  > = (props) => {
    const { organization, project, name, data } = props ?? {};

    return adminServiceEditAlert(organization, project, name, data);
  };

  return createMutation<
    Awaited<ReturnType<typeof adminServiceEditAlert>>,
    TError,
    {
      organization: string;
      project: string;
      name: string;
      data: AdminServiceCreateAlertBodyBody;
    },
    TContext
  >(mutationFn, mutationOptions);
};
/**
 * @summary UnsubscribeAlert removes the calling user from a alert's recipients list
 */
export const adminServiceUnsubscribeAlert = (
  organization: string,
  project: string,
  name: string,
  adminServiceTriggerReconcileBodyBody: AdminServiceTriggerReconcileBodyBody,
) => {
  return httpClient<V1UnsubscribeAlertResponse>({
    url: `/v1/organizations/${organization}/projects/${project}/alerts/${name}/unsubscribe`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: adminServiceTriggerReconcileBodyBody,
  });
};

export type AdminServiceUnsubscribeAlertMutationResult = NonNullable<
  Awaited<ReturnType<typeof adminServiceUnsubscribeAlert>>
>;
export type AdminServiceUnsubscribeAlertMutationBody =
  AdminServiceTriggerReconcileBodyBody;
export type AdminServiceUnsubscribeAlertMutationError = RpcStatus;

export const createAdminServiceUnsubscribeAlert = <
  TError = RpcStatus,
  TContext = unknown,
>(options?: {
  mutation?: CreateMutationOptions<
    Awaited<ReturnType<typeof adminServiceUnsubscribeAlert>>,
    TError,
    {
      organization: string;
      project: string;
      name: string;
      data: AdminServiceTriggerReconcileBodyBody;
    },
    TContext
  >;
}) => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof adminServiceUnsubscribeAlert>>,
    {
      organization: string;
      project: string;
      name: string;
      data: AdminServiceTriggerReconcileBodyBody;
    }
  > = (props) => {
    const { organization, project, name, data } = props ?? {};

    return adminServiceUnsubscribeAlert(organization, project, name, data);
  };

  return createMutation<
    Awaited<ReturnType<typeof adminServiceUnsubscribeAlert>>,
    TError,
    {
      organization: string;
      project: string;
      name: string;
      data: AdminServiceTriggerReconcileBodyBody;
    },
    TContext
  >(mutationFn, mutationOptions);
};
/**
 * @summary GenerateAlertYAML generates YAML for an alert to be copied into a project's Git repository
 */
export const adminServiceGetAlertYAML = (
  organization: string,
  project: string,
  name: string,
  signal?: AbortSignal,
) => {
  return httpClient<V1GetAlertYAMLResponse>({
    url: `/v1/organizations/${organization}/projects/${project}/alerts/${name}/yaml`,
    method: "get",
    signal,
  });
};

export const getAdminServiceGetAlertYAMLQueryKey = (
  organization: string,
  project: string,
  name: string,
) => [
  `/v1/organizations/${organization}/projects/${project}/alerts/${name}/yaml`,
];

export type AdminServiceGetAlertYAMLQueryResult = NonNullable<
  Awaited<ReturnType<typeof adminServiceGetAlertYAML>>
>;
export type AdminServiceGetAlertYAMLQueryError = RpcStatus;

export const createAdminServiceGetAlertYAML = <
  TData = Awaited<ReturnType<typeof adminServiceGetAlertYAML>>,
  TError = RpcStatus,
>(
  organization: string,
  project: string,
  name: string,
  options?: {
    query?: CreateQueryOptions<
      Awaited<ReturnType<typeof adminServiceGetAlertYAML>>,
      TError,
      TData
    >;
  },
): CreateQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getAdminServiceGetAlertYAMLQueryKey(organization, project, name);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof adminServiceGetAlertYAML>>
  > = ({ signal }) =>
    adminServiceGetAlertYAML(organization, project, name, signal);

  const query = createQuery<
    Awaited<ReturnType<typeof adminServiceGetAlertYAML>>,
    TError,
    TData
  >({
    queryKey,
    queryFn,
    enabled: !!(organization && project && name),
    ...queryOptions,
  }) as CreateQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
};

/**
 * @summary GetCloneCredentials returns credentials and other details for a project's Git repository or archive path if git repo is not configured.
 */
export const adminServiceGetCloneCredentials = (
  organization: string,
  project: string,
  signal?: AbortSignal,
) => {
  return httpClient<V1GetCloneCredentialsResponse>({
    url: `/v1/organizations/${organization}/projects/${project}/clone-credentials`,
    method: "get",
    signal,
  });
};

export const getAdminServiceGetCloneCredentialsQueryKey = (
  organization: string,
  project: string,
) => [
  `/v1/organizations/${organization}/projects/${project}/clone-credentials`,
];

export type AdminServiceGetCloneCredentialsQueryResult = NonNullable<
  Awaited<ReturnType<typeof adminServiceGetCloneCredentials>>
>;
export type AdminServiceGetCloneCredentialsQueryError = RpcStatus;

export const createAdminServiceGetCloneCredentials = <
  TData = Awaited<ReturnType<typeof adminServiceGetCloneCredentials>>,
  TError = RpcStatus,
>(
  organization: string,
  project: string,
  options?: {
    query?: CreateQueryOptions<
      Awaited<ReturnType<typeof adminServiceGetCloneCredentials>>,
      TError,
      TData
    >;
  },
): CreateQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getAdminServiceGetCloneCredentialsQueryKey(organization, project);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof adminServiceGetCloneCredentials>>
  > = ({ signal }) =>
    adminServiceGetCloneCredentials(organization, project, signal);

  const query = createQuery<
    Awaited<ReturnType<typeof adminServiceGetCloneCredentials>>,
    TError,
    TData
  >({
    queryKey,
    queryFn,
    enabled: !!(organization && project),
    ...queryOptions,
  }) as CreateQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
};

/**
 * @summary Connects a rill managed project to github.
Replaces the contents of the remote repo with the contents of the project.
 */
export const adminServiceConnectProjectToGithub = (
  organization: string,
  project: string,
  adminServiceConnectProjectToGithubBody: AdminServiceConnectProjectToGithubBody,
) => {
  return httpClient<V1ConnectProjectToGithubResponse>({
    url: `/v1/organizations/${organization}/projects/${project}/connect-to-github`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: adminServiceConnectProjectToGithubBody,
  });
};

export type AdminServiceConnectProjectToGithubMutationResult = NonNullable<
  Awaited<ReturnType<typeof adminServiceConnectProjectToGithub>>
>;
export type AdminServiceConnectProjectToGithubMutationBody =
  AdminServiceConnectProjectToGithubBody;
export type AdminServiceConnectProjectToGithubMutationError = RpcStatus;

export const createAdminServiceConnectProjectToGithub = <
  TError = RpcStatus,
  TContext = unknown,
>(options?: {
  mutation?: CreateMutationOptions<
    Awaited<ReturnType<typeof adminServiceConnectProjectToGithub>>,
    TError,
    {
      organization: string;
      project: string;
      data: AdminServiceConnectProjectToGithubBody;
    },
    TContext
  >;
}) => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof adminServiceConnectProjectToGithub>>,
    {
      organization: string;
      project: string;
      data: AdminServiceConnectProjectToGithubBody;
    }
  > = (props) => {
    const { organization, project, data } = props ?? {};

    return adminServiceConnectProjectToGithub(organization, project, data);
  };

  return createMutation<
    Awaited<ReturnType<typeof adminServiceConnectProjectToGithub>>,
    TError,
    {
      organization: string;
      project: string;
      data: AdminServiceConnectProjectToGithubBody;
    },
    TContext
  >(mutationFn, mutationOptions);
};
/**
 * @summary GetDeploymentCredentials returns runtime info and access token on behalf of a specific user, or alternatively for a raw set of JWT attributes
 */
export const adminServiceGetDeploymentCredentials = (
  organization: string,
  project: string,
  adminServiceGetDeploymentCredentialsBody: AdminServiceGetDeploymentCredentialsBody,
) => {
  return httpClient<V1GetDeploymentCredentialsResponse>({
    url: `/v1/organizations/${organization}/projects/${project}/credentials`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: adminServiceGetDeploymentCredentialsBody,
  });
};

export const getAdminServiceGetDeploymentCredentialsQueryKey = (
  organization: string,
  project: string,
  adminServiceGetDeploymentCredentialsBody: AdminServiceGetDeploymentCredentialsBody,
) => [
  `/v1/organizations/${organization}/projects/${project}/credentials`,
  adminServiceGetDeploymentCredentialsBody,
];

export type AdminServiceGetDeploymentCredentialsQueryResult = NonNullable<
  Awaited<ReturnType<typeof adminServiceGetDeploymentCredentials>>
>;
export type AdminServiceGetDeploymentCredentialsQueryError = RpcStatus;

export const createAdminServiceGetDeploymentCredentials = <
  TData = Awaited<ReturnType<typeof adminServiceGetDeploymentCredentials>>,
  TError = RpcStatus,
>(
  organization: string,
  project: string,
  adminServiceGetDeploymentCredentialsBody: AdminServiceGetDeploymentCredentialsBody,
  options?: {
    query?: CreateQueryOptions<
      Awaited<ReturnType<typeof adminServiceGetDeploymentCredentials>>,
      TError,
      TData
    >;
  },
): CreateQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getAdminServiceGetDeploymentCredentialsQueryKey(
      organization,
      project,
      adminServiceGetDeploymentCredentialsBody,
    );

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof adminServiceGetDeploymentCredentials>>
  > = () =>
    adminServiceGetDeploymentCredentials(
      organization,
      project,
      adminServiceGetDeploymentCredentialsBody,
    );

  const query = createQuery<
    Awaited<ReturnType<typeof adminServiceGetDeploymentCredentials>>,
    TError,
    TData
  >({
    queryKey,
    queryFn,
    enabled: !!(organization && project),
    ...queryOptions,
  }) as CreateQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
};

/**
 * @summary HibernateProject hibernates a project by tearing down its deployments.
 */
export const adminServiceHibernateProject = (
  organization: string,
  project: string,
) => {
  return httpClient<V1HibernateProjectResponse>({
    url: `/v1/organizations/${organization}/projects/${project}/hibernate`,
    method: "post",
  });
};

export type AdminServiceHibernateProjectMutationResult = NonNullable<
  Awaited<ReturnType<typeof adminServiceHibernateProject>>
>;

export type AdminServiceHibernateProjectMutationError = RpcStatus;

export const createAdminServiceHibernateProject = <
  TError = RpcStatus,
  TContext = unknown,
>(options?: {
  mutation?: CreateMutationOptions<
    Awaited<ReturnType<typeof adminServiceHibernateProject>>,
    TError,
    { organization: string; project: string },
    TContext
  >;
}) => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof adminServiceHibernateProject>>,
    { organization: string; project: string }
  > = (props) => {
    const { organization, project } = props ?? {};

    return adminServiceHibernateProject(organization, project);
  };

  return createMutation<
    Awaited<ReturnType<typeof adminServiceHibernateProject>>,
    TError,
    { organization: string; project: string },
    TContext
  >(mutationFn, mutationOptions);
};
/**
 * @summary GetIFrame returns the iframe URL for the given project
 */
export const adminServiceGetIFrame = (
  organization: string,
  project: string,
  adminServiceGetIFrameBody: AdminServiceGetIFrameBody,
) => {
  return httpClient<V1GetIFrameResponse>({
    url: `/v1/organizations/${organization}/projects/${project}/iframe`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: adminServiceGetIFrameBody,
  });
};

export type AdminServiceGetIFrameMutationResult = NonNullable<
  Awaited<ReturnType<typeof adminServiceGetIFrame>>
>;
export type AdminServiceGetIFrameMutationBody = AdminServiceGetIFrameBody;
export type AdminServiceGetIFrameMutationError = RpcStatus;

export const createAdminServiceGetIFrame = <
  TError = RpcStatus,
  TContext = unknown,
>(options?: {
  mutation?: CreateMutationOptions<
    Awaited<ReturnType<typeof adminServiceGetIFrame>>,
    TError,
    { organization: string; project: string; data: AdminServiceGetIFrameBody },
    TContext
  >;
}) => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof adminServiceGetIFrame>>,
    { organization: string; project: string; data: AdminServiceGetIFrameBody }
  > = (props) => {
    const { organization, project, data } = props ?? {};

    return adminServiceGetIFrame(organization, project, data);
  };

  return createMutation<
    Awaited<ReturnType<typeof adminServiceGetIFrame>>,
    TError,
    { organization: string; project: string; data: AdminServiceGetIFrameBody },
    TContext
  >(mutationFn, mutationOptions);
};
/**
 * @summary ListProjectInvites lists all the project invites
 */
export const adminServiceListProjectInvites = (
  organization: string,
  project: string,
  params?: AdminServiceListProjectInvitesParams,
  signal?: AbortSignal,
) => {
  return httpClient<V1ListProjectInvitesResponse>({
    url: `/v1/organizations/${organization}/projects/${project}/invites`,
    method: "get",
    params,
    signal,
  });
};

export const getAdminServiceListProjectInvitesQueryKey = (
  organization: string,
  project: string,
  params?: AdminServiceListProjectInvitesParams,
) => [
  `/v1/organizations/${organization}/projects/${project}/invites`,
  ...(params ? [params] : []),
];

export type AdminServiceListProjectInvitesQueryResult = NonNullable<
  Awaited<ReturnType<typeof adminServiceListProjectInvites>>
>;
export type AdminServiceListProjectInvitesQueryError = RpcStatus;

export const createAdminServiceListProjectInvites = <
  TData = Awaited<ReturnType<typeof adminServiceListProjectInvites>>,
  TError = RpcStatus,
>(
  organization: string,
  project: string,
  params?: AdminServiceListProjectInvitesParams,
  options?: {
    query?: CreateQueryOptions<
      Awaited<ReturnType<typeof adminServiceListProjectInvites>>,
      TError,
      TData
    >;
  },
): CreateQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getAdminServiceListProjectInvitesQueryKey(organization, project, params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof adminServiceListProjectInvites>>
  > = ({ signal }) =>
    adminServiceListProjectInvites(organization, project, params, signal);

  const query = createQuery<
    Awaited<ReturnType<typeof adminServiceListProjectInvites>>,
    TError,
    TData
  >({
    queryKey,
    queryFn,
    enabled: !!(organization && project),
    ...queryOptions,
  }) as CreateQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
};

/**
 * @summary ListProjectMemberUsers lists all the project members
 */
export const adminServiceListProjectMemberUsers = (
  organization: string,
  project: string,
  params?: AdminServiceListProjectMemberUsersParams,
  signal?: AbortSignal,
) => {
  return httpClient<V1ListProjectMemberUsersResponse>({
    url: `/v1/organizations/${organization}/projects/${project}/members`,
    method: "get",
    params,
    signal,
  });
};

export const getAdminServiceListProjectMemberUsersQueryKey = (
  organization: string,
  project: string,
  params?: AdminServiceListProjectMemberUsersParams,
) => [
  `/v1/organizations/${organization}/projects/${project}/members`,
  ...(params ? [params] : []),
];

export type AdminServiceListProjectMemberUsersQueryResult = NonNullable<
  Awaited<ReturnType<typeof adminServiceListProjectMemberUsers>>
>;
export type AdminServiceListProjectMemberUsersQueryError = RpcStatus;

export const createAdminServiceListProjectMemberUsers = <
  TData = Awaited<ReturnType<typeof adminServiceListProjectMemberUsers>>,
  TError = RpcStatus,
>(
  organization: string,
  project: string,
  params?: AdminServiceListProjectMemberUsersParams,
  options?: {
    query?: CreateQueryOptions<
      Awaited<ReturnType<typeof adminServiceListProjectMemberUsers>>,
      TError,
      TData
    >;
  },
): CreateQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getAdminServiceListProjectMemberUsersQueryKey(
      organization,
      project,
      params,
    );

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof adminServiceListProjectMemberUsers>>
  > = ({ signal }) =>
    adminServiceListProjectMemberUsers(organization, project, params, signal);

  const query = createQuery<
    Awaited<ReturnType<typeof adminServiceListProjectMemberUsers>>,
    TError,
    TData
  >({
    queryKey,
    queryFn,
    enabled: !!(organization && project),
    ...queryOptions,
  }) as CreateQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
};

/**
 * @summary AddProjectMemberUser adds a member to the project
 */
export const adminServiceAddProjectMemberUser = (
  organization: string,
  project: string,
  adminServiceAddProjectMemberUserBody: AdminServiceAddProjectMemberUserBody,
) => {
  return httpClient<V1AddProjectMemberUserResponse>({
    url: `/v1/organizations/${organization}/projects/${project}/members`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: adminServiceAddProjectMemberUserBody,
  });
};

export type AdminServiceAddProjectMemberUserMutationResult = NonNullable<
  Awaited<ReturnType<typeof adminServiceAddProjectMemberUser>>
>;
export type AdminServiceAddProjectMemberUserMutationBody =
  AdminServiceAddProjectMemberUserBody;
export type AdminServiceAddProjectMemberUserMutationError = RpcStatus;

export const createAdminServiceAddProjectMemberUser = <
  TError = RpcStatus,
  TContext = unknown,
>(options?: {
  mutation?: CreateMutationOptions<
    Awaited<ReturnType<typeof adminServiceAddProjectMemberUser>>,
    TError,
    {
      organization: string;
      project: string;
      data: AdminServiceAddProjectMemberUserBody;
    },
    TContext
  >;
}) => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof adminServiceAddProjectMemberUser>>,
    {
      organization: string;
      project: string;
      data: AdminServiceAddProjectMemberUserBody;
    }
  > = (props) => {
    const { organization, project, data } = props ?? {};

    return adminServiceAddProjectMemberUser(organization, project, data);
  };

  return createMutation<
    Awaited<ReturnType<typeof adminServiceAddProjectMemberUser>>,
    TError,
    {
      organization: string;
      project: string;
      data: AdminServiceAddProjectMemberUserBody;
    },
    TContext
  >(mutationFn, mutationOptions);
};
/**
 * @summary RemoveProjectMemberUser removes member from the project
 */
export const adminServiceRemoveProjectMemberUser = (
  organization: string,
  project: string,
  email: string,
) => {
  return httpClient<V1RemoveProjectMemberUserResponse>({
    url: `/v1/organizations/${organization}/projects/${project}/members/${email}`,
    method: "delete",
  });
};

export type AdminServiceRemoveProjectMemberUserMutationResult = NonNullable<
  Awaited<ReturnType<typeof adminServiceRemoveProjectMemberUser>>
>;

export type AdminServiceRemoveProjectMemberUserMutationError = RpcStatus;

export const createAdminServiceRemoveProjectMemberUser = <
  TError = RpcStatus,
  TContext = unknown,
>(options?: {
  mutation?: CreateMutationOptions<
    Awaited<ReturnType<typeof adminServiceRemoveProjectMemberUser>>,
    TError,
    { organization: string; project: string; email: string },
    TContext
  >;
}) => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof adminServiceRemoveProjectMemberUser>>,
    { organization: string; project: string; email: string }
  > = (props) => {
    const { organization, project, email } = props ?? {};

    return adminServiceRemoveProjectMemberUser(organization, project, email);
  };

  return createMutation<
    Awaited<ReturnType<typeof adminServiceRemoveProjectMemberUser>>,
    TError,
    { organization: string; project: string; email: string },
    TContext
  >(mutationFn, mutationOptions);
};
/**
 * @summary SetProjectMemberUserRole sets the role for the member
 */
export const adminServiceSetProjectMemberUserRole = (
  organization: string,
  project: string,
  email: string,
  adminServiceSetOrganizationMemberUserRoleBodyBody: AdminServiceSetOrganizationMemberUserRoleBodyBody,
) => {
  return httpClient<V1SetProjectMemberUserRoleResponse>({
    url: `/v1/organizations/${organization}/projects/${project}/members/${email}`,
    method: "put",
    headers: { "Content-Type": "application/json" },
    data: adminServiceSetOrganizationMemberUserRoleBodyBody,
  });
};

export type AdminServiceSetProjectMemberUserRoleMutationResult = NonNullable<
  Awaited<ReturnType<typeof adminServiceSetProjectMemberUserRole>>
>;
export type AdminServiceSetProjectMemberUserRoleMutationBody =
  AdminServiceSetOrganizationMemberUserRoleBodyBody;
export type AdminServiceSetProjectMemberUserRoleMutationError = RpcStatus;

export const createAdminServiceSetProjectMemberUserRole = <
  TError = RpcStatus,
  TContext = unknown,
>(options?: {
  mutation?: CreateMutationOptions<
    Awaited<ReturnType<typeof adminServiceSetProjectMemberUserRole>>,
    TError,
    {
      organization: string;
      project: string;
      email: string;
      data: AdminServiceSetOrganizationMemberUserRoleBodyBody;
    },
    TContext
  >;
}) => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof adminServiceSetProjectMemberUserRole>>,
    {
      organization: string;
      project: string;
      email: string;
      data: AdminServiceSetOrganizationMemberUserRoleBodyBody;
    }
  > = (props) => {
    const { organization, project, email, data } = props ?? {};

    return adminServiceSetProjectMemberUserRole(
      organization,
      project,
      email,
      data,
    );
  };

  return createMutation<
    Awaited<ReturnType<typeof adminServiceSetProjectMemberUserRole>>,
    TError,
    {
      organization: string;
      project: string;
      email: string;
      data: AdminServiceSetOrganizationMemberUserRoleBodyBody;
    },
    TContext
  >(mutationFn, mutationOptions);
};
/**
 * @summary RedeployProject creates a new production deployment for a project.
If the project currently has another production deployment, the old deployment will be deprovisioned.
This RPC can be used to redeploy a project that has been hibernated.
 */
export const adminServiceRedeployProject = (
  organization: string,
  project: string,
) => {
  return httpClient<V1RedeployProjectResponse>({
    url: `/v1/organizations/${organization}/projects/${project}/redeploy`,
    method: "post",
  });
};

export type AdminServiceRedeployProjectMutationResult = NonNullable<
  Awaited<ReturnType<typeof adminServiceRedeployProject>>
>;

export type AdminServiceRedeployProjectMutationError = RpcStatus;

export const createAdminServiceRedeployProject = <
  TError = RpcStatus,
  TContext = unknown,
>(options?: {
  mutation?: CreateMutationOptions<
    Awaited<ReturnType<typeof adminServiceRedeployProject>>,
    TError,
    { organization: string; project: string },
    TContext
  >;
}) => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof adminServiceRedeployProject>>,
    { organization: string; project: string }
  > = (props) => {
    const { organization, project } = props ?? {};

    return adminServiceRedeployProject(organization, project);
  };

  return createMutation<
    Awaited<ReturnType<typeof adminServiceRedeployProject>>,
    TError,
    { organization: string; project: string },
    TContext
  >(mutationFn, mutationOptions);
};
/**
 * @summary CreateReport adds a virtual file for a report, triggers a reconcile, and waits for the report to be added to the runtime catalog
 */
export const adminServiceCreateReport = (
  organization: string,
  project: string,
  adminServiceCreateReportBodyBody: AdminServiceCreateReportBodyBody,
) => {
  return httpClient<V1CreateReportResponse>({
    url: `/v1/organizations/${organization}/projects/${project}/reports`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: adminServiceCreateReportBodyBody,
  });
};

export type AdminServiceCreateReportMutationResult = NonNullable<
  Awaited<ReturnType<typeof adminServiceCreateReport>>
>;
export type AdminServiceCreateReportMutationBody =
  AdminServiceCreateReportBodyBody;
export type AdminServiceCreateReportMutationError = RpcStatus;

export const createAdminServiceCreateReport = <
  TError = RpcStatus,
  TContext = unknown,
>(options?: {
  mutation?: CreateMutationOptions<
    Awaited<ReturnType<typeof adminServiceCreateReport>>,
    TError,
    {
      organization: string;
      project: string;
      data: AdminServiceCreateReportBodyBody;
    },
    TContext
  >;
}) => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof adminServiceCreateReport>>,
    {
      organization: string;
      project: string;
      data: AdminServiceCreateReportBodyBody;
    }
  > = (props) => {
    const { organization, project, data } = props ?? {};

    return adminServiceCreateReport(organization, project, data);
  };

  return createMutation<
    Awaited<ReturnType<typeof adminServiceCreateReport>>,
    TError,
    {
      organization: string;
      project: string;
      data: AdminServiceCreateReportBodyBody;
    },
    TContext
  >(mutationFn, mutationOptions);
};
/**
 * @summary GenerateReportYAML generates YAML for a scheduled report to be copied into a project's Git repository
 */
export const adminServiceGenerateReportYAML = (
  organization: string,
  project: string,
  adminServiceCreateReportBodyBody: AdminServiceCreateReportBodyBody,
) => {
  return httpClient<V1GenerateReportYAMLResponse>({
    url: `/v1/organizations/${organization}/projects/${project}/reports/-/yaml`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: adminServiceCreateReportBodyBody,
  });
};

export const getAdminServiceGenerateReportYAMLQueryKey = (
  organization: string,
  project: string,
  adminServiceCreateReportBodyBody: AdminServiceCreateReportBodyBody,
) => [
  `/v1/organizations/${organization}/projects/${project}/reports/-/yaml`,
  adminServiceCreateReportBodyBody,
];

export type AdminServiceGenerateReportYAMLQueryResult = NonNullable<
  Awaited<ReturnType<typeof adminServiceGenerateReportYAML>>
>;
export type AdminServiceGenerateReportYAMLQueryError = RpcStatus;

export const createAdminServiceGenerateReportYAML = <
  TData = Awaited<ReturnType<typeof adminServiceGenerateReportYAML>>,
  TError = RpcStatus,
>(
  organization: string,
  project: string,
  adminServiceCreateReportBodyBody: AdminServiceCreateReportBodyBody,
  options?: {
    query?: CreateQueryOptions<
      Awaited<ReturnType<typeof adminServiceGenerateReportYAML>>,
      TError,
      TData
    >;
  },
): CreateQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getAdminServiceGenerateReportYAMLQueryKey(
      organization,
      project,
      adminServiceCreateReportBodyBody,
    );

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof adminServiceGenerateReportYAML>>
  > = () =>
    adminServiceGenerateReportYAML(
      organization,
      project,
      adminServiceCreateReportBodyBody,
    );

  const query = createQuery<
    Awaited<ReturnType<typeof adminServiceGenerateReportYAML>>,
    TError,
    TData
  >({
    queryKey,
    queryFn,
    enabled: !!(organization && project),
    ...queryOptions,
  }) as CreateQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
};

/**
 * @summary DeleteReport deletes the virtual file for a UI-managed report, triggers a reconcile, and waits for the report to be deleted in the runtime
 */
export const adminServiceDeleteReport = (
  organization: string,
  project: string,
  name: string,
) => {
  return httpClient<V1DeleteReportResponse>({
    url: `/v1/organizations/${organization}/projects/${project}/reports/${name}`,
    method: "delete",
  });
};

export type AdminServiceDeleteReportMutationResult = NonNullable<
  Awaited<ReturnType<typeof adminServiceDeleteReport>>
>;

export type AdminServiceDeleteReportMutationError = RpcStatus;

export const createAdminServiceDeleteReport = <
  TError = RpcStatus,
  TContext = unknown,
>(options?: {
  mutation?: CreateMutationOptions<
    Awaited<ReturnType<typeof adminServiceDeleteReport>>,
    TError,
    { organization: string; project: string; name: string },
    TContext
  >;
}) => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof adminServiceDeleteReport>>,
    { organization: string; project: string; name: string }
  > = (props) => {
    const { organization, project, name } = props ?? {};

    return adminServiceDeleteReport(organization, project, name);
  };

  return createMutation<
    Awaited<ReturnType<typeof adminServiceDeleteReport>>,
    TError,
    { organization: string; project: string; name: string },
    TContext
  >(mutationFn, mutationOptions);
};
/**
 * @summary EditReport edits a virtual file for a UI-managed report, triggers a reconcile, and waits for the report to be updated in the runtime
 */
export const adminServiceEditReport = (
  organization: string,
  project: string,
  name: string,
  adminServiceCreateReportBodyBody: AdminServiceCreateReportBodyBody,
) => {
  return httpClient<V1EditReportResponse>({
    url: `/v1/organizations/${organization}/projects/${project}/reports/${name}`,
    method: "put",
    headers: { "Content-Type": "application/json" },
    data: adminServiceCreateReportBodyBody,
  });
};

export type AdminServiceEditReportMutationResult = NonNullable<
  Awaited<ReturnType<typeof adminServiceEditReport>>
>;
export type AdminServiceEditReportMutationBody =
  AdminServiceCreateReportBodyBody;
export type AdminServiceEditReportMutationError = RpcStatus;

export const createAdminServiceEditReport = <
  TError = RpcStatus,
  TContext = unknown,
>(options?: {
  mutation?: CreateMutationOptions<
    Awaited<ReturnType<typeof adminServiceEditReport>>,
    TError,
    {
      organization: string;
      project: string;
      name: string;
      data: AdminServiceCreateReportBodyBody;
    },
    TContext
  >;
}) => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof adminServiceEditReport>>,
    {
      organization: string;
      project: string;
      name: string;
      data: AdminServiceCreateReportBodyBody;
    }
  > = (props) => {
    const { organization, project, name, data } = props ?? {};

    return adminServiceEditReport(organization, project, name, data);
  };

  return createMutation<
    Awaited<ReturnType<typeof adminServiceEditReport>>,
    TError,
    {
      organization: string;
      project: string;
      name: string;
      data: AdminServiceCreateReportBodyBody;
    },
    TContext
  >(mutationFn, mutationOptions);
};
/**
 * @summary TriggerReport triggers an ad-hoc report run
 */
export const adminServiceTriggerReport = (
  organization: string,
  project: string,
  name: string,
  adminServiceTriggerReconcileBodyBody: AdminServiceTriggerReconcileBodyBody,
) => {
  return httpClient<V1TriggerReportResponse>({
    url: `/v1/organizations/${organization}/projects/${project}/reports/${name}/trigger`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: adminServiceTriggerReconcileBodyBody,
  });
};

export type AdminServiceTriggerReportMutationResult = NonNullable<
  Awaited<ReturnType<typeof adminServiceTriggerReport>>
>;
export type AdminServiceTriggerReportMutationBody =
  AdminServiceTriggerReconcileBodyBody;
export type AdminServiceTriggerReportMutationError = RpcStatus;

export const createAdminServiceTriggerReport = <
  TError = RpcStatus,
  TContext = unknown,
>(options?: {
  mutation?: CreateMutationOptions<
    Awaited<ReturnType<typeof adminServiceTriggerReport>>,
    TError,
    {
      organization: string;
      project: string;
      name: string;
      data: AdminServiceTriggerReconcileBodyBody;
    },
    TContext
  >;
}) => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof adminServiceTriggerReport>>,
    {
      organization: string;
      project: string;
      name: string;
      data: AdminServiceTriggerReconcileBodyBody;
    }
  > = (props) => {
    const { organization, project, name, data } = props ?? {};

    return adminServiceTriggerReport(organization, project, name, data);
  };

  return createMutation<
    Awaited<ReturnType<typeof adminServiceTriggerReport>>,
    TError,
    {
      organization: string;
      project: string;
      name: string;
      data: AdminServiceTriggerReconcileBodyBody;
    },
    TContext
  >(mutationFn, mutationOptions);
};
/**
 * @summary UnsubscribeReport removes the calling user from a reports recipients list
 */
export const adminServiceUnsubscribeReport = (
  organization: string,
  project: string,
  name: string,
  adminServiceTriggerReconcileBodyBody: AdminServiceTriggerReconcileBodyBody,
) => {
  return httpClient<V1UnsubscribeReportResponse>({
    url: `/v1/organizations/${organization}/projects/${project}/reports/${name}/unsubscribe`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: adminServiceTriggerReconcileBodyBody,
  });
};

export type AdminServiceUnsubscribeReportMutationResult = NonNullable<
  Awaited<ReturnType<typeof adminServiceUnsubscribeReport>>
>;
export type AdminServiceUnsubscribeReportMutationBody =
  AdminServiceTriggerReconcileBodyBody;
export type AdminServiceUnsubscribeReportMutationError = RpcStatus;

export const createAdminServiceUnsubscribeReport = <
  TError = RpcStatus,
  TContext = unknown,
>(options?: {
  mutation?: CreateMutationOptions<
    Awaited<ReturnType<typeof adminServiceUnsubscribeReport>>,
    TError,
    {
      organization: string;
      project: string;
      name: string;
      data: AdminServiceTriggerReconcileBodyBody;
    },
    TContext
  >;
}) => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof adminServiceUnsubscribeReport>>,
    {
      organization: string;
      project: string;
      name: string;
      data: AdminServiceTriggerReconcileBodyBody;
    }
  > = (props) => {
    const { organization, project, name, data } = props ?? {};

    return adminServiceUnsubscribeReport(organization, project, name, data);
  };

  return createMutation<
    Awaited<ReturnType<typeof adminServiceUnsubscribeReport>>,
    TError,
    {
      organization: string;
      project: string;
      name: string;
      data: AdminServiceTriggerReconcileBodyBody;
    },
    TContext
  >(mutationFn, mutationOptions);
};
export const adminServiceRequestProjectAccess = (
  organization: string,
  project: string,
  adminServiceTriggerReconcileBodyBody: AdminServiceTriggerReconcileBodyBody,
) => {
  return httpClient<V1RequestProjectAccessResponse>({
    url: `/v1/organizations/${organization}/projects/${project}/request-access`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: adminServiceTriggerReconcileBodyBody,
  });
};

export type AdminServiceRequestProjectAccessMutationResult = NonNullable<
  Awaited<ReturnType<typeof adminServiceRequestProjectAccess>>
>;
export type AdminServiceRequestProjectAccessMutationBody =
  AdminServiceTriggerReconcileBodyBody;
export type AdminServiceRequestProjectAccessMutationError = RpcStatus;

export const createAdminServiceRequestProjectAccess = <
  TError = RpcStatus,
  TContext = unknown,
>(options?: {
  mutation?: CreateMutationOptions<
    Awaited<ReturnType<typeof adminServiceRequestProjectAccess>>,
    TError,
    {
      organization: string;
      project: string;
      data: AdminServiceTriggerReconcileBodyBody;
    },
    TContext
  >;
}) => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof adminServiceRequestProjectAccess>>,
    {
      organization: string;
      project: string;
      data: AdminServiceTriggerReconcileBodyBody;
    }
  > = (props) => {
    const { organization, project, data } = props ?? {};

    return adminServiceRequestProjectAccess(organization, project, data);
  };

  return createMutation<
    Awaited<ReturnType<typeof adminServiceRequestProjectAccess>>,
    TError,
    {
      organization: string;
      project: string;
      data: AdminServiceTriggerReconcileBodyBody;
    },
    TContext
  >(mutationFn, mutationOptions);
};
/**
 * @summary ListMagicAuthTokens lists all the magic auth tokens for a specific project.
 */
export const adminServiceListMagicAuthTokens = (
  organization: string,
  project: string,
  params?: AdminServiceListMagicAuthTokensParams,
  signal?: AbortSignal,
) => {
  return httpClient<V1ListMagicAuthTokensResponse>({
    url: `/v1/organizations/${organization}/projects/${project}/tokens/magic`,
    method: "get",
    params,
    signal,
  });
};

export const getAdminServiceListMagicAuthTokensQueryKey = (
  organization: string,
  project: string,
  params?: AdminServiceListMagicAuthTokensParams,
) => [
  `/v1/organizations/${organization}/projects/${project}/tokens/magic`,
  ...(params ? [params] : []),
];

export type AdminServiceListMagicAuthTokensQueryResult = NonNullable<
  Awaited<ReturnType<typeof adminServiceListMagicAuthTokens>>
>;
export type AdminServiceListMagicAuthTokensQueryError = RpcStatus;

export const createAdminServiceListMagicAuthTokens = <
  TData = Awaited<ReturnType<typeof adminServiceListMagicAuthTokens>>,
  TError = RpcStatus,
>(
  organization: string,
  project: string,
  params?: AdminServiceListMagicAuthTokensParams,
  options?: {
    query?: CreateQueryOptions<
      Awaited<ReturnType<typeof adminServiceListMagicAuthTokens>>,
      TError,
      TData
    >;
  },
): CreateQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getAdminServiceListMagicAuthTokensQueryKey(organization, project, params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof adminServiceListMagicAuthTokens>>
  > = ({ signal }) =>
    adminServiceListMagicAuthTokens(organization, project, params, signal);

  const query = createQuery<
    Awaited<ReturnType<typeof adminServiceListMagicAuthTokens>>,
    TError,
    TData
  >({
    queryKey,
    queryFn,
    enabled: !!(organization && project),
    ...queryOptions,
  }) as CreateQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
};

/**
 * @summary IssueMagicAuthToken creates a "magic" auth token that provides limited access to a specific filtered dashboard in a specific project.
 */
export const adminServiceIssueMagicAuthToken = (
  organization: string,
  project: string,
  adminServiceIssueMagicAuthTokenBody: AdminServiceIssueMagicAuthTokenBody,
) => {
  return httpClient<V1IssueMagicAuthTokenResponse>({
    url: `/v1/organizations/${organization}/projects/${project}/tokens/magic`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: adminServiceIssueMagicAuthTokenBody,
  });
};

export type AdminServiceIssueMagicAuthTokenMutationResult = NonNullable<
  Awaited<ReturnType<typeof adminServiceIssueMagicAuthToken>>
>;
export type AdminServiceIssueMagicAuthTokenMutationBody =
  AdminServiceIssueMagicAuthTokenBody;
export type AdminServiceIssueMagicAuthTokenMutationError = RpcStatus;

export const createAdminServiceIssueMagicAuthToken = <
  TError = RpcStatus,
  TContext = unknown,
>(options?: {
  mutation?: CreateMutationOptions<
    Awaited<ReturnType<typeof adminServiceIssueMagicAuthToken>>,
    TError,
    {
      organization: string;
      project: string;
      data: AdminServiceIssueMagicAuthTokenBody;
    },
    TContext
  >;
}) => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof adminServiceIssueMagicAuthToken>>,
    {
      organization: string;
      project: string;
      data: AdminServiceIssueMagicAuthTokenBody;
    }
  > = (props) => {
    const { organization, project, data } = props ?? {};

    return adminServiceIssueMagicAuthToken(organization, project, data);
  };

  return createMutation<
    Awaited<ReturnType<typeof adminServiceIssueMagicAuthToken>>,
    TError,
    {
      organization: string;
      project: string;
      data: AdminServiceIssueMagicAuthTokenBody;
    },
    TContext
  >(mutationFn, mutationOptions);
};
/**
 * @summary Converts a project connected to github to a rill managed project.
Uploads the current project to assets.
 */
export const adminServiceUploadProjectAssets = (
  organization: string,
  project: string,
  adminServiceTriggerReconcileBodyBody: AdminServiceTriggerReconcileBodyBody,
) => {
  return httpClient<V1UploadProjectAssetsResponse>({
    url: `/v1/organizations/${organization}/projects/${project}/upload-assets`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: adminServiceTriggerReconcileBodyBody,
  });
};

export type AdminServiceUploadProjectAssetsMutationResult = NonNullable<
  Awaited<ReturnType<typeof adminServiceUploadProjectAssets>>
>;
export type AdminServiceUploadProjectAssetsMutationBody =
  AdminServiceTriggerReconcileBodyBody;
export type AdminServiceUploadProjectAssetsMutationError = RpcStatus;

export const createAdminServiceUploadProjectAssets = <
  TError = RpcStatus,
  TContext = unknown,
>(options?: {
  mutation?: CreateMutationOptions<
    Awaited<ReturnType<typeof adminServiceUploadProjectAssets>>,
    TError,
    {
      organization: string;
      project: string;
      data: AdminServiceTriggerReconcileBodyBody;
    },
    TContext
  >;
}) => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof adminServiceUploadProjectAssets>>,
    {
      organization: string;
      project: string;
      data: AdminServiceTriggerReconcileBodyBody;
    }
  > = (props) => {
    const { organization, project, data } = props ?? {};

    return adminServiceUploadProjectAssets(organization, project, data);
  };

  return createMutation<
    Awaited<ReturnType<typeof adminServiceUploadProjectAssets>>,
    TError,
    {
      organization: string;
      project: string;
      data: AdminServiceTriggerReconcileBodyBody;
    },
    TContext
  >(mutationFn, mutationOptions);
};
/**
 * @summary RemoveProjectMemberUsergroup revokes the project-level role for the user group
 */
export const adminServiceRemoveProjectMemberUsergroup = (
  organization: string,
  project: string,
  usergroup: string,
) => {
  return httpClient<V1RemoveProjectMemberUsergroupResponse>({
    url: `/v1/organizations/${organization}/projects/${project}/usergroups/${usergroup}/roles`,
    method: "delete",
  });
};

export type AdminServiceRemoveProjectMemberUsergroupMutationResult =
  NonNullable<
    Awaited<ReturnType<typeof adminServiceRemoveProjectMemberUsergroup>>
  >;

export type AdminServiceRemoveProjectMemberUsergroupMutationError = RpcStatus;

export const createAdminServiceRemoveProjectMemberUsergroup = <
  TError = RpcStatus,
  TContext = unknown,
>(options?: {
  mutation?: CreateMutationOptions<
    Awaited<ReturnType<typeof adminServiceRemoveProjectMemberUsergroup>>,
    TError,
    { organization: string; project: string; usergroup: string },
    TContext
  >;
}) => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof adminServiceRemoveProjectMemberUsergroup>>,
    { organization: string; project: string; usergroup: string }
  > = (props) => {
    const { organization, project, usergroup } = props ?? {};

    return adminServiceRemoveProjectMemberUsergroup(
      organization,
      project,
      usergroup,
    );
  };

  return createMutation<
    Awaited<ReturnType<typeof adminServiceRemoveProjectMemberUsergroup>>,
    TError,
    { organization: string; project: string; usergroup: string },
    TContext
  >(mutationFn, mutationOptions);
};
/**
 * @summary AddProjectMemberUsergroupRole adds the role for the user group
 */
export const adminServiceAddProjectMemberUsergroup = (
  organization: string,
  project: string,
  usergroup: string,
  adminServiceSetOrganizationMemberUserRoleBodyBody: AdminServiceSetOrganizationMemberUserRoleBodyBody,
) => {
  return httpClient<V1AddProjectMemberUsergroupResponse>({
    url: `/v1/organizations/${organization}/projects/${project}/usergroups/${usergroup}/roles`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: adminServiceSetOrganizationMemberUserRoleBodyBody,
  });
};

export type AdminServiceAddProjectMemberUsergroupMutationResult = NonNullable<
  Awaited<ReturnType<typeof adminServiceAddProjectMemberUsergroup>>
>;
export type AdminServiceAddProjectMemberUsergroupMutationBody =
  AdminServiceSetOrganizationMemberUserRoleBodyBody;
export type AdminServiceAddProjectMemberUsergroupMutationError = RpcStatus;

export const createAdminServiceAddProjectMemberUsergroup = <
  TError = RpcStatus,
  TContext = unknown,
>(options?: {
  mutation?: CreateMutationOptions<
    Awaited<ReturnType<typeof adminServiceAddProjectMemberUsergroup>>,
    TError,
    {
      organization: string;
      project: string;
      usergroup: string;
      data: AdminServiceSetOrganizationMemberUserRoleBodyBody;
    },
    TContext
  >;
}) => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof adminServiceAddProjectMemberUsergroup>>,
    {
      organization: string;
      project: string;
      usergroup: string;
      data: AdminServiceSetOrganizationMemberUserRoleBodyBody;
    }
  > = (props) => {
    const { organization, project, usergroup, data } = props ?? {};

    return adminServiceAddProjectMemberUsergroup(
      organization,
      project,
      usergroup,
      data,
    );
  };

  return createMutation<
    Awaited<ReturnType<typeof adminServiceAddProjectMemberUsergroup>>,
    TError,
    {
      organization: string;
      project: string;
      usergroup: string;
      data: AdminServiceSetOrganizationMemberUserRoleBodyBody;
    },
    TContext
  >(mutationFn, mutationOptions);
};
/**
 * @summary SetProjectMemberUsergroupRole sets the role for the user group
 */
export const adminServiceSetProjectMemberUsergroupRole = (
  organization: string,
  project: string,
  usergroup: string,
  adminServiceSetOrganizationMemberUserRoleBodyBody: AdminServiceSetOrganizationMemberUserRoleBodyBody,
) => {
  return httpClient<V1SetProjectMemberUsergroupRoleResponse>({
    url: `/v1/organizations/${organization}/projects/${project}/usergroups/${usergroup}/roles`,
    method: "put",
    headers: { "Content-Type": "application/json" },
    data: adminServiceSetOrganizationMemberUserRoleBodyBody,
  });
};

export type AdminServiceSetProjectMemberUsergroupRoleMutationResult =
  NonNullable<
    Awaited<ReturnType<typeof adminServiceSetProjectMemberUsergroupRole>>
  >;
export type AdminServiceSetProjectMemberUsergroupRoleMutationBody =
  AdminServiceSetOrganizationMemberUserRoleBodyBody;
export type AdminServiceSetProjectMemberUsergroupRoleMutationError = RpcStatus;

export const createAdminServiceSetProjectMemberUsergroupRole = <
  TError = RpcStatus,
  TContext = unknown,
>(options?: {
  mutation?: CreateMutationOptions<
    Awaited<ReturnType<typeof adminServiceSetProjectMemberUsergroupRole>>,
    TError,
    {
      organization: string;
      project: string;
      usergroup: string;
      data: AdminServiceSetOrganizationMemberUserRoleBodyBody;
    },
    TContext
  >;
}) => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof adminServiceSetProjectMemberUsergroupRole>>,
    {
      organization: string;
      project: string;
      usergroup: string;
      data: AdminServiceSetOrganizationMemberUserRoleBodyBody;
    }
  > = (props) => {
    const { organization, project, usergroup, data } = props ?? {};

    return adminServiceSetProjectMemberUsergroupRole(
      organization,
      project,
      usergroup,
      data,
    );
  };

  return createMutation<
    Awaited<ReturnType<typeof adminServiceSetProjectMemberUsergroupRole>>,
    TError,
    {
      organization: string;
      project: string;
      usergroup: string;
      data: AdminServiceSetOrganizationMemberUserRoleBodyBody;
    },
    TContext
  >(mutationFn, mutationOptions);
};
/**
 * @summary SearchProjectUsers returns users who has access to to a project (including org members that have access through a usergroup)
 */
export const adminServiceSearchProjectUsers = (
  organization: string,
  project: string,
  params?: AdminServiceSearchProjectUsersParams,
  signal?: AbortSignal,
) => {
  return httpClient<V1SearchProjectUsersResponse>({
    url: `/v1/organizations/${organization}/projects/${project}/users/search`,
    method: "get",
    params,
    signal,
  });
};

export const getAdminServiceSearchProjectUsersQueryKey = (
  organization: string,
  project: string,
  params?: AdminServiceSearchProjectUsersParams,
) => [
  `/v1/organizations/${organization}/projects/${project}/users/search`,
  ...(params ? [params] : []),
];

export type AdminServiceSearchProjectUsersQueryResult = NonNullable<
  Awaited<ReturnType<typeof adminServiceSearchProjectUsers>>
>;
export type AdminServiceSearchProjectUsersQueryError = RpcStatus;

export const createAdminServiceSearchProjectUsers = <
  TData = Awaited<ReturnType<typeof adminServiceSearchProjectUsers>>,
  TError = RpcStatus,
>(
  organization: string,
  project: string,
  params?: AdminServiceSearchProjectUsersParams,
  options?: {
    query?: CreateQueryOptions<
      Awaited<ReturnType<typeof adminServiceSearchProjectUsers>>,
      TError,
      TData
    >;
  },
): CreateQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getAdminServiceSearchProjectUsersQueryKey(organization, project, params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof adminServiceSearchProjectUsers>>
  > = ({ signal }) =>
    adminServiceSearchProjectUsers(organization, project, params, signal);

  const query = createQuery<
    Awaited<ReturnType<typeof adminServiceSearchProjectUsers>>,
    TError,
    TData
  >({
    queryKey,
    queryFn,
    enabled: !!(organization && project),
    ...queryOptions,
  }) as CreateQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
};

/**
 * @summary GetProjectVariables returns project variables.
 */
export const adminServiceGetProjectVariables = (
  organization: string,
  project: string,
  params?: AdminServiceGetProjectVariablesParams,
  signal?: AbortSignal,
) => {
  return httpClient<V1GetProjectVariablesResponse>({
    url: `/v1/organizations/${organization}/projects/${project}/variables`,
    method: "get",
    params,
    signal,
  });
};

export const getAdminServiceGetProjectVariablesQueryKey = (
  organization: string,
  project: string,
  params?: AdminServiceGetProjectVariablesParams,
) => [
  `/v1/organizations/${organization}/projects/${project}/variables`,
  ...(params ? [params] : []),
];

export type AdminServiceGetProjectVariablesQueryResult = NonNullable<
  Awaited<ReturnType<typeof adminServiceGetProjectVariables>>
>;
export type AdminServiceGetProjectVariablesQueryError = RpcStatus;

export const createAdminServiceGetProjectVariables = <
  TData = Awaited<ReturnType<typeof adminServiceGetProjectVariables>>,
  TError = RpcStatus,
>(
  organization: string,
  project: string,
  params?: AdminServiceGetProjectVariablesParams,
  options?: {
    query?: CreateQueryOptions<
      Awaited<ReturnType<typeof adminServiceGetProjectVariables>>,
      TError,
      TData
    >;
  },
): CreateQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getAdminServiceGetProjectVariablesQueryKey(organization, project, params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof adminServiceGetProjectVariables>>
  > = ({ signal }) =>
    adminServiceGetProjectVariables(organization, project, params, signal);

  const query = createQuery<
    Awaited<ReturnType<typeof adminServiceGetProjectVariables>>,
    TError,
    TData
  >({
    queryKey,
    queryFn,
    enabled: !!(organization && project),
    ...queryOptions,
  }) as CreateQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
};

/**
 * @summary UpdateProjectVariables updates variables for a project.
 */
export const adminServiceUpdateProjectVariables = (
  organization: string,
  project: string,
  adminServiceUpdateProjectVariablesBody: AdminServiceUpdateProjectVariablesBody,
) => {
  return httpClient<V1UpdateProjectVariablesResponse>({
    url: `/v1/organizations/${organization}/projects/${project}/variables`,
    method: "put",
    headers: { "Content-Type": "application/json" },
    data: adminServiceUpdateProjectVariablesBody,
  });
};

export type AdminServiceUpdateProjectVariablesMutationResult = NonNullable<
  Awaited<ReturnType<typeof adminServiceUpdateProjectVariables>>
>;
export type AdminServiceUpdateProjectVariablesMutationBody =
  AdminServiceUpdateProjectVariablesBody;
export type AdminServiceUpdateProjectVariablesMutationError = RpcStatus;

export const createAdminServiceUpdateProjectVariables = <
  TError = RpcStatus,
  TContext = unknown,
>(options?: {
  mutation?: CreateMutationOptions<
    Awaited<ReturnType<typeof adminServiceUpdateProjectVariables>>,
    TError,
    {
      organization: string;
      project: string;
      data: AdminServiceUpdateProjectVariablesBody;
    },
    TContext
  >;
}) => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof adminServiceUpdateProjectVariables>>,
    {
      organization: string;
      project: string;
      data: AdminServiceUpdateProjectVariablesBody;
    }
  > = (props) => {
    const { organization, project, data } = props ?? {};

    return adminServiceUpdateProjectVariables(organization, project, data);
  };

  return createMutation<
    Awaited<ReturnType<typeof adminServiceUpdateProjectVariables>>,
    TError,
    {
      organization: string;
      project: string;
      data: AdminServiceUpdateProjectVariablesBody;
    },
    TContext
  >(mutationFn, mutationOptions);
};
/**
 * @summary ListWhitelistedDomains lists all the whitelisted domains of the project
 */
export const adminServiceListProjectWhitelistedDomains = (
  organization: string,
  project: string,
  signal?: AbortSignal,
) => {
  return httpClient<V1ListProjectWhitelistedDomainsResponse>({
    url: `/v1/organizations/${organization}/projects/${project}/whitelisted`,
    method: "get",
    signal,
  });
};

export const getAdminServiceListProjectWhitelistedDomainsQueryKey = (
  organization: string,
  project: string,
) => [`/v1/organizations/${organization}/projects/${project}/whitelisted`];

export type AdminServiceListProjectWhitelistedDomainsQueryResult = NonNullable<
  Awaited<ReturnType<typeof adminServiceListProjectWhitelistedDomains>>
>;
export type AdminServiceListProjectWhitelistedDomainsQueryError = RpcStatus;

export const createAdminServiceListProjectWhitelistedDomains = <
  TData = Awaited<ReturnType<typeof adminServiceListProjectWhitelistedDomains>>,
  TError = RpcStatus,
>(
  organization: string,
  project: string,
  options?: {
    query?: CreateQueryOptions<
      Awaited<ReturnType<typeof adminServiceListProjectWhitelistedDomains>>,
      TError,
      TData
    >;
  },
): CreateQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getAdminServiceListProjectWhitelistedDomainsQueryKey(organization, project);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof adminServiceListProjectWhitelistedDomains>>
  > = ({ signal }) =>
    adminServiceListProjectWhitelistedDomains(organization, project, signal);

  const query = createQuery<
    Awaited<ReturnType<typeof adminServiceListProjectWhitelistedDomains>>,
    TError,
    TData
  >({
    queryKey,
    queryFn,
    enabled: !!(organization && project),
    ...queryOptions,
  }) as CreateQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
};

/**
 * @summary CreateProjectWhitelistedDomain adds a domain to the project's whitelisted
 */
export const adminServiceCreateProjectWhitelistedDomain = (
  organization: string,
  project: string,
  adminServiceCreateProjectWhitelistedDomainBodyBody: AdminServiceCreateProjectWhitelistedDomainBodyBody,
) => {
  return httpClient<V1CreateProjectWhitelistedDomainResponse>({
    url: `/v1/organizations/${organization}/projects/${project}/whitelisted`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: adminServiceCreateProjectWhitelistedDomainBodyBody,
  });
};

export type AdminServiceCreateProjectWhitelistedDomainMutationResult =
  NonNullable<
    Awaited<ReturnType<typeof adminServiceCreateProjectWhitelistedDomain>>
  >;
export type AdminServiceCreateProjectWhitelistedDomainMutationBody =
  AdminServiceCreateProjectWhitelistedDomainBodyBody;
export type AdminServiceCreateProjectWhitelistedDomainMutationError = RpcStatus;

export const createAdminServiceCreateProjectWhitelistedDomain = <
  TError = RpcStatus,
  TContext = unknown,
>(options?: {
  mutation?: CreateMutationOptions<
    Awaited<ReturnType<typeof adminServiceCreateProjectWhitelistedDomain>>,
    TError,
    {
      organization: string;
      project: string;
      data: AdminServiceCreateProjectWhitelistedDomainBodyBody;
    },
    TContext
  >;
}) => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof adminServiceCreateProjectWhitelistedDomain>>,
    {
      organization: string;
      project: string;
      data: AdminServiceCreateProjectWhitelistedDomainBodyBody;
    }
  > = (props) => {
    const { organization, project, data } = props ?? {};

    return adminServiceCreateProjectWhitelistedDomain(
      organization,
      project,
      data,
    );
  };

  return createMutation<
    Awaited<ReturnType<typeof adminServiceCreateProjectWhitelistedDomain>>,
    TError,
    {
      organization: string;
      project: string;
      data: AdminServiceCreateProjectWhitelistedDomainBodyBody;
    },
    TContext
  >(mutationFn, mutationOptions);
};
/**
 * @summary RemoveProjectWhitelistedDomain removes a domain from the project's whitelisted
 */
export const adminServiceRemoveProjectWhitelistedDomain = (
  organization: string,
  project: string,
  domain: string,
) => {
  return httpClient<V1RemoveProjectWhitelistedDomainResponse>({
    url: `/v1/organizations/${organization}/projects/${project}/whitelisted/${domain}`,
    method: "delete",
  });
};

export type AdminServiceRemoveProjectWhitelistedDomainMutationResult =
  NonNullable<
    Awaited<ReturnType<typeof adminServiceRemoveProjectWhitelistedDomain>>
  >;

export type AdminServiceRemoveProjectWhitelistedDomainMutationError = RpcStatus;

export const createAdminServiceRemoveProjectWhitelistedDomain = <
  TError = RpcStatus,
  TContext = unknown,
>(options?: {
  mutation?: CreateMutationOptions<
    Awaited<ReturnType<typeof adminServiceRemoveProjectWhitelistedDomain>>,
    TError,
    { organization: string; project: string; domain: string },
    TContext
  >;
}) => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof adminServiceRemoveProjectWhitelistedDomain>>,
    { organization: string; project: string; domain: string }
  > = (props) => {
    const { organization, project, domain } = props ?? {};

    return adminServiceRemoveProjectWhitelistedDomain(
      organization,
      project,
      domain,
    );
  };

  return createMutation<
    Awaited<ReturnType<typeof adminServiceRemoveProjectWhitelistedDomain>>,
    TError,
    { organization: string; project: string; domain: string },
    TContext
  >(mutationFn, mutationOptions);
};
/**
 * @summary ListOrganizationMemberUsergroups lists the org's user groups
 */
export const adminServiceListOrganizationMemberUsergroups = (
  organization: string,
  params?: AdminServiceListOrganizationMemberUsergroupsParams,
  signal?: AbortSignal,
) => {
  return httpClient<V1ListOrganizationMemberUsergroupsResponse>({
    url: `/v1/organizations/${organization}/usergroups`,
    method: "get",
    params,
    signal,
  });
};

export const getAdminServiceListOrganizationMemberUsergroupsQueryKey = (
  organization: string,
  params?: AdminServiceListOrganizationMemberUsergroupsParams,
) => [
  `/v1/organizations/${organization}/usergroups`,
  ...(params ? [params] : []),
];

export type AdminServiceListOrganizationMemberUsergroupsQueryResult =
  NonNullable<
    Awaited<ReturnType<typeof adminServiceListOrganizationMemberUsergroups>>
  >;
export type AdminServiceListOrganizationMemberUsergroupsQueryError = RpcStatus;

export const createAdminServiceListOrganizationMemberUsergroups = <
  TData = Awaited<
    ReturnType<typeof adminServiceListOrganizationMemberUsergroups>
  >,
  TError = RpcStatus,
>(
  organization: string,
  params?: AdminServiceListOrganizationMemberUsergroupsParams,
  options?: {
    query?: CreateQueryOptions<
      Awaited<ReturnType<typeof adminServiceListOrganizationMemberUsergroups>>,
      TError,
      TData
    >;
  },
): CreateQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getAdminServiceListOrganizationMemberUsergroupsQueryKey(
      organization,
      params,
    );

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof adminServiceListOrganizationMemberUsergroups>>
  > = ({ signal }) =>
    adminServiceListOrganizationMemberUsergroups(organization, params, signal);

  const query = createQuery<
    Awaited<ReturnType<typeof adminServiceListOrganizationMemberUsergroups>>,
    TError,
    TData
  >({
    queryKey,
    queryFn,
    enabled: !!organization,
    ...queryOptions,
  }) as CreateQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
};

/**
 * @summary CreateUsergroup creates a user group in the organization
 */
export const adminServiceCreateUsergroup = (
  organization: string,
  adminServiceCreateUsergroupBodyBody: AdminServiceCreateUsergroupBodyBody,
) => {
  return httpClient<V1CreateUsergroupResponse>({
    url: `/v1/organizations/${organization}/usergroups`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: adminServiceCreateUsergroupBodyBody,
  });
};

export type AdminServiceCreateUsergroupMutationResult = NonNullable<
  Awaited<ReturnType<typeof adminServiceCreateUsergroup>>
>;
export type AdminServiceCreateUsergroupMutationBody =
  AdminServiceCreateUsergroupBodyBody;
export type AdminServiceCreateUsergroupMutationError = RpcStatus;

export const createAdminServiceCreateUsergroup = <
  TError = RpcStatus,
  TContext = unknown,
>(options?: {
  mutation?: CreateMutationOptions<
    Awaited<ReturnType<typeof adminServiceCreateUsergroup>>,
    TError,
    { organization: string; data: AdminServiceCreateUsergroupBodyBody },
    TContext
  >;
}) => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof adminServiceCreateUsergroup>>,
    { organization: string; data: AdminServiceCreateUsergroupBodyBody }
  > = (props) => {
    const { organization, data } = props ?? {};

    return adminServiceCreateUsergroup(organization, data);
  };

  return createMutation<
    Awaited<ReturnType<typeof adminServiceCreateUsergroup>>,
    TError,
    { organization: string; data: AdminServiceCreateUsergroupBodyBody },
    TContext
  >(mutationFn, mutationOptions);
};
/**
 * @summary GetUsergroups returns the user group details
 */
export const adminServiceGetUsergroup = (
  organization: string,
  usergroup: string,
  params?: AdminServiceGetUsergroupParams,
  signal?: AbortSignal,
) => {
  return httpClient<V1GetUsergroupResponse>({
    url: `/v1/organizations/${organization}/usergroups/${usergroup}`,
    method: "get",
    params,
    signal,
  });
};

export const getAdminServiceGetUsergroupQueryKey = (
  organization: string,
  usergroup: string,
  params?: AdminServiceGetUsergroupParams,
) => [
  `/v1/organizations/${organization}/usergroups/${usergroup}`,
  ...(params ? [params] : []),
];

export type AdminServiceGetUsergroupQueryResult = NonNullable<
  Awaited<ReturnType<typeof adminServiceGetUsergroup>>
>;
export type AdminServiceGetUsergroupQueryError = RpcStatus;

export const createAdminServiceGetUsergroup = <
  TData = Awaited<ReturnType<typeof adminServiceGetUsergroup>>,
  TError = RpcStatus,
>(
  organization: string,
  usergroup: string,
  params?: AdminServiceGetUsergroupParams,
  options?: {
    query?: CreateQueryOptions<
      Awaited<ReturnType<typeof adminServiceGetUsergroup>>,
      TError,
      TData
    >;
  },
): CreateQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getAdminServiceGetUsergroupQueryKey(organization, usergroup, params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof adminServiceGetUsergroup>>
  > = ({ signal }) =>
    adminServiceGetUsergroup(organization, usergroup, params, signal);

  const query = createQuery<
    Awaited<ReturnType<typeof adminServiceGetUsergroup>>,
    TError,
    TData
  >({
    queryKey,
    queryFn,
    enabled: !!(organization && usergroup),
    ...queryOptions,
  }) as CreateQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
};

/**
 * @summary DeleteUsergroup deletes the user group from the organization
 */
export const adminServiceDeleteUsergroup = (
  organization: string,
  usergroup: string,
) => {
  return httpClient<V1DeleteUsergroupResponse>({
    url: `/v1/organizations/${organization}/usergroups/${usergroup}`,
    method: "delete",
  });
};

export type AdminServiceDeleteUsergroupMutationResult = NonNullable<
  Awaited<ReturnType<typeof adminServiceDeleteUsergroup>>
>;

export type AdminServiceDeleteUsergroupMutationError = RpcStatus;

export const createAdminServiceDeleteUsergroup = <
  TError = RpcStatus,
  TContext = unknown,
>(options?: {
  mutation?: CreateMutationOptions<
    Awaited<ReturnType<typeof adminServiceDeleteUsergroup>>,
    TError,
    { organization: string; usergroup: string },
    TContext
  >;
}) => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof adminServiceDeleteUsergroup>>,
    { organization: string; usergroup: string }
  > = (props) => {
    const { organization, usergroup } = props ?? {};

    return adminServiceDeleteUsergroup(organization, usergroup);
  };

  return createMutation<
    Awaited<ReturnType<typeof adminServiceDeleteUsergroup>>,
    TError,
    { organization: string; usergroup: string },
    TContext
  >(mutationFn, mutationOptions);
};
/**
 * @summary RenameUsergroup renames the user group
 */
export const adminServiceRenameUsergroup = (
  organization: string,
  usergroup: string,
  adminServiceCreateUsergroupBodyBody: AdminServiceCreateUsergroupBodyBody,
) => {
  return httpClient<V1RenameUsergroupResponse>({
    url: `/v1/organizations/${organization}/usergroups/${usergroup}`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: adminServiceCreateUsergroupBodyBody,
  });
};

export type AdminServiceRenameUsergroupMutationResult = NonNullable<
  Awaited<ReturnType<typeof adminServiceRenameUsergroup>>
>;
export type AdminServiceRenameUsergroupMutationBody =
  AdminServiceCreateUsergroupBodyBody;
export type AdminServiceRenameUsergroupMutationError = RpcStatus;

export const createAdminServiceRenameUsergroup = <
  TError = RpcStatus,
  TContext = unknown,
>(options?: {
  mutation?: CreateMutationOptions<
    Awaited<ReturnType<typeof adminServiceRenameUsergroup>>,
    TError,
    {
      organization: string;
      usergroup: string;
      data: AdminServiceCreateUsergroupBodyBody;
    },
    TContext
  >;
}) => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof adminServiceRenameUsergroup>>,
    {
      organization: string;
      usergroup: string;
      data: AdminServiceCreateUsergroupBodyBody;
    }
  > = (props) => {
    const { organization, usergroup, data } = props ?? {};

    return adminServiceRenameUsergroup(organization, usergroup, data);
  };

  return createMutation<
    Awaited<ReturnType<typeof adminServiceRenameUsergroup>>,
    TError,
    {
      organization: string;
      usergroup: string;
      data: AdminServiceCreateUsergroupBodyBody;
    },
    TContext
  >(mutationFn, mutationOptions);
};
/**
 * @summary EditUsergroup renames the user group
 */
export const adminServiceEditUsergroup = (
  organization: string,
  usergroup: string,
  adminServiceEditUsergroupBody: AdminServiceEditUsergroupBody,
) => {
  return httpClient<V1EditUsergroupResponse>({
    url: `/v1/organizations/${organization}/usergroups/${usergroup}`,
    method: "put",
    headers: { "Content-Type": "application/json" },
    data: adminServiceEditUsergroupBody,
  });
};

export type AdminServiceEditUsergroupMutationResult = NonNullable<
  Awaited<ReturnType<typeof adminServiceEditUsergroup>>
>;
export type AdminServiceEditUsergroupMutationBody =
  AdminServiceEditUsergroupBody;
export type AdminServiceEditUsergroupMutationError = RpcStatus;

export const createAdminServiceEditUsergroup = <
  TError = RpcStatus,
  TContext = unknown,
>(options?: {
  mutation?: CreateMutationOptions<
    Awaited<ReturnType<typeof adminServiceEditUsergroup>>,
    TError,
    {
      organization: string;
      usergroup: string;
      data: AdminServiceEditUsergroupBody;
    },
    TContext
  >;
}) => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof adminServiceEditUsergroup>>,
    {
      organization: string;
      usergroup: string;
      data: AdminServiceEditUsergroupBody;
    }
  > = (props) => {
    const { organization, usergroup, data } = props ?? {};

    return adminServiceEditUsergroup(organization, usergroup, data);
  };

  return createMutation<
    Awaited<ReturnType<typeof adminServiceEditUsergroup>>,
    TError,
    {
      organization: string;
      usergroup: string;
      data: AdminServiceEditUsergroupBody;
    },
    TContext
  >(mutationFn, mutationOptions);
};
/**
 * @summary ListUsergroupMemberUsers lists all the user group members
 */
export const adminServiceListUsergroupMemberUsers = (
  organization: string,
  usergroup: string,
  params?: AdminServiceListUsergroupMemberUsersParams,
  signal?: AbortSignal,
) => {
  return httpClient<V1ListUsergroupMemberUsersResponse>({
    url: `/v1/organizations/${organization}/usergroups/${usergroup}/members`,
    method: "get",
    params,
    signal,
  });
};

export const getAdminServiceListUsergroupMemberUsersQueryKey = (
  organization: string,
  usergroup: string,
  params?: AdminServiceListUsergroupMemberUsersParams,
) => [
  `/v1/organizations/${organization}/usergroups/${usergroup}/members`,
  ...(params ? [params] : []),
];

export type AdminServiceListUsergroupMemberUsersQueryResult = NonNullable<
  Awaited<ReturnType<typeof adminServiceListUsergroupMemberUsers>>
>;
export type AdminServiceListUsergroupMemberUsersQueryError = RpcStatus;

export const createAdminServiceListUsergroupMemberUsers = <
  TData = Awaited<ReturnType<typeof adminServiceListUsergroupMemberUsers>>,
  TError = RpcStatus,
>(
  organization: string,
  usergroup: string,
  params?: AdminServiceListUsergroupMemberUsersParams,
  options?: {
    query?: CreateQueryOptions<
      Awaited<ReturnType<typeof adminServiceListUsergroupMemberUsers>>,
      TError,
      TData
    >;
  },
): CreateQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getAdminServiceListUsergroupMemberUsersQueryKey(
      organization,
      usergroup,
      params,
    );

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof adminServiceListUsergroupMemberUsers>>
  > = ({ signal }) =>
    adminServiceListUsergroupMemberUsers(
      organization,
      usergroup,
      params,
      signal,
    );

  const query = createQuery<
    Awaited<ReturnType<typeof adminServiceListUsergroupMemberUsers>>,
    TError,
    TData
  >({
    queryKey,
    queryFn,
    enabled: !!(organization && usergroup),
    ...queryOptions,
  }) as CreateQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
};

/**
 * @summary RemoveUsergroupMemberUser removes member from the user group
 */
export const adminServiceRemoveUsergroupMemberUser = (
  organization: string,
  usergroup: string,
  email: string,
) => {
  return httpClient<V1RemoveUsergroupMemberUserResponse>({
    url: `/v1/organizations/${organization}/usergroups/${usergroup}/members/${email}`,
    method: "delete",
  });
};

export type AdminServiceRemoveUsergroupMemberUserMutationResult = NonNullable<
  Awaited<ReturnType<typeof adminServiceRemoveUsergroupMemberUser>>
>;

export type AdminServiceRemoveUsergroupMemberUserMutationError = RpcStatus;

export const createAdminServiceRemoveUsergroupMemberUser = <
  TError = RpcStatus,
  TContext = unknown,
>(options?: {
  mutation?: CreateMutationOptions<
    Awaited<ReturnType<typeof adminServiceRemoveUsergroupMemberUser>>,
    TError,
    { organization: string; usergroup: string; email: string },
    TContext
  >;
}) => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof adminServiceRemoveUsergroupMemberUser>>,
    { organization: string; usergroup: string; email: string }
  > = (props) => {
    const { organization, usergroup, email } = props ?? {};

    return adminServiceRemoveUsergroupMemberUser(
      organization,
      usergroup,
      email,
    );
  };

  return createMutation<
    Awaited<ReturnType<typeof adminServiceRemoveUsergroupMemberUser>>,
    TError,
    { organization: string; usergroup: string; email: string },
    TContext
  >(mutationFn, mutationOptions);
};
/**
 * @summary AddUsergroupMemberUser adds a member to the user group
 */
export const adminServiceAddUsergroupMemberUser = (
  organization: string,
  usergroup: string,
  email: string,
  adminServiceTriggerReconcileBodyBody: AdminServiceTriggerReconcileBodyBody,
) => {
  return httpClient<V1AddUsergroupMemberUserResponse>({
    url: `/v1/organizations/${organization}/usergroups/${usergroup}/members/${email}`,
    method: "put",
    headers: { "Content-Type": "application/json" },
    data: adminServiceTriggerReconcileBodyBody,
  });
};

export type AdminServiceAddUsergroupMemberUserMutationResult = NonNullable<
  Awaited<ReturnType<typeof adminServiceAddUsergroupMemberUser>>
>;
export type AdminServiceAddUsergroupMemberUserMutationBody =
  AdminServiceTriggerReconcileBodyBody;
export type AdminServiceAddUsergroupMemberUserMutationError = RpcStatus;

export const createAdminServiceAddUsergroupMemberUser = <
  TError = RpcStatus,
  TContext = unknown,
>(options?: {
  mutation?: CreateMutationOptions<
    Awaited<ReturnType<typeof adminServiceAddUsergroupMemberUser>>,
    TError,
    {
      organization: string;
      usergroup: string;
      email: string;
      data: AdminServiceTriggerReconcileBodyBody;
    },
    TContext
  >;
}) => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof adminServiceAddUsergroupMemberUser>>,
    {
      organization: string;
      usergroup: string;
      email: string;
      data: AdminServiceTriggerReconcileBodyBody;
    }
  > = (props) => {
    const { organization, usergroup, email, data } = props ?? {};

    return adminServiceAddUsergroupMemberUser(
      organization,
      usergroup,
      email,
      data,
    );
  };

  return createMutation<
    Awaited<ReturnType<typeof adminServiceAddUsergroupMemberUser>>,
    TError,
    {
      organization: string;
      usergroup: string;
      email: string;
      data: AdminServiceTriggerReconcileBodyBody;
    },
    TContext
  >(mutationFn, mutationOptions);
};
/**
 * @summary RemoveOrganizationMemberUsergroup revokes the organization-level role for the user group
 */
export const adminServiceRemoveOrganizationMemberUsergroup = (
  organization: string,
  usergroup: string,
) => {
  return httpClient<V1RemoveOrganizationMemberUsergroupResponse>({
    url: `/v1/organizations/${organization}/usergroups/${usergroup}/role`,
    method: "delete",
  });
};

export type AdminServiceRemoveOrganizationMemberUsergroupMutationResult =
  NonNullable<
    Awaited<ReturnType<typeof adminServiceRemoveOrganizationMemberUsergroup>>
  >;

export type AdminServiceRemoveOrganizationMemberUsergroupMutationError =
  RpcStatus;

export const createAdminServiceRemoveOrganizationMemberUsergroup = <
  TError = RpcStatus,
  TContext = unknown,
>(options?: {
  mutation?: CreateMutationOptions<
    Awaited<ReturnType<typeof adminServiceRemoveOrganizationMemberUsergroup>>,
    TError,
    { organization: string; usergroup: string },
    TContext
  >;
}) => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof adminServiceRemoveOrganizationMemberUsergroup>>,
    { organization: string; usergroup: string }
  > = (props) => {
    const { organization, usergroup } = props ?? {};

    return adminServiceRemoveOrganizationMemberUsergroup(
      organization,
      usergroup,
    );
  };

  return createMutation<
    Awaited<ReturnType<typeof adminServiceRemoveOrganizationMemberUsergroup>>,
    TError,
    { organization: string; usergroup: string },
    TContext
  >(mutationFn, mutationOptions);
};
/**
 * @summary AddOrganizationMemberUsergroupRole adds the role for the user group
 */
export const adminServiceAddOrganizationMemberUsergroup = (
  organization: string,
  usergroup: string,
  adminServiceSetOrganizationMemberUserRoleBodyBody: AdminServiceSetOrganizationMemberUserRoleBodyBody,
) => {
  return httpClient<V1AddOrganizationMemberUsergroupResponse>({
    url: `/v1/organizations/${organization}/usergroups/${usergroup}/role`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: adminServiceSetOrganizationMemberUserRoleBodyBody,
  });
};

export type AdminServiceAddOrganizationMemberUsergroupMutationResult =
  NonNullable<
    Awaited<ReturnType<typeof adminServiceAddOrganizationMemberUsergroup>>
  >;
export type AdminServiceAddOrganizationMemberUsergroupMutationBody =
  AdminServiceSetOrganizationMemberUserRoleBodyBody;
export type AdminServiceAddOrganizationMemberUsergroupMutationError = RpcStatus;

export const createAdminServiceAddOrganizationMemberUsergroup = <
  TError = RpcStatus,
  TContext = unknown,
>(options?: {
  mutation?: CreateMutationOptions<
    Awaited<ReturnType<typeof adminServiceAddOrganizationMemberUsergroup>>,
    TError,
    {
      organization: string;
      usergroup: string;
      data: AdminServiceSetOrganizationMemberUserRoleBodyBody;
    },
    TContext
  >;
}) => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof adminServiceAddOrganizationMemberUsergroup>>,
    {
      organization: string;
      usergroup: string;
      data: AdminServiceSetOrganizationMemberUserRoleBodyBody;
    }
  > = (props) => {
    const { organization, usergroup, data } = props ?? {};

    return adminServiceAddOrganizationMemberUsergroup(
      organization,
      usergroup,
      data,
    );
  };

  return createMutation<
    Awaited<ReturnType<typeof adminServiceAddOrganizationMemberUsergroup>>,
    TError,
    {
      organization: string;
      usergroup: string;
      data: AdminServiceSetOrganizationMemberUserRoleBodyBody;
    },
    TContext
  >(mutationFn, mutationOptions);
};
/**
 * @summary SetOrganizationMemberUsergroupRole sets the role for the user group
 */
export const adminServiceSetOrganizationMemberUsergroupRole = (
  organization: string,
  usergroup: string,
  adminServiceSetOrganizationMemberUserRoleBodyBody: AdminServiceSetOrganizationMemberUserRoleBodyBody,
) => {
  return httpClient<V1SetOrganizationMemberUsergroupRoleResponse>({
    url: `/v1/organizations/${organization}/usergroups/${usergroup}/role`,
    method: "put",
    headers: { "Content-Type": "application/json" },
    data: adminServiceSetOrganizationMemberUserRoleBodyBody,
  });
};

export type AdminServiceSetOrganizationMemberUsergroupRoleMutationResult =
  NonNullable<
    Awaited<ReturnType<typeof adminServiceSetOrganizationMemberUsergroupRole>>
  >;
export type AdminServiceSetOrganizationMemberUsergroupRoleMutationBody =
  AdminServiceSetOrganizationMemberUserRoleBodyBody;
export type AdminServiceSetOrganizationMemberUsergroupRoleMutationError =
  RpcStatus;

export const createAdminServiceSetOrganizationMemberUsergroupRole = <
  TError = RpcStatus,
  TContext = unknown,
>(options?: {
  mutation?: CreateMutationOptions<
    Awaited<ReturnType<typeof adminServiceSetOrganizationMemberUsergroupRole>>,
    TError,
    {
      organization: string;
      usergroup: string;
      data: AdminServiceSetOrganizationMemberUserRoleBodyBody;
    },
    TContext
  >;
}) => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof adminServiceSetOrganizationMemberUsergroupRole>>,
    {
      organization: string;
      usergroup: string;
      data: AdminServiceSetOrganizationMemberUserRoleBodyBody;
    }
  > = (props) => {
    const { organization, usergroup, data } = props ?? {};

    return adminServiceSetOrganizationMemberUsergroupRole(
      organization,
      usergroup,
      data,
    );
  };

  return createMutation<
    Awaited<ReturnType<typeof adminServiceSetOrganizationMemberUsergroupRole>>,
    TError,
    {
      organization: string;
      usergroup: string;
      data: AdminServiceSetOrganizationMemberUserRoleBodyBody;
    },
    TContext
  >(mutationFn, mutationOptions);
};
/**
 * @summary ListWhitelistedDomains lists all the whitelisted domains for the organization
 */
export const adminServiceListWhitelistedDomains = (
  organization: string,
  signal?: AbortSignal,
) => {
  return httpClient<V1ListWhitelistedDomainsResponse>({
    url: `/v1/organizations/${organization}/whitelisted`,
    method: "get",
    signal,
  });
};

export const getAdminServiceListWhitelistedDomainsQueryKey = (
  organization: string,
) => [`/v1/organizations/${organization}/whitelisted`];

export type AdminServiceListWhitelistedDomainsQueryResult = NonNullable<
  Awaited<ReturnType<typeof adminServiceListWhitelistedDomains>>
>;
export type AdminServiceListWhitelistedDomainsQueryError = RpcStatus;

export const createAdminServiceListWhitelistedDomains = <
  TData = Awaited<ReturnType<typeof adminServiceListWhitelistedDomains>>,
  TError = RpcStatus,
>(
  organization: string,
  options?: {
    query?: CreateQueryOptions<
      Awaited<ReturnType<typeof adminServiceListWhitelistedDomains>>,
      TError,
      TData
    >;
  },
): CreateQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getAdminServiceListWhitelistedDomainsQueryKey(organization);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof adminServiceListWhitelistedDomains>>
  > = ({ signal }) => adminServiceListWhitelistedDomains(organization, signal);

  const query = createQuery<
    Awaited<ReturnType<typeof adminServiceListWhitelistedDomains>>,
    TError,
    TData
  >({
    queryKey,
    queryFn,
    enabled: !!organization,
    ...queryOptions,
  }) as CreateQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
};

/**
 * @summary CreateWhitelistedDomain adds a domain to the whitelist
 */
export const adminServiceCreateWhitelistedDomain = (
  organization: string,
  adminServiceCreateProjectWhitelistedDomainBodyBody: AdminServiceCreateProjectWhitelistedDomainBodyBody,
) => {
  return httpClient<V1CreateWhitelistedDomainResponse>({
    url: `/v1/organizations/${organization}/whitelisted`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: adminServiceCreateProjectWhitelistedDomainBodyBody,
  });
};

export type AdminServiceCreateWhitelistedDomainMutationResult = NonNullable<
  Awaited<ReturnType<typeof adminServiceCreateWhitelistedDomain>>
>;
export type AdminServiceCreateWhitelistedDomainMutationBody =
  AdminServiceCreateProjectWhitelistedDomainBodyBody;
export type AdminServiceCreateWhitelistedDomainMutationError = RpcStatus;

export const createAdminServiceCreateWhitelistedDomain = <
  TError = RpcStatus,
  TContext = unknown,
>(options?: {
  mutation?: CreateMutationOptions<
    Awaited<ReturnType<typeof adminServiceCreateWhitelistedDomain>>,
    TError,
    {
      organization: string;
      data: AdminServiceCreateProjectWhitelistedDomainBodyBody;
    },
    TContext
  >;
}) => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof adminServiceCreateWhitelistedDomain>>,
    {
      organization: string;
      data: AdminServiceCreateProjectWhitelistedDomainBodyBody;
    }
  > = (props) => {
    const { organization, data } = props ?? {};

    return adminServiceCreateWhitelistedDomain(organization, data);
  };

  return createMutation<
    Awaited<ReturnType<typeof adminServiceCreateWhitelistedDomain>>,
    TError,
    {
      organization: string;
      data: AdminServiceCreateProjectWhitelistedDomainBodyBody;
    },
    TContext
  >(mutationFn, mutationOptions);
};
/**
 * @summary RemoveWhitelistedDomain removes a domain from the whitelist list
 */
export const adminServiceRemoveWhitelistedDomain = (
  organization: string,
  domain: string,
) => {
  return httpClient<V1RemoveWhitelistedDomainResponse>({
    url: `/v1/organizations/${organization}/whitelisted/${domain}`,
    method: "delete",
  });
};

export type AdminServiceRemoveWhitelistedDomainMutationResult = NonNullable<
  Awaited<ReturnType<typeof adminServiceRemoveWhitelistedDomain>>
>;

export type AdminServiceRemoveWhitelistedDomainMutationError = RpcStatus;

export const createAdminServiceRemoveWhitelistedDomain = <
  TError = RpcStatus,
  TContext = unknown,
>(options?: {
  mutation?: CreateMutationOptions<
    Awaited<ReturnType<typeof adminServiceRemoveWhitelistedDomain>>,
    TError,
    { organization: string; domain: string },
    TContext
  >;
}) => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof adminServiceRemoveWhitelistedDomain>>,
    { organization: string; domain: string }
  > = (props) => {
    const { organization, domain } = props ?? {};

    return adminServiceRemoveWhitelistedDomain(organization, domain);
  };

  return createMutation<
    Awaited<ReturnType<typeof adminServiceRemoveWhitelistedDomain>>,
    TError,
    { organization: string; domain: string },
    TContext
  >(mutationFn, mutationOptions);
};
/**
 * @summary CreateAsset returns a one time signed URL using which any asset can be uploaded.
 */
export const adminServiceCreateAsset = (
  organizationName: string,
  adminServiceCreateAssetBody: AdminServiceCreateAssetBody,
) => {
  return httpClient<V1CreateAssetResponse>({
    url: `/v1/organizations/${organizationName}/create_asset`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: adminServiceCreateAssetBody,
  });
};

export type AdminServiceCreateAssetMutationResult = NonNullable<
  Awaited<ReturnType<typeof adminServiceCreateAsset>>
>;
export type AdminServiceCreateAssetMutationBody = AdminServiceCreateAssetBody;
export type AdminServiceCreateAssetMutationError = RpcStatus;

export const createAdminServiceCreateAsset = <
  TError = RpcStatus,
  TContext = unknown,
>(options?: {
  mutation?: CreateMutationOptions<
    Awaited<ReturnType<typeof adminServiceCreateAsset>>,
    TError,
    { organizationName: string; data: AdminServiceCreateAssetBody },
    TContext
  >;
}) => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof adminServiceCreateAsset>>,
    { organizationName: string; data: AdminServiceCreateAssetBody }
  > = (props) => {
    const { organizationName, data } = props ?? {};

    return adminServiceCreateAsset(organizationName, data);
  };

  return createMutation<
    Awaited<ReturnType<typeof adminServiceCreateAsset>>,
    TError,
    { organizationName: string; data: AdminServiceCreateAssetBody },
    TContext
  >(mutationFn, mutationOptions);
};
/**
 * @summary ListProjectsForOrganization lists all the projects currently available for given organizations
 */
export const adminServiceListProjectsForOrganization = (
  organizationName: string,
  params?: AdminServiceListProjectsForOrganizationParams,
  signal?: AbortSignal,
) => {
  return httpClient<V1ListProjectsForOrganizationResponse>({
    url: `/v1/organizations/${organizationName}/projects`,
    method: "get",
    params,
    signal,
  });
};

export const getAdminServiceListProjectsForOrganizationQueryKey = (
  organizationName: string,
  params?: AdminServiceListProjectsForOrganizationParams,
) => [
  `/v1/organizations/${organizationName}/projects`,
  ...(params ? [params] : []),
];

export type AdminServiceListProjectsForOrganizationQueryResult = NonNullable<
  Awaited<ReturnType<typeof adminServiceListProjectsForOrganization>>
>;
export type AdminServiceListProjectsForOrganizationQueryError = RpcStatus;

export const createAdminServiceListProjectsForOrganization = <
  TData = Awaited<ReturnType<typeof adminServiceListProjectsForOrganization>>,
  TError = RpcStatus,
>(
  organizationName: string,
  params?: AdminServiceListProjectsForOrganizationParams,
  options?: {
    query?: CreateQueryOptions<
      Awaited<ReturnType<typeof adminServiceListProjectsForOrganization>>,
      TError,
      TData
    >;
  },
): CreateQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getAdminServiceListProjectsForOrganizationQueryKey(
      organizationName,
      params,
    );

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof adminServiceListProjectsForOrganization>>
  > = ({ signal }) =>
    adminServiceListProjectsForOrganization(organizationName, params, signal);

  const query = createQuery<
    Awaited<ReturnType<typeof adminServiceListProjectsForOrganization>>,
    TError,
    TData
  >({
    queryKey,
    queryFn,
    enabled: !!organizationName,
    ...queryOptions,
  }) as CreateQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
};

/**
 * @summary CreateProject creates a new project
 */
export const adminServiceCreateProject = (
  organizationName: string,
  adminServiceCreateProjectBody: AdminServiceCreateProjectBody,
) => {
  return httpClient<V1CreateProjectResponse>({
    url: `/v1/organizations/${organizationName}/projects`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: adminServiceCreateProjectBody,
  });
};

export type AdminServiceCreateProjectMutationResult = NonNullable<
  Awaited<ReturnType<typeof adminServiceCreateProject>>
>;
export type AdminServiceCreateProjectMutationBody =
  AdminServiceCreateProjectBody;
export type AdminServiceCreateProjectMutationError = RpcStatus;

export const createAdminServiceCreateProject = <
  TError = RpcStatus,
  TContext = unknown,
>(options?: {
  mutation?: CreateMutationOptions<
    Awaited<ReturnType<typeof adminServiceCreateProject>>,
    TError,
    { organizationName: string; data: AdminServiceCreateProjectBody },
    TContext
  >;
}) => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof adminServiceCreateProject>>,
    { organizationName: string; data: AdminServiceCreateProjectBody }
  > = (props) => {
    const { organizationName, data } = props ?? {};

    return adminServiceCreateProject(organizationName, data);
  };

  return createMutation<
    Awaited<ReturnType<typeof adminServiceCreateProject>>,
    TError,
    { organizationName: string; data: AdminServiceCreateProjectBody },
    TContext
  >(mutationFn, mutationOptions);
};
/**
 * @summary GetProject returns information about a specific project
 */
export const adminServiceGetProject = (
  organizationName: string,
  name: string,
  params?: AdminServiceGetProjectParams,
  signal?: AbortSignal,
) => {
  return httpClient<V1GetProjectResponse>({
    url: `/v1/organizations/${organizationName}/projects/${name}`,
    method: "get",
    params,
    signal,
  });
};

export const getAdminServiceGetProjectQueryKey = (
  organizationName: string,
  name: string,
  params?: AdminServiceGetProjectParams,
) => [
  `/v1/organizations/${organizationName}/projects/${name}`,
  ...(params ? [params] : []),
];

export type AdminServiceGetProjectQueryResult = NonNullable<
  Awaited<ReturnType<typeof adminServiceGetProject>>
>;
export type AdminServiceGetProjectQueryError = RpcStatus;

export const createAdminServiceGetProject = <
  TData = Awaited<ReturnType<typeof adminServiceGetProject>>,
  TError = RpcStatus,
>(
  organizationName: string,
  name: string,
  params?: AdminServiceGetProjectParams,
  options?: {
    query?: CreateQueryOptions<
      Awaited<ReturnType<typeof adminServiceGetProject>>,
      TError,
      TData
    >;
  },
): CreateQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getAdminServiceGetProjectQueryKey(organizationName, name, params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof adminServiceGetProject>>
  > = ({ signal }) =>
    adminServiceGetProject(organizationName, name, params, signal);

  const query = createQuery<
    Awaited<ReturnType<typeof adminServiceGetProject>>,
    TError,
    TData
  >({
    queryKey,
    queryFn,
    enabled: !!(organizationName && name),
    ...queryOptions,
  }) as CreateQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
};

/**
 * @summary DeleteProject deletes an project
 */
export const adminServiceDeleteProject = (
  organizationName: string,
  name: string,
) => {
  return httpClient<V1DeleteProjectResponse>({
    url: `/v1/organizations/${organizationName}/projects/${name}`,
    method: "delete",
  });
};

export type AdminServiceDeleteProjectMutationResult = NonNullable<
  Awaited<ReturnType<typeof adminServiceDeleteProject>>
>;

export type AdminServiceDeleteProjectMutationError = RpcStatus;

export const createAdminServiceDeleteProject = <
  TError = RpcStatus,
  TContext = unknown,
>(options?: {
  mutation?: CreateMutationOptions<
    Awaited<ReturnType<typeof adminServiceDeleteProject>>,
    TError,
    { organizationName: string; name: string },
    TContext
  >;
}) => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof adminServiceDeleteProject>>,
    { organizationName: string; name: string }
  > = (props) => {
    const { organizationName, name } = props ?? {};

    return adminServiceDeleteProject(organizationName, name);
  };

  return createMutation<
    Awaited<ReturnType<typeof adminServiceDeleteProject>>,
    TError,
    { organizationName: string; name: string },
    TContext
  >(mutationFn, mutationOptions);
};
/**
 * @summary UpdateProject updates a project
 */
export const adminServiceUpdateProject = (
  organizationName: string,
  name: string,
  adminServiceUpdateProjectBody: AdminServiceUpdateProjectBody,
) => {
  return httpClient<V1UpdateProjectResponse>({
    url: `/v1/organizations/${organizationName}/projects/${name}`,
    method: "patch",
    headers: { "Content-Type": "application/json" },
    data: adminServiceUpdateProjectBody,
  });
};

export type AdminServiceUpdateProjectMutationResult = NonNullable<
  Awaited<ReturnType<typeof adminServiceUpdateProject>>
>;
export type AdminServiceUpdateProjectMutationBody =
  AdminServiceUpdateProjectBody;
export type AdminServiceUpdateProjectMutationError = RpcStatus;

export const createAdminServiceUpdateProject = <
  TError = RpcStatus,
  TContext = unknown,
>(options?: {
  mutation?: CreateMutationOptions<
    Awaited<ReturnType<typeof adminServiceUpdateProject>>,
    TError,
    {
      organizationName: string;
      name: string;
      data: AdminServiceUpdateProjectBody;
    },
    TContext
  >;
}) => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof adminServiceUpdateProject>>,
    {
      organizationName: string;
      name: string;
      data: AdminServiceUpdateProjectBody;
    }
  > = (props) => {
    const { organizationName, name, data } = props ?? {};

    return adminServiceUpdateProject(organizationName, name, data);
  };

  return createMutation<
    Awaited<ReturnType<typeof adminServiceUpdateProject>>,
    TError,
    {
      organizationName: string;
      name: string;
      data: AdminServiceUpdateProjectBody;
    },
    TContext
  >(mutationFn, mutationOptions);
};
/**
 * @summary ListService returns all the services per organization
 */
export const adminServiceListServices = (
  organizationName: string,
  signal?: AbortSignal,
) => {
  return httpClient<V1ListServicesResponse>({
    url: `/v1/organizations/${organizationName}/services`,
    method: "get",
    signal,
  });
};

export const getAdminServiceListServicesQueryKey = (
  organizationName: string,
) => [`/v1/organizations/${organizationName}/services`];

export type AdminServiceListServicesQueryResult = NonNullable<
  Awaited<ReturnType<typeof adminServiceListServices>>
>;
export type AdminServiceListServicesQueryError = RpcStatus;

export const createAdminServiceListServices = <
  TData = Awaited<ReturnType<typeof adminServiceListServices>>,
  TError = RpcStatus,
>(
  organizationName: string,
  options?: {
    query?: CreateQueryOptions<
      Awaited<ReturnType<typeof adminServiceListServices>>,
      TError,
      TData
    >;
  },
): CreateQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getAdminServiceListServicesQueryKey(organizationName);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof adminServiceListServices>>
  > = ({ signal }) => adminServiceListServices(organizationName, signal);

  const query = createQuery<
    Awaited<ReturnType<typeof adminServiceListServices>>,
    TError,
    TData
  >({
    queryKey,
    queryFn,
    enabled: !!organizationName,
    ...queryOptions,
  }) as CreateQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
};

/**
 * @summary CreateService creates a new service per organization
 */
export const adminServiceCreateService = (
  organizationName: string,
  params?: AdminServiceCreateServiceParams,
) => {
  return httpClient<V1CreateServiceResponse>({
    url: `/v1/organizations/${organizationName}/services`,
    method: "post",
    params,
  });
};

export type AdminServiceCreateServiceMutationResult = NonNullable<
  Awaited<ReturnType<typeof adminServiceCreateService>>
>;

export type AdminServiceCreateServiceMutationError = RpcStatus;

export const createAdminServiceCreateService = <
  TError = RpcStatus,
  TContext = unknown,
>(options?: {
  mutation?: CreateMutationOptions<
    Awaited<ReturnType<typeof adminServiceCreateService>>,
    TError,
    { organizationName: string; params?: AdminServiceCreateServiceParams },
    TContext
  >;
}) => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof adminServiceCreateService>>,
    { organizationName: string; params?: AdminServiceCreateServiceParams }
  > = (props) => {
    const { organizationName, params } = props ?? {};

    return adminServiceCreateService(organizationName, params);
  };

  return createMutation<
    Awaited<ReturnType<typeof adminServiceCreateService>>,
    TError,
    { organizationName: string; params?: AdminServiceCreateServiceParams },
    TContext
  >(mutationFn, mutationOptions);
};
/**
 * @summary DeleteService deletes a service per organization
 */
export const adminServiceDeleteService = (
  organizationName: string,
  name: string,
) => {
  return httpClient<V1DeleteServiceResponse>({
    url: `/v1/organizations/${organizationName}/services/${name}`,
    method: "delete",
  });
};

export type AdminServiceDeleteServiceMutationResult = NonNullable<
  Awaited<ReturnType<typeof adminServiceDeleteService>>
>;

export type AdminServiceDeleteServiceMutationError = RpcStatus;

export const createAdminServiceDeleteService = <
  TError = RpcStatus,
  TContext = unknown,
>(options?: {
  mutation?: CreateMutationOptions<
    Awaited<ReturnType<typeof adminServiceDeleteService>>,
    TError,
    { organizationName: string; name: string },
    TContext
  >;
}) => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof adminServiceDeleteService>>,
    { organizationName: string; name: string }
  > = (props) => {
    const { organizationName, name } = props ?? {};

    return adminServiceDeleteService(organizationName, name);
  };

  return createMutation<
    Awaited<ReturnType<typeof adminServiceDeleteService>>,
    TError,
    { organizationName: string; name: string },
    TContext
  >(mutationFn, mutationOptions);
};
/**
 * @summary UpdateService updates a service per organization
 */
export const adminServiceUpdateService = (
  organizationName: string,
  name: string,
  adminServiceUpdateServiceBody: AdminServiceUpdateServiceBody,
) => {
  return httpClient<V1UpdateServiceResponse>({
    url: `/v1/organizations/${organizationName}/services/${name}`,
    method: "patch",
    headers: { "Content-Type": "application/json" },
    data: adminServiceUpdateServiceBody,
  });
};

export type AdminServiceUpdateServiceMutationResult = NonNullable<
  Awaited<ReturnType<typeof adminServiceUpdateService>>
>;
export type AdminServiceUpdateServiceMutationBody =
  AdminServiceUpdateServiceBody;
export type AdminServiceUpdateServiceMutationError = RpcStatus;

export const createAdminServiceUpdateService = <
  TError = RpcStatus,
  TContext = unknown,
>(options?: {
  mutation?: CreateMutationOptions<
    Awaited<ReturnType<typeof adminServiceUpdateService>>,
    TError,
    {
      organizationName: string;
      name: string;
      data: AdminServiceUpdateServiceBody;
    },
    TContext
  >;
}) => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof adminServiceUpdateService>>,
    {
      organizationName: string;
      name: string;
      data: AdminServiceUpdateServiceBody;
    }
  > = (props) => {
    const { organizationName, name, data } = props ?? {};

    return adminServiceUpdateService(organizationName, name, data);
  };

  return createMutation<
    Awaited<ReturnType<typeof adminServiceUpdateService>>,
    TError,
    {
      organizationName: string;
      name: string;
      data: AdminServiceUpdateServiceBody;
    },
    TContext
  >(mutationFn, mutationOptions);
};
/**
 * @summary ListServiceAuthTokens lists all the service auth tokens
 */
export const adminServiceListServiceAuthTokens = (
  organizationName: string,
  serviceName: string,
  signal?: AbortSignal,
) => {
  return httpClient<V1ListServiceAuthTokensResponse>({
    url: `/v1/organizations/${organizationName}/services/${serviceName}/tokens`,
    method: "get",
    signal,
  });
};

export const getAdminServiceListServiceAuthTokensQueryKey = (
  organizationName: string,
  serviceName: string,
) => [`/v1/organizations/${organizationName}/services/${serviceName}/tokens`];

export type AdminServiceListServiceAuthTokensQueryResult = NonNullable<
  Awaited<ReturnType<typeof adminServiceListServiceAuthTokens>>
>;
export type AdminServiceListServiceAuthTokensQueryError = RpcStatus;

export const createAdminServiceListServiceAuthTokens = <
  TData = Awaited<ReturnType<typeof adminServiceListServiceAuthTokens>>,
  TError = RpcStatus,
>(
  organizationName: string,
  serviceName: string,
  options?: {
    query?: CreateQueryOptions<
      Awaited<ReturnType<typeof adminServiceListServiceAuthTokens>>,
      TError,
      TData
    >;
  },
): CreateQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getAdminServiceListServiceAuthTokensQueryKey(organizationName, serviceName);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof adminServiceListServiceAuthTokens>>
  > = ({ signal }) =>
    adminServiceListServiceAuthTokens(organizationName, serviceName, signal);

  const query = createQuery<
    Awaited<ReturnType<typeof adminServiceListServiceAuthTokens>>,
    TError,
    TData
  >({
    queryKey,
    queryFn,
    enabled: !!(organizationName && serviceName),
    ...queryOptions,
  }) as CreateQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
};

/**
 * @summary IssueServiceAuthToken returns the temporary token for given service account
 */
export const adminServiceIssueServiceAuthToken = (
  organizationName: string,
  serviceName: string,
  adminServiceTriggerReconcileBodyBody: AdminServiceTriggerReconcileBodyBody,
) => {
  return httpClient<V1IssueServiceAuthTokenResponse>({
    url: `/v1/organizations/${organizationName}/services/${serviceName}/tokens`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: adminServiceTriggerReconcileBodyBody,
  });
};

export type AdminServiceIssueServiceAuthTokenMutationResult = NonNullable<
  Awaited<ReturnType<typeof adminServiceIssueServiceAuthToken>>
>;
export type AdminServiceIssueServiceAuthTokenMutationBody =
  AdminServiceTriggerReconcileBodyBody;
export type AdminServiceIssueServiceAuthTokenMutationError = RpcStatus;

export const createAdminServiceIssueServiceAuthToken = <
  TError = RpcStatus,
  TContext = unknown,
>(options?: {
  mutation?: CreateMutationOptions<
    Awaited<ReturnType<typeof adminServiceIssueServiceAuthToken>>,
    TError,
    {
      organizationName: string;
      serviceName: string;
      data: AdminServiceTriggerReconcileBodyBody;
    },
    TContext
  >;
}) => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof adminServiceIssueServiceAuthToken>>,
    {
      organizationName: string;
      serviceName: string;
      data: AdminServiceTriggerReconcileBodyBody;
    }
  > = (props) => {
    const { organizationName, serviceName, data } = props ?? {};

    return adminServiceIssueServiceAuthToken(
      organizationName,
      serviceName,
      data,
    );
  };

  return createMutation<
    Awaited<ReturnType<typeof adminServiceIssueServiceAuthToken>>,
    TError,
    {
      organizationName: string;
      serviceName: string;
      data: AdminServiceTriggerReconcileBodyBody;
    },
    TContext
  >(mutationFn, mutationOptions);
};
/**
 * @summary Ping returns information about the server
 */
export const adminServicePing = (signal?: AbortSignal) => {
  return httpClient<V1PingResponse>({ url: `/v1/ping`, method: "get", signal });
};

export const getAdminServicePingQueryKey = () => [`/v1/ping`];

export type AdminServicePingQueryResult = NonNullable<
  Awaited<ReturnType<typeof adminServicePing>>
>;
export type AdminServicePingQueryError = RpcStatus;

export const createAdminServicePing = <
  TData = Awaited<ReturnType<typeof adminServicePing>>,
  TError = RpcStatus,
>(options?: {
  query?: CreateQueryOptions<
    Awaited<ReturnType<typeof adminServicePing>>,
    TError,
    TData
  >;
}): CreateQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getAdminServicePingQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof adminServicePing>>
  > = ({ signal }) => adminServicePing(signal);

  const query = createQuery<
    Awaited<ReturnType<typeof adminServicePing>>,
    TError,
    TData
  >({ queryKey, queryFn, ...queryOptions }) as CreateQueryResult<
    TData,
    TError
  > & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
};

export const adminServiceGetProjectAccessRequest = (
  id: string,
  signal?: AbortSignal,
) => {
  return httpClient<V1GetProjectAccessRequestResponse>({
    url: `/v1/project-access-request/${id}`,
    method: "get",
    signal,
  });
};

export const getAdminServiceGetProjectAccessRequestQueryKey = (id: string) => [
  `/v1/project-access-request/${id}`,
];

export type AdminServiceGetProjectAccessRequestQueryResult = NonNullable<
  Awaited<ReturnType<typeof adminServiceGetProjectAccessRequest>>
>;
export type AdminServiceGetProjectAccessRequestQueryError = RpcStatus;

export const createAdminServiceGetProjectAccessRequest = <
  TData = Awaited<ReturnType<typeof adminServiceGetProjectAccessRequest>>,
  TError = RpcStatus,
>(
  id: string,
  options?: {
    query?: CreateQueryOptions<
      Awaited<ReturnType<typeof adminServiceGetProjectAccessRequest>>,
      TError,
      TData
    >;
  },
): CreateQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getAdminServiceGetProjectAccessRequestQueryKey(id);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof adminServiceGetProjectAccessRequest>>
  > = ({ signal }) => adminServiceGetProjectAccessRequest(id, signal);

  const query = createQuery<
    Awaited<ReturnType<typeof adminServiceGetProjectAccessRequest>>,
    TError,
    TData
  >({ queryKey, queryFn, enabled: !!id, ...queryOptions }) as CreateQueryResult<
    TData,
    TError
  > & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
};

export const adminServiceApproveProjectAccess = (
  id: string,
  adminServiceSetOrganizationMemberUserRoleBodyBody: AdminServiceSetOrganizationMemberUserRoleBodyBody,
) => {
  return httpClient<V1ApproveProjectAccessResponse>({
    url: `/v1/project-access-request/${id}/approve`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: adminServiceSetOrganizationMemberUserRoleBodyBody,
  });
};

export type AdminServiceApproveProjectAccessMutationResult = NonNullable<
  Awaited<ReturnType<typeof adminServiceApproveProjectAccess>>
>;
export type AdminServiceApproveProjectAccessMutationBody =
  AdminServiceSetOrganizationMemberUserRoleBodyBody;
export type AdminServiceApproveProjectAccessMutationError = RpcStatus;

export const createAdminServiceApproveProjectAccess = <
  TError = RpcStatus,
  TContext = unknown,
>(options?: {
  mutation?: CreateMutationOptions<
    Awaited<ReturnType<typeof adminServiceApproveProjectAccess>>,
    TError,
    { id: string; data: AdminServiceSetOrganizationMemberUserRoleBodyBody },
    TContext
  >;
}) => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof adminServiceApproveProjectAccess>>,
    { id: string; data: AdminServiceSetOrganizationMemberUserRoleBodyBody }
  > = (props) => {
    const { id, data } = props ?? {};

    return adminServiceApproveProjectAccess(id, data);
  };

  return createMutation<
    Awaited<ReturnType<typeof adminServiceApproveProjectAccess>>,
    TError,
    { id: string; data: AdminServiceSetOrganizationMemberUserRoleBodyBody },
    TContext
  >(mutationFn, mutationOptions);
};
export const adminServiceDenyProjectAccess = (
  id: string,
  adminServiceTriggerReconcileBodyBody: AdminServiceTriggerReconcileBodyBody,
) => {
  return httpClient<V1DenyProjectAccessResponse>({
    url: `/v1/project-access-request/${id}/deny`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: adminServiceTriggerReconcileBodyBody,
  });
};

export type AdminServiceDenyProjectAccessMutationResult = NonNullable<
  Awaited<ReturnType<typeof adminServiceDenyProjectAccess>>
>;
export type AdminServiceDenyProjectAccessMutationBody =
  AdminServiceTriggerReconcileBodyBody;
export type AdminServiceDenyProjectAccessMutationError = RpcStatus;

export const createAdminServiceDenyProjectAccess = <
  TError = RpcStatus,
  TContext = unknown,
>(options?: {
  mutation?: CreateMutationOptions<
    Awaited<ReturnType<typeof adminServiceDenyProjectAccess>>,
    TError,
    { id: string; data: AdminServiceTriggerReconcileBodyBody },
    TContext
  >;
}) => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof adminServiceDenyProjectAccess>>,
    { id: string; data: AdminServiceTriggerReconcileBodyBody }
  > = (props) => {
    const { id, data } = props ?? {};

    return adminServiceDenyProjectAccess(id, data);
  };

  return createMutation<
    Awaited<ReturnType<typeof adminServiceDenyProjectAccess>>,
    TError,
    { id: string; data: AdminServiceTriggerReconcileBodyBody },
    TContext
  >(mutationFn, mutationOptions);
};
/**
 * @summary TriggerRedeploy is similar to RedeployProject.
DEPRECATED: Use RedeployProject instead.
 */
export const adminServiceTriggerRedeploy = (
  v1TriggerRedeployRequest: V1TriggerRedeployRequest,
) => {
  return httpClient<V1TriggerRedeployResponse>({
    url: `/v1/projects/-/redeploy`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: v1TriggerRedeployRequest,
  });
};

export type AdminServiceTriggerRedeployMutationResult = NonNullable<
  Awaited<ReturnType<typeof adminServiceTriggerRedeploy>>
>;
export type AdminServiceTriggerRedeployMutationBody = V1TriggerRedeployRequest;
export type AdminServiceTriggerRedeployMutationError = RpcStatus;

export const createAdminServiceTriggerRedeploy = <
  TError = RpcStatus,
  TContext = unknown,
>(options?: {
  mutation?: CreateMutationOptions<
    Awaited<ReturnType<typeof adminServiceTriggerRedeploy>>,
    TError,
    { data: V1TriggerRedeployRequest },
    TContext
  >;
}) => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof adminServiceTriggerRedeploy>>,
    { data: V1TriggerRedeployRequest }
  > = (props) => {
    const { data } = props ?? {};

    return adminServiceTriggerRedeploy(data);
  };

  return createMutation<
    Awaited<ReturnType<typeof adminServiceTriggerRedeploy>>,
    TError,
    { data: V1TriggerRedeployRequest },
    TContext
  >(mutationFn, mutationOptions);
};
/**
 * @summary GetProject returns information about a specific project
 */
export const adminServiceGetProjectByID = (
  id: string,
  signal?: AbortSignal,
) => {
  return httpClient<V1GetProjectByIDResponse>({
    url: `/v1/projects/${id}`,
    method: "get",
    signal,
  });
};

export const getAdminServiceGetProjectByIDQueryKey = (id: string) => [
  `/v1/projects/${id}`,
];

export type AdminServiceGetProjectByIDQueryResult = NonNullable<
  Awaited<ReturnType<typeof adminServiceGetProjectByID>>
>;
export type AdminServiceGetProjectByIDQueryError = RpcStatus;

export const createAdminServiceGetProjectByID = <
  TData = Awaited<ReturnType<typeof adminServiceGetProjectByID>>,
  TError = RpcStatus,
>(
  id: string,
  options?: {
    query?: CreateQueryOptions<
      Awaited<ReturnType<typeof adminServiceGetProjectByID>>,
      TError,
      TData
    >;
  },
): CreateQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getAdminServiceGetProjectByIDQueryKey(id);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof adminServiceGetProjectByID>>
  > = ({ signal }) => adminServiceGetProjectByID(id, signal);

  const query = createQuery<
    Awaited<ReturnType<typeof adminServiceGetProjectByID>>,
    TError,
    TData
  >({ queryKey, queryFn, enabled: !!id, ...queryOptions }) as CreateQueryResult<
    TData,
    TError
  > & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
};

/**
 * @summary GetAlertMeta returns metadata for checking an alert. It's currently only called by the alert reconciler in the runtime.
 */
export const adminServiceGetAlertMeta = (
  projectId: string,
  adminServiceGetAlertMetaBody: AdminServiceGetAlertMetaBody,
) => {
  return httpClient<V1GetAlertMetaResponse>({
    url: `/v1/projects/${projectId}/alerts/meta`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: adminServiceGetAlertMetaBody,
  });
};

export type AdminServiceGetAlertMetaMutationResult = NonNullable<
  Awaited<ReturnType<typeof adminServiceGetAlertMeta>>
>;
export type AdminServiceGetAlertMetaMutationBody = AdminServiceGetAlertMetaBody;
export type AdminServiceGetAlertMetaMutationError = RpcStatus;

export const createAdminServiceGetAlertMeta = <
  TError = RpcStatus,
  TContext = unknown,
>(options?: {
  mutation?: CreateMutationOptions<
    Awaited<ReturnType<typeof adminServiceGetAlertMeta>>,
    TError,
    { projectId: string; data: AdminServiceGetAlertMetaBody },
    TContext
  >;
}) => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof adminServiceGetAlertMeta>>,
    { projectId: string; data: AdminServiceGetAlertMetaBody }
  > = (props) => {
    const { projectId, data } = props ?? {};

    return adminServiceGetAlertMeta(projectId, data);
  };

  return createMutation<
    Awaited<ReturnType<typeof adminServiceGetAlertMeta>>,
    TError,
    { projectId: string; data: AdminServiceGetAlertMetaBody },
    TContext
  >(mutationFn, mutationOptions);
};
/**
 * @summary GetRepoMeta returns credentials and other metadata for accessing a project's repo
 */
export const adminServiceGetRepoMeta = (
  projectId: string,
  params?: AdminServiceGetRepoMetaParams,
  signal?: AbortSignal,
) => {
  return httpClient<V1GetRepoMetaResponse>({
    url: `/v1/projects/${projectId}/repo/meta`,
    method: "get",
    params,
    signal,
  });
};

export const getAdminServiceGetRepoMetaQueryKey = (
  projectId: string,
  params?: AdminServiceGetRepoMetaParams,
) => [`/v1/projects/${projectId}/repo/meta`, ...(params ? [params] : [])];

export type AdminServiceGetRepoMetaQueryResult = NonNullable<
  Awaited<ReturnType<typeof adminServiceGetRepoMeta>>
>;
export type AdminServiceGetRepoMetaQueryError = RpcStatus;

export const createAdminServiceGetRepoMeta = <
  TData = Awaited<ReturnType<typeof adminServiceGetRepoMeta>>,
  TError = RpcStatus,
>(
  projectId: string,
  params?: AdminServiceGetRepoMetaParams,
  options?: {
    query?: CreateQueryOptions<
      Awaited<ReturnType<typeof adminServiceGetRepoMeta>>,
      TError,
      TData
    >;
  },
): CreateQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getAdminServiceGetRepoMetaQueryKey(projectId, params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof adminServiceGetRepoMeta>>
  > = ({ signal }) => adminServiceGetRepoMeta(projectId, params, signal);

  const query = createQuery<
    Awaited<ReturnType<typeof adminServiceGetRepoMeta>>,
    TError,
    TData
  >({
    queryKey,
    queryFn,
    enabled: !!projectId,
    ...queryOptions,
  }) as CreateQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
};

/**
 * @summary PullVirtualRepo fetches files from a project's virtual repo
 */
export const adminServicePullVirtualRepo = (
  projectId: string,
  params?: AdminServicePullVirtualRepoParams,
  signal?: AbortSignal,
) => {
  return httpClient<V1PullVirtualRepoResponse>({
    url: `/v1/projects/${projectId}/repo/virtual`,
    method: "get",
    params,
    signal,
  });
};

export const getAdminServicePullVirtualRepoQueryKey = (
  projectId: string,
  params?: AdminServicePullVirtualRepoParams,
) => [`/v1/projects/${projectId}/repo/virtual`, ...(params ? [params] : [])];

export type AdminServicePullVirtualRepoQueryResult = NonNullable<
  Awaited<ReturnType<typeof adminServicePullVirtualRepo>>
>;
export type AdminServicePullVirtualRepoQueryError = RpcStatus;

export const createAdminServicePullVirtualRepo = <
  TData = Awaited<ReturnType<typeof adminServicePullVirtualRepo>>,
  TError = RpcStatus,
>(
  projectId: string,
  params?: AdminServicePullVirtualRepoParams,
  options?: {
    query?: CreateQueryOptions<
      Awaited<ReturnType<typeof adminServicePullVirtualRepo>>,
      TError,
      TData
    >;
  },
): CreateQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getAdminServicePullVirtualRepoQueryKey(projectId, params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof adminServicePullVirtualRepo>>
  > = ({ signal }) => adminServicePullVirtualRepo(projectId, params, signal);

  const query = createQuery<
    Awaited<ReturnType<typeof adminServicePullVirtualRepo>>,
    TError,
    TData
  >({
    queryKey,
    queryFn,
    enabled: !!projectId,
    ...queryOptions,
  }) as CreateQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
};

/**
 * @summary GetReportMeta returns metadata for generating a report. It's currently only called by the report reconciler in the runtime.
 */
export const adminServiceGetReportMeta = (
  projectId: string,
  adminServiceGetReportMetaBody: AdminServiceGetReportMetaBody,
) => {
  return httpClient<V1GetReportMetaResponse>({
    url: `/v1/projects/${projectId}/reports/meta`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: adminServiceGetReportMetaBody,
  });
};

export type AdminServiceGetReportMetaMutationResult = NonNullable<
  Awaited<ReturnType<typeof adminServiceGetReportMeta>>
>;
export type AdminServiceGetReportMetaMutationBody =
  AdminServiceGetReportMetaBody;
export type AdminServiceGetReportMetaMutationError = RpcStatus;

export const createAdminServiceGetReportMeta = <
  TError = RpcStatus,
  TContext = unknown,
>(options?: {
  mutation?: CreateMutationOptions<
    Awaited<ReturnType<typeof adminServiceGetReportMeta>>,
    TError,
    { projectId: string; data: AdminServiceGetReportMetaBody },
    TContext
  >;
}) => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof adminServiceGetReportMeta>>,
    { projectId: string; data: AdminServiceGetReportMetaBody }
  > = (props) => {
    const { projectId, data } = props ?? {};

    return adminServiceGetReportMeta(projectId, data);
  };

  return createMutation<
    Awaited<ReturnType<typeof adminServiceGetReportMeta>>,
    TError,
    { projectId: string; data: AdminServiceGetReportMetaBody },
    TContext
  >(mutationFn, mutationOptions);
};
/**
 * @summary RevokeServiceAuthToken revoke the service auth token
 */
export const adminServiceRevokeServiceAuthToken = (tokenId: string) => {
  return httpClient<V1RevokeServiceAuthTokenResponse>({
    url: `/v1/services/tokens/${tokenId}`,
    method: "delete",
  });
};

export type AdminServiceRevokeServiceAuthTokenMutationResult = NonNullable<
  Awaited<ReturnType<typeof adminServiceRevokeServiceAuthToken>>
>;

export type AdminServiceRevokeServiceAuthTokenMutationError = RpcStatus;

export const createAdminServiceRevokeServiceAuthToken = <
  TError = RpcStatus,
  TContext = unknown,
>(options?: {
  mutation?: CreateMutationOptions<
    Awaited<ReturnType<typeof adminServiceRevokeServiceAuthToken>>,
    TError,
    { tokenId: string },
    TContext
  >;
}) => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof adminServiceRevokeServiceAuthToken>>,
    { tokenId: string }
  > = (props) => {
    const { tokenId } = props ?? {};

    return adminServiceRevokeServiceAuthToken(tokenId);
  };

  return createMutation<
    Awaited<ReturnType<typeof adminServiceRevokeServiceAuthToken>>,
    TError,
    { tokenId: string },
    TContext
  >(mutationFn, mutationOptions);
};
/**
 * @summary SudoIssueRuntimeManagerToken returns a runtime JWT with full manager permissions for a runtime.
 */
export const adminServiceSudoIssueRuntimeManagerToken = (
  v1SudoIssueRuntimeManagerTokenRequest: V1SudoIssueRuntimeManagerTokenRequest,
) => {
  return httpClient<V1SudoIssueRuntimeManagerTokenResponse>({
    url: `/v1/superuser/deployments/manager-token`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: v1SudoIssueRuntimeManagerTokenRequest,
  });
};

export type AdminServiceSudoIssueRuntimeManagerTokenMutationResult =
  NonNullable<
    Awaited<ReturnType<typeof adminServiceSudoIssueRuntimeManagerToken>>
  >;
export type AdminServiceSudoIssueRuntimeManagerTokenMutationBody =
  V1SudoIssueRuntimeManagerTokenRequest;
export type AdminServiceSudoIssueRuntimeManagerTokenMutationError = RpcStatus;

export const createAdminServiceSudoIssueRuntimeManagerToken = <
  TError = RpcStatus,
  TContext = unknown,
>(options?: {
  mutation?: CreateMutationOptions<
    Awaited<ReturnType<typeof adminServiceSudoIssueRuntimeManagerToken>>,
    TError,
    { data: V1SudoIssueRuntimeManagerTokenRequest },
    TContext
  >;
}) => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof adminServiceSudoIssueRuntimeManagerToken>>,
    { data: V1SudoIssueRuntimeManagerTokenRequest }
  > = (props) => {
    const { data } = props ?? {};

    return adminServiceSudoIssueRuntimeManagerToken(data);
  };

  return createMutation<
    Awaited<ReturnType<typeof adminServiceSudoIssueRuntimeManagerToken>>,
    TError,
    { data: V1SudoIssueRuntimeManagerTokenRequest },
    TContext
  >(mutationFn, mutationOptions);
};
/**
 * @summary ListSuperusers lists all the superusers
 */
export const adminServiceListSuperusers = (signal?: AbortSignal) => {
  return httpClient<V1ListSuperusersResponse>({
    url: `/v1/superuser/members`,
    method: "get",
    signal,
  });
};

export const getAdminServiceListSuperusersQueryKey = () => [
  `/v1/superuser/members`,
];

export type AdminServiceListSuperusersQueryResult = NonNullable<
  Awaited<ReturnType<typeof adminServiceListSuperusers>>
>;
export type AdminServiceListSuperusersQueryError = RpcStatus;

export const createAdminServiceListSuperusers = <
  TData = Awaited<ReturnType<typeof adminServiceListSuperusers>>,
  TError = RpcStatus,
>(options?: {
  query?: CreateQueryOptions<
    Awaited<ReturnType<typeof adminServiceListSuperusers>>,
    TError,
    TData
  >;
}): CreateQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getAdminServiceListSuperusersQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof adminServiceListSuperusers>>
  > = ({ signal }) => adminServiceListSuperusers(signal);

  const query = createQuery<
    Awaited<ReturnType<typeof adminServiceListSuperusers>>,
    TError,
    TData
  >({ queryKey, queryFn, ...queryOptions }) as CreateQueryResult<
    TData,
    TError
  > & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
};

/**
 * @summary SetSuperuser adds/remove a superuser
 */
export const adminServiceSetSuperuser = (
  v1SetSuperuserRequest: V1SetSuperuserRequest,
) => {
  return httpClient<V1SetSuperuserResponse>({
    url: `/v1/superuser/members`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: v1SetSuperuserRequest,
  });
};

export type AdminServiceSetSuperuserMutationResult = NonNullable<
  Awaited<ReturnType<typeof adminServiceSetSuperuser>>
>;
export type AdminServiceSetSuperuserMutationBody = V1SetSuperuserRequest;
export type AdminServiceSetSuperuserMutationError = RpcStatus;

export const createAdminServiceSetSuperuser = <
  TError = RpcStatus,
  TContext = unknown,
>(options?: {
  mutation?: CreateMutationOptions<
    Awaited<ReturnType<typeof adminServiceSetSuperuser>>,
    TError,
    { data: V1SetSuperuserRequest },
    TContext
  >;
}) => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof adminServiceSetSuperuser>>,
    { data: V1SetSuperuserRequest }
  > = (props) => {
    const { data } = props ?? {};

    return adminServiceSetSuperuser(data);
  };

  return createMutation<
    Awaited<ReturnType<typeof adminServiceSetSuperuser>>,
    TError,
    { data: V1SetSuperuserRequest },
    TContext
  >(mutationFn, mutationOptions);
};
/**
 * @summary SudoUpdateOrganizationBillingCustomer update the billing customer for the organization
 */
export const adminServiceSudoUpdateOrganizationBillingCustomer = (
  v1SudoUpdateOrganizationBillingCustomerRequest: V1SudoUpdateOrganizationBillingCustomerRequest,
) => {
  return httpClient<V1SudoUpdateOrganizationBillingCustomerResponse>({
    url: `/v1/superuser/organization/billing/customer_id`,
    method: "patch",
    headers: { "Content-Type": "application/json" },
    data: v1SudoUpdateOrganizationBillingCustomerRequest,
  });
};

export type AdminServiceSudoUpdateOrganizationBillingCustomerMutationResult =
  NonNullable<
    Awaited<
      ReturnType<typeof adminServiceSudoUpdateOrganizationBillingCustomer>
    >
  >;
export type AdminServiceSudoUpdateOrganizationBillingCustomerMutationBody =
  V1SudoUpdateOrganizationBillingCustomerRequest;
export type AdminServiceSudoUpdateOrganizationBillingCustomerMutationError =
  RpcStatus;

export const createAdminServiceSudoUpdateOrganizationBillingCustomer = <
  TError = RpcStatus,
  TContext = unknown,
>(options?: {
  mutation?: CreateMutationOptions<
    Awaited<
      ReturnType<typeof adminServiceSudoUpdateOrganizationBillingCustomer>
    >,
    TError,
    { data: V1SudoUpdateOrganizationBillingCustomerRequest },
    TContext
  >;
}) => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<
      ReturnType<typeof adminServiceSudoUpdateOrganizationBillingCustomer>
    >,
    { data: V1SudoUpdateOrganizationBillingCustomerRequest }
  > = (props) => {
    const { data } = props ?? {};

    return adminServiceSudoUpdateOrganizationBillingCustomer(data);
  };

  return createMutation<
    Awaited<
      ReturnType<typeof adminServiceSudoUpdateOrganizationBillingCustomer>
    >,
    TError,
    { data: V1SudoUpdateOrganizationBillingCustomerRequest },
    TContext
  >(mutationFn, mutationOptions);
};
/**
 * @summary SudoUpdateOrganizationCustomDomain updates the custom domain for an organization.
It only updates the custom domain in the database, which is used to ensure correct redirects.
The DNS records and ingress TLS must be configured separately.
 */
export const adminServiceSudoUpdateOrganizationCustomDomain = (
  v1SudoUpdateOrganizationCustomDomainRequest: V1SudoUpdateOrganizationCustomDomainRequest,
) => {
  return httpClient<V1SudoUpdateOrganizationCustomDomainResponse>({
    url: `/v1/superuser/organization/custom-domain`,
    method: "patch",
    headers: { "Content-Type": "application/json" },
    data: v1SudoUpdateOrganizationCustomDomainRequest,
  });
};

export type AdminServiceSudoUpdateOrganizationCustomDomainMutationResult =
  NonNullable<
    Awaited<ReturnType<typeof adminServiceSudoUpdateOrganizationCustomDomain>>
  >;
export type AdminServiceSudoUpdateOrganizationCustomDomainMutationBody =
  V1SudoUpdateOrganizationCustomDomainRequest;
export type AdminServiceSudoUpdateOrganizationCustomDomainMutationError =
  RpcStatus;

export const createAdminServiceSudoUpdateOrganizationCustomDomain = <
  TError = RpcStatus,
  TContext = unknown,
>(options?: {
  mutation?: CreateMutationOptions<
    Awaited<ReturnType<typeof adminServiceSudoUpdateOrganizationCustomDomain>>,
    TError,
    { data: V1SudoUpdateOrganizationCustomDomainRequest },
    TContext
  >;
}) => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof adminServiceSudoUpdateOrganizationCustomDomain>>,
    { data: V1SudoUpdateOrganizationCustomDomainRequest }
  > = (props) => {
    const { data } = props ?? {};

    return adminServiceSudoUpdateOrganizationCustomDomain(data);
  };

  return createMutation<
    Awaited<ReturnType<typeof adminServiceSudoUpdateOrganizationCustomDomain>>,
    TError,
    { data: V1SudoUpdateOrganizationCustomDomainRequest },
    TContext
  >(mutationFn, mutationOptions);
};
/**
 * @summary SudoDeleteOrganizationBillingIssue deletes a billing issue of a type for the organization
 */
export const adminServiceSudoDeleteOrganizationBillingIssue = (
  organization: string,
  type:
    | "BILLING_ISSUE_TYPE_UNSPECIFIED"
    | "BILLING_ISSUE_TYPE_ON_TRIAL"
    | "BILLING_ISSUE_TYPE_TRIAL_ENDED"
    | "BILLING_ISSUE_TYPE_NO_PAYMENT_METHOD"
    | "BILLING_ISSUE_TYPE_NO_BILLABLE_ADDRESS"
    | "BILLING_ISSUE_TYPE_PAYMENT_FAILED"
    | "BILLING_ISSUE_TYPE_SUBSCRIPTION_CANCELLED"
    | "BILLING_ISSUE_TYPE_NEVER_SUBSCRIBED",
) => {
  return httpClient<V1SudoDeleteOrganizationBillingIssueResponse>({
    url: `/v1/superuser/organizations/${organization}/billing/issues/${type}`,
    method: "delete",
  });
};

export type AdminServiceSudoDeleteOrganizationBillingIssueMutationResult =
  NonNullable<
    Awaited<ReturnType<typeof adminServiceSudoDeleteOrganizationBillingIssue>>
  >;

export type AdminServiceSudoDeleteOrganizationBillingIssueMutationError =
  RpcStatus;

export const createAdminServiceSudoDeleteOrganizationBillingIssue = <
  TError = RpcStatus,
  TContext = unknown,
>(options?: {
  mutation?: CreateMutationOptions<
    Awaited<ReturnType<typeof adminServiceSudoDeleteOrganizationBillingIssue>>,
    TError,
    {
      organization: string;
      type:
        | "BILLING_ISSUE_TYPE_UNSPECIFIED"
        | "BILLING_ISSUE_TYPE_ON_TRIAL"
        | "BILLING_ISSUE_TYPE_TRIAL_ENDED"
        | "BILLING_ISSUE_TYPE_NO_PAYMENT_METHOD"
        | "BILLING_ISSUE_TYPE_NO_BILLABLE_ADDRESS"
        | "BILLING_ISSUE_TYPE_PAYMENT_FAILED"
        | "BILLING_ISSUE_TYPE_SUBSCRIPTION_CANCELLED"
        | "BILLING_ISSUE_TYPE_NEVER_SUBSCRIBED";
    },
    TContext
  >;
}) => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof adminServiceSudoDeleteOrganizationBillingIssue>>,
    {
      organization: string;
      type:
        | "BILLING_ISSUE_TYPE_UNSPECIFIED"
        | "BILLING_ISSUE_TYPE_ON_TRIAL"
        | "BILLING_ISSUE_TYPE_TRIAL_ENDED"
        | "BILLING_ISSUE_TYPE_NO_PAYMENT_METHOD"
        | "BILLING_ISSUE_TYPE_NO_BILLABLE_ADDRESS"
        | "BILLING_ISSUE_TYPE_PAYMENT_FAILED"
        | "BILLING_ISSUE_TYPE_SUBSCRIPTION_CANCELLED"
        | "BILLING_ISSUE_TYPE_NEVER_SUBSCRIBED";
    }
  > = (props) => {
    const { organization, type } = props ?? {};

    return adminServiceSudoDeleteOrganizationBillingIssue(organization, type);
  };

  return createMutation<
    Awaited<ReturnType<typeof adminServiceSudoDeleteOrganizationBillingIssue>>,
    TError,
    {
      organization: string;
      type:
        | "BILLING_ISSUE_TYPE_UNSPECIFIED"
        | "BILLING_ISSUE_TYPE_ON_TRIAL"
        | "BILLING_ISSUE_TYPE_TRIAL_ENDED"
        | "BILLING_ISSUE_TYPE_NO_PAYMENT_METHOD"
        | "BILLING_ISSUE_TYPE_NO_BILLABLE_ADDRESS"
        | "BILLING_ISSUE_TYPE_PAYMENT_FAILED"
        | "BILLING_ISSUE_TYPE_SUBSCRIPTION_CANCELLED"
        | "BILLING_ISSUE_TYPE_NEVER_SUBSCRIBED";
    },
    TContext
  >(mutationFn, mutationOptions);
};
/**
 * @summary SudoUpdateAnnotations endpoint for superusers to update project annotations
 */
export const adminServiceSudoUpdateAnnotations = (
  v1SudoUpdateAnnotationsRequest: V1SudoUpdateAnnotationsRequest,
) => {
  return httpClient<V1SudoUpdateAnnotationsResponse>({
    url: `/v1/superuser/projects/annotations`,
    method: "patch",
    headers: { "Content-Type": "application/json" },
    data: v1SudoUpdateAnnotationsRequest,
  });
};

export type AdminServiceSudoUpdateAnnotationsMutationResult = NonNullable<
  Awaited<ReturnType<typeof adminServiceSudoUpdateAnnotations>>
>;
export type AdminServiceSudoUpdateAnnotationsMutationBody =
  V1SudoUpdateAnnotationsRequest;
export type AdminServiceSudoUpdateAnnotationsMutationError = RpcStatus;

export const createAdminServiceSudoUpdateAnnotations = <
  TError = RpcStatus,
  TContext = unknown,
>(options?: {
  mutation?: CreateMutationOptions<
    Awaited<ReturnType<typeof adminServiceSudoUpdateAnnotations>>,
    TError,
    { data: V1SudoUpdateAnnotationsRequest },
    TContext
  >;
}) => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof adminServiceSudoUpdateAnnotations>>,
    { data: V1SudoUpdateAnnotationsRequest }
  > = (props) => {
    const { data } = props ?? {};

    return adminServiceSudoUpdateAnnotations(data);
  };

  return createMutation<
    Awaited<ReturnType<typeof adminServiceSudoUpdateAnnotations>>,
    TError,
    { data: V1SudoUpdateAnnotationsRequest },
    TContext
  >(mutationFn, mutationOptions);
};
/**
 * @summary SearchProjectNames returns project names matching the pattern
 */
export const adminServiceSearchProjectNames = (
  params?: AdminServiceSearchProjectNamesParams,
  signal?: AbortSignal,
) => {
  return httpClient<V1SearchProjectNamesResponse>({
    url: `/v1/superuser/projects/search`,
    method: "get",
    params,
    signal,
  });
};

export const getAdminServiceSearchProjectNamesQueryKey = (
  params?: AdminServiceSearchProjectNamesParams,
) => [`/v1/superuser/projects/search`, ...(params ? [params] : [])];

export type AdminServiceSearchProjectNamesQueryResult = NonNullable<
  Awaited<ReturnType<typeof adminServiceSearchProjectNames>>
>;
export type AdminServiceSearchProjectNamesQueryError = RpcStatus;

export const createAdminServiceSearchProjectNames = <
  TData = Awaited<ReturnType<typeof adminServiceSearchProjectNames>>,
  TError = RpcStatus,
>(
  params?: AdminServiceSearchProjectNamesParams,
  options?: {
    query?: CreateQueryOptions<
      Awaited<ReturnType<typeof adminServiceSearchProjectNames>>,
      TError,
      TData
    >;
  },
): CreateQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getAdminServiceSearchProjectNamesQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof adminServiceSearchProjectNames>>
  > = ({ signal }) => adminServiceSearchProjectNames(params, signal);

  const query = createQuery<
    Awaited<ReturnType<typeof adminServiceSearchProjectNames>>,
    TError,
    TData
  >({ queryKey, queryFn, ...queryOptions }) as CreateQueryResult<
    TData,
    TError
  > & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
};

/**
 * @summary SudoUpdateOrganizationQuotas update the quotas available for orgs
 */
export const adminServiceSudoUpdateOrganizationQuotas = (
  v1SudoUpdateOrganizationQuotasRequest: V1SudoUpdateOrganizationQuotasRequest,
) => {
  return httpClient<V1SudoUpdateOrganizationQuotasResponse>({
    url: `/v1/superuser/quotas/organization`,
    method: "patch",
    headers: { "Content-Type": "application/json" },
    data: v1SudoUpdateOrganizationQuotasRequest,
  });
};

export type AdminServiceSudoUpdateOrganizationQuotasMutationResult =
  NonNullable<
    Awaited<ReturnType<typeof adminServiceSudoUpdateOrganizationQuotas>>
  >;
export type AdminServiceSudoUpdateOrganizationQuotasMutationBody =
  V1SudoUpdateOrganizationQuotasRequest;
export type AdminServiceSudoUpdateOrganizationQuotasMutationError = RpcStatus;

export const createAdminServiceSudoUpdateOrganizationQuotas = <
  TError = RpcStatus,
  TContext = unknown,
>(options?: {
  mutation?: CreateMutationOptions<
    Awaited<ReturnType<typeof adminServiceSudoUpdateOrganizationQuotas>>,
    TError,
    { data: V1SudoUpdateOrganizationQuotasRequest },
    TContext
  >;
}) => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof adminServiceSudoUpdateOrganizationQuotas>>,
    { data: V1SudoUpdateOrganizationQuotasRequest }
  > = (props) => {
    const { data } = props ?? {};

    return adminServiceSudoUpdateOrganizationQuotas(data);
  };

  return createMutation<
    Awaited<ReturnType<typeof adminServiceSudoUpdateOrganizationQuotas>>,
    TError,
    { data: V1SudoUpdateOrganizationQuotasRequest },
    TContext
  >(mutationFn, mutationOptions);
};
/**
 * @summary SudoUpdateUserQuotas update the quotas for users
 */
export const adminServiceSudoUpdateUserQuotas = (
  v1SudoUpdateUserQuotasRequest: V1SudoUpdateUserQuotasRequest,
) => {
  return httpClient<V1SudoUpdateUserQuotasResponse>({
    url: `/v1/superuser/quotas/user`,
    method: "patch",
    headers: { "Content-Type": "application/json" },
    data: v1SudoUpdateUserQuotasRequest,
  });
};

export type AdminServiceSudoUpdateUserQuotasMutationResult = NonNullable<
  Awaited<ReturnType<typeof adminServiceSudoUpdateUserQuotas>>
>;
export type AdminServiceSudoUpdateUserQuotasMutationBody =
  V1SudoUpdateUserQuotasRequest;
export type AdminServiceSudoUpdateUserQuotasMutationError = RpcStatus;

export const createAdminServiceSudoUpdateUserQuotas = <
  TError = RpcStatus,
  TContext = unknown,
>(options?: {
  mutation?: CreateMutationOptions<
    Awaited<ReturnType<typeof adminServiceSudoUpdateUserQuotas>>,
    TError,
    { data: V1SudoUpdateUserQuotasRequest },
    TContext
  >;
}) => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof adminServiceSudoUpdateUserQuotas>>,
    { data: V1SudoUpdateUserQuotasRequest }
  > = (props) => {
    const { data } = props ?? {};

    return adminServiceSudoUpdateUserQuotas(data);
  };

  return createMutation<
    Awaited<ReturnType<typeof adminServiceSudoUpdateUserQuotas>>,
    TError,
    { data: V1SudoUpdateUserQuotasRequest },
    TContext
  >(mutationFn, mutationOptions);
};
/**
 * @summary SudoGetResource returns details about a resource by ID lookup
 */
export const adminServiceSudoGetResource = (
  params?: AdminServiceSudoGetResourceParams,
  signal?: AbortSignal,
) => {
  return httpClient<V1SudoGetResourceResponse>({
    url: `/v1/superuser/resource`,
    method: "get",
    params,
    signal,
  });
};

export const getAdminServiceSudoGetResourceQueryKey = (
  params?: AdminServiceSudoGetResourceParams,
) => [`/v1/superuser/resource`, ...(params ? [params] : [])];

export type AdminServiceSudoGetResourceQueryResult = NonNullable<
  Awaited<ReturnType<typeof adminServiceSudoGetResource>>
>;
export type AdminServiceSudoGetResourceQueryError = RpcStatus;

export const createAdminServiceSudoGetResource = <
  TData = Awaited<ReturnType<typeof adminServiceSudoGetResource>>,
  TError = RpcStatus,
>(
  params?: AdminServiceSudoGetResourceParams,
  options?: {
    query?: CreateQueryOptions<
      Awaited<ReturnType<typeof adminServiceSudoGetResource>>,
      TError,
      TData
    >;
  },
): CreateQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getAdminServiceSudoGetResourceQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof adminServiceSudoGetResource>>
  > = ({ signal }) => adminServiceSudoGetResource(params, signal);

  const query = createQuery<
    Awaited<ReturnType<typeof adminServiceSudoGetResource>>,
    TError,
    TData
  >({ queryKey, queryFn, ...queryOptions }) as CreateQueryResult<
    TData,
    TError
  > & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
};

/**
 * @summary RevokeCurrentAuthToken revoke the current auth token
 */
export const adminServiceRevokeCurrentAuthToken = () => {
  return httpClient<V1RevokeCurrentAuthTokenResponse>({
    url: `/v1/tokens/current`,
    method: "delete",
  });
};

export type AdminServiceRevokeCurrentAuthTokenMutationResult = NonNullable<
  Awaited<ReturnType<typeof adminServiceRevokeCurrentAuthToken>>
>;

export type AdminServiceRevokeCurrentAuthTokenMutationError = RpcStatus;

export const createAdminServiceRevokeCurrentAuthToken = <
  TError = RpcStatus,
  TVariables = void,
  TContext = unknown,
>(options?: {
  mutation?: CreateMutationOptions<
    Awaited<ReturnType<typeof adminServiceRevokeCurrentAuthToken>>,
    TError,
    TVariables,
    TContext
  >;
}) => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof adminServiceRevokeCurrentAuthToken>>,
    TVariables
  > = () => {
    return adminServiceRevokeCurrentAuthToken();
  };

  return createMutation<
    Awaited<ReturnType<typeof adminServiceRevokeCurrentAuthToken>>,
    TError,
    TVariables,
    TContext
  >(mutationFn, mutationOptions);
};
/**
 * @summary IssueRepresentativeAuthToken returns the temporary token for given email
 */
export const adminServiceIssueRepresentativeAuthToken = (
  v1IssueRepresentativeAuthTokenRequest: V1IssueRepresentativeAuthTokenRequest,
) => {
  return httpClient<V1IssueRepresentativeAuthTokenResponse>({
    url: `/v1/tokens/represent`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: v1IssueRepresentativeAuthTokenRequest,
  });
};

export type AdminServiceIssueRepresentativeAuthTokenMutationResult =
  NonNullable<
    Awaited<ReturnType<typeof adminServiceIssueRepresentativeAuthToken>>
  >;
export type AdminServiceIssueRepresentativeAuthTokenMutationBody =
  V1IssueRepresentativeAuthTokenRequest;
export type AdminServiceIssueRepresentativeAuthTokenMutationError = RpcStatus;

export const createAdminServiceIssueRepresentativeAuthToken = <
  TError = RpcStatus,
  TContext = unknown,
>(options?: {
  mutation?: CreateMutationOptions<
    Awaited<ReturnType<typeof adminServiceIssueRepresentativeAuthToken>>,
    TError,
    { data: V1IssueRepresentativeAuthTokenRequest },
    TContext
  >;
}) => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof adminServiceIssueRepresentativeAuthToken>>,
    { data: V1IssueRepresentativeAuthTokenRequest }
  > = (props) => {
    const { data } = props ?? {};

    return adminServiceIssueRepresentativeAuthToken(data);
  };

  return createMutation<
    Awaited<ReturnType<typeof adminServiceIssueRepresentativeAuthToken>>,
    TError,
    { data: V1IssueRepresentativeAuthTokenRequest },
    TContext
  >(mutationFn, mutationOptions);
};
/**
 * @summary GetUser returns user by email
 */
export const adminServiceGetUser = (
  params?: AdminServiceGetUserParams,
  signal?: AbortSignal,
) => {
  return httpClient<V1GetUserResponse>({
    url: `/v1/users`,
    method: "get",
    params,
    signal,
  });
};

export const getAdminServiceGetUserQueryKey = (
  params?: AdminServiceGetUserParams,
) => [`/v1/users`, ...(params ? [params] : [])];

export type AdminServiceGetUserQueryResult = NonNullable<
  Awaited<ReturnType<typeof adminServiceGetUser>>
>;
export type AdminServiceGetUserQueryError = RpcStatus;

export const createAdminServiceGetUser = <
  TData = Awaited<ReturnType<typeof adminServiceGetUser>>,
  TError = RpcStatus,
>(
  params?: AdminServiceGetUserParams,
  options?: {
    query?: CreateQueryOptions<
      Awaited<ReturnType<typeof adminServiceGetUser>>,
      TError,
      TData
    >;
  },
): CreateQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getAdminServiceGetUserQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof adminServiceGetUser>>
  > = ({ signal }) => adminServiceGetUser(params, signal);

  const query = createQuery<
    Awaited<ReturnType<typeof adminServiceGetUser>>,
    TError,
    TData
  >({ queryKey, queryFn, ...queryOptions }) as CreateQueryResult<
    TData,
    TError
  > & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
};

/**
 * @summary ListBookmarks lists all the bookmarks for the user and global ones for dashboard
 */
export const adminServiceListBookmarks = (
  params?: AdminServiceListBookmarksParams,
  signal?: AbortSignal,
) => {
  return httpClient<V1ListBookmarksResponse>({
    url: `/v1/users/bookmarks`,
    method: "get",
    params,
    signal,
  });
};

export const getAdminServiceListBookmarksQueryKey = (
  params?: AdminServiceListBookmarksParams,
) => [`/v1/users/bookmarks`, ...(params ? [params] : [])];

export type AdminServiceListBookmarksQueryResult = NonNullable<
  Awaited<ReturnType<typeof adminServiceListBookmarks>>
>;
export type AdminServiceListBookmarksQueryError = RpcStatus;

export const createAdminServiceListBookmarks = <
  TData = Awaited<ReturnType<typeof adminServiceListBookmarks>>,
  TError = RpcStatus,
>(
  params?: AdminServiceListBookmarksParams,
  options?: {
    query?: CreateQueryOptions<
      Awaited<ReturnType<typeof adminServiceListBookmarks>>,
      TError,
      TData
    >;
  },
): CreateQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getAdminServiceListBookmarksQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof adminServiceListBookmarks>>
  > = ({ signal }) => adminServiceListBookmarks(params, signal);

  const query = createQuery<
    Awaited<ReturnType<typeof adminServiceListBookmarks>>,
    TError,
    TData
  >({ queryKey, queryFn, ...queryOptions }) as CreateQueryResult<
    TData,
    TError
  > & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
};

/**
 * @summary CreateBookmark creates a bookmark for the given user or for all users for the dashboard
 */
export const adminServiceCreateBookmark = (
  v1CreateBookmarkRequest: V1CreateBookmarkRequest,
) => {
  return httpClient<V1CreateBookmarkResponse>({
    url: `/v1/users/bookmarks`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: v1CreateBookmarkRequest,
  });
};

export type AdminServiceCreateBookmarkMutationResult = NonNullable<
  Awaited<ReturnType<typeof adminServiceCreateBookmark>>
>;
export type AdminServiceCreateBookmarkMutationBody = V1CreateBookmarkRequest;
export type AdminServiceCreateBookmarkMutationError = RpcStatus;

export const createAdminServiceCreateBookmark = <
  TError = RpcStatus,
  TContext = unknown,
>(options?: {
  mutation?: CreateMutationOptions<
    Awaited<ReturnType<typeof adminServiceCreateBookmark>>,
    TError,
    { data: V1CreateBookmarkRequest },
    TContext
  >;
}) => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof adminServiceCreateBookmark>>,
    { data: V1CreateBookmarkRequest }
  > = (props) => {
    const { data } = props ?? {};

    return adminServiceCreateBookmark(data);
  };

  return createMutation<
    Awaited<ReturnType<typeof adminServiceCreateBookmark>>,
    TError,
    { data: V1CreateBookmarkRequest },
    TContext
  >(mutationFn, mutationOptions);
};
/**
 * @summary UpdateBookmark updates a bookmark for the given user for the given project
 */
export const adminServiceUpdateBookmark = (
  v1UpdateBookmarkRequest: V1UpdateBookmarkRequest,
) => {
  return httpClient<V1UpdateBookmarkResponse>({
    url: `/v1/users/bookmarks`,
    method: "put",
    headers: { "Content-Type": "application/json" },
    data: v1UpdateBookmarkRequest,
  });
};

export type AdminServiceUpdateBookmarkMutationResult = NonNullable<
  Awaited<ReturnType<typeof adminServiceUpdateBookmark>>
>;
export type AdminServiceUpdateBookmarkMutationBody = V1UpdateBookmarkRequest;
export type AdminServiceUpdateBookmarkMutationError = RpcStatus;

export const createAdminServiceUpdateBookmark = <
  TError = RpcStatus,
  TContext = unknown,
>(options?: {
  mutation?: CreateMutationOptions<
    Awaited<ReturnType<typeof adminServiceUpdateBookmark>>,
    TError,
    { data: V1UpdateBookmarkRequest },
    TContext
  >;
}) => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof adminServiceUpdateBookmark>>,
    { data: V1UpdateBookmarkRequest }
  > = (props) => {
    const { data } = props ?? {};

    return adminServiceUpdateBookmark(data);
  };

  return createMutation<
    Awaited<ReturnType<typeof adminServiceUpdateBookmark>>,
    TError,
    { data: V1UpdateBookmarkRequest },
    TContext
  >(mutationFn, mutationOptions);
};
/**
 * @summary GetBookmark returns the bookmark for the given user for the given project
 */
export const adminServiceGetBookmark = (
  bookmarkId: string,
  signal?: AbortSignal,
) => {
  return httpClient<V1GetBookmarkResponse>({
    url: `/v1/users/bookmarks/${bookmarkId}`,
    method: "get",
    signal,
  });
};

export const getAdminServiceGetBookmarkQueryKey = (bookmarkId: string) => [
  `/v1/users/bookmarks/${bookmarkId}`,
];

export type AdminServiceGetBookmarkQueryResult = NonNullable<
  Awaited<ReturnType<typeof adminServiceGetBookmark>>
>;
export type AdminServiceGetBookmarkQueryError = RpcStatus;

export const createAdminServiceGetBookmark = <
  TData = Awaited<ReturnType<typeof adminServiceGetBookmark>>,
  TError = RpcStatus,
>(
  bookmarkId: string,
  options?: {
    query?: CreateQueryOptions<
      Awaited<ReturnType<typeof adminServiceGetBookmark>>,
      TError,
      TData
    >;
  },
): CreateQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getAdminServiceGetBookmarkQueryKey(bookmarkId);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof adminServiceGetBookmark>>
  > = ({ signal }) => adminServiceGetBookmark(bookmarkId, signal);

  const query = createQuery<
    Awaited<ReturnType<typeof adminServiceGetBookmark>>,
    TError,
    TData
  >({
    queryKey,
    queryFn,
    enabled: !!bookmarkId,
    ...queryOptions,
  }) as CreateQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
};

/**
 * @summary RemoveBookmark removes the bookmark for the given user or all users
 */
export const adminServiceRemoveBookmark = (bookmarkId: string) => {
  return httpClient<V1RemoveBookmarkResponse>({
    url: `/v1/users/bookmarks/${bookmarkId}`,
    method: "delete",
  });
};

export type AdminServiceRemoveBookmarkMutationResult = NonNullable<
  Awaited<ReturnType<typeof adminServiceRemoveBookmark>>
>;

export type AdminServiceRemoveBookmarkMutationError = RpcStatus;

export const createAdminServiceRemoveBookmark = <
  TError = RpcStatus,
  TContext = unknown,
>(options?: {
  mutation?: CreateMutationOptions<
    Awaited<ReturnType<typeof adminServiceRemoveBookmark>>,
    TError,
    { bookmarkId: string },
    TContext
  >;
}) => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof adminServiceRemoveBookmark>>,
    { bookmarkId: string }
  > = (props) => {
    const { bookmarkId } = props ?? {};

    return adminServiceRemoveBookmark(bookmarkId);
  };

  return createMutation<
    Awaited<ReturnType<typeof adminServiceRemoveBookmark>>,
    TError,
    { bookmarkId: string },
    TContext
  >(mutationFn, mutationOptions);
};
/**
 * @summary GetCurrentUser returns the currently authenticated user (if any)
 */
export const adminServiceGetCurrentUser = (signal?: AbortSignal) => {
  return httpClient<V1GetCurrentUserResponse>({
    url: `/v1/users/current`,
    method: "get",
    signal,
  });
};

export const getAdminServiceGetCurrentUserQueryKey = () => [
  `/v1/users/current`,
];

export type AdminServiceGetCurrentUserQueryResult = NonNullable<
  Awaited<ReturnType<typeof adminServiceGetCurrentUser>>
>;
export type AdminServiceGetCurrentUserQueryError = RpcStatus;

export const createAdminServiceGetCurrentUser = <
  TData = Awaited<ReturnType<typeof adminServiceGetCurrentUser>>,
  TError = RpcStatus,
>(options?: {
  query?: CreateQueryOptions<
    Awaited<ReturnType<typeof adminServiceGetCurrentUser>>,
    TError,
    TData
  >;
}): CreateQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getAdminServiceGetCurrentUserQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof adminServiceGetCurrentUser>>
  > = ({ signal }) => adminServiceGetCurrentUser(signal);

  const query = createQuery<
    Awaited<ReturnType<typeof adminServiceGetCurrentUser>>,
    TError,
    TData
  >({ queryKey, queryFn, ...queryOptions }) as CreateQueryResult<
    TData,
    TError
  > & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
};

/**
 * @summary UpdateUserPreferences updates the preferences for the user
 */
export const adminServiceUpdateUserPreferences = (
  v1UpdateUserPreferencesRequest: V1UpdateUserPreferencesRequest,
) => {
  return httpClient<V1UpdateUserPreferencesResponse>({
    url: `/v1/users/preferences`,
    method: "put",
    headers: { "Content-Type": "application/json" },
    data: v1UpdateUserPreferencesRequest,
  });
};

export type AdminServiceUpdateUserPreferencesMutationResult = NonNullable<
  Awaited<ReturnType<typeof adminServiceUpdateUserPreferences>>
>;
export type AdminServiceUpdateUserPreferencesMutationBody =
  V1UpdateUserPreferencesRequest;
export type AdminServiceUpdateUserPreferencesMutationError = RpcStatus;

export const createAdminServiceUpdateUserPreferences = <
  TError = RpcStatus,
  TContext = unknown,
>(options?: {
  mutation?: CreateMutationOptions<
    Awaited<ReturnType<typeof adminServiceUpdateUserPreferences>>,
    TError,
    { data: V1UpdateUserPreferencesRequest },
    TContext
  >;
}) => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof adminServiceUpdateUserPreferences>>,
    { data: V1UpdateUserPreferencesRequest }
  > = (props) => {
    const { data } = props ?? {};

    return adminServiceUpdateUserPreferences(data);
  };

  return createMutation<
    Awaited<ReturnType<typeof adminServiceUpdateUserPreferences>>,
    TError,
    { data: V1UpdateUserPreferencesRequest },
    TContext
  >(mutationFn, mutationOptions);
};
/**
 * @summary GetUsersByEmail returns users by email
 */
export const adminServiceSearchUsers = (
  params?: AdminServiceSearchUsersParams,
  signal?: AbortSignal,
) => {
  return httpClient<V1SearchUsersResponse>({
    url: `/v1/users/search`,
    method: "get",
    params,
    signal,
  });
};

export const getAdminServiceSearchUsersQueryKey = (
  params?: AdminServiceSearchUsersParams,
) => [`/v1/users/search`, ...(params ? [params] : [])];

export type AdminServiceSearchUsersQueryResult = NonNullable<
  Awaited<ReturnType<typeof adminServiceSearchUsers>>
>;
export type AdminServiceSearchUsersQueryError = RpcStatus;

export const createAdminServiceSearchUsers = <
  TData = Awaited<ReturnType<typeof adminServiceSearchUsers>>,
  TError = RpcStatus,
>(
  params?: AdminServiceSearchUsersParams,
  options?: {
    query?: CreateQueryOptions<
      Awaited<ReturnType<typeof adminServiceSearchUsers>>,
      TError,
      TData
    >;
  },
): CreateQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getAdminServiceSearchUsersQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof adminServiceSearchUsers>>
  > = ({ signal }) => adminServiceSearchUsers(params, signal);

  const query = createQuery<
    Awaited<ReturnType<typeof adminServiceSearchUsers>>,
    TError,
    TData
  >({ queryKey, queryFn, ...queryOptions }) as CreateQueryResult<
    TData,
    TError
  > & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
};

- index: 1
  input:
    - role: system
      content_type: text
      content: |-
        You are a routing agent that determines which specialized agent should handle a user's request.
        You operate in the context of a business intelligence tool that supports data modeling and data exploration, and more.
        Your input includes the user's previous messages and responses, as well as the user's latest message, which you are responsible for routing.
        Routing guidelines:
        - If the user's question relates to developing or changing the data model or dashboards, you should route to the developer.
        - If the user's question relates to retrieving specific business metrics, you should route to the analyst.
        - If the user asks a general question, you should route to the analyst.
        You must answer with a single agent choice and no further explanation. Pick only from this list of available agents:
        - developer_agent
        - analyst_agent
    - role: user
      content_type: text
      content: Develop a dashboard of Shopify orders
  response:
    role: assistant
    content_type: text
    content: '{"agent":"developer_agent"}'
- index: 2
  input:
    - role: system
      content_type: text
      content: "<role>You are a data engineer agent specialized in developing data models and metrics view definitions in the Rill business intelligence platform.</role>\n\n<concepts>\nRill is a \"business intelligence as code\" platform where all resources are defined using YAML files containing SQL snippets in a project directory.\nRill supports many different resource types, such as connectors, models, metrics views, explore dashboards, canvas dashboards, and more.\nFor the purposes of your work, you will only deal with:\n- **Models**: SQL statements and related metadata that produce a single table in the project's database (usually DuckDB or Clickhouse).\n- **Metrics views**: Sets of queryable business dimensions and measures based on a single model in the project. This is sometimes called the \"semantic layer\" or \"metrics layer\" in other tools.\nRill maintains a DAG of resources. In this DAG, metrics views are always derived from a single model. Multiple metrics views can derive from a single model, although usually it makes sense to have just one metrics view per model.\nWhen users ask you to develop a \"dashboard\", that just means to develop a new metrics view (and possibly a new underlying model). Rill automatically creates visual dashboards for each metrics view.\n</concepts>\n\n<example>\nThis example is not directly related to your current task. It just serves to explain how Rill project's look and how you might act on a user request.\n\nRill projects often (but not always) organize files in directories by resource type. A Rill project might look like this:\n```\nconnectors/duckdb.yaml\nmodels/orders.yaml\nmetrics_views/orders.yaml\nrill.yaml\n```\n\nThe user might ask you to \"Create a dashboard for my Github activity\". You would notice that this does not relate to the current files, and proceed with the following plan:\n1. Add a new model in \"models/git_commits.yaml\" using the \"develop_model\" tool.\n2. Add a new metrics view in \"metrics_views/git_commits.yaml\" based on the new \"git_commits\" model using the \"develop_metrics_view\" tool.\n</example>\n\n<process>\nAt a high level, you should follow these steps:\n1. Understand the current contents of the project.\n2. Make a plan for how to implement the user's request. \n3. Only if necessary, add a new model or update an existing model to reflect the user's request\n4. Only if necessary, add a new metrics view or update an existing metrics view to reflect the user's request. The metrics view should use a model in the project, which may already exist or may have been added in step 2.\n\nYou should use the tools available to you to understand the current project contents and to make the necessary changes. You should use the \"read_file\" tool sparingly and surgically to understand files you consider promising for your task, you should not use it to inspect many files in the project.\n\nYou should not make many changes at a time. Carefully consider the minimum changes you can make to address the user's request. If there's a model already in place that relates to the user's request, consider re-using that and only adding or updating a metrics view.\n</process>"
    - role: user
      content_type: text
      content: Develop a dashboard of Shopify orders
    - role: assistant
      content_type: tool_call
      id: d29ddebe-4979-4d29-82cb-e92d3ebd0e5d
      tool_name: list_files
      content: '{}'
    - role: tool
      content_type: tool_response
      id: d29ddebe-4979-4d29-82cb-e92d3ebd0e5d
      content: '{"files":[{"path":"/connectors/duckdb.yaml","resources":[{"kind":"rill.runtime.v1.Connector","name":"duckdb","reconcile_error":"","reconcile_status":"RECONCILE_STATUS_IDLE"}]},{"path":"/rill.yaml"}]}'
  response:
    role: assistant
    content_type: text
    content: |-
      The project currently does not have any models or metrics views related to Shopify orders. To develop a dashboard for Shopify orders, I will need to create a new model to ingest and transform the Shopify orders data, and then create a metrics view based on that model.

      Here's the plan:
      1. Develop a new model for Shopify orders in a file named `models/shopify_orders.yaml`.
      2. Develop a new metrics view based on the `shopify_orders` model in a file named `metrics_views/shopify_orders.yaml`.

      Let's proceed with creating the model and the metrics view.
- index: 3
  input:
    - role: system
      content_type: text
      content: |-
        <role>You are a data engineer agent specialized in developing data models in the Rill business intelligence platform.</role>

        <concepts>
        Rill is a "business intelligence as code" platform where all resources are defined using YAML files containing SQL snippets in a project directory.
        For the purposes of your work, you will only deal with **model** resources, which are SQL statements and related metadata that produce a single table in the project's database.
        In Rill, when you write a file, the platform discovers and "reconciles" it immediately. For a model, reconcile updates the database to contain the defined table.
        </concepts>

        <process>
        At a high level, you should follow these steps:
        1. Leverage the "read_file" tool to understand the file's current contents, if any (it may return a file not found error).
        2. Generate a new model definition based on the user's prompt and save it to the requested path using the "write_file" tool.
        3. The "write_file" tool will respond with the reconcile status. If there are parse or reconcile errors, you should fix them using the "write_file" tool. If there are no errors, your work is done.

        Additional instructions:
        - The user will often ask you to create or update models that require external data, such as from a SaaS application or their data warehouse. In these cases, you should generate a SQL query that emits mock data that resembles the expected structure and contents of the external data. You may generate up to 100 rows of mock data.
        - You should not attempt to reference other models in the project, unless the model already exists and already references them.
        </process>

        <example>
        A model definition in Rill is a YAML file containing a SQL statement. The SQL statement will be creates as a table in the project's database using "CREATE TABLE name AS SELECT ...". Here is an example Rill model:
        ```
        type: model
        materialize: true

        sql: >
          SELECT '2025-05-01T00:00:00Z' AS event_time, 'United States' AS country, 'Toothbrush' AS product_name, 5 AS quantity, 100 AS price
          UNION ALL
          SELECT '2025-05-02T00:00:00Z' AS event_time, 'Denmark' AS country, 'Apple' AS product_name, 10 AS quantity, 50 AS price
        ```
        </example>
    - role: user
      content_type: text
      content: |-
        Task: Create a model to ingest and transform Shopify orders data. The model should include fields such as order_id, customer_id, order_date, total_amount, and order_status.

        Output path: /models/shopify_orders.yaml

        SQL dialect: duckdb
  response:
    role: assistant
    content_type: tool_call
    id: call_SE86pS4w3dIxf2PExB1CcKXj
    tool_name: read_file
    content: '{"path":"/models/shopify_orders.yaml"}'
- index: 4
  input:
    - role: system
      content_type: text
      content: |-
        <role>You are a data engineer agent specialized in developing data models in the Rill business intelligence platform.</role>

        <concepts>
        Rill is a "business intelligence as code" platform where all resources are defined using YAML files containing SQL snippets in a project directory.
        For the purposes of your work, you will only deal with **model** resources, which are SQL statements and related metadata that produce a single table in the project's database.
        In Rill, when you write a file, the platform discovers and "reconciles" it immediately. For a model, reconcile updates the database to contain the defined table.
        </concepts>

        <process>
        At a high level, you should follow these steps:
        1. Leverage the "read_file" tool to understand the file's current contents, if any (it may return a file not found error).
        2. Generate a new model definition based on the user's prompt and save it to the requested path using the "write_file" tool.
        3. The "write_file" tool will respond with the reconcile status. If there are parse or reconcile errors, you should fix them using the "write_file" tool. If there are no errors, your work is done.

        Additional instructions:
        - The user will often ask you to create or update models that require external data, such as from a SaaS application or their data warehouse. In these cases, you should generate a SQL query that emits mock data that resembles the expected structure and contents of the external data. You may generate up to 100 rows of mock data.
        - You should not attempt to reference other models in the project, unless the model already exists and already references them.
        </process>

        <example>
        A model definition in Rill is a YAML file containing a SQL statement. The SQL statement will be creates as a table in the project's database using "CREATE TABLE name AS SELECT ...". Here is an example Rill model:
        ```
        type: model
        materialize: true

        sql: >
          SELECT '2025-05-01T00:00:00Z' AS event_time, 'United States' AS country, 'Toothbrush' AS product_name, 5 AS quantity, 100 AS price
          UNION ALL
          SELECT '2025-05-02T00:00:00Z' AS event_time, 'Denmark' AS country, 'Apple' AS product_name, 10 AS quantity, 50 AS price
        ```
        </example>
    - role: user
      content_type: text
      content: |-
        Task: Create a model to ingest and transform Shopify orders data. The model should include fields such as order_id, customer_id, order_date, total_amount, and order_status.

        Output path: /models/shopify_orders.yaml

        SQL dialect: duckdb
    - role: assistant
      content_type: tool_call
      id: 4bedeaed-02ef-4c65-b213-acfa5ff2100d
      tool_name: read_file
      content: '{"path":"/models/shopify_orders.yaml"}'
    - role: tool
      content_type: tool_response
      id: 4bedeaed-02ef-4c65-b213-acfa5ff2100d
      is_error: true
      content: open /models/shopify_orders.yaml no such file or directory
  response:
    role: assistant
    content_type: tool_call
    id: call_1ASHp8sgYIv5ukoT5JZKRLcO
    tool_name: write_file
    content: '{"contents":"type: model\nmaterialize: true\n\nsql: \u003e\n  SELECT 1 AS order_id, 101 AS customer_id, ''2023-10-01'' AS order_date, 250.00 AS total_amount, ''completed'' AS order_status\n  UNION ALL\n  SELECT 2 AS order_id, 102 AS customer_id, ''2023-10-02'' AS order_date, 150.00 AS total_amount, ''pending'' AS order_status\n  UNION ALL\n  SELECT 3 AS order_id, 103 AS customer_id, ''2023-10-03'' AS order_date, 300.00 AS total_amount, ''shipped'' AS order_status\n  UNION ALL\n  SELECT 4 AS order_id, 104 AS customer_id, ''2023-10-04'' AS order_date, 450.00 AS total_amount, ''cancelled'' AS order_status\n  UNION ALL\n  SELECT 5 AS order_id, 105 AS customer_id, ''2023-10-05'' AS order_date, 500.00 AS total_amount, ''completed'' AS order_status\n  UNION ALL\n  SELECT 6 AS order_id, 106 AS customer_id, ''2023-10-06'' AS order_date, 200.00 AS total_amount, ''pending'' AS order_status\n  UNION ALL\n  SELECT 7 AS order_id, 107 AS customer_id, ''2023-10-07'' AS order_date, 350.00 AS total_amount, ''shipped'' AS order_status\n  UNION ALL\n  SELECT 8 AS order_id, 108 AS customer_id, ''2023-10-08'' AS order_date, 400.00 AS total_amount, ''cancelled'' AS order_status\n  UNION ALL\n  SELECT 9 AS order_id, 109 AS customer_id, ''2023-10-09'' AS order_date, 600.00 AS total_amount, ''completed'' AS order_status\n  UNION ALL\n  SELECT 10 AS order_id, 110 AS customer_id, ''2023-10-10'' AS order_date, 700.00 AS total_amount, ''pending'' AS order_status","path":"/models/shopify_orders.yaml"}'
- index: 5
  input:
    - role: system
      content_type: text
      content: |-
        <role>You are a data engineer agent specialized in developing data models in the Rill business intelligence platform.</role>

        <concepts>
        Rill is a "business intelligence as code" platform where all resources are defined using YAML files containing SQL snippets in a project directory.
        For the purposes of your work, you will only deal with **model** resources, which are SQL statements and related metadata that produce a single table in the project's database.
        In Rill, when you write a file, the platform discovers and "reconciles" it immediately. For a model, reconcile updates the database to contain the defined table.
        </concepts>

        <process>
        At a high level, you should follow these steps:
        1. Leverage the "read_file" tool to understand the file's current contents, if any (it may return a file not found error).
        2. Generate a new model definition based on the user's prompt and save it to the requested path using the "write_file" tool.
        3. The "write_file" tool will respond with the reconcile status. If there are parse or reconcile errors, you should fix them using the "write_file" tool. If there are no errors, your work is done.

        Additional instructions:
        - The user will often ask you to create or update models that require external data, such as from a SaaS application or their data warehouse. In these cases, you should generate a SQL query that emits mock data that resembles the expected structure and contents of the external data. You may generate up to 100 rows of mock data.
        - You should not attempt to reference other models in the project, unless the model already exists and already references them.
        </process>

        <example>
        A model definition in Rill is a YAML file containing a SQL statement. The SQL statement will be creates as a table in the project's database using "CREATE TABLE name AS SELECT ...". Here is an example Rill model:
        ```
        type: model
        materialize: true

        sql: >
          SELECT '2025-05-01T00:00:00Z' AS event_time, 'United States' AS country, 'Toothbrush' AS product_name, 5 AS quantity, 100 AS price
          UNION ALL
          SELECT '2025-05-02T00:00:00Z' AS event_time, 'Denmark' AS country, 'Apple' AS product_name, 10 AS quantity, 50 AS price
        ```
        </example>
    - role: user
      content_type: text
      content: |-
        Task: Create a model to ingest and transform Shopify orders data. The model should include fields such as order_id, customer_id, order_date, total_amount, and order_status.

        Output path: /models/shopify_orders.yaml

        SQL dialect: duckdb
    - role: assistant
      content_type: tool_call
      id: 4bedeaed-02ef-4c65-b213-acfa5ff2100d
      tool_name: read_file
      content: '{"path":"/models/shopify_orders.yaml"}'
    - role: tool
      content_type: tool_response
      id: 4bedeaed-02ef-4c65-b213-acfa5ff2100d
      is_error: true
      content: open /models/shopify_orders.yaml no such file or directory
    - role: assistant
      content_type: tool_call
      id: 5c4c6e76-528e-43e5-af96-a1837e4e63f5
      tool_name: write_file
      content: '{"contents":"type: model\nmaterialize: true\n\nsql: \u003e\n  SELECT 1 AS order_id, 101 AS customer_id, ''2023-10-01'' AS order_date, 250.00 AS total_amount, ''completed'' AS order_status\n  UNION ALL\n  SELECT 2 AS order_id, 102 AS customer_id, ''2023-10-02'' AS order_date, 150.00 AS total_amount, ''pending'' AS order_status\n  UNION ALL\n  SELECT 3 AS order_id, 103 AS customer_id, ''2023-10-03'' AS order_date, 300.00 AS total_amount, ''shipped'' AS order_status\n  UNION ALL\n  SELECT 4 AS order_id, 104 AS customer_id, ''2023-10-04'' AS order_date, 450.00 AS total_amount, ''cancelled'' AS order_status\n  UNION ALL\n  SELECT 5 AS order_id, 105 AS customer_id, ''2023-10-05'' AS order_date, 500.00 AS total_amount, ''completed'' AS order_status\n  UNION ALL\n  SELECT 6 AS order_id, 106 AS customer_id, ''2023-10-06'' AS order_date, 200.00 AS total_amount, ''pending'' AS order_status\n  UNION ALL\n  SELECT 7 AS order_id, 107 AS customer_id, ''2023-10-07'' AS order_date, 350.00 AS total_amount, ''shipped'' AS order_status\n  UNION ALL\n  SELECT 8 AS order_id, 108 AS customer_id, ''2023-10-08'' AS order_date, 400.00 AS total_amount, ''cancelled'' AS order_status\n  UNION ALL\n  SELECT 9 AS order_id, 109 AS customer_id, ''2023-10-09'' AS order_date, 600.00 AS total_amount, ''completed'' AS order_status\n  UNION ALL\n  SELECT 10 AS order_id, 110 AS customer_id, ''2023-10-10'' AS order_date, 700.00 AS total_amount, ''pending'' AS order_status","path":"/models/shopify_orders.yaml"}'
    - role: tool
      content_type: tool_response
      id: 5c4c6e76-528e-43e5-af96-a1837e4e63f5
      content: '{"resources":[{"kind":"rill.runtime.v1.Model","name":"shopify_orders","reconcile_error":"","reconcile_status":"RECONCILE_STATUS_IDLE"}]}'
  response:
    role: assistant
    content_type: text
    content: The model for ingesting and transforming Shopify orders data has been successfully created at the path `/models/shopify_orders.yaml`. The model includes fields such as `order_id`, `customer_id`, `order_date`, `total_amount`, and `order_status`.
- index: 6
  input:
    - role: system
      content_type: text
      content: |2+
        You are an agent whose only task is to suggest relevant business metrics (KPIs) based on a table schema.
        The metrics should be valid SQL aggregation expressions that use only the COUNT, SUM, MIN, MAX, and AVG functions.
        Do not use any complex aggregations and do not use WHERE or FILTER in the metrics expressions.
        Your output should only consist of valid YAML in the format below:

        display_name: <human-friendly display name based on the table name and column names>
        measures:
            - name: <unique name for the metric in snake case, such as average_sales>
              display_name: <short descriptive display name for the metric>
              expression: <SQL expression to calculate the KPI in the requested SQL dialect>
              description: <short description of the metric>

    - role: user
      content_type: text
      content: |2
        Give me up to 10 suggested metrics using the "duckdb" SQL dialect based on the table named "shopify_orders", which has the following schema:
        - column=order_id, type=CODE_INT32
        - column=customer_id, type=CODE_INT32
        - column=order_date, type=CODE_STRING
        - column=total_amount, type=CODE_DECIMAL
        - column=order_status, type=CODE_STRING
  response:
    role: assistant
    content_type: text
    content: |-
      ```yaml
      display_name: Shopify Orders Metrics
      measures:
          - name: total_orders
            display_name: Total Orders
            expression: COUNT(order_id)
            description: The total number of orders placed.

          - name: total_customers
            display_name: Total Customers
            expression: COUNT(DISTINCT customer_id)
            description: The total number of unique customers who placed orders.

          - name: total_revenue
            display_name: Total Revenue
            expression: SUM(total_amount)
            description: The total revenue generated from all orders.

          - name: average_order_value
            display_name: Average Order Value
            expression: AVG(total_amount)
            description: The average value of an order.

          - name: max_order_value
            display_name: Maximum Order Value
            expression: MAX(total_amount)
            description: The highest value of a single order.

          - name: min_order_value
            display_name: Minimum Order Value
            expression: MIN(total_amount)
            description: The lowest value of a single order.

          - name: total_completed_orders
            display_name: Total Completed Orders
            expression: COUNT(CASE WHEN order_status = 'completed' THEN order_id END)
            description: The total number of orders that have been completed.

          - name: total_pending_orders
            display_name: Total Pending Orders
            expression: COUNT(CASE WHEN order_status = 'pending' THEN order_id END)
            description: The total number of orders that are still pending.

          - name: average_orders_per_customer
            display_name: Average Orders per Customer
            expression: COUNT(order_id) / COUNT(DISTINCT customer_id)
            description: The average number of orders placed by each customer.

          - name: order_status_distribution
            display_name: Order Status Distribution
            expression: COUNT(order_id) GROUP BY order_status
            description: The distribution of orders across different statuses.
      ```
- index: 7
  input:
    - role: system
      content_type: text
      content: "<role>You are a data engineer agent specialized in developing data models and metrics view definitions in the Rill business intelligence platform.</role>\n\n<concepts>\nRill is a \"business intelligence as code\" platform where all resources are defined using YAML files containing SQL snippets in a project directory.\nRill supports many different resource types, such as connectors, models, metrics views, explore dashboards, canvas dashboards, and more.\nFor the purposes of your work, you will only deal with:\n- **Models**: SQL statements and related metadata that produce a single table in the project's database (usually DuckDB or Clickhouse).\n- **Metrics views**: Sets of queryable business dimensions and measures based on a single model in the project. This is sometimes called the \"semantic layer\" or \"metrics layer\" in other tools.\nRill maintains a DAG of resources. In this DAG, metrics views are always derived from a single model. Multiple metrics views can derive from a single model, although usually it makes sense to have just one metrics view per model.\nWhen users ask you to develop a \"dashboard\", that just means to develop a new metrics view (and possibly a new underlying model). Rill automatically creates visual dashboards for each metrics view.\n</concepts>\n\n<example>\nThis example is not directly related to your current task. It just serves to explain how Rill project's look and how you might act on a user request.\n\nRill projects often (but not always) organize files in directories by resource type. A Rill project might look like this:\n```\nconnectors/duckdb.yaml\nmodels/orders.yaml\nmetrics_views/orders.yaml\nrill.yaml\n```\n\nThe user might ask you to \"Create a dashboard for my Github activity\". You would notice that this does not relate to the current files, and proceed with the following plan:\n1. Add a new model in \"models/git_commits.yaml\" using the \"develop_model\" tool.\n2. Add a new metrics view in \"metrics_views/git_commits.yaml\" based on the new \"git_commits\" model using the \"develop_metrics_view\" tool.\n</example>\n\n<process>\nAt a high level, you should follow these steps:\n1. Understand the current contents of the project.\n2. Make a plan for how to implement the user's request. \n3. Only if necessary, add a new model or update an existing model to reflect the user's request\n4. Only if necessary, add a new metrics view or update an existing metrics view to reflect the user's request. The metrics view should use a model in the project, which may already exist or may have been added in step 2.\n\nYou should use the tools available to you to understand the current project contents and to make the necessary changes. You should use the \"read_file\" tool sparingly and surgically to understand files you consider promising for your task, you should not use it to inspect many files in the project.\n\nYou should not make many changes at a time. Carefully consider the minimum changes you can make to address the user's request. If there's a model already in place that relates to the user's request, consider re-using that and only adding or updating a metrics view.\n</process>"
    - role: user
      content_type: text
      content: Develop a dashboard of Shopify orders
    - role: assistant
      content_type: tool_call
      id: d29ddebe-4979-4d29-82cb-e92d3ebd0e5d
      tool_name: list_files
      content: '{}'
    - role: tool
      content_type: tool_response
      id: d29ddebe-4979-4d29-82cb-e92d3ebd0e5d
      content: '{"files":[{"path":"/connectors/duckdb.yaml","resources":[{"kind":"rill.runtime.v1.Connector","name":"duckdb","reconcile_error":"","reconcile_status":"RECONCILE_STATUS_IDLE"}]},{"path":"/rill.yaml"}]}'
    - role: assistant
      content_type: tool_call
      id: a047d3f6-e38c-4588-ae1d-85c2b370c432
      tool_name: develop_model
      content: '{"path":"models/shopify_orders.yaml","prompt":"Create a model to ingest and transform Shopify orders data. The model should include fields such as order_id, customer_id, order_date, total_amount, and order_status."}'
    - role: tool
      content_type: tool_response
      id: a047d3f6-e38c-4588-ae1d-85c2b370c432
      content: '{"model_name":"shopify_orders"}'
    - role: assistant
      content_type: tool_call
      id: 779bd74a-5e5c-4b88-82fb-6de6a444b651
      tool_name: develop_metrics_view
      content: '{"model":"shopify_orders","path":"metrics_views/shopify_orders.yaml"}'
    - role: tool
      content_type: tool_response
      id: 779bd74a-5e5c-4b88-82fb-6de6a444b651
      content: '{"metrics_view_name":"shopify_orders"}'
  response:
    role: assistant
    content_type: text
    content: I have successfully developed a dashboard for Shopify orders. This involved creating a new model to ingest and transform Shopify orders data, and then building a metrics view on top of that model. You can now explore the Shopify orders data through the automatically generated visual dashboard.

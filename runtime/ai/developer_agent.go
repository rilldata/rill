package ai

import (
	"context"
	"fmt"
	"strings"

	"github.com/modelcontextprotocol/go-sdk/mcp"
	aiv1 "github.com/rilldata/rill/proto/gen/rill/ai/v1"
	"github.com/rilldata/rill/runtime"
	"github.com/rilldata/rill/runtime/ai/instructions"
)

const DeveloperAgentName = "developer_agent"

type DeveloperAgent struct {
	Runtime *runtime.Runtime
}

var _ Tool[*DeveloperAgentArgs, *DeveloperAgentResult] = (*DeveloperAgent)(nil)

type DeveloperAgentArgs struct {
	Prompt          string `json:"prompt" jsonschema:"User prompt for the developer agent."`
	InitProject     bool   `json:"init_project,omitempty" jsonschema:"Set to true if the prompt is provided as part of project initialization. Should only be used when the project directory contains an empty project (except for the boilerplate generated by UnpackEmpty)."`
	CurrentFilePath string `json:"current_file_path,omitempty" jsonschema:"Optional path to the file that the user is currently viewing/editing."`
}

type DeveloperAgentResult struct {
	Response string `json:"response"`
}

func (t *DeveloperAgent) Spec() *mcp.Tool {
	return &mcp.Tool{
		Name:        DeveloperAgentName,
		Title:       "Developer Agent",
		Description: "Agent that assists with development tasks.",
		Meta: map[string]any{
			"openai/toolInvocation/invoking": "Developing...",
			"openai/toolInvocation/invoked":  "Development completed",
		},
	}
}

func (t *DeveloperAgent) CheckAccess(ctx context.Context) (bool, error) {
	return checkDeveloperAccess(ctx, t.Runtime, true)
}

func (t *DeveloperAgent) Handler(ctx context.Context, args *DeveloperAgentArgs) (*DeveloperAgentResult, error) {
	// Generate the prompts
	systemPrompt, err := t.systemPrompt(ctx)
	if err != nil {
		return nil, err
	}
	userPrompt, err := t.userPrompt(ctx, args)
	if err != nil {
		return nil, err
	}

	// Pre-invoke some tool calls
	s := GetSession(ctx)
	_, err = s.CallTool(ctx, RoleAssistant, ListFilesName, nil, &ListFilesArgs{})
	if err != nil {
		return nil, err
	}
	_, err = s.CallTool(ctx, RoleAssistant, ProjectStatusName, nil, &ProjectStatusArgs{})
	if err != nil {
		return nil, err
	}
	if args.CurrentFilePath != "" {
		_, err := s.CallTool(ctx, RoleAssistant, ReadFileName, nil, &ReadFileArgs{
			Path: args.CurrentFilePath,
		})
		if err != nil {
			return nil, err
		}
	}

	// Build initial completion messages
	messages := []*aiv1.CompletionMessage{NewTextCompletionMessage(RoleSystem, systemPrompt)}
	messages = append(messages, s.NewCompletionMessages(s.MessagesWithResults(FilterByType(MessageTypeCall), FilterByTool(DeveloperAgentName)))...)
	messages = append(messages, NewTextCompletionMessage(RoleUser, userPrompt))
	messages = append(messages, s.NewCompletionMessages(s.MessagesWithResults(FilterByParent(s.ID())))...)

	// Run an LLM tool call loop
	var response string
	err = s.Complete(ctx, "Developer loop", &response, &CompleteOptions{
		Messages: messages,
		Tools: []string{
			ProjectStatusName,
			ListFilesName,
			SearchFilesName,
			ReadFileName,
			ListBucketsName,
			ListBucketObjectsName,
			ListTablesName,
			ShowTableName,
			QuerySQLName,
			DevelopFileName,
		},
		MaxIterations: 20,
		UnwrapCall:    true,
	})
	if err != nil {
		return nil, err
	}

	return &DeveloperAgentResult{
		Response: response,
	}, nil
}

func (t *DeveloperAgent) systemPrompt(ctx context.Context) (string, error) {
	instr, err := instructions.Load("development.md", instructions.Options{})
	if err != nil {
		return "", fmt.Errorf("failed to load developer agent system prompt: %w", err)
	}

	return instr.Body, nil
}

func (t *DeveloperAgent) userPrompt(ctx context.Context, args *DeveloperAgentArgs) (string, error) {
	// Get default OLAP info
	olapConnector, olapDriver, olapModeReadwrite, err := defaultOLAPInfo(ctx, t.Runtime, GetSession(ctx).InstanceID())
	if err != nil {
		return "", err
	}

	// Prepare template data.
	session := GetSession(ctx)
	data := map[string]any{
		"prompt":                 args.Prompt,
		"init_project":           args.InitProject,
		"current_file_path":      args.CurrentFilePath,
		"ai_instructions":        session.ProjectInstructions(),
		"default_olap_connector": olapConnector,
		"default_olap_driver":    olapDriver,
		"default_olap_readwrite": olapModeReadwrite,
	}

	// Generate the system prompt
	return executeTemplate(`
{{ if .current_file_path }}
The user is currently viewing/editing the file: {{ .current_file_path }}
Their request may or may not relate to this file.
{{ end }}

{{ if .init_project }}
The project is currently empty apart from a few boilerplate files (like rill.yaml).
You should help them set up their initial project based on their task description.
Ideally you should set up a full initial data source to dashboard journey.
If the user did not explicitly mention an initial data source, generate a model with mock data.
Feel free to change the default OLAP connector if it makes sense for the task.
{{ end }}

{{ if .ai_instructions }}
The user has configured global additional instructions for you. They may not relate to the current request, and may not even relate to your work as a data engineer agent. Only use them if you find them relevant. They are: {{ .ai_instructions }}
{{ end }}

This may not relate to the user's task, but for context, the project's default OLAP connector is named {{ .default_olap_connector }} (driver: {{ .default_olap_driver }}).
{{ if .default_olap_readwrite }} The default OLAP is in readwrite mode, so you can use it in models if you want.
{{ else }} The default OLAP is in read-only mode, so you cannot create models in it. {{ end }}

Task: {{ .prompt }}
`, data)
}

// checkDeveloperAccess checks whether developer tools should be available in the current session.
// If isAgentTool is true, it indicates that the check is being performed for an agent tool instead of a plain tool.
func checkDeveloperAccess(ctx context.Context, rt *runtime.Runtime, isAgentTool bool) (bool, error) {
	// Must be able to use AI and edit the project
	s := GetSession(ctx)
	if !s.Claims().Can(runtime.UseAI) || !s.Claims().Can(runtime.EditRepo) {
		return false, nil
	}

	// Don't expose agent tools to external clients (like MCP)
	if isAgentTool {
		if !strings.HasPrefix(s.CatalogSession().UserAgent, "rill") {
			return false, nil
		}
	}

	// Must have the developer_agent feature flag
	ff, err := rt.FeatureFlags(ctx, s.InstanceID(), s.Claims())
	if err != nil {
		return false, err
	}
	return ff["developer_agent"], nil
}

// defaultOLAPInfo retrieves the default OLAP connector name, driver, and whether it is in readwrite mode.
func defaultOLAPInfo(ctx context.Context, rt *runtime.Runtime, instanceID string) (string, string, bool, error) {
	// Get instance config
	inst, err := rt.Instance(ctx, instanceID)
	if err != nil {
		return "", "", false, err
	}
	olapConnector := inst.ResolveOLAPConnector()

	// Open OLAP
	olapCfg, err := rt.ConnectorConfig(ctx, instanceID, olapConnector)
	if err != nil {
		return "", "", false, err
	}
	olapModeReadwrite := olapCfg.Provision || olapCfg.Resolve()["mode"] == "readwrite"

	return olapConnector, olapCfg.Driver, olapModeReadwrite, nil
}

package ai

import (
	"context"
	"errors"
	"fmt"
	"strings"

	"github.com/modelcontextprotocol/go-sdk/mcp"
	aiv1 "github.com/rilldata/rill/proto/gen/rill/ai/v1"
	"github.com/rilldata/rill/runtime"
	"github.com/rilldata/rill/runtime/ai/instructions"
)

const DeveloperAgentName = "developer_agent"

type DeveloperAgent struct {
	Runtime *runtime.Runtime
}

var _ Tool[*DeveloperAgentArgs, *DeveloperAgentResult] = (*DeveloperAgent)(nil)

type DeveloperAgentArgs struct {
	Prompt          string `json:"prompt" jsonschema:"User prompt for the developer agent."`
	InitProject     bool   `json:"init_project,omitempty" jsonschema:"Set to true if the prompt is provided as part of project initialization. Should only be used when the project directory contains an empty project (except for the boilerplate generated by UnpackEmpty)."`
	CurrentFilePath string `json:"current_file_path,omitempty" jsonschema:"Optional path to the file that the user is currently viewing/editing."`
}

type DeveloperAgentResult struct {
	Response string `json:"response"`
}

func (t *DeveloperAgent) Spec() *mcp.Tool {
	return &mcp.Tool{
		Name:        DeveloperAgentName,
		Title:       "Developer Agent",
		Description: "Agent that assists with development tasks.",
		Meta: map[string]any{
			"openai/toolInvocation/invoking": "Developing...",
			"openai/toolInvocation/invoked":  "Development completed",
		},
	}
}

func (t *DeveloperAgent) CheckAccess(ctx context.Context) (bool, error) {
	return checkDeveloperAccess(ctx, t.Runtime, true)
}

func (t *DeveloperAgent) Handler(ctx context.Context, args *DeveloperAgentArgs) (*DeveloperAgentResult, error) {
	// Generate the prompts
	systemPrompt, err := t.systemPrompt()
	if err != nil {
		return nil, err
	}
	userPrompt, err := t.userPrompt(ctx, args)
	if err != nil {
		return nil, err
	}

	// Pre-invoke some tool calls
	s := GetSession(ctx)
	_, err = s.CallTool(ctx, RoleAssistant, ListFilesName, nil, &ListFilesArgs{})
	if err != nil {
		return nil, err
	}
	_, err = s.CallTool(ctx, RoleAssistant, ProjectStatusName, nil, &ProjectStatusArgs{})
	if err != nil {
		return nil, err
	}
	if args.CurrentFilePath != "" {
		_, _ = s.CallTool(ctx, RoleAssistant, ReadFileName, nil, &ReadFileArgs{
			Path: args.CurrentFilePath,
		})
		if ctx.Err() != nil { // Ignore tool error since the file may not exist
			return nil, ctx.Err()
		}
	}

	// Build initial completion messages
	messages := []*aiv1.CompletionMessage{NewTextCompletionMessage(RoleSystem, systemPrompt)}
	messages = append(messages, s.NewCompletionMessages(s.MessagesWithResults(FilterByType(MessageTypeCall), FilterByTool(DeveloperAgentName)))...)
	messages = append(messages, NewTextCompletionMessage(RoleUser, userPrompt))
	messages = append(messages, s.NewCompletionMessages(s.MessagesWithResults(FilterByParent(s.ID())))...)

	// Run an LLM tool call loop
	var response string
	err = s.Complete(ctx, "Developer loop", &response, &CompleteOptions{
		Messages: messages,
		Tools: []string{
			ProjectStatusName,
			ListFilesName,
			SearchFilesName,
			ReadFileName,
			ListBucketsName,
			ListBucketObjectsName,
			ListTablesName,
			ShowTableName,
			QuerySQLName,
			DevelopFileName,
			// NavigateName,
		},
		MaxIterations: 20,
		UnwrapCall:    true,
	})
	if err != nil {
		return nil, err
	}

	return &DeveloperAgentResult{
		Response: response,
	}, nil
}

func (t *DeveloperAgent) systemPrompt() (string, error) {
	instr, err := instructions.Load("development.md", instructions.Options{})
	if err != nil {
		return "", fmt.Errorf("failed to load developer agent system prompt: %w", err)
	}

	return instr.Body, nil
}

func (t *DeveloperAgent) userPrompt(ctx context.Context, args *DeveloperAgentArgs) (string, error) {
	// Get default OLAP info
	olapInfo, err := defaultOLAPInfo(ctx, t.Runtime, GetSession(ctx).InstanceID())
	if err != nil {
		return "", err
	}

	// Prepare template data.
	session := GetSession(ctx)
	data := map[string]any{
		"prompt":            args.Prompt,
		"init_project":      args.InitProject,
		"current_file_path": args.CurrentFilePath,
		"ai_instructions":   session.ProjectInstructions(),
		"default_olap_info": olapInfo,
	}

	// Generate the system prompt
	return executeTemplate(`
{{ if .current_file_path }}
The user is currently viewing/editing the file: {{ .current_file_path }}
Their request may or may not relate to this file.
{{ end }}

{{ if .init_project }}
The project is currently empty apart from a few boilerplate files (like rill.yaml).
You should help them set up their initial project based on their task description.
Ideally you should set up a full initial data source to dashboard journey.
If the user did not explicitly mention an initial data source, generate a model with mock data.
Feel free to change the default OLAP connector if it makes sense for the task.
{{ end }}

{{ if .ai_instructions }}
The user has configured global additional instructions for you. They may not relate to the current request, and may not even relate to your work as a data engineer agent. Only use them if you find them relevant. They are: {{ .ai_instructions }}
{{ end }}

For context, here are some details about the project's default OLAP connector: {{ .default_olap_info }}.
Note that you can only use it in model resources if it is not readonly.

Call "navigate" tool for the main file created/edited (not if it is deleted) in the conversation. Use kind "file" and pass the written file path.
Prefer dashboard or metrics view files over other files.

Task: {{ .prompt }}
`, data)
}

// checkDeveloperAccess checks whether developer tools should be available in the current session.
// If internal is true, it indicates that the tool should not be exposed to external clients (like MCP).
func checkDeveloperAccess(ctx context.Context, rt *runtime.Runtime, internal bool) (bool, error) {
	// Must be able to use AI and edit the project
	s := GetSession(ctx)
	if !s.Claims().Can(runtime.UseAI) || !s.Claims().Can(runtime.EditRepo) {
		return false, nil
	}

	// Don't expose agent tools to external clients (like MCP)
	if internal {
		if !strings.HasPrefix(s.CatalogSession().UserAgent, "rill") {
			return false, nil
		}
	}

	// Must have the developer_agent feature flag
	ff, err := rt.FeatureFlags(ctx, s.InstanceID(), s.Claims())
	if err != nil {
		return false, err
	}
	return ff["developer_agent"], nil
}

// defaultOLAPInfo returns info about the default OLAP connector name, driver, and whether it is in readwrite mode.
func defaultOLAPInfo(ctx context.Context, rt *runtime.Runtime, instanceID string) (string, error) {
	// Get instance config
	inst, err := rt.Instance(ctx, instanceID)
	if err != nil {
		return "", err
	}
	olapConnector := inst.ResolveOLAPConnector()

	// Open OLAP handle
	handle, release, err := rt.AcquireHandle(ctx, instanceID, olapConnector)
	if err != nil {
		if errors.Is(err, ctx.Err()) {
			return "", err
		}
		return fmt.Sprintf("name: %q, error: %v", olapConnector, err), nil
	}
	defer release()

	// Get dialect

	// Add OLAP dialect
	olap, ok := handle.AsOLAP(instanceID)
	if !ok {
		return fmt.Sprintf("name: %q, error: not an OLAP connector", olapConnector), nil
	}
	dialect := olap.Dialect()

	// Determine if OLAP can run models
	_, err = handle.AsModelManager(instanceID)
	olapModeReadwrite := err == nil

	return fmt.Sprintf("name: %q, driver: %q, dialect: %q, readonly: %v", olapConnector, handle.Driver(), dialect.String(), !olapModeReadwrite), nil
}

/**
 * Generated by orval v7.9.0 üç∫
 * Do not edit manually.
 * rill/runtime/v1/schema.proto
 * OpenAPI spec version: version not set
 */
export interface ColumnTimeSeriesRequestBasicMeasure {
  id?: string;
  expression?: string;
  sqlName?: string;
}

export interface ConnectorDriverProperty {
  key?: string;
  type?: ConnectorDriverPropertyType;
  required?: boolean;
  displayName?: string;
  description?: string;
  docsUrl?: string;
  hint?: string;
  default?: string;
  placeholder?: string;
  secret?: boolean;
  noPrompt?: boolean;
}

export type ConnectorDriverPropertyType =
  (typeof ConnectorDriverPropertyType)[keyof typeof ConnectorDriverPropertyType];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ConnectorDriverPropertyType = {
  TYPE_UNSPECIFIED: "TYPE_UNSPECIFIED",
  TYPE_NUMBER: "TYPE_NUMBER",
  TYPE_BOOLEAN: "TYPE_BOOLEAN",
  TYPE_STRING: "TYPE_STRING",
  TYPE_FILE: "TYPE_FILE",
  TYPE_INFORMATIONAL: "TYPE_INFORMATIONAL",
} as const;

export interface MetricsViewFilterCond {
  name?: string;
  in?: unknown[];
  like?: string[];
}

export interface MetricsViewSearchResponseSearchResult {
  dimension?: string;
  value?: unknown;
}

export interface MetricsViewSpecDimension {
  name?: string;
  type?: MetricsViewSpecDimensionType;
  displayName?: string;
  description?: string;
  tags?: string[];
  column?: string;
  expression?: string;
  unnest?: boolean;
  uri?: string;
  lookupTable?: string;
  lookupKeyColumn?: string;
  lookupValueColumn?: string;
  lookupDefaultExpression?: string;
  smallestTimeGrain?: V1TimeGrain;
  dataType?: Runtimev1Type;
}

export interface MetricsViewSpecDimensionSelector {
  name?: string;
  timeGrain?: V1TimeGrain;
  desc?: boolean;
}

export type MetricsViewSpecDimensionType =
  (typeof MetricsViewSpecDimensionType)[keyof typeof MetricsViewSpecDimensionType];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const MetricsViewSpecDimensionType = {
  DIMENSION_TYPE_UNSPECIFIED: "DIMENSION_TYPE_UNSPECIFIED",
  DIMENSION_TYPE_CATEGORICAL: "DIMENSION_TYPE_CATEGORICAL",
  DIMENSION_TYPE_TIME: "DIMENSION_TYPE_TIME",
  DIMENSION_TYPE_GEOSPATIAL: "DIMENSION_TYPE_GEOSPATIAL",
} as const;

export type MetricsViewSpecMeasureFormatD3Locale = { [key: string]: unknown };

export interface MetricsViewSpecMeasure {
  name?: string;
  displayName?: string;
  description?: string;
  tags?: string[];
  expression?: string;
  type?: MetricsViewSpecMeasureType;
  window?: MetricsViewSpecMeasureWindow;
  perDimensions?: MetricsViewSpecDimensionSelector[];
  requiredDimensions?: MetricsViewSpecDimensionSelector[];
  referencedMeasures?: string[];
  formatPreset?: string;
  formatD3?: string;
  formatD3Locale?: MetricsViewSpecMeasureFormatD3Locale;
  validPercentOfTotal?: boolean;
  treatNullsAs?: string;
  dataType?: Runtimev1Type;
}

export type MetricsViewSpecMeasureType =
  (typeof MetricsViewSpecMeasureType)[keyof typeof MetricsViewSpecMeasureType];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const MetricsViewSpecMeasureType = {
  MEASURE_TYPE_UNSPECIFIED: "MEASURE_TYPE_UNSPECIFIED",
  MEASURE_TYPE_SIMPLE: "MEASURE_TYPE_SIMPLE",
  MEASURE_TYPE_DERIVED: "MEASURE_TYPE_DERIVED",
  MEASURE_TYPE_TIME_COMPARISON: "MEASURE_TYPE_TIME_COMPARISON",
} as const;

export interface MetricsViewSpecMeasureWindow {
  partition?: boolean;
  /** Dimensions to order the window by. Must be present in required_dimensions. */
  orderBy?: MetricsViewSpecDimensionSelector[];
  frameExpression?: string;
}

export interface NumericHistogramBinsBin {
  bucket?: number;
  low?: number;
  midpoint?: number;
  high?: number;
  count?: number;
}

export interface NumericOutliersOutlier {
  bucket?: number;
  low?: number;
  high?: number;
  present?: boolean;
  count?: number;
}

export interface StructTypeField {
  name?: string;
  type?: Runtimev1Type;
}

export interface TopKEntry {
  value?: unknown;
  count?: number;
}

export type TypeCode = (typeof TypeCode)[keyof typeof TypeCode];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const TypeCode = {
  CODE_UNSPECIFIED: "CODE_UNSPECIFIED",
  CODE_BOOL: "CODE_BOOL",
  CODE_INT8: "CODE_INT8",
  CODE_INT16: "CODE_INT16",
  CODE_INT32: "CODE_INT32",
  CODE_INT64: "CODE_INT64",
  CODE_INT128: "CODE_INT128",
  CODE_INT256: "CODE_INT256",
  CODE_UINT8: "CODE_UINT8",
  CODE_UINT16: "CODE_UINT16",
  CODE_UINT32: "CODE_UINT32",
  CODE_UINT64: "CODE_UINT64",
  CODE_UINT128: "CODE_UINT128",
  CODE_UINT256: "CODE_UINT256",
  CODE_FLOAT32: "CODE_FLOAT32",
  CODE_FLOAT64: "CODE_FLOAT64",
  CODE_TIMESTAMP: "CODE_TIMESTAMP",
  CODE_INTERVAL: "CODE_INTERVAL",
  CODE_DATE: "CODE_DATE",
  CODE_TIME: "CODE_TIME",
  CODE_STRING: "CODE_STRING",
  CODE_BYTES: "CODE_BYTES",
  CODE_ARRAY: "CODE_ARRAY",
  CODE_STRUCT: "CODE_STRUCT",
  CODE_MAP: "CODE_MAP",
  CODE_DECIMAL: "CODE_DECIMAL",
  CODE_JSON: "CODE_JSON",
  CODE_UUID: "CODE_UUID",
  CODE_POINT: "CODE_POINT",
  CODE_POLYGON: "CODE_POLYGON",
} as const;

export interface ProtobufAny {
  "@type"?: string;
  [key: string]: unknown;
}

/**
 * `NullValue` is a singleton enumeration to represent the null value for the
`Value` type union.

The JSON representation for `NullValue` is JSON `null`.

 - NULL_VALUE: Null value.
 */
export type ProtobufNullValue =
  (typeof ProtobufNullValue)[keyof typeof ProtobufNullValue];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ProtobufNullValue = {
  NULL_VALUE: "NULL_VALUE",
} as const;

export interface RpcStatus {
  code?: number;
  message?: string;
  details?: ProtobufAny[];
}

export interface Runtimev1Type {
  code?: TypeCode;
  nullable?: boolean;
  arrayElementType?: Runtimev1Type;
  structType?: V1StructType;
  mapType?: V1MapType;
}

/**
 * API defines a custom operation for querying data stored in Rill.
 */
export interface V1API {
  spec?: V1APISpec;
  state?: V1APIState;
}

export type V1APISpecResolverProperties = { [key: string]: unknown };

export interface V1APISpec {
  resolver?: string;
  resolverProperties?: V1APISpecResolverProperties;
  openapiSummary?: string;
  openapiParametersJson?: string;
  openapiRequestSchemaJson?: string;
  openapiResponseSchemaJson?: string;
  openapiDefsPrefix?: string;
  securityRules?: V1SecurityRule[];
  skipNestedSecurity?: boolean;
}

export interface V1APIState {
  [key: string]: unknown;
}

export interface V1Alert {
  spec?: V1AlertSpec;
  state?: V1AlertState;
}

export interface V1AlertExecution {
  adhoc?: boolean;
  result?: V1AssertionResult;
  sentNotifications?: boolean;
  executionTime?: string;
  startedOn?: string;
  finishedOn?: string;
  suppressedSince?: string;
}

export type V1AlertSpecResolverProperties = { [key: string]: unknown };

export type V1AlertSpecQueryForAttributes = { [key: string]: unknown };

export type V1AlertSpecAnnotations = { [key: string]: string };

export interface V1AlertSpec {
  displayName?: string;
  trigger?: boolean;
  refreshSchedule?: V1Schedule;
  /** If true, will use the lowest watermark of its refs instead of the trigger time. */
  watermarkInherit?: boolean;
  intervalsIsoDuration?: string;
  intervalsLimit?: number;
  intervalsCheckUnclosed?: boolean;
  timeoutSeconds?: number;
  queryName?: string;
  queryArgsJson?: string;
  resolver?: string;
  resolverProperties?: V1AlertSpecResolverProperties;
  queryForUserId?: string;
  queryForUserEmail?: string;
  queryForAttributes?: V1AlertSpecQueryForAttributes;
  notifyOnRecover?: boolean;
  notifyOnFail?: boolean;
  notifyOnError?: boolean;
  renotify?: boolean;
  renotifyAfterSeconds?: number;
  notifiers?: V1Notifier[];
  annotations?: V1AlertSpecAnnotations;
}

export interface V1AlertState {
  specHash?: string;
  refsHash?: string;
  nextRunOn?: string;
  currentExecution?: V1AlertExecution;
  executionHistory?: V1AlertExecution[];
  executionCount?: number;
}

/**
 * Context for prompts handled by the analyst_agent.
 */
export interface V1AnalystAgentContext {
  /** Optional explore dashboard. */
  explore?: string;
  canvas?: string;
  canvasComponent?: string;
  /** Optional dimensions. */
  dimensions?: string[];
  /** Optional measures. */
  measures?: string[];
  where?: V1Expression;
  /** Optional start of a time range. */
  timeStart?: string;
  /** Optional end of a time range. */
  timeEnd?: string;
}

export interface V1AnalyzeConnectorsResponse {
  connectors?: V1AnalyzedConnector[];
}

export interface V1AnalyzeVariablesResponse {
  variables?: V1AnalyzedVariable[];
}

export type V1AnalyzedConnectorConfig = { [key: string]: unknown };

export type V1AnalyzedConnectorPresetConfig = { [key: string]: unknown };

export type V1AnalyzedConnectorProjectConfig = { [key: string]: unknown };

export type V1AnalyzedConnectorEnvConfig = { [key: string]: string };

export type V1AnalyzedConnectorProvisionArgs = { [key: string]: unknown };

/**
 * AnalyzedConnector contains information about a connector that is referenced in the project files.
 */
export interface V1AnalyzedConnector {
  name?: string;
  driver?: V1ConnectorDriver;
  config?: V1AnalyzedConnectorConfig;
  presetConfig?: V1AnalyzedConnectorPresetConfig;
  projectConfig?: V1AnalyzedConnectorProjectConfig;
  envConfig?: V1AnalyzedConnectorEnvConfig;
  provision?: boolean;
  provisionArgs?: V1AnalyzedConnectorProvisionArgs;
  hasAnonymousAccess?: boolean;
  usedBy?: V1ResourceName[];
  errorMessage?: string;
}

export interface V1AnalyzedVariable {
  /** Name of the variable. */
  name?: string;
  /** Default value set for the variable in rill.yaml, if any. */
  defaultValue?: string;
  /** List of resources that appear to use the connector. */
  usedBy?: V1ResourceName[];
}

export type V1AssertionResultFailRow = { [key: string]: unknown };

export interface V1AssertionResult {
  status?: V1AssertionStatus;
  failRow?: V1AssertionResultFailRow;
  errorMessage?: string;
}

export type V1AssertionStatus =
  (typeof V1AssertionStatus)[keyof typeof V1AssertionStatus];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const V1AssertionStatus = {
  ASSERTION_STATUS_UNSPECIFIED: "ASSERTION_STATUS_UNSPECIFIED",
  ASSERTION_STATUS_PASS: "ASSERTION_STATUS_PASS",
  ASSERTION_STATUS_FAIL: "ASSERTION_STATUS_FAIL",
  ASSERTION_STATUS_ERROR: "ASSERTION_STATUS_ERROR",
} as const;

export type V1BuiltinMeasure =
  (typeof V1BuiltinMeasure)[keyof typeof V1BuiltinMeasure];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const V1BuiltinMeasure = {
  BUILTIN_MEASURE_UNSPECIFIED: "BUILTIN_MEASURE_UNSPECIFIED",
  BUILTIN_MEASURE_COUNT: "BUILTIN_MEASURE_COUNT",
  BUILTIN_MEASURE_COUNT_DISTINCT: "BUILTIN_MEASURE_COUNT_DISTINCT",
} as const;

export interface V1Canvas {
  spec?: V1CanvasSpec;
  state?: V1CanvasState;
}

export interface V1CanvasItem {
  /** Name of the component to render. */
  component?: string;
  /** Indicates if the component was defined inline as part of the canvas YAML. */
  definedInCanvas?: boolean;
  /** Width of the item. The unit is given in width_unit. */
  width?: number;
  /** Unit of the width. Current possible values: empty string. */
  widthUnit?: string;
}

export type V1CanvasPresetFilterExpr = {
  [key: string]: V1DefaultMetricsSQLFilter;
};

export interface V1CanvasPreset {
  /** Time range for the explore.
It corresponds to the `range` property of the explore's `time_ranges`.
If not found in `time_ranges`, it should be added to the list. */
  timeRange?: string;
  comparisonMode?: V1ExploreComparisonMode;
  /** If comparison_mode is EXPLORE_COMPARISON_MODE_DIMENSION, this indicates the dimension to use. */
  comparisonDimension?: string;
  filterExpr?: V1CanvasPresetFilterExpr;
}

export interface V1CanvasRow {
  /** Height of the row. The unit is given in height_unit. */
  height?: number;
  /** Unit of the height. Current possible values: "px", empty string. */
  heightUnit?: string;
  /** Items to render in the row. */
  items?: V1CanvasItem[];
}

export interface V1CanvasSpec {
  /** Display name for the canvas. */
  displayName?: string;
  /** Banner text that can be displayed in Rill Cloud. */
  banner?: string;
  /** Max width in pixels of the canvas. */
  maxWidth?: number;
  /** Horizontal gap in pixels of the canvas. */
  gapX?: number;
  /** Vertical gap in pixels of the canvas. */
  gapY?: number;
  /** Name of the theme to use. Only one of theme and embedded_theme can be set. */
  theme?: string;
  embeddedTheme?: V1ThemeSpec;
  /** List of selectable time ranges with comparison time ranges.
If the list is empty, a default list should be shown.
TODO: Once the canvas APIs have stabilized, rename ExploreTimeRange to a non-explore-specific name. */
  timeRanges?: V1ExploreTimeRange[];
  allowCustomTimeRange?: boolean;
  /** List of selectable time zones.
If the list is empty, a default list should be shown.
The values should be valid IANA location identifiers. */
  timeZones?: string[];
  /** Indicates if filters should be enabled for the canvas. */
  filtersEnabled?: boolean;
  defaultPreset?: V1CanvasPreset;
  /** Variables that can be used in the canvas. */
  variables?: V1ComponentVariable[];
  rows?: V1CanvasRow[];
  /** Security rules to apply for access to the canvas. */
  securityRules?: V1SecurityRule[];
  pinnedFilters?: string[];
}

export interface V1CanvasState {
  validSpec?: V1CanvasSpec;
  /** The last time any underlying metrics view(s)'s data was refreshed.
This may be empty if the data refresh time is not known, e.g. if the metrics view is based on an externally managed table. */
  dataRefreshedOn?: string;
}

export interface V1CategoricalSummary {
  topK?: V1TopK;
  cardinality?: number;
}

export interface V1CharLocation {
  line?: number;
}

export interface V1Color {
  red?: number;
  green?: number;
  blue?: number;
  alpha?: number;
}

export interface V1ColumnCardinalityRequest {
  instanceId?: string;
  connector?: string;
  database?: string;
  databaseSchema?: string;
  tableName?: string;
  columnName?: string;
  priority?: number;
}

export interface V1ColumnCardinalityResponse {
  categoricalSummary?: V1CategoricalSummary;
}

export interface V1ColumnDescriptiveStatisticsRequest {
  instanceId?: string;
  connector?: string;
  database?: string;
  databaseSchema?: string;
  tableName?: string;
  columnName?: string;
  priority?: number;
}

export interface V1ColumnDescriptiveStatisticsResponse {
  numericSummary?: V1NumericSummary;
}

export interface V1ColumnNullCountRequest {
  instanceId?: string;
  connector?: string;
  database?: string;
  databaseSchema?: string;
  tableName?: string;
  columnName?: string;
  priority?: number;
}

export interface V1ColumnNullCountResponse {
  count?: number;
}

export interface V1ColumnNumericHistogramRequest {
  instanceId?: string;
  connector?: string;
  database?: string;
  databaseSchema?: string;
  tableName?: string;
  columnName?: string;
  histogramMethod?: V1HistogramMethod;
  priority?: number;
}

export interface V1ColumnNumericHistogramResponse {
  numericSummary?: V1NumericSummary;
}

export interface V1ColumnRollupIntervalRequest {
  instanceId?: string;
  connector?: string;
  database?: string;
  databaseSchema?: string;
  tableName?: string;
  columnName?: string;
  priority?: number;
}

export interface V1ColumnRollupIntervalResponse {
  start?: string;
  end?: string;
  interval?: V1TimeGrain;
}

export interface V1ColumnRugHistogramRequest {
  instanceId?: string;
  connector?: string;
  database?: string;
  databaseSchema?: string;
  tableName?: string;
  columnName?: string;
  priority?: number;
}

export interface V1ColumnRugHistogramResponse {
  numericSummary?: V1NumericSummary;
}

export interface V1ColumnTimeGrainRequest {
  instanceId?: string;
  connector?: string;
  database?: string;
  databaseSchema?: string;
  tableName?: string;
  columnName?: string;
  priority?: number;
}

export interface V1ColumnTimeGrainResponse {
  timeGrain?: V1TimeGrain;
}

export interface V1ColumnTimeRangeRequest {
  instanceId?: string;
  connector?: string;
  database?: string;
  databaseSchema?: string;
  tableName?: string;
  columnName?: string;
  priority?: number;
}

export interface V1ColumnTimeRangeResponse {
  timeRangeSummary?: V1TimeRangeSummary;
}

export interface V1ColumnTimeSeriesRequest {
  instanceId?: string;
  connector?: string;
  database?: string;
  databaseSchema?: string;
  tableName?: string;
  measures?: ColumnTimeSeriesRequestBasicMeasure[];
  timestampColumnName?: string;
  timeRange?: V1TimeSeriesTimeRange;
  pixels?: number;
  sampleSize?: number;
  priority?: number;
  timeZone?: string;
}

export interface V1ColumnTimeSeriesResponse {
  rollup?: V1TimeSeriesResponse;
}

export interface V1ColumnTopKRequest {
  instanceId?: string;
  connector?: string;
  database?: string;
  databaseSchema?: string;
  tableName?: string;
  columnName?: string;
  agg?: string;
  k?: number;
  priority?: number;
}

export interface V1ColumnTopKResponse {
  categoricalSummary?: V1CategoricalSummary;
}

export interface V1CompleteResponse {
  conversationId?: string;
  messages?: V1Message[];
}

export interface V1CompleteStreamingResponse {
  conversationId?: string;
  message?: V1Message;
}

export interface V1Component {
  spec?: V1ComponentSpec;
  state?: V1ComponentState;
}

export type V1ComponentSpecRendererProperties = { [key: string]: unknown };

export interface V1ComponentSpec {
  displayName?: string;
  description?: string;
  renderer?: string;
  rendererProperties?: V1ComponentSpecRendererProperties;
  input?: V1ComponentVariable[];
  output?: V1ComponentVariable;
  definedInCanvas?: boolean;
}

export interface V1ComponentState {
  validSpec?: V1ComponentSpec;
  /** The last time any underlying metrics view(s)'s data was refreshed.
This may be empty if the data refresh time is not known, e.g. if the metrics view is based on an externally managed table. */
  dataRefreshedOn?: string;
}

export interface V1ComponentVariable {
  name?: string;
  type?: string;
  defaultValue?: unknown;
}

export interface V1Condition {
  op?: V1Operation;
  exprs?: V1Expression[];
}

export type V1ConnectorConfig = { [key: string]: unknown };

export type V1ConnectorProvisionArgs = { [key: string]: unknown };

export interface V1Connector {
  /** Type of the connector. One of the infra driver supported. */
  type?: string;
  name?: string;
  config?: V1ConnectorConfig;
  templatedProperties?: string[];
  provision?: boolean;
  provisionArgs?: V1ConnectorProvisionArgs;
}

/**
 * ConnectorDriver represents a connector driver available in the runtime.
 */
export interface V1ConnectorDriver {
  name?: string;
  configProperties?: ConnectorDriverProperty[];
  sourceProperties?: ConnectorDriverProperty[];
  displayName?: string;
  description?: string;
  docsUrl?: string;
  implementsRegistry?: boolean;
  implementsCatalog?: boolean;
  implementsRepo?: boolean;
  implementsAdmin?: boolean;
  implementsAi?: boolean;
  implementsSqlStore?: boolean;
  implementsOlap?: boolean;
  implementsObjectStore?: boolean;
  implementsFileStore?: boolean;
  implementsNotifier?: boolean;
  implementsWarehouse?: boolean;
}

export type V1ConnectorSpecProperties = { [key: string]: unknown };

export type V1ConnectorSpecProvisionArgs = { [key: string]: unknown };

export interface V1ConnectorSpec {
  driver?: string;
  properties?: V1ConnectorSpecProperties;
  templatedProperties?: string[];
  provision?: boolean;
  provisionArgs?: V1ConnectorSpecProvisionArgs;
}

export interface V1ConnectorState {
  specHash?: string;
}

export interface V1ConnectorV2 {
  spec?: V1ConnectorSpec;
  state?: V1ConnectorState;
}

export interface V1ContentBlock {
  text?: string;
  toolCall?: V1ToolCall;
  toolResult?: V1ToolResult;
}

export interface V1Conversation {
  id?: string;
  ownerId?: string;
  title?: string;
  userAgent?: string;
  createdOn?: string;
  updatedOn?: string;
  /** NOTE: Deprecated. */
  messages?: V1Message[];
}

export interface V1ConvertExpressionToMetricsSQLResponse {
  /** The SQL filter string representation of the expression. */
  sql?: string;
}

export interface V1CreateDirectoryResponse {
  [key: string]: unknown;
}

export type V1CreateInstanceRequestVariables = { [key: string]: string };

export type V1CreateInstanceRequestAnnotations = { [key: string]: string };

/**
 * Request message for RuntimeService.CreateInstance.
See message Instance for field descriptions.
 */
export interface V1CreateInstanceRequest {
  instanceId?: string;
  environment?: string;
  olapConnector?: string;
  repoConnector?: string;
  adminConnector?: string;
  aiConnector?: string;
  connectors?: V1Connector[];
  variables?: V1CreateInstanceRequestVariables;
  annotations?: V1CreateInstanceRequestAnnotations;
  frontendUrl?: string;
}

export interface V1CreateInstanceResponse {
  instance?: V1Instance;
}

export interface V1CreateTriggerResponse {
  [key: string]: unknown;
}

export interface V1DatabaseSchemaInfo {
  database?: string;
  databaseSchema?: string;
}

export interface V1DefaultMetricsSQLFilter {
  expression?: V1Expression;
}

export interface V1DeleteFileResponse {
  [key: string]: unknown;
}

export interface V1DeleteInstanceResponse {
  [key: string]: unknown;
}

/**
 * Context for prompts handled by the developer_agent.
 */
export interface V1DeveloperAgentContext {
  /** Set to true if the prompt is provided as part of project initialization.
This should only be used when the project directory contains an empty project (except for the boilerplate generated by UnpackEmpty). */
  initProject?: boolean;
  /** Optional path to the file that the user is currently viewing/editing.
This helps the agent understand which file the user is referring to in their request. */
  currentFilePath?: string;
}

export interface V1DirEntry {
  path?: string;
  isDir?: boolean;
}

export interface V1EditInstanceResponse {
  instance?: V1Instance;
}

/**
 * Example contains metadata about an example project that is available for unpacking.
 */
export interface V1Example {
  name?: string;
  displayName?: string;
  description?: string;
}

export interface V1Explore {
  spec?: V1ExploreSpec;
  state?: V1ExploreState;
}

export type V1ExploreComparisonMode =
  (typeof V1ExploreComparisonMode)[keyof typeof V1ExploreComparisonMode];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const V1ExploreComparisonMode = {
  EXPLORE_COMPARISON_MODE_UNSPECIFIED: "EXPLORE_COMPARISON_MODE_UNSPECIFIED",
  EXPLORE_COMPARISON_MODE_NONE: "EXPLORE_COMPARISON_MODE_NONE",
  EXPLORE_COMPARISON_MODE_TIME: "EXPLORE_COMPARISON_MODE_TIME",
  EXPLORE_COMPARISON_MODE_DIMENSION: "EXPLORE_COMPARISON_MODE_DIMENSION",
} as const;

export interface V1ExploreComparisonTimeRange {
  /** ISO 8601 duration string to use as an offset from the base time range. */
  offset?: string;
  /** ISO 8601 duration string for the duration of the comparison time range.
If not specified, it should fallback to the range of the base time range. */
  range?: string;
}

export interface V1ExplorePreset {
  /** Dimensions to show. If `dimensions_selector` is set, this will only be set in `state.valid_spec`. */
  dimensions?: string[];
  dimensionsSelector?: V1FieldSelector;
  /** Measures to show. If `measures_selector` is set, this will only be set in `state.valid_spec`. */
  measures?: string[];
  measuresSelector?: V1FieldSelector;
  where?: V1Expression;
  /** Temporary to differentiate between "select" and "in list" modes. Expression will be replaced with UI specific state in the future. */
  dimensionsWithInlistFilter?: string[];
  /** Time range for the explore.
It corresponds to the `range` property of the explore's `time_ranges`.
If not found in `time_ranges`, it should be added to the list. */
  timeRange?: string;
  timezone?: string;
  timeGrain?: string;
  selectTimeRange?: string;
  comparisonMode?: V1ExploreComparisonMode;
  compareTimeRange?: string;
  /** If comparison_mode is EXPLORE_COMPARISON_MODE_DIMENSION, this indicates the dimension to use. */
  comparisonDimension?: string;
  view?: V1ExploreWebView;
  exploreSortBy?: string;
  exploreSortAsc?: boolean;
  exploreSortType?: V1ExploreSortType;
  exploreExpandedDimension?: string;
  exploreLeaderboardMeasureCount?: number;
  exploreLeaderboardMeasures?: string[];
  exploreLeaderboardShowContextForAllMeasures?: boolean;
  timeDimensionMeasure?: string;
  timeDimensionChartType?: string;
  timeDimensionPin?: boolean;
  pivotRows?: string[];
  pivotCols?: string[];
  pivotSortBy?: string;
  pivotSortAsc?: boolean;
  pivotTableMode?: string;
  pivotRowLimit?: number;
}

export type V1ExploreSortType =
  (typeof V1ExploreSortType)[keyof typeof V1ExploreSortType];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const V1ExploreSortType = {
  EXPLORE_SORT_TYPE_UNSPECIFIED: "EXPLORE_SORT_TYPE_UNSPECIFIED",
  EXPLORE_SORT_TYPE_VALUE: "EXPLORE_SORT_TYPE_VALUE",
  EXPLORE_SORT_TYPE_PERCENT: "EXPLORE_SORT_TYPE_PERCENT",
  EXPLORE_SORT_TYPE_DELTA_PERCENT: "EXPLORE_SORT_TYPE_DELTA_PERCENT",
  EXPLORE_SORT_TYPE_DELTA_ABSOLUTE: "EXPLORE_SORT_TYPE_DELTA_ABSOLUTE",
  EXPLORE_SORT_TYPE_DIMENSION: "EXPLORE_SORT_TYPE_DIMENSION",
} as const;

export interface V1ExploreSpec {
  displayName?: string;
  description?: string;
  metricsView?: string;
  /** Dimensions to show. If `dimensions_selector` is set, this will only be set in `state.valid_spec`. */
  dimensions?: string[];
  dimensionsSelector?: V1FieldSelector;
  /** Measures to show. If `measures_selector` is set, this will only be set in `state.valid_spec`. */
  measures?: string[];
  measuresSelector?: V1FieldSelector;
  theme?: string;
  embeddedTheme?: V1ThemeSpec;
  /** List of selectable time ranges with comparison time ranges.
If the list is empty, a default list should be shown. */
  timeRanges?: V1ExploreTimeRange[];
  /** List of selectable time zones.
If the list is empty, a default list should be shown.
The values should be valid IANA location identifiers. */
  timeZones?: string[];
  defaultPreset?: V1ExplorePreset;
  /** If true, the pivot tab will be hidden when the explore is embedded. */
  embedsHidePivot?: boolean;
  /** Security for the explore dashboard.
These are not currently parsed from YAML, but will be derived from the parent metrics view. */
  securityRules?: V1SecurityRule[];
  /** Banner text that can be displayed in Rill Cloud. */
  banner?: string;
  lockTimeZone?: boolean;
  allowCustomTimeRange?: boolean;
  /** When true, it indicates that the explore was defined in a metrics view either explicitly or emitted because version was not set. */
  definedInMetricsView?: boolean;
}

export interface V1ExploreState {
  validSpec?: V1ExploreSpec;
  /** The last time the underlying metrics view's data was refreshed.
This may be empty if the data refresh time is not known, e.g. if the metrics view is based on an externally managed table. */
  dataRefreshedOn?: string;
}

export interface V1ExploreTimeRange {
  range?: string;
  comparisonTimeRanges?: V1ExploreComparisonTimeRange[];
}

export type V1ExploreWebView =
  (typeof V1ExploreWebView)[keyof typeof V1ExploreWebView];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const V1ExploreWebView = {
  EXPLORE_WEB_VIEW_UNSPECIFIED: "EXPLORE_WEB_VIEW_UNSPECIFIED",
  EXPLORE_WEB_VIEW_EXPLORE: "EXPLORE_WEB_VIEW_EXPLORE",
  EXPLORE_WEB_VIEW_TIME_DIMENSION: "EXPLORE_WEB_VIEW_TIME_DIMENSION",
  EXPLORE_WEB_VIEW_PIVOT: "EXPLORE_WEB_VIEW_PIVOT",
  EXPLORE_WEB_VIEW_CANVAS: "EXPLORE_WEB_VIEW_CANVAS",
} as const;

export type V1ExportFormat =
  (typeof V1ExportFormat)[keyof typeof V1ExportFormat];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const V1ExportFormat = {
  EXPORT_FORMAT_UNSPECIFIED: "EXPORT_FORMAT_UNSPECIFIED",
  EXPORT_FORMAT_CSV: "EXPORT_FORMAT_CSV",
  EXPORT_FORMAT_XLSX: "EXPORT_FORMAT_XLSX",
  EXPORT_FORMAT_PARQUET: "EXPORT_FORMAT_PARQUET",
} as const;

export interface V1ExportReportResponse {
  downloadUrlPath?: string;
}

export interface V1ExportResponse {
  downloadUrlPath?: string;
}

export interface V1Expression {
  ident?: string;
  val?: unknown;
  cond?: V1Condition;
  subquery?: V1Subquery;
}

/**
 * FieldSelector describes logic for selecting a list of fields.
It is useful for dynamically evaluating fields when the list of potential fields is not known at parse time.
 */
export interface V1FieldSelector {
  /** Invert the result such that all fields *except* the selected fields are returned. */
  invert?: boolean;
  /** Select all fields. */
  all?: boolean;
  fields?: V1StringListValue;
  /** Select fields by a regular expression. */
  regex?: string;
  /** Select fields by a DuckDB SQL SELECT expression. For example "* EXCLUDE (city)". */
  duckdbExpression?: string;
}

/**
 * FileEvent describes a file change.
 */
export type V1FileEvent = (typeof V1FileEvent)[keyof typeof V1FileEvent];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const V1FileEvent = {
  FILE_EVENT_UNSPECIFIED: "FILE_EVENT_UNSPECIFIED",
  FILE_EVENT_WRITE: "FILE_EVENT_WRITE",
  FILE_EVENT_DELETE: "FILE_EVENT_DELETE",
} as const;

export interface V1ForkConversationResponse {
  conversationId?: string;
}

export interface V1GenerateCanvasFileResponse {
  /** Indicates if AI-based generation succeeded. If it failed, it falls back to the simpler heuristic approach. */
  aiSucceeded?: boolean;
}

export interface V1GenerateMetricsViewFileResponse {
  /** Indicates if AI-based generation succeeded. If it failed, it falls back to the simpler heuristic approach. */
  aiSucceeded?: boolean;
}

export type V1GenerateRendererResponseRendererProperties = {
  [key: string]: unknown;
};

export interface V1GenerateRendererResponse {
  renderer?: string;
  rendererProperties?: V1GenerateRendererResponseRendererProperties;
}

export type V1GenerateResolverResponseResolverProperties = {
  [key: string]: unknown;
};

export interface V1GenerateResolverResponse {
  resolver?: string;
  resolverProperties?: V1GenerateResolverResponseResolverProperties;
}

export interface V1GetConversationResponse {
  conversation?: V1Conversation;
  messages?: V1Message[];
  isOwner?: boolean;
}

export interface V1GetExploreResponse {
  explore?: V1Resource;
  metricsView?: V1Resource;
}

export interface V1GetFileResponse {
  blob?: string;
  updatedOn?: string;
}

export interface V1GetInstanceResponse {
  instance?: V1Instance;
}

export interface V1GetLogsResponse {
  logs?: V1Log[];
}

export interface V1GetModelPartitionsResponse {
  partitions?: V1ModelPartition[];
  nextPageToken?: string;
}

export interface V1GetResourceResponse {
  resource?: V1Resource;
}

export type V1GetTableResponseSchema = { [key: string]: string };

export interface V1GetTableResponse {
  schema?: V1GetTableResponseSchema;
}

export interface V1GitBranch {
  name?: string;
  hasDeployment?: boolean;
  editableDeployment?: boolean;
}

export interface V1GitCommit {
  commitSha?: string;
  authorName?: string;
  authorEmail?: string;
  committedOn?: string;
  message?: string;
}

export interface V1GitCommitResponse {
  commitSha?: string;
}

export interface V1GitMergeToBranchResponse {
  /** The output of the git merge command. Only set for unsuccessful merges. */
  output?: string;
}

export interface V1GitPullResponse {
  /** The output of the git pull command. Only set for unsuccessful pulls. */
  output?: string;
}

export interface V1GitPushResponse {
  [key: string]: unknown;
}

export interface V1GitStatusResponse {
  /** The current branch of the git repo. */
  branch?: string;
  /** The remote url of the git repo. */
  githubUrl?: string;
  /** If the repo is managed by Rill. */
  managedGit?: boolean;
  /** local_changes returns true if there are any staged, unstaged, or untracked changes in the local git repo. */
  localChanges?: boolean;
  /** local_commits returns number of local commits that are not pushed to the remote git repo. */
  localCommits?: number;
  /** remote_commits returns number of remote commits not pulled yet. */
  remoteCommits?: number;
}

export interface V1GitSwitchBranchResponse {
  [key: string]: unknown;
}

export type V1HealthResponseInstancesHealth = {
  [key: string]: V1InstanceHealth;
};

export interface V1HealthResponse {
  limiterError?: string;
  connCacheError?: string;
  metastoreError?: string;
  networkError?: string;
  instancesHealth?: V1HealthResponseInstancesHealth;
}

export type V1HistogramMethod =
  (typeof V1HistogramMethod)[keyof typeof V1HistogramMethod];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const V1HistogramMethod = {
  HISTOGRAM_METHOD_UNSPECIFIED: "HISTOGRAM_METHOD_UNSPECIFIED",
  HISTOGRAM_METHOD_FD: "HISTOGRAM_METHOD_FD",
  HISTOGRAM_METHOD_DIAGNOSTIC: "HISTOGRAM_METHOD_DIAGNOSTIC",
} as const;

export type V1InstanceVariables = { [key: string]: string };

export type V1InstanceProjectVariables = { [key: string]: string };

export type V1InstanceFeatureFlags = { [key: string]: boolean };

export type V1InstanceAnnotations = { [key: string]: string };

/**
 * Instance represents a single data project, meaning one set of code artifacts,
one connection to an OLAP datastore (DuckDB, Druid), and one catalog of related
metadata (such as reconciliation state). Instances are the unit of isolation within
the runtime. They enable one runtime deployment to serve not only multiple data
projects, but also multiple tenants. On local, the runtime will usually have
just a single instance.
 */
export interface V1Instance {
  instanceId?: string;
  environment?: string;
  projectDisplayName?: string;
  olapConnector?: string;
  repoConnector?: string;
  adminConnector?: string;
  aiConnector?: string;
  createdOn?: string;
  updatedOn?: string;
  connectors?: V1Connector[];
  projectConnectors?: V1Connector[];
  variables?: V1InstanceVariables;
  projectVariables?: V1InstanceProjectVariables;
  featureFlags?: V1InstanceFeatureFlags;
  annotations?: V1InstanceAnnotations;
  aiInstructions?: string;
  frontendUrl?: string;
}

export type V1InstanceHealthMetricsViewErrors = { [key: string]: string };

export interface V1InstanceHealth {
  controllerError?: string;
  olapError?: string;
  repoError?: string;
  metricsViewErrors?: V1InstanceHealthMetricsViewErrors;
  parseErrorCount?: number;
  reconcileErrorCount?: number;
}

export interface V1InstanceHealthResponse {
  instanceHealth?: V1InstanceHealth;
}

/**
 * Additional arbitrary attributes to include in the JWT.
They take precedence if they collide with name, email, groups or admin.
 */
export type V1IssueDevJWTRequestAttributes = { [key: string]: unknown };

export interface V1IssueDevJWTRequest {
  name?: string;
  email?: string;
  groups?: string[];
  admin?: boolean;
  /** Additional arbitrary attributes to include in the JWT.
They take precedence if they collide with name, email, groups or admin. */
  attributes?: V1IssueDevJWTRequestAttributes;
}

export interface V1IssueDevJWTResponse {
  jwt?: string;
}

export interface V1ListBucketsResponse {
  nextPageToken?: string;
  buckets?: string[];
}

export interface V1ListConnectorDriversResponse {
  connectors?: V1ConnectorDriver[];
}

export interface V1ListConversationsResponse {
  conversations?: V1Conversation[];
}

export interface V1ListDatabaseSchemasResponse {
  databaseSchemas?: V1DatabaseSchemaInfo[];
  nextPageToken?: string;
}

export interface V1ListExamplesResponse {
  examples?: V1Example[];
}

export interface V1ListFilesResponse {
  files?: V1DirEntry[];
}

export interface V1ListGitBranchesResponse {
  currentBranch?: string;
  branches?: V1GitBranch[];
}

export interface V1ListGitCommitsResponse {
  commits?: V1GitCommit[];
  nextPageToken?: string;
}

export interface V1ListInstancesResponse {
  instances?: V1Instance[];
  nextPageToken?: string;
}

export interface V1ListNotifierConnectorsResponse {
  /** Note: In this list, the Connector.config property will always be empty. */
  connectors?: V1Connector[];
}

export interface V1ListObjectsResponse {
  nextPageToken?: string;
  objects?: V1Object[];
}

export interface V1ListResourcesResponse {
  resources?: V1Resource[];
}

export interface V1ListTablesResponse {
  tables?: V1TableInfo[];
  nextPageToken?: string;
}

export interface V1ListToolsResponse {
  tools?: V1Tool[];
}

export interface V1Log {
  level?: V1LogLevel;
  time?: string;
  message?: string;
  jsonPayload?: string;
}

export type V1LogLevel = (typeof V1LogLevel)[keyof typeof V1LogLevel];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const V1LogLevel = {
  LOG_LEVEL_UNSPECIFIED: "LOG_LEVEL_UNSPECIFIED",
  LOG_LEVEL_DEBUG: "LOG_LEVEL_DEBUG",
  LOG_LEVEL_INFO: "LOG_LEVEL_INFO",
  LOG_LEVEL_WARN: "LOG_LEVEL_WARN",
  LOG_LEVEL_ERROR: "LOG_LEVEL_ERROR",
  LOG_LEVEL_FATAL: "LOG_LEVEL_FATAL",
} as const;

export interface V1MapType {
  keyType?: Runtimev1Type;
  valueType?: Runtimev1Type;
}

export interface V1Message {
  id?: string;
  parentId?: string;
  createdOn?: string;
  updatedOn?: string;
  index?: number;
  role?: string;
  type?: string;
  tool?: string;
  contentType?: string;
  contentData?: string;
  content?: V1ContentBlock[];
}

export interface V1MetricsView {
  spec?: V1MetricsViewSpec;
  state?: V1MetricsViewState;
}

export interface V1MetricsViewAggregationDimension {
  name?: string;
  timeGrain?: V1TimeGrain;
  timeZone?: string;
  alias?: string;
}

export interface V1MetricsViewAggregationMeasure {
  name?: string;
  builtinMeasure?: V1BuiltinMeasure;
  builtinMeasureArgs?: unknown[];
  filter?: V1Expression;
  count?: V1MetricsViewAggregationMeasureComputeCount;
  countDistinct?: V1MetricsViewAggregationMeasureComputeCountDistinct;
  comparisonValue?: V1MetricsViewAggregationMeasureComputeComparisonValue;
  comparisonDelta?: V1MetricsViewAggregationMeasureComputeComparisonDelta;
  comparisonRatio?: V1MetricsViewAggregationMeasureComputeComparisonRatio;
  percentOfTotal?: V1MetricsViewAggregationMeasureComputePercentOfTotal;
  uri?: V1MetricsViewAggregationMeasureComputeURI;
  comparisonTime?: V1MetricsViewAggregationMeasureComputeComparisonTime;
}

export interface V1MetricsViewAggregationMeasureComputeComparisonDelta {
  measure?: string;
}

export interface V1MetricsViewAggregationMeasureComputeComparisonRatio {
  measure?: string;
}

export interface V1MetricsViewAggregationMeasureComputeComparisonTime {
  dimension?: string;
}

export interface V1MetricsViewAggregationMeasureComputeComparisonValue {
  measure?: string;
}

export interface V1MetricsViewAggregationMeasureComputeCount {
  [key: string]: unknown;
}

export interface V1MetricsViewAggregationMeasureComputeCountDistinct {
  dimension?: string;
}

export interface V1MetricsViewAggregationMeasureComputePercentOfTotal {
  measure?: string;
}

export interface V1MetricsViewAggregationMeasureComputeURI {
  dimension?: string;
}

export interface V1MetricsViewAggregationRequest {
  instanceId?: string;
  metricsView?: string;
  dimensions?: V1MetricsViewAggregationDimension[];
  measures?: V1MetricsViewAggregationMeasure[];
  sort?: V1MetricsViewAggregationSort[];
  timeRange?: V1TimeRange;
  comparisonTimeRange?: V1TimeRange;
  timeStart?: string;
  timeEnd?: string;
  pivotOn?: string[];
  aliases?: V1MetricsViewComparisonMeasureAlias[];
  where?: V1Expression;
  /** Optional. If both where and where_sql are set, both will be applied with an AND between them. */
  whereSql?: string;
  having?: V1Expression;
  /** Optional. If both having and having_sql are set, both will be applied with an AND between them. */
  havingSql?: string;
  limit?: string;
  offset?: string;
  priority?: number;
  filter?: V1MetricsViewFilter;
  exact?: boolean;
  fillMissing?: boolean;
  rows?: boolean;
}

export type V1MetricsViewAggregationResponseDataItem = {
  [key: string]: unknown;
};

export interface V1MetricsViewAggregationResponse {
  schema?: V1StructType;
  data?: V1MetricsViewAggregationResponseDataItem[];
}

export interface V1MetricsViewAggregationSort {
  name?: string;
  desc?: boolean;
}

export interface V1MetricsViewAnnotationsResponse {
  rows?: V1MetricsViewAnnotationsResponseAnnotation[];
}

/**
 * Any other fields are captured here. Will be used in predicates in the future.
 */
export type V1MetricsViewAnnotationsResponseAnnotationAdditionalFields = {
  [key: string]: unknown;
};

export interface V1MetricsViewAnnotationsResponseAnnotation {
  /** Time when the annotation applies. Maps to `time` column from the table. */
  time?: string;
  /** Optional. Time when the annotation ends. Only present if the underlying table has the `time_end` column. */
  timeEnd?: string;
  /** User defined description of the annotation applies. Maps to `description` column from the table. */
  description?: string;
  /** Optional. Minimum duration this annotation is displayed for. Maps to `duration` column from the table. */
  duration?: string;
  /** Any other fields are captured here. Will be used in predicates in the future. */
  additionalFields?: V1MetricsViewAnnotationsResponseAnnotationAdditionalFields;
  /** List of measure names that this annotation applies to. If empty, no restrictions apply. */
  forMeasures?: string[];
}

export interface V1MetricsViewColumn {
  name?: string;
  type?: string;
  nullable?: boolean;
}

export interface V1MetricsViewComparisonMeasureAlias {
  name?: string;
  type?: V1MetricsViewComparisonMeasureType;
  alias?: string;
}

export type V1MetricsViewComparisonMeasureType =
  (typeof V1MetricsViewComparisonMeasureType)[keyof typeof V1MetricsViewComparisonMeasureType];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const V1MetricsViewComparisonMeasureType = {
  METRICS_VIEW_COMPARISON_MEASURE_TYPE_UNSPECIFIED:
    "METRICS_VIEW_COMPARISON_MEASURE_TYPE_UNSPECIFIED",
  METRICS_VIEW_COMPARISON_MEASURE_TYPE_BASE_VALUE:
    "METRICS_VIEW_COMPARISON_MEASURE_TYPE_BASE_VALUE",
  METRICS_VIEW_COMPARISON_MEASURE_TYPE_COMPARISON_VALUE:
    "METRICS_VIEW_COMPARISON_MEASURE_TYPE_COMPARISON_VALUE",
  METRICS_VIEW_COMPARISON_MEASURE_TYPE_ABS_DELTA:
    "METRICS_VIEW_COMPARISON_MEASURE_TYPE_ABS_DELTA",
  METRICS_VIEW_COMPARISON_MEASURE_TYPE_REL_DELTA:
    "METRICS_VIEW_COMPARISON_MEASURE_TYPE_REL_DELTA",
} as const;

export interface V1MetricsViewComparisonRequest {
  instanceId?: string;
  metricsViewName?: string;
  dimension?: V1MetricsViewAggregationDimension;
  measures?: V1MetricsViewAggregationMeasure[];
  comparisonMeasures?: string[];
  sort?: V1MetricsViewComparisonSort[];
  timeRange?: V1TimeRange;
  comparisonTimeRange?: V1TimeRange;
  where?: V1Expression;
  /** Optional. If both where and where_sql are set, both will be applied with an AND between them. */
  whereSql?: string;
  having?: V1Expression;
  /** Optional. If both having and having_sql are set, both will be applied with an AND between them. */
  havingSql?: string;
  aliases?: V1MetricsViewComparisonMeasureAlias[];
  limit?: string;
  offset?: string;
  priority?: number;
  exact?: boolean;
  filter?: V1MetricsViewFilter;
}

export interface V1MetricsViewComparisonResponse {
  rows?: V1MetricsViewComparisonRow[];
}

export interface V1MetricsViewComparisonRow {
  dimensionValue?: unknown;
  measureValues?: V1MetricsViewComparisonValue[];
}

export interface V1MetricsViewComparisonSort {
  name?: string;
  desc?: boolean;
  type?: V1MetricsViewComparisonSortType;
  sortType?: V1MetricsViewComparisonMeasureType;
}

export type V1MetricsViewComparisonSortType =
  (typeof V1MetricsViewComparisonSortType)[keyof typeof V1MetricsViewComparisonSortType];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const V1MetricsViewComparisonSortType = {
  METRICS_VIEW_COMPARISON_SORT_TYPE_UNSPECIFIED:
    "METRICS_VIEW_COMPARISON_SORT_TYPE_UNSPECIFIED",
  METRICS_VIEW_COMPARISON_SORT_TYPE_BASE_VALUE:
    "METRICS_VIEW_COMPARISON_SORT_TYPE_BASE_VALUE",
  METRICS_VIEW_COMPARISON_SORT_TYPE_COMPARISON_VALUE:
    "METRICS_VIEW_COMPARISON_SORT_TYPE_COMPARISON_VALUE",
  METRICS_VIEW_COMPARISON_SORT_TYPE_ABS_DELTA:
    "METRICS_VIEW_COMPARISON_SORT_TYPE_ABS_DELTA",
  METRICS_VIEW_COMPARISON_SORT_TYPE_REL_DELTA:
    "METRICS_VIEW_COMPARISON_SORT_TYPE_REL_DELTA",
} as const;

export interface V1MetricsViewComparisonValue {
  measureName?: string;
  baseValue?: unknown;
  comparisonValue?: unknown;
  deltaAbs?: unknown;
  deltaRel?: unknown;
}

export interface V1MetricsViewFilter {
  include?: MetricsViewFilterCond[];
  exclude?: MetricsViewFilterCond[];
}

export interface V1MetricsViewRowsRequest {
  instanceId?: string;
  metricsViewName?: string;
  timeStart?: string;
  timeEnd?: string;
  timeGranularity?: V1TimeGrain;
  where?: V1Expression;
  sort?: V1MetricsViewSort[];
  limit?: number;
  offset?: string;
  priority?: number;
  timeZone?: string;
  filter?: V1MetricsViewFilter;
  timeDimension?: string;
}

export type V1MetricsViewRowsResponseDataItem = { [key: string]: unknown };

export interface V1MetricsViewRowsResponse {
  meta?: V1MetricsViewColumn[];
  data?: V1MetricsViewRowsResponseDataItem[];
}

export interface V1MetricsViewSchemaResponse {
  schema?: V1StructType;
}

export interface V1MetricsViewSearchResponse {
  results?: MetricsViewSearchResponseSearchResult[];
}

export interface V1MetricsViewSort {
  name?: string;
  ascending?: boolean;
}

/**
 * Query attributes that can be templated with user context and used by drivers (e.g., appended to SETTINGS in ClickHouse).
Keys and values are stored as templates and will be resolved at query time.
 */
export type V1MetricsViewSpecQueryAttributes = { [key: string]: string };

export interface V1MetricsViewSpec {
  /** name of parent metrics view, if this is a derived metrics view. If this is set then certain fields like table, connector, database*, model, dimensions, and measures will only be set in `state.valid_spec`. */
  parent?: string;
  connector?: string;
  database?: string;
  databaseSchema?: string;
  table?: string;
  /** Name of the model the metrics view is based on. Either table or model should be set. */
  model?: string;
  displayName?: string;
  description?: string;
  /** Extra context for LLM/AI features. Used to guide natural language question answering and routing. */
  aiInstructions?: string;
  timeDimension?: string;
  smallestTimeGrain?: V1TimeGrain;
  /** Expression to evaluate a watermark for the metrics view. If not set, the watermark defaults to max(time_dimension). */
  watermarkExpression?: string;
  dimensions?: MetricsViewSpecDimension[];
  measures?: MetricsViewSpecMeasure[];
  parentDimensions?: V1FieldSelector;
  parentMeasures?: V1FieldSelector;
  annotations?: V1MetricsViewSpecAnnotation[];
  securityRules?: V1SecurityRule[];
  /** ISO 8601 weekday number to use as the base for time aggregations by week. Defaults to 1 (Monday). */
  firstDayOfWeek?: number;
  /** Month number to use as the base for time aggregations by year. Defaults to 1 (January). */
  firstMonthOfYear?: number;
  /** Cache controls for the metrics view. */
  cacheEnabled?: boolean;
  cacheKeySql?: string;
  cacheKeyTtlSeconds?: string;
  /** Query attributes that can be templated with user context and used by drivers (e.g., appended to SETTINGS in ClickHouse).
Keys and values are stored as templates and will be resolved at query time. */
  queryAttributes?: V1MetricsViewSpecQueryAttributes;
}

/**
 * Annotations that can be applied to measures. Each annotation needs to have a model or a table defined.
1. The underlying model/table has to have a `time` and `description` columns.
2. Can additionally have `time_end` column to convert the annotation to range type annotation.
3. Can additionally have `duration` column, this is used to not query for annotations greater than selected grain in dashboard. Also forces `time` and `time_end` in UI to be truncated to selected grain.
 */
export interface V1MetricsViewSpecAnnotation {
  name?: string;
  connector?: string;
  database?: string;
  databaseSchema?: string;
  table?: string;
  /** Name of the model that source of annotation. Either table or model should be set. */
  model?: string;
  /** Measures to apply the annotation to. If `measures_selector` is set, this will only be set in `state.valid_spec`. */
  measures?: string[];
  measuresSelector?: V1FieldSelector;
  /** Signifies that the underlying table has `time_end` column. Will be used while querying to add additional filter. */
  hasTimeEnd?: boolean;
  /** Signifies that the underlying table has `duration` column. Will be used while querying to add additional filter. */
  hasDuration?: boolean;
}

export interface V1MetricsViewState {
  validSpec?: V1MetricsViewSpec;
  /** Streaming is true if the underlying data may change without the metrics view's spec/state version changing.
It's set to true if the metrics view is based on an externally managed table. */
  streaming?: boolean;
  /** The last time the metrics view's underlying data was refreshed.
This may be empty if the metrics view is based on an externally managed table. */
  dataRefreshedOn?: string;
}

export interface V1MetricsViewTimeRangeResponse {
  timeRangeSummary?: V1TimeRangeSummary;
}

export interface V1MetricsViewTimeRangesResponse {
  fullTimeRange?: V1TimeRangeSummary;
  /** The resolved time ranges for the requested rilltime expressions. */
  resolvedTimeRanges?: V1ResolvedTimeRange[];
  /** The same values as resolved_time_ranges for backwards compatibility.
Deprecated: use resolved_time_ranges instead. */
  timeRanges?: V1TimeRange[];
}

export interface V1MetricsViewTimeSeriesRequest {
  instanceId?: string;
  metricsViewName?: string;
  measureNames?: string[];
  timeStart?: string;
  timeEnd?: string;
  timeGranularity?: V1TimeGrain;
  where?: V1Expression;
  /** Optional. If both where and where_sql are set, both will be applied with an AND between them. */
  whereSql?: string;
  having?: V1Expression;
  /** Optional. If both having and having_sql are set, both will be applied with an AND between them. */
  havingSql?: string;
  timeZone?: string;
  priority?: number;
  filter?: V1MetricsViewFilter;
  timeDimension?: string;
}

export interface V1MetricsViewTimeSeriesResponse {
  meta?: V1MetricsViewColumn[];
  data?: V1TimeSeriesValue[];
}

export interface V1MetricsViewToplistRequest {
  instanceId?: string;
  metricsViewName?: string;
  dimensionName?: string;
  measureNames?: string[];
  timeStart?: string;
  timeEnd?: string;
  limit?: string;
  offset?: string;
  sort?: V1MetricsViewSort[];
  where?: V1Expression;
  whereSql?: string;
  having?: V1Expression;
  havingSql?: string;
  priority?: number;
  filter?: V1MetricsViewFilter;
}

export type V1MetricsViewToplistResponseDataItem = { [key: string]: unknown };

export interface V1MetricsViewToplistResponse {
  meta?: V1MetricsViewColumn[];
  data?: V1MetricsViewToplistResponseDataItem[];
}

export interface V1MetricsViewTotalsRequest {
  instanceId?: string;
  metricsViewName?: string;
  measureNames?: string[];
  timeStart?: string;
  timeEnd?: string;
  where?: V1Expression;
  /** Optional. If both where and where_sql are set, both will be applied with an AND between them. */
  whereSql?: string;
  priority?: number;
  filter?: V1MetricsViewFilter;
  timeDimension?: string;
}

export type V1MetricsViewTotalsResponseData = { [key: string]: unknown };

export interface V1MetricsViewTotalsResponse {
  meta?: V1MetricsViewColumn[];
  data?: V1MetricsViewTotalsResponseData;
}

export interface V1Migration {
  spec?: V1MigrationSpec;
  state?: V1MigrationState;
}

export interface V1MigrationSpec {
  connector?: string;
  sql?: string;
  version?: number;
}

export interface V1MigrationState {
  version?: number;
}

export interface V1Model {
  spec?: V1ModelSpec;
  state?: V1ModelState;
}

export type V1ModelChangeMode =
  (typeof V1ModelChangeMode)[keyof typeof V1ModelChangeMode];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const V1ModelChangeMode = {
  MODEL_CHANGE_MODE_UNSPECIFIED: "MODEL_CHANGE_MODE_UNSPECIFIED",
  MODEL_CHANGE_MODE_RESET: "MODEL_CHANGE_MODE_RESET",
  MODEL_CHANGE_MODE_MANUAL: "MODEL_CHANGE_MODE_MANUAL",
  MODEL_CHANGE_MODE_PATCH: "MODEL_CHANGE_MODE_PATCH",
} as const;

export type V1ModelPartitionData = { [key: string]: unknown };

export interface V1ModelPartition {
  key?: string;
  data?: V1ModelPartitionData;
  watermark?: string;
  executedOn?: string;
  error?: string;
  elapsedMs?: number;
}

export type V1ModelSpecIncrementalStateResolverProperties = {
  [key: string]: unknown;
};

export type V1ModelSpecPartitionsResolverProperties = {
  [key: string]: unknown;
};

export type V1ModelSpecInputProperties = { [key: string]: unknown };

export type V1ModelSpecStageProperties = { [key: string]: unknown };

export type V1ModelSpecOutputProperties = { [key: string]: unknown };

export interface V1ModelSpec {
  refreshSchedule?: V1Schedule;
  timeoutSeconds?: number;
  incremental?: boolean;
  incrementalStateResolver?: string;
  incrementalStateResolverProperties?: V1ModelSpecIncrementalStateResolverProperties;
  partitionsResolver?: string;
  partitionsResolverProperties?: V1ModelSpecPartitionsResolverProperties;
  partitionsWatermarkField?: string;
  partitionsConcurrencyLimit?: number;
  inputConnector?: string;
  inputProperties?: V1ModelSpecInputProperties;
  /** stage_connector is optional. */
  stageConnector?: string;
  stageProperties?: V1ModelSpecStageProperties;
  outputConnector?: string;
  outputProperties?: V1ModelSpecOutputProperties;
  retryAttempts?: number;
  retryDelaySeconds?: number;
  retryExponentialBackoff?: boolean;
  retryIfErrorMatches?: string[];
  changeMode?: V1ModelChangeMode;
  tests?: V1ModelTest[];
  /** trigger indicates a normal refresh (incremental or full depending on the model type). */
  trigger?: boolean;
  /** trigger_full indicates a full refresh regardless of the model type. */
  triggerFull?: boolean;
  /** trigger_partitions indicates a refresh of existing partitions marked pending (won't sync new partitions). Only valid for incremental, partitioned models. */
  triggerPartitions?: boolean;
  /** defined_as_source is true if it was defined by user as a source but converted internally to a model. */
  definedAsSource?: boolean;
}

/**
 * result_properties are returned by the executor and contains metadata about the result.
 */
export type V1ModelStateResultProperties = { [key: string]: unknown };

/**
 * incremental_state contains the result of the most recent invocation of the model's incremental state resolver.
 */
export type V1ModelStateIncrementalState = { [key: string]: unknown };

export interface V1ModelState {
  /** executor_connector is the ModelExecutor that produced the model's result. */
  executorConnector?: string;
  /** result_connector is the connector where the model's result is stored. */
  resultConnector?: string;
  /** result_properties are returned by the executor and contains metadata about the result. */
  resultProperties?: V1ModelStateResultProperties;
  /** result_table contains the model's result table for SQL models. It is a convenience field that can also be derived from result_properties. */
  resultTable?: string;
  /** spec_hash is a hash of those parts of the spec that affect the model's result. */
  specHash?: string;
  /** refs_hash is a hash of the model's refs current state. It is used to determine if the model's refs have changed. */
  refsHash?: string;
  /** test_hash is a hash of the model's tests current state. It is used to determine if the model's tests have changed. */
  testHash?: string;
  /** test_errors contains the results of the model's tests. */
  testErrors?: string[];
  /** refreshed_on is the time the model was last executed. */
  refreshedOn?: string;
  /** incremental_state contains the result of the most recent invocation of the model's incremental state resolver. */
  incrementalState?: V1ModelStateIncrementalState;
  incrementalStateSchema?: V1StructType;
  /** partitions_model_id is a randomly generated ID used to store the model's partitions in the CatalogStore. */
  partitionsModelId?: string;
  /** partitions_have_errors is true if one or more partitions failed to execute. */
  partitionsHaveErrors?: boolean;
  /** total_execution_duration_ms is the time user queries took to execute while refreshing the model.
In case of incremental models it is the sum of all successful executions so far.
This is not the time it took to refresh the model which also includes other stuff like taking a write lock. */
  totalExecutionDurationMs?: string;
  /** latest_execution_duration_ms is the time user queries took to execute in the last successful refresh. */
  latestExecutionDurationMs?: string;
}

export type V1ModelTestResolverProperties = { [key: string]: unknown };

export interface V1ModelTest {
  name?: string;
  resolver?: string;
  resolverProperties?: V1ModelTestResolverProperties;
}

export type V1NotifierProperties = { [key: string]: unknown };

export interface V1Notifier {
  connector?: string;
  properties?: V1NotifierProperties;
}

export interface V1NumericHistogramBins {
  bins?: NumericHistogramBinsBin[];
}

export interface V1NumericOutliers {
  outliers?: NumericOutliersOutlier[];
}

export interface V1NumericStatistics {
  min?: number;
  max?: number;
  mean?: number;
  q25?: number;
  q50?: number;
  q75?: number;
  sd?: number;
}

export interface V1NumericSummary {
  numericHistogramBins?: V1NumericHistogramBins;
  numericStatistics?: V1NumericStatistics;
  numericOutliers?: V1NumericOutliers;
}

export type V1OLAPGetTableResponseUnsupportedColumns = {
  [key: string]: string;
};

export interface V1OLAPGetTableResponse {
  schema?: V1StructType;
  unsupportedColumns?: V1OLAPGetTableResponseUnsupportedColumns;
  view?: boolean;
  /** physical_size_bytes is the physical size of the table. Set to -1 if the size cannot be determined. */
  physicalSizeBytes?: string;
}

export interface V1OLAPListTablesResponse {
  tables?: V1OlapTableInfo[];
  nextPageToken?: string;
}

export interface V1Object {
  name?: string;
  modifiedOn?: string;
  size?: string;
  isDir?: boolean;
}

export interface V1OlapTableInfo {
  database?: string;
  databaseSchema?: string;
  isDefaultDatabase?: boolean;
  isDefaultDatabaseSchema?: boolean;
  name?: string;
  hasUnsupportedDataTypes?: boolean;
  /** physical_size_bytes is the physical size of the table. Set to -1 if the size cannot be determined. */
  physicalSizeBytes?: string;
}

export type V1Operation = (typeof V1Operation)[keyof typeof V1Operation];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const V1Operation = {
  OPERATION_UNSPECIFIED: "OPERATION_UNSPECIFIED",
  OPERATION_EQ: "OPERATION_EQ",
  OPERATION_NEQ: "OPERATION_NEQ",
  OPERATION_LT: "OPERATION_LT",
  OPERATION_LTE: "OPERATION_LTE",
  OPERATION_GT: "OPERATION_GT",
  OPERATION_GTE: "OPERATION_GTE",
  OPERATION_OR: "OPERATION_OR",
  OPERATION_AND: "OPERATION_AND",
  OPERATION_IN: "OPERATION_IN",
  OPERATION_NIN: "OPERATION_NIN",
  OPERATION_LIKE: "OPERATION_LIKE",
  OPERATION_NLIKE: "OPERATION_NLIKE",
  OPERATION_CAST: "OPERATION_CAST",
} as const;

export interface V1ParseError {
  message?: string;
  filePath?: string;
  startLocation?: V1CharLocation;
  external?: boolean;
}

export interface V1PingResponse {
  version?: string;
  time?: string;
}

export interface V1ProfileColumn {
  name?: string;
  type?: string;
  largestStringLength?: number;
}

export interface V1ProjectParser {
  spec?: V1ProjectParserSpec;
  state?: V1ProjectParserState;
}

export interface V1ProjectParserSpec {
  [key: string]: unknown;
}

export interface V1ProjectParserState {
  parseErrors?: V1ParseError[];
  currentCommitSha?: string;
  currentCommitOn?: string;
  watching?: boolean;
}

export interface V1PutFileResponse {
  filePath?: string;
}

export interface V1Query {
  metricsViewAggregationRequest?: V1MetricsViewAggregationRequest;
  metricsViewToplistRequest?: V1MetricsViewToplistRequest;
  metricsViewComparisonRequest?: V1MetricsViewComparisonRequest;
  metricsViewTimeSeriesRequest?: V1MetricsViewTimeSeriesRequest;
  metricsViewTotalsRequest?: V1MetricsViewTotalsRequest;
  metricsViewRowsRequest?: V1MetricsViewRowsRequest;
  columnRollupIntervalRequest?: V1ColumnRollupIntervalRequest;
  columnTopKRequest?: V1ColumnTopKRequest;
  columnNullCountRequest?: V1ColumnNullCountRequest;
  columnDescriptiveStatisticsRequest?: V1ColumnDescriptiveStatisticsRequest;
  columnTimeGrainRequest?: V1ColumnTimeGrainRequest;
  columnNumericHistogramRequest?: V1ColumnNumericHistogramRequest;
  columnRugHistogramRequest?: V1ColumnRugHistogramRequest;
  columnTimeRangeRequest?: V1ColumnTimeRangeRequest;
  columnCardinalityRequest?: V1ColumnCardinalityRequest;
  columnTimeSeriesRequest?: V1ColumnTimeSeriesRequest;
  tableCardinalityRequest?: V1TableCardinalityRequest;
  tableColumnsRequest?: V1TableColumnsRequest;
  tableRowsRequest?: V1TableRowsRequest;
}

export interface V1QueryBatchResponse {
  index?: number;
  result?: V1QueryResult;
  error?: string;
}

export type V1QueryResolverResponseMeta = { [key: string]: unknown };

export type V1QueryResolverResponseDataItem = { [key: string]: unknown };

export interface V1QueryResolverResponse {
  meta?: V1QueryResolverResponseMeta;
  schema?: V1StructType;
  data?: V1QueryResolverResponseDataItem[];
}

export type V1QueryResponseDataItem = { [key: string]: unknown };

export interface V1QueryResponse {
  meta?: V1StructType;
  data?: V1QueryResponseDataItem[];
}

export interface V1QueryResult {
  metricsViewAggregationResponse?: V1MetricsViewAggregationResponse;
  metricsViewToplistResponse?: V1MetricsViewToplistResponse;
  metricsViewComparisonResponse?: V1MetricsViewComparisonResponse;
  metricsViewTimeSeriesResponse?: V1MetricsViewTimeSeriesResponse;
  metricsViewTotalsResponse?: V1MetricsViewTotalsResponse;
  metricsViewRowsResponse?: V1MetricsViewRowsResponse;
  columnRollupIntervalResponse?: V1ColumnRollupIntervalResponse;
  columnTopKResponse?: V1ColumnTopKResponse;
  columnNullCountResponse?: V1ColumnNullCountResponse;
  columnDescriptiveStatisticsResponse?: V1ColumnDescriptiveStatisticsResponse;
  columnTimeGrainResponse?: V1ColumnTimeGrainResponse;
  columnNumericHistogramResponse?: V1ColumnNumericHistogramResponse;
  columnRugHistogramResponse?: V1ColumnRugHistogramResponse;
  columnTimeRangeResponse?: V1ColumnTimeRangeResponse;
  columnCardinalityResponse?: V1ColumnCardinalityResponse;
  columnTimeSeriesResponse?: V1ColumnTimeSeriesResponse;
  tableCardinalityResponse?: V1TableCardinalityResponse;
  tableColumnsResponse?: V1TableColumnsResponse;
  tableRowsResponse?: V1TableRowsResponse;
}

export type V1ReconcileStatus =
  (typeof V1ReconcileStatus)[keyof typeof V1ReconcileStatus];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const V1ReconcileStatus = {
  RECONCILE_STATUS_UNSPECIFIED: "RECONCILE_STATUS_UNSPECIFIED",
  RECONCILE_STATUS_IDLE: "RECONCILE_STATUS_IDLE",
  RECONCILE_STATUS_PENDING: "RECONCILE_STATUS_PENDING",
  RECONCILE_STATUS_RUNNING: "RECONCILE_STATUS_RUNNING",
} as const;

export interface V1RefreshModelTrigger {
  /** The model to refresh. */
  model?: string;
  /** If true, the current table and state will be dropped before refreshing.
For non-incremental models, this is equivalent to a normal refresh. */
  full?: boolean;
  /** Keys of specific partitions to refresh. */
  partitions?: string[];
  /** If true, it will refresh all partitions that errored on their last execution. */
  allErroredPartitions?: boolean;
}

export interface V1RefreshTrigger {
  spec?: V1RefreshTriggerSpec;
  state?: V1RefreshTriggerState;
}

export interface V1RefreshTriggerSpec {
  /** Resources to refresh. The refreshable types are sources, models, alerts, reports, and the project parser.
If a model is specified, a normal incremental refresh is triggered. Use the "models" field to trigger other kinds of model refreshes. */
  resources?: V1ResourceName[];
  /** Models to refresh. These are specified separately to enable more fine-grained configuration. */
  models?: V1RefreshModelTrigger[];
}

export interface V1RefreshTriggerState {
  [key: string]: unknown;
}

export interface V1ReloadConfigResponse {
  [key: string]: unknown;
}

export interface V1RenameFileResponse {
  [key: string]: unknown;
}

export interface V1Report {
  spec?: V1ReportSpec;
  state?: V1ReportState;
}

export interface V1ReportExecution {
  adhoc?: boolean;
  errorMessage?: string;
  reportTime?: string;
  startedOn?: string;
  finishedOn?: string;
}

export type V1ReportSpecAnnotations = { [key: string]: string };

export interface V1ReportSpec {
  displayName?: string;
  trigger?: boolean;
  refreshSchedule?: V1Schedule;
  timeoutSeconds?: number;
  queryName?: string;
  queryArgsJson?: string;
  exportLimit?: string;
  exportFormat?: V1ExportFormat;
  exportIncludeHeader?: boolean;
  notifiers?: V1Notifier[];
  annotations?: V1ReportSpecAnnotations;
  /** If true, will use the lowest watermark of its refs instead of the trigger time. */
  watermarkInherit?: boolean;
  intervalsIsoDuration?: string;
  intervalsLimit?: number;
  intervalsCheckUnclosed?: boolean;
}

export interface V1ReportState {
  nextRunOn?: string;
  currentExecution?: V1ReportExecution;
  executionHistory?: V1ReportExecution[];
  executionCount?: number;
}

/**
 * All the component resources referenced by the canvas.
The resources state.valid_spec.renderer_properties will have templating resolved for the provided args.
(Corresponds to calling the ResolveComponent API for each component referenced in the canvas spec).
 */
export type V1ResolveCanvasResponseResolvedComponents = {
  [key: string]: V1Resource;
};

/**
 * All the metrics view resources referenced in the components' renderer_properties.metrics_view field.
 */
export type V1ResolveCanvasResponseReferencedMetricsViews = {
  [key: string]: V1Resource;
};

export interface V1ResolveCanvasResponse {
  canvas?: V1Resource;
  /** All the component resources referenced by the canvas.
The resources state.valid_spec.renderer_properties will have templating resolved for the provided args.
(Corresponds to calling the ResolveComponent API for each component referenced in the canvas spec). */
  resolvedComponents?: V1ResolveCanvasResponseResolvedComponents;
  /** All the metrics view resources referenced in the components' renderer_properties.metrics_view field. */
  referencedMetricsViews?: V1ResolveCanvasResponseReferencedMetricsViews;
}

export type V1ResolveComponentResponseRendererProperties = {
  [key: string]: unknown;
};

export interface V1ResolveComponentResponse {
  rendererProperties?: V1ResolveComponentResponseRendererProperties;
}

export interface V1ResolveTemplatedStringResponse {
  body?: string;
}

export interface V1ResolvedTimeRange {
  /** The start of the resolved time range. */
  start?: string;
  /** The end of the resolved time range. */
  end?: string;
  grain?: V1TimeGrain;
  /** The time dimension that was used to resolve the time range. */
  timeDimension?: string;
  /** The time zone that was used to resolve the time range. */
  timeZone?: string;
  /** The original expression used to resolve the time range. */
  expression?: string;
}

export interface V1Resource {
  meta?: V1ResourceMeta;
  projectParser?: V1ProjectParser;
  source?: V1Source;
  model?: V1Model;
  metricsView?: V1MetricsView;
  explore?: V1Explore;
  migration?: V1Migration;
  report?: V1Report;
  alert?: V1Alert;
  refreshTrigger?: V1RefreshTrigger;
  theme?: V1Theme;
  component?: V1Component;
  canvas?: V1Canvas;
  api?: V1API;
  connector?: V1ConnectorV2;
}

export type V1ResourceEvent =
  (typeof V1ResourceEvent)[keyof typeof V1ResourceEvent];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const V1ResourceEvent = {
  RESOURCE_EVENT_UNSPECIFIED: "RESOURCE_EVENT_UNSPECIFIED",
  RESOURCE_EVENT_WRITE: "RESOURCE_EVENT_WRITE",
  RESOURCE_EVENT_DELETE: "RESOURCE_EVENT_DELETE",
} as const;

export interface V1ResourceMeta {
  name?: V1ResourceName;
  refs?: V1ResourceName[];
  owner?: V1ResourceName;
  filePaths?: string[];
  hidden?: boolean;
  version?: string;
  specVersion?: string;
  stateVersion?: string;
  createdOn?: string;
  specUpdatedOn?: string;
  stateUpdatedOn?: string;
  deletedOn?: string;
  reconcileStatus?: V1ReconcileStatus;
  reconcileError?: string;
  reconcileOn?: string;
  renamedFrom?: V1ResourceName;
}

export interface V1ResourceName {
  kind?: string;
  name?: string;
}

export interface V1RestoreGitCommitResponse {
  newCommitSha?: string;
}

export interface V1Schedule {
  refUpdate?: boolean;
  disable?: boolean;
  cron?: string;
  tickerSeconds?: number;
  timeZone?: string;
}

export interface V1SecurityRule {
  access?: V1SecurityRuleAccess;
  fieldAccess?: V1SecurityRuleFieldAccess;
  rowFilter?: V1SecurityRuleRowFilter;
  transitiveAccess?: V1SecurityRuleTransitiveAccess;
}

export interface V1SecurityRuleAccess {
  /** The condition under which this rule applies.
It is ANDed together with the condition_kinds and condition_resources. */
  conditionExpression?: string;
  /** The resource kinds the rule applies to. If empty, it defaults to all resource kinds. */
  conditionKinds?: string[];
  /** The resources the rule applies to. If empty, it defaults to all resources in scope covered by `resource_kinds`.
It is ORed together with the condition_kinds. */
  conditionResources?: V1ResourceName[];
  /** Whether to allow or deny access to the resources covered by the conditions. */
  allow?: boolean;
  /** If true, any resource not covered by the conditions will explicitly get the opposite permission (e.g. will be denied if `allow` is true). */
  exclusive?: boolean;
}

export interface V1SecurityRuleFieldAccess {
  /** The condition under which this rule applies.
It is ANDed together with the condition_kinds and condition_resources. */
  conditionExpression?: string;
  /** The resource kinds the rule applies to. If empty, it defaults to all resource kinds. */
  conditionKinds?: string[];
  /** The resources the rule applies to. If empty, it defaults to all resources in scope covered by `resource_kinds`.
It is ORed together with the condition_kinds. */
  conditionResources?: V1ResourceName[];
  allow?: boolean;
  /** If true, all other fields not explicitly listed will get the opposite permission (e.g. will be denied if `allow` is true). */
  exclusive?: boolean;
  fields?: string[];
  allFields?: boolean;
}

export interface V1SecurityRuleRowFilter {
  /** The condition under which this rule applies.
It is ANDed together with the condition_kinds and condition_resources. */
  conditionExpression?: string;
  /** The resource kinds the rule applies to. If empty, it defaults to all resource kinds. */
  conditionKinds?: string[];
  /** The resources the rule applies to. If empty, it defaults to all resources in scope covered by `resource_kinds`.
It is ORed together with the condition_kinds. */
  conditionResources?: V1ResourceName[];
  sql?: string;
  expression?: V1Expression;
}

export interface V1SecurityRuleTransitiveAccess {
  resource?: V1ResourceName;
}

export interface V1ShareConversationResponse {
  [key: string]: unknown;
}

export interface V1Source {
  spec?: V1SourceSpec;
  state?: V1SourceState;
}

export type V1SourceSpecProperties = { [key: string]: unknown };

export interface V1SourceSpec {
  sourceConnector?: string;
  sinkConnector?: string;
  properties?: V1SourceSpecProperties;
  refreshSchedule?: V1Schedule;
  timeoutSeconds?: number;
  stageChanges?: boolean;
  streamIngestion?: boolean;
  trigger?: boolean;
}

export interface V1SourceState {
  connector?: string;
  table?: string;
  specHash?: string;
  refreshedOn?: string;
}

export interface V1StringListValue {
  values?: string[];
}

export interface V1StructType {
  fields?: StructTypeField[];
}

export interface V1Subquery {
  dimension?: string;
  measures?: string[];
  where?: V1Expression;
  having?: V1Expression;
}

export interface V1TableCardinalityRequest {
  instanceId?: string;
  connector?: string;
  database?: string;
  databaseSchema?: string;
  tableName?: string;
  priority?: number;
}

export interface V1TableCardinalityResponse {
  cardinality?: string;
}

export interface V1TableColumnsRequest {
  instanceId?: string;
  connector?: string;
  database?: string;
  databaseSchema?: string;
  tableName?: string;
  priority?: number;
}

export type V1TableColumnsResponseUnsupportedColumns = {
  [key: string]: string;
};

export interface V1TableColumnsResponse {
  profileColumns?: V1ProfileColumn[];
  unsupportedColumns?: V1TableColumnsResponseUnsupportedColumns;
}

export interface V1TableInfo {
  name?: string;
  view?: boolean;
}

export interface V1TableRowsRequest {
  instanceId?: string;
  connector?: string;
  database?: string;
  databaseSchema?: string;
  tableName?: string;
  limit?: number;
  priority?: number;
}

export type V1TableRowsResponseDataItem = { [key: string]: unknown };

export interface V1TableRowsResponse {
  data?: V1TableRowsResponseDataItem[];
}

export interface V1Theme {
  spec?: V1ThemeSpec;
  state?: V1ThemeState;
}

export type V1ThemeColorsVariables = { [key: string]: string };

export interface V1ThemeColors {
  primary?: string;
  secondary?: string;
  variables?: V1ThemeColorsVariables;
}

export interface V1ThemeSpec {
  primaryColor?: V1Color;
  secondaryColor?: V1Color;
  primaryColorRaw?: string;
  secondaryColorRaw?: string;
  light?: V1ThemeColors;
  dark?: V1ThemeColors;
}

export interface V1ThemeState {
  [key: string]: unknown;
}

export type V1TimeGrain = (typeof V1TimeGrain)[keyof typeof V1TimeGrain];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const V1TimeGrain = {
  TIME_GRAIN_UNSPECIFIED: "TIME_GRAIN_UNSPECIFIED",
  TIME_GRAIN_MILLISECOND: "TIME_GRAIN_MILLISECOND",
  TIME_GRAIN_SECOND: "TIME_GRAIN_SECOND",
  TIME_GRAIN_MINUTE: "TIME_GRAIN_MINUTE",
  TIME_GRAIN_HOUR: "TIME_GRAIN_HOUR",
  TIME_GRAIN_DAY: "TIME_GRAIN_DAY",
  TIME_GRAIN_WEEK: "TIME_GRAIN_WEEK",
  TIME_GRAIN_MONTH: "TIME_GRAIN_MONTH",
  TIME_GRAIN_QUARTER: "TIME_GRAIN_QUARTER",
  TIME_GRAIN_YEAR: "TIME_GRAIN_YEAR",
} as const;

export interface V1TimeRange {
  start?: string;
  end?: string;
  isoDuration?: string;
  isoOffset?: string;
  roundToGrain?: V1TimeGrain;
  timeZone?: string;
  /** Optional. Rill format time range. Should only be used for alerts and reports.
For dashboard call ResolveTimeRanges. */
  expression?: string;
  timeDimension?: string;
}

export interface V1TimeRangeSummary {
  min?: string;
  max?: string;
  watermark?: string;
}

export interface V1TimeSeriesResponse {
  results?: V1TimeSeriesValue[];
  spark?: V1TimeSeriesValue[];
  sampleSize?: number;
}

export interface V1TimeSeriesTimeRange {
  start?: string;
  end?: string;
  interval?: V1TimeGrain;
}

export type V1TimeSeriesValueRecords = { [key: string]: unknown };

export interface V1TimeSeriesValue {
  ts?: string;
  bin?: number;
  records?: V1TimeSeriesValueRecords;
}

export type V1ToolMeta = { [key: string]: unknown };

export interface V1Tool {
  name?: string;
  displayName?: string;
  description?: string;
  meta?: V1ToolMeta;
  inputSchema?: string;
  outputSchema?: string;
}

export type V1ToolCallInput = { [key: string]: unknown };

export interface V1ToolCall {
  id?: string;
  name?: string;
  input?: V1ToolCallInput;
}

export interface V1ToolResult {
  id?: string;
  content?: string;
  isError?: boolean;
}

export interface V1TopK {
  entries?: TopKEntry[];
}

export interface V1UnpackEmptyResponse {
  [key: string]: unknown;
}

export interface V1UnpackExampleResponse {
  [key: string]: unknown;
}

export interface V1WatchFilesResponse {
  event?: V1FileEvent;
  path?: string;
  isDir?: boolean;
}

export interface V1WatchLogsResponse {
  log?: V1Log;
}

export interface V1WatchResourcesResponse {
  event?: V1ResourceEvent;
  name?: V1ResourceName;
  resource?: V1Resource;
}

export type ConnectorServiceListDatabaseSchemasParams = {
  instanceId?: string;
  connector?: string;
  pageSize?: number;
  pageToken?: string;
};

export type ConnectorServiceOLAPGetTableParams = {
  instanceId?: string;
  connector?: string;
  database?: string;
  databaseSchema?: string;
  table?: string;
};

export type ConnectorServiceGetTableParams = {
  instanceId?: string;
  connector?: string;
  database?: string;
  databaseSchema?: string;
  table?: string;
};

export type ConnectorServiceListTablesParams = {
  instanceId?: string;
  connector?: string;
  database?: string;
  databaseSchema?: string;
  pageSize?: number;
  pageToken?: string;
};

export type RuntimeServiceListInstancesParams = {
  pageSize?: number;
  pageToken?: string;
};

export type RuntimeServiceGetInstanceParams = {
  sensitive?: boolean;
};

export type RuntimeServiceDeleteInstanceBody = { [key: string]: unknown };

/**
 * Request message for RuntimeService.EditInstance.
See message Instance for field descriptions.
 */
export type RuntimeServiceEditInstanceBody = {
  environment?: string;
  olapConnector?: string;
  repoConnector?: string;
  adminConnector?: string;
  aiConnector?: string;
  connectors?: V1Connector[];
};

export type RuntimeServiceCompleteBody = {
  /** Conversation ID to continue. If empty, a new conversation is created. */
  conversationId?: string;
  /** The prompt to complete. */
  prompt?: string;
  /** Optional agent to use for the completion.
If not set, it will infer an agent based on the prompt and conversation history. */
  agent?: string;
  analystAgentContext?: V1AnalystAgentContext;
  developerAgentContext?: V1DeveloperAgentContext;
};

export type RuntimeServiceCompleteStreamingBody = {
  /** Conversation ID to continue. If empty, a new conversation is created. */
  conversationId?: string;
  /** The prompt to complete. */
  prompt?: string;
  /** Optional agent to use for the completion.
If not set, it will infer an agent based on the prompt and conversation history. */
  agent?: string;
  analystAgentContext?: V1AnalystAgentContext;
  developerAgentContext?: V1DeveloperAgentContext;
};

export type RuntimeServiceCompleteStreaming200 = {
  result?: V1CompleteStreamingResponse;
  error?: RpcStatus;
};

export type RuntimeServiceListConversationsParams = {
  /**
   * Optional search pattern for filtering by user agent.
   */
  userAgentPattern?: string;
};

export type RuntimeServiceForkConversationBody = { [key: string]: unknown };

export type RuntimeServiceShareConversationBody = {
  /** optional message ID up to which to share otherwise share all current messages
only valid conversation having last message of "result" type from "router" agent till until this message ID will be shared.npm
It supports a special value of "none" to unshare the conversation. */
  untilMessageId?: string;
};

export type ConnectorServiceListBucketsParams = {
  pageSize?: number;
  pageToken?: string;
};

export type ConnectorServiceListObjectsParams = {
  path?: string;
  delimiter?: string;
  pageSize?: number;
  pageToken?: string;
};

export type RuntimeServiceListFilesParams = {
  glob?: string;
};

export type RuntimeServiceCreateDirectoryBody = {
  path?: string;
};

export type RuntimeServiceGetFileParams = {
  path?: string;
};

export type RuntimeServiceDeleteFileParams = {
  path?: string;
  force?: boolean;
};

export type RuntimeServicePutFileBody = {
  path?: string;
  blob?: string;
  create?: boolean;
  /** Will cause the operation to fail if the file already exists.
It should only be set when create = true. */
  createOnly?: boolean;
};

export type RuntimeServiceGenerateCanvasFileBody = {
  /** Metrics view name to base the canvas on. */
  metricsViewName?: string;
  /** Path to save the canvas file to. */
  path?: string;
  /** If true, the AI will be used to generate the canvas file.
Otherwise, it falls back to a simpler heuristic approach. */
  useAi?: boolean;
};

export type RuntimeServiceGenerateMetricsViewFileBody = {
  /** Model to base the metrics view on.
If you set this, do NOT set connector, database, database_schema or table. */
  model?: string;
  /** Connector for the table.
See "table" for more details. */
  connector?: string;
  /** Database for the table.
See "table" for more details. */
  database?: string;
  /** Database schema for the table.
See "table" for more details. */
  databaseSchema?: string;
  /** Table to base the metrics view on.
If you set this, do NOT set model. */
  table?: string;
  /** Path to save the metrics view file to. */
  path?: string;
  /** If true, the AI will be used to generate the metrics view file.
Otherwise, it falls back to a simpler heuristic approach. */
  useAi?: boolean;
  /** Optional prompt to guide AI generation. */
  prompt?: string;
};

export type RuntimeServiceRenameFileBody = {
  fromPath?: string;
  toPath?: string;
};

export type RuntimeServiceUnpackEmptyBody = {
  displayName?: string;
  olap?: string;
  force?: boolean;
};

export type RuntimeServiceUnpackExampleBody = {
  name?: string;
  force?: boolean;
};

export type RuntimeServiceWatchFilesParams = {
  replay?: boolean;
};

export type RuntimeServiceWatchFiles200 = {
  result?: V1WatchFilesResponse;
  error?: RpcStatus;
};

export type RuntimeServiceGenerateRendererBodyResolverProperties = {
  [key: string]: unknown;
};

export type RuntimeServiceGenerateRendererBody = {
  prompt?: string;
  resolver?: string;
  resolverProperties?: RuntimeServiceGenerateRendererBodyResolverProperties;
};

export type RuntimeServiceGenerateResolverBody = {
  prompt?: string;
  /** Both connector and table must be specified if metrics_view is not. */
  connector?: string;
  table?: string;
  /** table and connector should not be provided if metrics_view is provided. */
  metricsView?: string;
};

export type RuntimeServiceGitSwitchBranchBody = {
  branch?: string;
  create?: boolean;
  ignoreLocalChanges?: boolean;
};

export type RuntimeServiceGitCommitBody = {
  commitMessage?: string;
};

export type RuntimeServiceListGitCommitsParams = {
  pageSize?: number;
  pageToken?: string;
};

export type RuntimeServiceGitMergeToBranchBody = {
  branch?: string;
  /** In case of merge conflicts, prefer current changes. */
  force?: boolean;
};

export type RuntimeServiceGitPullBody = {
  discardLocal?: boolean;
};

export type RuntimeServiceGitPushBody = {
  commitMessage?: string;
  force?: boolean;
};

export type RuntimeServiceRestoreGitCommitBody = { [key: string]: unknown };

export type RuntimeServiceGetLogsParams = {
  ascending?: boolean;
  limit?: number;
  level?: RuntimeServiceGetLogsLevel;
};

export type RuntimeServiceGetLogsLevel =
  (typeof RuntimeServiceGetLogsLevel)[keyof typeof RuntimeServiceGetLogsLevel];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const RuntimeServiceGetLogsLevel = {
  LOG_LEVEL_UNSPECIFIED: "LOG_LEVEL_UNSPECIFIED",
  LOG_LEVEL_DEBUG: "LOG_LEVEL_DEBUG",
  LOG_LEVEL_INFO: "LOG_LEVEL_INFO",
  LOG_LEVEL_WARN: "LOG_LEVEL_WARN",
  LOG_LEVEL_ERROR: "LOG_LEVEL_ERROR",
  LOG_LEVEL_FATAL: "LOG_LEVEL_FATAL",
} as const;

export type RuntimeServiceWatchLogsParams = {
  replay?: boolean;
  replayLimit?: number;
  level?: RuntimeServiceWatchLogsLevel;
};

export type RuntimeServiceWatchLogsLevel =
  (typeof RuntimeServiceWatchLogsLevel)[keyof typeof RuntimeServiceWatchLogsLevel];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const RuntimeServiceWatchLogsLevel = {
  LOG_LEVEL_UNSPECIFIED: "LOG_LEVEL_UNSPECIFIED",
  LOG_LEVEL_DEBUG: "LOG_LEVEL_DEBUG",
  LOG_LEVEL_INFO: "LOG_LEVEL_INFO",
  LOG_LEVEL_WARN: "LOG_LEVEL_WARN",
  LOG_LEVEL_ERROR: "LOG_LEVEL_ERROR",
  LOG_LEVEL_FATAL: "LOG_LEVEL_FATAL",
} as const;

export type RuntimeServiceWatchLogs200 = {
  result?: V1WatchLogsResponse;
  error?: RpcStatus;
};

export type RuntimeServiceGetModelPartitionsParams = {
  pending?: boolean;
  errored?: boolean;
  pageSize?: number;
  pageToken?: string;
};

export type QueryServiceResolveCanvasBodyArgs = { [key: string]: unknown };

export type QueryServiceResolveCanvasBody = {
  args?: QueryServiceResolveCanvasBodyArgs;
};

export type QueryServiceColumnCardinalityParams = {
  connector?: string;
  database?: string;
  databaseSchema?: string;
  /**
   * Required
   */
  columnName?: string;
  priority?: number;
};

export type QueryServiceTableColumnsParams = {
  connector?: string;
  database?: string;
  databaseSchema?: string;
  priority?: number;
};

export type QueryServiceResolveComponentBodyArgs = { [key: string]: unknown };

export type QueryServiceResolveComponentBody = {
  args?: QueryServiceResolveComponentBodyArgs;
};

export type QueryServiceColumnDescriptiveStatisticsParams = {
  connector?: string;
  database?: string;
  databaseSchema?: string;
  /**
   * Required
   */
  columnName?: string;
  priority?: number;
};

export type QueryServiceExportBody = {
  /** Optional limit on the number of rows to export. It is applied in addition to any limit specified in the query. */
  limit?: string;
  format?: V1ExportFormat;
  query?: V1Query;
  /** Deprecated. Use query instead. */
  bakedQuery?: string;
  /** If true, the export will include header comments with metadata about the export. */
  includeHeader?: boolean;
  originDashboard?: V1ResourceName;
  /** Optional UI URL that the export originates from.
Only used if include_header is true. */
  originUrl?: string;
  /** Optional Execution to attach to the underlying query. Used to resolve rill-time expressions. */
  executionTime?: string;
};

export type QueryServiceConvertExpressionToMetricsSQLBody = {
  expression?: V1Expression;
};

export type QueryServiceMetricsViewAggregationBody = {
  dimensions?: V1MetricsViewAggregationDimension[];
  measures?: V1MetricsViewAggregationMeasure[];
  sort?: V1MetricsViewAggregationSort[];
  timeRange?: V1TimeRange;
  comparisonTimeRange?: V1TimeRange;
  timeStart?: string;
  timeEnd?: string;
  pivotOn?: string[];
  aliases?: V1MetricsViewComparisonMeasureAlias[];
  where?: V1Expression;
  /** Optional. If both where and where_sql are set, both will be applied with an AND between them. */
  whereSql?: string;
  having?: V1Expression;
  /** Optional. If both having and having_sql are set, both will be applied with an AND between them. */
  havingSql?: string;
  limit?: string;
  offset?: string;
  priority?: number;
  filter?: V1MetricsViewFilter;
  exact?: boolean;
  fillMissing?: boolean;
  rows?: boolean;
};

export type QueryServiceMetricsViewAnnotationsBody = {
  measures?: string[];
  priority?: number;
  timeRange?: V1TimeRange;
  timeGrain?: V1TimeGrain;
  timeZone?: string;
  limit?: string;
  offset?: string;
};

export type QueryServiceMetricsViewComparisonBody = {
  dimension?: V1MetricsViewAggregationDimension;
  measures?: V1MetricsViewAggregationMeasure[];
  comparisonMeasures?: string[];
  sort?: V1MetricsViewComparisonSort[];
  timeRange?: V1TimeRange;
  comparisonTimeRange?: V1TimeRange;
  where?: V1Expression;
  /** Optional. If both where and where_sql are set, both will be applied with an AND between them. */
  whereSql?: string;
  having?: V1Expression;
  /** Optional. If both having and having_sql are set, both will be applied with an AND between them. */
  havingSql?: string;
  aliases?: V1MetricsViewComparisonMeasureAlias[];
  limit?: string;
  offset?: string;
  priority?: number;
  exact?: boolean;
  filter?: V1MetricsViewFilter;
};

export type QueryServiceMetricsViewRowsBody = {
  timeStart?: string;
  timeEnd?: string;
  timeGranularity?: V1TimeGrain;
  where?: V1Expression;
  sort?: V1MetricsViewSort[];
  limit?: number;
  offset?: string;
  priority?: number;
  timeZone?: string;
  filter?: V1MetricsViewFilter;
  timeDimension?: string;
};

export type QueryServiceMetricsViewSchemaParams = {
  priority?: number;
};

export type QueryServiceMetricsViewSearchBody = {
  dimensions?: string[];
  search?: string;
  timeRange?: V1TimeRange;
  where?: V1Expression;
  having?: V1Expression;
  limit?: number;
  priority?: number;
};

export type QueryServiceMetricsViewTimeRangeBody = {
  priority?: number;
  timeDimension?: string;
};

export type QueryServiceMetricsViewTimeRangesBody = {
  /** Optional time range expressions to resolve (uses the rilltime expression syntax). */
  expressions?: string[];
  /** Optional query priority. */
  priority?: number;
  /** Optional time zone that overrides the time zones used when resolving the time range expressions. */
  timeZone?: string;
  /** Optional time dimension to return time ranges for. If not specified, it uses the metrics view's default time dimension. */
  timeDimension?: string;
  /** Optional execution time against which the time ranges needs to be resolved. Watermark, latest and now are all replaced with this if provided. */
  executionTime?: string;
};

export type QueryServiceMetricsViewTimeSeriesBody = {
  measureNames?: string[];
  timeStart?: string;
  timeEnd?: string;
  timeGranularity?: V1TimeGrain;
  where?: V1Expression;
  /** Optional. If both where and where_sql are set, both will be applied with an AND between them. */
  whereSql?: string;
  having?: V1Expression;
  /** Optional. If both having and having_sql are set, both will be applied with an AND between them. */
  havingSql?: string;
  timeZone?: string;
  priority?: number;
  filter?: V1MetricsViewFilter;
  timeDimension?: string;
};

export type QueryServiceMetricsViewToplistBody = {
  dimensionName?: string;
  measureNames?: string[];
  timeStart?: string;
  timeEnd?: string;
  limit?: string;
  offset?: string;
  sort?: V1MetricsViewSort[];
  where?: V1Expression;
  whereSql?: string;
  having?: V1Expression;
  havingSql?: string;
  priority?: number;
  filter?: V1MetricsViewFilter;
};

export type QueryServiceMetricsViewTotalsBody = {
  measureNames?: string[];
  timeStart?: string;
  timeEnd?: string;
  where?: V1Expression;
  /** Optional. If both where and where_sql are set, both will be applied with an AND between them. */
  whereSql?: string;
  priority?: number;
  filter?: V1MetricsViewFilter;
  timeDimension?: string;
};

export type QueryServiceColumnNullCountParams = {
  connector?: string;
  database?: string;
  databaseSchema?: string;
  /**
   * Required
   */
  columnName?: string;
  priority?: number;
};

export type QueryServiceColumnNumericHistogramParams = {
  connector?: string;
  database?: string;
  databaseSchema?: string;
  columnName?: string;
  histogramMethod?: QueryServiceColumnNumericHistogramHistogramMethod;
  priority?: number;
};

export type QueryServiceColumnNumericHistogramHistogramMethod =
  (typeof QueryServiceColumnNumericHistogramHistogramMethod)[keyof typeof QueryServiceColumnNumericHistogramHistogramMethod];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const QueryServiceColumnNumericHistogramHistogramMethod = {
  HISTOGRAM_METHOD_UNSPECIFIED: "HISTOGRAM_METHOD_UNSPECIFIED",
  HISTOGRAM_METHOD_FD: "HISTOGRAM_METHOD_FD",
  HISTOGRAM_METHOD_DIAGNOSTIC: "HISTOGRAM_METHOD_DIAGNOSTIC",
} as const;

export type QueryServiceResolveTemplatedStringBodyAdditionalWhereByMetricsView =
  { [key: string]: V1Expression };

export type QueryServiceResolveTemplatedStringBody = {
  body?: string;
  /** If true, output format tokens instead of raw values. */
  useFormatTokens?: boolean;
  additionalWhereByMetricsView?: QueryServiceResolveTemplatedStringBodyAdditionalWhereByMetricsView;
  additionalTimeRange?: V1TimeRange;
};

export type QueryServiceColumnRollupIntervalBody = {
  connector?: string;
  database?: string;
  databaseSchema?: string;
  columnName?: string;
  priority?: number;
};

export type QueryServiceTableRowsParams = {
  connector?: string;
  database?: string;
  databaseSchema?: string;
  limit?: number;
  priority?: number;
};

export type QueryServiceColumnRugHistogramParams = {
  connector?: string;
  database?: string;
  databaseSchema?: string;
  columnName?: string;
  priority?: number;
};

export type QueryServiceColumnTimeGrainParams = {
  connector?: string;
  database?: string;
  databaseSchema?: string;
  /**
   * Required
   */
  columnName?: string;
  priority?: number;
};

export type QueryServiceTableCardinalityParams = {
  connector?: string;
  database?: string;
  databaseSchema?: string;
  priority?: number;
};

export type QueryServiceColumnTimeRangeParams = {
  connector?: string;
  database?: string;
  databaseSchema?: string;
  columnName?: string;
  priority?: number;
};

export type QueryServiceColumnTimeSeriesBody = {
  connector?: string;
  database?: string;
  databaseSchema?: string;
  measures?: ColumnTimeSeriesRequestBasicMeasure[];
  timestampColumnName?: string;
  timeRange?: V1TimeSeriesTimeRange;
  pixels?: number;
  sampleSize?: number;
  priority?: number;
  timeZone?: string;
};

export type QueryServiceColumnTopKBody = {
  connector?: string;
  database?: string;
  databaseSchema?: string;
  columnName?: string;
  agg?: string;
  k?: number;
  priority?: number;
};

export type QueryServiceQueryBody = {
  connector?: string;
  sql?: string;
  args?: unknown[];
  priority?: number;
  dryRun?: boolean;
  limit?: number;
};

export type QueryServiceQueryBatchBody = {
  queries?: V1Query[];
};

export type QueryServiceQueryBatch200 = {
  result?: V1QueryBatchResponse;
  error?: RpcStatus;
};

export type RuntimeServiceQueryResolverBodyResolverProperties = {
  [key: string]: unknown;
};

export type RuntimeServiceQueryResolverBodyResolverArgs = {
  [key: string]: unknown;
};

export type RuntimeServiceQueryResolverBody = {
  resolver?: string;
  resolverProperties?: RuntimeServiceQueryResolverBodyResolverProperties;
  resolverArgs?: RuntimeServiceQueryResolverBodyResolverArgs;
  limit?: number;
};

export type RuntimeServiceReloadConfigBody = { [key: string]: unknown };

export type QueryServiceExportReportBody = {
  /** The execution time to evaluate the report relative to.
This is provided by the report implementation when sending a report. */
  executionTime?: string;
  /** Contextual information about the base URL of the UI that initiated the export.
This is used to generate header comments in the exported file when include_header is true in the report spec. */
  originBaseUrl?: string;
};

export type RuntimeServiceGetResourceParams = {
  "name.kind"?: string;
  "name.name"?: string;
  skipSecurityChecks?: boolean;
};

export type RuntimeServiceListResourcesParams = {
  /**
   * Filter by resource kind (optional).
   */
  kind?: string;
  /**
   * Filter by resource path (optional).
   */
  path?: string;
  /**
   * Skip security checks
   */
  skipSecurityChecks?: boolean;
};

export type RuntimeServiceWatchResourcesParams = {
  kind?: string;
  replay?: boolean;
};

export type RuntimeServiceWatchResources200 = {
  result?: V1WatchResourcesResponse;
  error?: RpcStatus;
};

export type RuntimeServiceGetExploreParams = {
  name?: string;
};

export type RuntimeServiceCreateTriggerBody = {
  /** Resources to trigger. See RefreshTriggerSpec for details. */
  resources?: V1ResourceName[];
  /** Models to trigger. Unlike resources, this supports advanced configuration of the refresh trigger. */
  models?: V1RefreshModelTrigger[];
  /** Parser is a convenience flag to trigger the global project parser.
Triggering the project parser ensures a pull of the repository and a full parse of all files. */
  parser?: boolean;
  /** Convenience flag to trigger all resources.
Note: Despite the name, it does not currently trigger alerts and reports. */
  all?: boolean;
  /** Convenience flag to trigger all resources with full refreshes for resources that support it.
Currently, only models support full refreshes. It's equivalent to passing RefreshModelTrigger.full for those models.
Note: Despite the name, it does not currently trigger alerts and reports. */
  allFull?: boolean;
};

export type ConnectorServiceOLAPListTablesParams = {
  instanceId?: string;
  /**
   * Connector to list tables from.
   */
  connector?: string;
  /**
 * Optional search pattern to filter tables by.
Has the same syntax and behavior as ILIKE in SQL.
If the connector supports schema/database names, it searches against both the plain table name and the fully qualified table name.
 */
  searchPattern?: string;
  pageSize?: number;
  pageToken?: string;
};

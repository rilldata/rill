/**
 * Generated by orval v6.12.0 üç∫
 * Do not edit manually.
 * rill/runtime/v1/schema.proto
 * OpenAPI spec version: version not set
 */
import { createQuery, createMutation } from "@tanstack/svelte-query";
import type {
  CreateQueryOptions,
  CreateMutationOptions,
  QueryFunction,
  MutationFunction,
  CreateQueryResult,
  QueryKey,
} from "@tanstack/svelte-query";
import type {
  V1ResolveCanvasResponse,
  RpcStatus,
  QueryServiceResolveCanvasBody,
  V1ColumnCardinalityResponse,
  QueryServiceColumnCardinalityParams,
  V1TableColumnsResponse,
  QueryServiceTableColumnsParams,
  V1ResolveComponentResponse,
  QueryServiceResolveComponentBody,
  V1ColumnDescriptiveStatisticsResponse,
  QueryServiceColumnDescriptiveStatisticsParams,
  V1ExportResponse,
  QueryServiceExportBody,
  V1MetricsViewAggregationResponse,
  QueryServiceMetricsViewAggregationBody,
  V1MetricsViewComparisonResponse,
  QueryServiceMetricsViewComparisonBody,
  V1MetricsViewRowsResponse,
  QueryServiceMetricsViewRowsBody,
  V1MetricsViewSchemaResponse,
  QueryServiceMetricsViewSchemaParams,
  V1MetricsViewSearchResponse,
  QueryServiceMetricsViewSearchBody,
  V1MetricsViewTimeRangeResponse,
  QueryServiceMetricsViewTimeRangeBody,
  V1MetricsViewTimeRangesResponse,
  QueryServiceMetricsViewTimeRangesBody,
  V1MetricsViewTimeSeriesResponse,
  QueryServiceMetricsViewTimeSeriesBody,
  V1MetricsViewToplistResponse,
  QueryServiceMetricsViewToplistBody,
  V1MetricsViewTotalsResponse,
  QueryServiceMetricsViewTotalsBody,
  V1ColumnNullCountResponse,
  QueryServiceColumnNullCountParams,
  V1ColumnNumericHistogramResponse,
  QueryServiceColumnNumericHistogramParams,
  V1ColumnRollupIntervalResponse,
  QueryServiceColumnRollupIntervalBody,
  V1TableRowsResponse,
  QueryServiceTableRowsParams,
  V1ColumnRugHistogramResponse,
  QueryServiceColumnRugHistogramParams,
  V1ColumnTimeGrainResponse,
  QueryServiceColumnTimeGrainParams,
  V1TableCardinalityResponse,
  QueryServiceTableCardinalityParams,
  V1ColumnTimeRangeResponse,
  QueryServiceColumnTimeRangeParams,
  V1ColumnTimeSeriesResponse,
  QueryServiceColumnTimeSeriesBody,
  V1ColumnTopKResponse,
  QueryServiceColumnTopKBody,
  V1QueryResponse,
  QueryServiceQueryBody,
  QueryServiceQueryBatch200,
  QueryServiceQueryBatchBody,
  V1ExportReportResponse,
  QueryServiceExportReportBody,
} from "../index.schemas";
import { httpClient } from "../../http-client";
import type { ErrorType } from "../../http-client";

type AwaitedInput<T> = PromiseLike<T> | T;

type Awaited<O> = O extends AwaitedInput<infer T> ? T : never;

/**
 * @summary ResolveCanvas is a convenience API that returns a canvas and all its referenced components and metrics views.
 */
export const queryServiceResolveCanvas = (
  instanceId: string,
  canvas: string,
  queryServiceResolveCanvasBody: QueryServiceResolveCanvasBody,
  signal?: AbortSignal,
) => {
  return httpClient<V1ResolveCanvasResponse>({
    url: `/v1/instances/${instanceId}/queries/canvases/${canvas}/resolve`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: queryServiceResolveCanvasBody,
    signal,
  });
};

export const getQueryServiceResolveCanvasQueryKey = (
  instanceId: string,
  canvas: string,
  queryServiceResolveCanvasBody: QueryServiceResolveCanvasBody,
) => [
  `/v1/instances/${instanceId}/queries/canvases/${canvas}/resolve`,
  queryServiceResolveCanvasBody,
];

export type QueryServiceResolveCanvasQueryResult = NonNullable<
  Awaited<ReturnType<typeof queryServiceResolveCanvas>>
>;
export type QueryServiceResolveCanvasQueryError = ErrorType<RpcStatus>;

export const createQueryServiceResolveCanvas = <
  TData = Awaited<ReturnType<typeof queryServiceResolveCanvas>>,
  TError = ErrorType<RpcStatus>,
>(
  instanceId: string,
  canvas: string,
  queryServiceResolveCanvasBody: QueryServiceResolveCanvasBody,
  options?: {
    query?: CreateQueryOptions<
      Awaited<ReturnType<typeof queryServiceResolveCanvas>>,
      TError,
      TData
    >;
  },
): CreateQueryResult<TData, TError> & {
  queryKey: QueryKey;
} => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getQueryServiceResolveCanvasQueryKey(
      instanceId,
      canvas,
      queryServiceResolveCanvasBody,
    );

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof queryServiceResolveCanvas>>
  > = ({ signal }) =>
    queryServiceResolveCanvas(
      instanceId,
      canvas,
      queryServiceResolveCanvasBody,
      signal,
    );

  const query = createQuery<
    Awaited<ReturnType<typeof queryServiceResolveCanvas>>,
    TError,
    TData
  >({
    queryKey,
    queryFn,
    enabled: !!(instanceId && canvas),
    ...queryOptions,
  }) as CreateQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryKey;

  return query;
};

/**
 * @summary Get cardinality for a column
 */
export const queryServiceColumnCardinality = (
  instanceId: string,
  tableName: string,
  params?: QueryServiceColumnCardinalityParams,
  signal?: AbortSignal,
) => {
  return httpClient<V1ColumnCardinalityResponse>({
    url: `/v1/instances/${instanceId}/queries/column-cardinality/tables/${tableName}`,
    method: "get",
    params,
    signal,
  });
};

export const getQueryServiceColumnCardinalityQueryKey = (
  instanceId: string,
  tableName: string,
  params?: QueryServiceColumnCardinalityParams,
) => [
  `/v1/instances/${instanceId}/queries/column-cardinality/tables/${tableName}`,
  ...(params ? [params] : []),
];

export type QueryServiceColumnCardinalityQueryResult = NonNullable<
  Awaited<ReturnType<typeof queryServiceColumnCardinality>>
>;
export type QueryServiceColumnCardinalityQueryError = ErrorType<RpcStatus>;

export const createQueryServiceColumnCardinality = <
  TData = Awaited<ReturnType<typeof queryServiceColumnCardinality>>,
  TError = ErrorType<RpcStatus>,
>(
  instanceId: string,
  tableName: string,
  params?: QueryServiceColumnCardinalityParams,
  options?: {
    query?: CreateQueryOptions<
      Awaited<ReturnType<typeof queryServiceColumnCardinality>>,
      TError,
      TData
    >;
  },
): CreateQueryResult<TData, TError> & {
  queryKey: QueryKey;
} => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getQueryServiceColumnCardinalityQueryKey(instanceId, tableName, params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof queryServiceColumnCardinality>>
  > = ({ signal }) =>
    queryServiceColumnCardinality(instanceId, tableName, params, signal);

  const query = createQuery<
    Awaited<ReturnType<typeof queryServiceColumnCardinality>>,
    TError,
    TData
  >({
    queryKey,
    queryFn,
    enabled: !!(instanceId && tableName),
    ...queryOptions,
  }) as CreateQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryKey;

  return query;
};

/**
 * @summary TableColumns returns column profiles
 */
export const queryServiceTableColumns = (
  instanceId: string,
  tableName: string,
  params?: QueryServiceTableColumnsParams,
  signal?: AbortSignal,
) => {
  return httpClient<V1TableColumnsResponse>({
    url: `/v1/instances/${instanceId}/queries/columns-profile/tables/${tableName}`,
    method: "post",
    params,
    signal,
  });
};

export const getQueryServiceTableColumnsQueryKey = (
  instanceId: string,
  tableName: string,
  params?: QueryServiceTableColumnsParams,
) => [
  `/v1/instances/${instanceId}/queries/columns-profile/tables/${tableName}`,
  ...(params ? [params] : []),
];

export type QueryServiceTableColumnsQueryResult = NonNullable<
  Awaited<ReturnType<typeof queryServiceTableColumns>>
>;
export type QueryServiceTableColumnsQueryError = ErrorType<RpcStatus>;

export const createQueryServiceTableColumns = <
  TData = Awaited<ReturnType<typeof queryServiceTableColumns>>,
  TError = ErrorType<RpcStatus>,
>(
  instanceId: string,
  tableName: string,
  params?: QueryServiceTableColumnsParams,
  options?: {
    query?: CreateQueryOptions<
      Awaited<ReturnType<typeof queryServiceTableColumns>>,
      TError,
      TData
    >;
  },
): CreateQueryResult<TData, TError> & {
  queryKey: QueryKey;
} => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getQueryServiceTableColumnsQueryKey(instanceId, tableName, params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof queryServiceTableColumns>>
  > = ({ signal }) =>
    queryServiceTableColumns(instanceId, tableName, params, signal);

  const query = createQuery<
    Awaited<ReturnType<typeof queryServiceTableColumns>>,
    TError,
    TData
  >({
    queryKey,
    queryFn,
    enabled: !!(instanceId && tableName),
    ...queryOptions,
  }) as CreateQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryKey;

  return query;
};

/**
 * @summary ResolveComponent resolves renderer for a Component resource.
 */
export const queryServiceResolveComponent = (
  instanceId: string,
  component: string,
  queryServiceResolveComponentBody: QueryServiceResolveComponentBody,
  signal?: AbortSignal,
) => {
  return httpClient<V1ResolveComponentResponse>({
    url: `/v1/instances/${instanceId}/queries/components/${component}/resolve`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: queryServiceResolveComponentBody,
    signal,
  });
};

export const getQueryServiceResolveComponentQueryKey = (
  instanceId: string,
  component: string,
  queryServiceResolveComponentBody: QueryServiceResolveComponentBody,
) => [
  `/v1/instances/${instanceId}/queries/components/${component}/resolve`,
  queryServiceResolveComponentBody,
];

export type QueryServiceResolveComponentQueryResult = NonNullable<
  Awaited<ReturnType<typeof queryServiceResolveComponent>>
>;
export type QueryServiceResolveComponentQueryError = ErrorType<RpcStatus>;

export const createQueryServiceResolveComponent = <
  TData = Awaited<ReturnType<typeof queryServiceResolveComponent>>,
  TError = ErrorType<RpcStatus>,
>(
  instanceId: string,
  component: string,
  queryServiceResolveComponentBody: QueryServiceResolveComponentBody,
  options?: {
    query?: CreateQueryOptions<
      Awaited<ReturnType<typeof queryServiceResolveComponent>>,
      TError,
      TData
    >;
  },
): CreateQueryResult<TData, TError> & {
  queryKey: QueryKey;
} => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getQueryServiceResolveComponentQueryKey(
      instanceId,
      component,
      queryServiceResolveComponentBody,
    );

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof queryServiceResolveComponent>>
  > = ({ signal }) =>
    queryServiceResolveComponent(
      instanceId,
      component,
      queryServiceResolveComponentBody,
      signal,
    );

  const query = createQuery<
    Awaited<ReturnType<typeof queryServiceResolveComponent>>,
    TError,
    TData
  >({
    queryKey,
    queryFn,
    enabled: !!(instanceId && component),
    ...queryOptions,
  }) as CreateQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryKey;

  return query;
};

/**
 * @summary Get basic stats for a numeric column like min, max, mean, stddev, etc
 */
export const queryServiceColumnDescriptiveStatistics = (
  instanceId: string,
  tableName: string,
  params?: QueryServiceColumnDescriptiveStatisticsParams,
  signal?: AbortSignal,
) => {
  return httpClient<V1ColumnDescriptiveStatisticsResponse>({
    url: `/v1/instances/${instanceId}/queries/descriptive-statistics/tables/${tableName}`,
    method: "get",
    params,
    signal,
  });
};

export const getQueryServiceColumnDescriptiveStatisticsQueryKey = (
  instanceId: string,
  tableName: string,
  params?: QueryServiceColumnDescriptiveStatisticsParams,
) => [
  `/v1/instances/${instanceId}/queries/descriptive-statistics/tables/${tableName}`,
  ...(params ? [params] : []),
];

export type QueryServiceColumnDescriptiveStatisticsQueryResult = NonNullable<
  Awaited<ReturnType<typeof queryServiceColumnDescriptiveStatistics>>
>;
export type QueryServiceColumnDescriptiveStatisticsQueryError =
  ErrorType<RpcStatus>;

export const createQueryServiceColumnDescriptiveStatistics = <
  TData = Awaited<ReturnType<typeof queryServiceColumnDescriptiveStatistics>>,
  TError = ErrorType<RpcStatus>,
>(
  instanceId: string,
  tableName: string,
  params?: QueryServiceColumnDescriptiveStatisticsParams,
  options?: {
    query?: CreateQueryOptions<
      Awaited<ReturnType<typeof queryServiceColumnDescriptiveStatistics>>,
      TError,
      TData
    >;
  },
): CreateQueryResult<TData, TError> & {
  queryKey: QueryKey;
} => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getQueryServiceColumnDescriptiveStatisticsQueryKey(
      instanceId,
      tableName,
      params,
    );

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof queryServiceColumnDescriptiveStatistics>>
  > = ({ signal }) =>
    queryServiceColumnDescriptiveStatistics(
      instanceId,
      tableName,
      params,
      signal,
    );

  const query = createQuery<
    Awaited<ReturnType<typeof queryServiceColumnDescriptiveStatistics>>,
    TError,
    TData
  >({
    queryKey,
    queryFn,
    enabled: !!(instanceId && tableName),
    ...queryOptions,
  }) as CreateQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryKey;

  return query;
};

/**
 * @summary Export builds a URL to download the results of a query as a file.
 */
export const queryServiceExport = (
  instanceId: string,
  queryServiceExportBody: QueryServiceExportBody,
) => {
  return httpClient<V1ExportResponse>({
    url: `/v1/instances/${instanceId}/queries/export`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: queryServiceExportBody,
  });
};

export type QueryServiceExportMutationResult = NonNullable<
  Awaited<ReturnType<typeof queryServiceExport>>
>;
export type QueryServiceExportMutationBody = QueryServiceExportBody;
export type QueryServiceExportMutationError = ErrorType<RpcStatus>;

export const createQueryServiceExport = <
  TError = ErrorType<RpcStatus>,
  TContext = unknown,
>(options?: {
  mutation?: CreateMutationOptions<
    Awaited<ReturnType<typeof queryServiceExport>>,
    TError,
    {
      instanceId: string;
      data: QueryServiceExportBody;
    },
    TContext
  >;
}) => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof queryServiceExport>>,
    {
      instanceId: string;
      data: QueryServiceExportBody;
    }
  > = (props) => {
    const { instanceId, data } = props ?? {};

    return queryServiceExport(instanceId, data);
  };

  return createMutation<
    Awaited<ReturnType<typeof queryServiceExport>>,
    TError,
    {
      instanceId: string;
      data: QueryServiceExportBody;
    },
    TContext
  >(mutationFn, mutationOptions);
};
/**
 * @summary MetricsViewAggregation is a generic API for running group-by/pivot queries against a metrics view.
 */
export const queryServiceMetricsViewAggregation = (
  instanceId: string,
  metricsView: string,
  queryServiceMetricsViewAggregationBody: QueryServiceMetricsViewAggregationBody,
  signal?: AbortSignal,
) => {
  return httpClient<V1MetricsViewAggregationResponse>({
    url: `/v1/instances/${instanceId}/queries/metrics-views/${metricsView}/aggregation`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: queryServiceMetricsViewAggregationBody,
    signal,
  });
};

export const getQueryServiceMetricsViewAggregationQueryKey = (
  instanceId: string,
  metricsView: string,
  queryServiceMetricsViewAggregationBody: QueryServiceMetricsViewAggregationBody,
) => [
  `/v1/instances/${instanceId}/queries/metrics-views/${metricsView}/aggregation`,
  queryServiceMetricsViewAggregationBody,
];

export type QueryServiceMetricsViewAggregationQueryResult = NonNullable<
  Awaited<ReturnType<typeof queryServiceMetricsViewAggregation>>
>;
export type QueryServiceMetricsViewAggregationQueryError = ErrorType<RpcStatus>;

export const createQueryServiceMetricsViewAggregation = <
  TData = Awaited<ReturnType<typeof queryServiceMetricsViewAggregation>>,
  TError = ErrorType<RpcStatus>,
>(
  instanceId: string,
  metricsView: string,
  queryServiceMetricsViewAggregationBody: QueryServiceMetricsViewAggregationBody,
  options?: {
    query?: CreateQueryOptions<
      Awaited<ReturnType<typeof queryServiceMetricsViewAggregation>>,
      TError,
      TData
    >;
  },
): CreateQueryResult<TData, TError> & {
  queryKey: QueryKey;
} => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getQueryServiceMetricsViewAggregationQueryKey(
      instanceId,
      metricsView,
      queryServiceMetricsViewAggregationBody,
    );

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof queryServiceMetricsViewAggregation>>
  > = ({ signal }) =>
    queryServiceMetricsViewAggregation(
      instanceId,
      metricsView,
      queryServiceMetricsViewAggregationBody,
      signal,
    );

  const query = createQuery<
    Awaited<ReturnType<typeof queryServiceMetricsViewAggregation>>,
    TError,
    TData
  >({
    queryKey,
    queryFn,
    enabled: !!(instanceId && metricsView),
    ...queryOptions,
  }) as CreateQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryKey;

  return query;
};

/**
 * ie. comparsion toplist:
| measure1_base | measure1_previous   | measure1__delta_abs | measure1__delta_rel | dimension |
|---------------|---------------------|---------------------|--------------------|-----------|
| 2             | 2                   | 0                   | 0                  | Safari    |
| 1             | 0                   | 1                   | N/A                | Chrome    |
| 0             | 4                   | -4                  | -1.0               | Firefox   |

ie. toplist:
| measure1 | measure2 | dimension |
|----------|----------|-----------|
| 2        | 45       | Safari    |
| 1        | 350      | Chrome    |
| 0        | 25       | Firefox   |
 * @summary MetricsViewComparison returns a toplist containing comparison data of another toplist (same dimension/measure but a different time range).
Returns a toplist without comparison data if comparison time range is omitted.
 */
export const queryServiceMetricsViewComparison = (
  instanceId: string,
  metricsViewName: string,
  queryServiceMetricsViewComparisonBody: QueryServiceMetricsViewComparisonBody,
  signal?: AbortSignal,
) => {
  return httpClient<V1MetricsViewComparisonResponse>({
    url: `/v1/instances/${instanceId}/queries/metrics-views/${metricsViewName}/compare-toplist`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: queryServiceMetricsViewComparisonBody,
    signal,
  });
};

export const getQueryServiceMetricsViewComparisonQueryKey = (
  instanceId: string,
  metricsViewName: string,
  queryServiceMetricsViewComparisonBody: QueryServiceMetricsViewComparisonBody,
) => [
  `/v1/instances/${instanceId}/queries/metrics-views/${metricsViewName}/compare-toplist`,
  queryServiceMetricsViewComparisonBody,
];

export type QueryServiceMetricsViewComparisonQueryResult = NonNullable<
  Awaited<ReturnType<typeof queryServiceMetricsViewComparison>>
>;
export type QueryServiceMetricsViewComparisonQueryError = ErrorType<RpcStatus>;

export const createQueryServiceMetricsViewComparison = <
  TData = Awaited<ReturnType<typeof queryServiceMetricsViewComparison>>,
  TError = ErrorType<RpcStatus>,
>(
  instanceId: string,
  metricsViewName: string,
  queryServiceMetricsViewComparisonBody: QueryServiceMetricsViewComparisonBody,
  options?: {
    query?: CreateQueryOptions<
      Awaited<ReturnType<typeof queryServiceMetricsViewComparison>>,
      TError,
      TData
    >;
  },
): CreateQueryResult<TData, TError> & {
  queryKey: QueryKey;
} => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getQueryServiceMetricsViewComparisonQueryKey(
      instanceId,
      metricsViewName,
      queryServiceMetricsViewComparisonBody,
    );

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof queryServiceMetricsViewComparison>>
  > = ({ signal }) =>
    queryServiceMetricsViewComparison(
      instanceId,
      metricsViewName,
      queryServiceMetricsViewComparisonBody,
      signal,
    );

  const query = createQuery<
    Awaited<ReturnType<typeof queryServiceMetricsViewComparison>>,
    TError,
    TData
  >({
    queryKey,
    queryFn,
    enabled: !!(instanceId && metricsViewName),
    ...queryOptions,
  }) as CreateQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryKey;

  return query;
};

/**
 * ie. without granularity
| column1 | column2 | dimension |
|---------|---------|-----------|
| 2       | 2       | Safari    |
| 1       | 0       | Chrome    |
| 0       | 4       | Firefox   |

ie. with granularity
| timestamp__day0      | column1 | column2 | dimension |
|----------------------|---------|---------|-----------|
| 2022-01-01T00:00:00Z | 2       | 2       | Safari    |
| 2022-01-01T00:00:00Z | 1       | 0       | Chrome    |
| 2022-01-01T00:00:00Z | 0       | 4       | Firefox   |
 * @summary MetricsViewRows returns the underlying model rows matching a metrics view time range and filter(s).
 */
export const queryServiceMetricsViewRows = (
  instanceId: string,
  metricsViewName: string,
  queryServiceMetricsViewRowsBody: QueryServiceMetricsViewRowsBody,
  signal?: AbortSignal,
) => {
  return httpClient<V1MetricsViewRowsResponse>({
    url: `/v1/instances/${instanceId}/queries/metrics-views/${metricsViewName}/rows`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: queryServiceMetricsViewRowsBody,
    signal,
  });
};

export const getQueryServiceMetricsViewRowsQueryKey = (
  instanceId: string,
  metricsViewName: string,
  queryServiceMetricsViewRowsBody: QueryServiceMetricsViewRowsBody,
) => [
  `/v1/instances/${instanceId}/queries/metrics-views/${metricsViewName}/rows`,
  queryServiceMetricsViewRowsBody,
];

export type QueryServiceMetricsViewRowsQueryResult = NonNullable<
  Awaited<ReturnType<typeof queryServiceMetricsViewRows>>
>;
export type QueryServiceMetricsViewRowsQueryError = ErrorType<RpcStatus>;

export const createQueryServiceMetricsViewRows = <
  TData = Awaited<ReturnType<typeof queryServiceMetricsViewRows>>,
  TError = ErrorType<RpcStatus>,
>(
  instanceId: string,
  metricsViewName: string,
  queryServiceMetricsViewRowsBody: QueryServiceMetricsViewRowsBody,
  options?: {
    query?: CreateQueryOptions<
      Awaited<ReturnType<typeof queryServiceMetricsViewRows>>,
      TError,
      TData
    >;
  },
): CreateQueryResult<TData, TError> & {
  queryKey: QueryKey;
} => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getQueryServiceMetricsViewRowsQueryKey(
      instanceId,
      metricsViewName,
      queryServiceMetricsViewRowsBody,
    );

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof queryServiceMetricsViewRows>>
  > = ({ signal }) =>
    queryServiceMetricsViewRows(
      instanceId,
      metricsViewName,
      queryServiceMetricsViewRowsBody,
      signal,
    );

  const query = createQuery<
    Awaited<ReturnType<typeof queryServiceMetricsViewRows>>,
    TError,
    TData
  >({
    queryKey,
    queryFn,
    enabled: !!(instanceId && metricsViewName),
    ...queryOptions,
  }) as CreateQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryKey;

  return query;
};

/**
 * @summary MetricsViewSchema Get the data types of measures and dimensions
 */
export const queryServiceMetricsViewSchema = (
  instanceId: string,
  metricsViewName: string,
  params?: QueryServiceMetricsViewSchemaParams,
  signal?: AbortSignal,
) => {
  return httpClient<V1MetricsViewSchemaResponse>({
    url: `/v1/instances/${instanceId}/queries/metrics-views/${metricsViewName}/schema`,
    method: "get",
    params,
    signal,
  });
};

export const getQueryServiceMetricsViewSchemaQueryKey = (
  instanceId: string,
  metricsViewName: string,
  params?: QueryServiceMetricsViewSchemaParams,
) => [
  `/v1/instances/${instanceId}/queries/metrics-views/${metricsViewName}/schema`,
  ...(params ? [params] : []),
];

export type QueryServiceMetricsViewSchemaQueryResult = NonNullable<
  Awaited<ReturnType<typeof queryServiceMetricsViewSchema>>
>;
export type QueryServiceMetricsViewSchemaQueryError = ErrorType<RpcStatus>;

export const createQueryServiceMetricsViewSchema = <
  TData = Awaited<ReturnType<typeof queryServiceMetricsViewSchema>>,
  TError = ErrorType<RpcStatus>,
>(
  instanceId: string,
  metricsViewName: string,
  params?: QueryServiceMetricsViewSchemaParams,
  options?: {
    query?: CreateQueryOptions<
      Awaited<ReturnType<typeof queryServiceMetricsViewSchema>>,
      TError,
      TData
    >;
  },
): CreateQueryResult<TData, TError> & {
  queryKey: QueryKey;
} => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getQueryServiceMetricsViewSchemaQueryKey(
      instanceId,
      metricsViewName,
      params,
    );

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof queryServiceMetricsViewSchema>>
  > = ({ signal }) =>
    queryServiceMetricsViewSchema(instanceId, metricsViewName, params, signal);

  const query = createQuery<
    Awaited<ReturnType<typeof queryServiceMetricsViewSchema>>,
    TError,
    TData
  >({
    queryKey,
    queryFn,
    enabled: !!(instanceId && metricsViewName),
    ...queryOptions,
  }) as CreateQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryKey;

  return query;
};

/**
 * @summary MetricsViewSearch Get the data types of measures and dimensions
 */
export const queryServiceMetricsViewSearch = (
  instanceId: string,
  metricsViewName: string,
  queryServiceMetricsViewSearchBody: QueryServiceMetricsViewSearchBody,
  signal?: AbortSignal,
) => {
  return httpClient<V1MetricsViewSearchResponse>({
    url: `/v1/instances/${instanceId}/queries/metrics-views/${metricsViewName}/search`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: queryServiceMetricsViewSearchBody,
    signal,
  });
};

export const getQueryServiceMetricsViewSearchQueryKey = (
  instanceId: string,
  metricsViewName: string,
  queryServiceMetricsViewSearchBody: QueryServiceMetricsViewSearchBody,
) => [
  `/v1/instances/${instanceId}/queries/metrics-views/${metricsViewName}/search`,
  queryServiceMetricsViewSearchBody,
];

export type QueryServiceMetricsViewSearchQueryResult = NonNullable<
  Awaited<ReturnType<typeof queryServiceMetricsViewSearch>>
>;
export type QueryServiceMetricsViewSearchQueryError = ErrorType<RpcStatus>;

export const createQueryServiceMetricsViewSearch = <
  TData = Awaited<ReturnType<typeof queryServiceMetricsViewSearch>>,
  TError = ErrorType<RpcStatus>,
>(
  instanceId: string,
  metricsViewName: string,
  queryServiceMetricsViewSearchBody: QueryServiceMetricsViewSearchBody,
  options?: {
    query?: CreateQueryOptions<
      Awaited<ReturnType<typeof queryServiceMetricsViewSearch>>,
      TError,
      TData
    >;
  },
): CreateQueryResult<TData, TError> & {
  queryKey: QueryKey;
} => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getQueryServiceMetricsViewSearchQueryKey(
      instanceId,
      metricsViewName,
      queryServiceMetricsViewSearchBody,
    );

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof queryServiceMetricsViewSearch>>
  > = ({ signal }) =>
    queryServiceMetricsViewSearch(
      instanceId,
      metricsViewName,
      queryServiceMetricsViewSearchBody,
      signal,
    );

  const query = createQuery<
    Awaited<ReturnType<typeof queryServiceMetricsViewSearch>>,
    TError,
    TData
  >({
    queryKey,
    queryFn,
    enabled: !!(instanceId && metricsViewName),
    ...queryOptions,
  }) as CreateQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryKey;

  return query;
};

/**
 * @summary MetricsViewTimeRange Get the time range summaries (min, max) for time column in a metrics view
 */
export const queryServiceMetricsViewTimeRange = (
  instanceId: string,
  metricsViewName: string,
  queryServiceMetricsViewTimeRangeBody: QueryServiceMetricsViewTimeRangeBody,
  signal?: AbortSignal,
) => {
  return httpClient<V1MetricsViewTimeRangeResponse>({
    url: `/v1/instances/${instanceId}/queries/metrics-views/${metricsViewName}/time-range-summary`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: queryServiceMetricsViewTimeRangeBody,
    signal,
  });
};

export const getQueryServiceMetricsViewTimeRangeQueryKey = (
  instanceId: string,
  metricsViewName: string,
  queryServiceMetricsViewTimeRangeBody: QueryServiceMetricsViewTimeRangeBody,
) => [
  `/v1/instances/${instanceId}/queries/metrics-views/${metricsViewName}/time-range-summary`,
  queryServiceMetricsViewTimeRangeBody,
];

export type QueryServiceMetricsViewTimeRangeQueryResult = NonNullable<
  Awaited<ReturnType<typeof queryServiceMetricsViewTimeRange>>
>;
export type QueryServiceMetricsViewTimeRangeQueryError = ErrorType<RpcStatus>;

export const createQueryServiceMetricsViewTimeRange = <
  TData = Awaited<ReturnType<typeof queryServiceMetricsViewTimeRange>>,
  TError = ErrorType<RpcStatus>,
>(
  instanceId: string,
  metricsViewName: string,
  queryServiceMetricsViewTimeRangeBody: QueryServiceMetricsViewTimeRangeBody,
  options?: {
    query?: CreateQueryOptions<
      Awaited<ReturnType<typeof queryServiceMetricsViewTimeRange>>,
      TError,
      TData
    >;
  },
): CreateQueryResult<TData, TError> & {
  queryKey: QueryKey;
} => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getQueryServiceMetricsViewTimeRangeQueryKey(
      instanceId,
      metricsViewName,
      queryServiceMetricsViewTimeRangeBody,
    );

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof queryServiceMetricsViewTimeRange>>
  > = ({ signal }) =>
    queryServiceMetricsViewTimeRange(
      instanceId,
      metricsViewName,
      queryServiceMetricsViewTimeRangeBody,
      signal,
    );

  const query = createQuery<
    Awaited<ReturnType<typeof queryServiceMetricsViewTimeRange>>,
    TError,
    TData
  >({
    queryKey,
    queryFn,
    enabled: !!(instanceId && metricsViewName),
    ...queryOptions,
  }) as CreateQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryKey;

  return query;
};

export const queryServiceMetricsViewTimeRanges = (
  instanceId: string,
  metricsViewName: string,
  queryServiceMetricsViewTimeRangesBody: QueryServiceMetricsViewTimeRangesBody,
) => {
  return httpClient<V1MetricsViewTimeRangesResponse>({
    url: `/v1/instances/${instanceId}/queries/metrics-views/${metricsViewName}/time-ranges`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: queryServiceMetricsViewTimeRangesBody,
  });
};

export type QueryServiceMetricsViewTimeRangesMutationResult = NonNullable<
  Awaited<ReturnType<typeof queryServiceMetricsViewTimeRanges>>
>;
export type QueryServiceMetricsViewTimeRangesMutationBody =
  QueryServiceMetricsViewTimeRangesBody;
export type QueryServiceMetricsViewTimeRangesMutationError =
  ErrorType<RpcStatus>;

export const createQueryServiceMetricsViewTimeRanges = <
  TError = ErrorType<RpcStatus>,
  TContext = unknown,
>(options?: {
  mutation?: CreateMutationOptions<
    Awaited<ReturnType<typeof queryServiceMetricsViewTimeRanges>>,
    TError,
    {
      instanceId: string;
      metricsViewName: string;
      data: QueryServiceMetricsViewTimeRangesBody;
    },
    TContext
  >;
}) => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof queryServiceMetricsViewTimeRanges>>,
    {
      instanceId: string;
      metricsViewName: string;
      data: QueryServiceMetricsViewTimeRangesBody;
    }
  > = (props) => {
    const { instanceId, metricsViewName, data } = props ?? {};

    return queryServiceMetricsViewTimeRanges(instanceId, metricsViewName, data);
  };

  return createMutation<
    Awaited<ReturnType<typeof queryServiceMetricsViewTimeRanges>>,
    TError,
    {
      instanceId: string;
      metricsViewName: string;
      data: QueryServiceMetricsViewTimeRangesBody;
    },
    TContext
  >(mutationFn, mutationOptions);
};
/**
 * @summary MetricsViewTimeSeries returns time series for the measures in the metrics view.
It's a convenience API for querying a metrics view.
 */
export const queryServiceMetricsViewTimeSeries = (
  instanceId: string,
  metricsViewName: string,
  queryServiceMetricsViewTimeSeriesBody: QueryServiceMetricsViewTimeSeriesBody,
  signal?: AbortSignal,
) => {
  return httpClient<V1MetricsViewTimeSeriesResponse>({
    url: `/v1/instances/${instanceId}/queries/metrics-views/${metricsViewName}/timeseries`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: queryServiceMetricsViewTimeSeriesBody,
    signal,
  });
};

export const getQueryServiceMetricsViewTimeSeriesQueryKey = (
  instanceId: string,
  metricsViewName: string,
  queryServiceMetricsViewTimeSeriesBody: QueryServiceMetricsViewTimeSeriesBody,
) => [
  `/v1/instances/${instanceId}/queries/metrics-views/${metricsViewName}/timeseries`,
  queryServiceMetricsViewTimeSeriesBody,
];

export type QueryServiceMetricsViewTimeSeriesQueryResult = NonNullable<
  Awaited<ReturnType<typeof queryServiceMetricsViewTimeSeries>>
>;
export type QueryServiceMetricsViewTimeSeriesQueryError = ErrorType<RpcStatus>;

export const createQueryServiceMetricsViewTimeSeries = <
  TData = Awaited<ReturnType<typeof queryServiceMetricsViewTimeSeries>>,
  TError = ErrorType<RpcStatus>,
>(
  instanceId: string,
  metricsViewName: string,
  queryServiceMetricsViewTimeSeriesBody: QueryServiceMetricsViewTimeSeriesBody,
  options?: {
    query?: CreateQueryOptions<
      Awaited<ReturnType<typeof queryServiceMetricsViewTimeSeries>>,
      TError,
      TData
    >;
  },
): CreateQueryResult<TData, TError> & {
  queryKey: QueryKey;
} => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getQueryServiceMetricsViewTimeSeriesQueryKey(
      instanceId,
      metricsViewName,
      queryServiceMetricsViewTimeSeriesBody,
    );

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof queryServiceMetricsViewTimeSeries>>
  > = ({ signal }) =>
    queryServiceMetricsViewTimeSeries(
      instanceId,
      metricsViewName,
      queryServiceMetricsViewTimeSeriesBody,
      signal,
    );

  const query = createQuery<
    Awaited<ReturnType<typeof queryServiceMetricsViewTimeSeries>>,
    TError,
    TData
  >({
    queryKey,
    queryFn,
    enabled: !!(instanceId && metricsViewName),
    ...queryOptions,
  }) as CreateQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryKey;

  return query;
};

/**
 * @summary Deprecated - use MetricsViewComparison instead.
MetricsViewToplist returns the top dimension values of a metrics view sorted by one or more measures.
It's a convenience API for querying a metrics view.
 */
export const queryServiceMetricsViewToplist = (
  instanceId: string,
  metricsViewName: string,
  queryServiceMetricsViewToplistBody: QueryServiceMetricsViewToplistBody,
  signal?: AbortSignal,
) => {
  return httpClient<V1MetricsViewToplistResponse>({
    url: `/v1/instances/${instanceId}/queries/metrics-views/${metricsViewName}/toplist`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: queryServiceMetricsViewToplistBody,
    signal,
  });
};

export const getQueryServiceMetricsViewToplistQueryKey = (
  instanceId: string,
  metricsViewName: string,
  queryServiceMetricsViewToplistBody: QueryServiceMetricsViewToplistBody,
) => [
  `/v1/instances/${instanceId}/queries/metrics-views/${metricsViewName}/toplist`,
  queryServiceMetricsViewToplistBody,
];

export type QueryServiceMetricsViewToplistQueryResult = NonNullable<
  Awaited<ReturnType<typeof queryServiceMetricsViewToplist>>
>;
export type QueryServiceMetricsViewToplistQueryError = ErrorType<RpcStatus>;

export const createQueryServiceMetricsViewToplist = <
  TData = Awaited<ReturnType<typeof queryServiceMetricsViewToplist>>,
  TError = ErrorType<RpcStatus>,
>(
  instanceId: string,
  metricsViewName: string,
  queryServiceMetricsViewToplistBody: QueryServiceMetricsViewToplistBody,
  options?: {
    query?: CreateQueryOptions<
      Awaited<ReturnType<typeof queryServiceMetricsViewToplist>>,
      TError,
      TData
    >;
  },
): CreateQueryResult<TData, TError> & {
  queryKey: QueryKey;
} => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getQueryServiceMetricsViewToplistQueryKey(
      instanceId,
      metricsViewName,
      queryServiceMetricsViewToplistBody,
    );

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof queryServiceMetricsViewToplist>>
  > = ({ signal }) =>
    queryServiceMetricsViewToplist(
      instanceId,
      metricsViewName,
      queryServiceMetricsViewToplistBody,
      signal,
    );

  const query = createQuery<
    Awaited<ReturnType<typeof queryServiceMetricsViewToplist>>,
    TError,
    TData
  >({
    queryKey,
    queryFn,
    enabled: !!(instanceId && metricsViewName),
    ...queryOptions,
  }) as CreateQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryKey;

  return query;
};

/**
 * @summary MetricsViewTotals returns totals over a time period for the measures in a metrics view.
It's a convenience API for querying a metrics view.
 */
export const queryServiceMetricsViewTotals = (
  instanceId: string,
  metricsViewName: string,
  queryServiceMetricsViewTotalsBody: QueryServiceMetricsViewTotalsBody,
  signal?: AbortSignal,
) => {
  return httpClient<V1MetricsViewTotalsResponse>({
    url: `/v1/instances/${instanceId}/queries/metrics-views/${metricsViewName}/totals`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: queryServiceMetricsViewTotalsBody,
    signal,
  });
};

export const getQueryServiceMetricsViewTotalsQueryKey = (
  instanceId: string,
  metricsViewName: string,
  queryServiceMetricsViewTotalsBody: QueryServiceMetricsViewTotalsBody,
) => [
  `/v1/instances/${instanceId}/queries/metrics-views/${metricsViewName}/totals`,
  queryServiceMetricsViewTotalsBody,
];

export type QueryServiceMetricsViewTotalsQueryResult = NonNullable<
  Awaited<ReturnType<typeof queryServiceMetricsViewTotals>>
>;
export type QueryServiceMetricsViewTotalsQueryError = ErrorType<RpcStatus>;

export const createQueryServiceMetricsViewTotals = <
  TData = Awaited<ReturnType<typeof queryServiceMetricsViewTotals>>,
  TError = ErrorType<RpcStatus>,
>(
  instanceId: string,
  metricsViewName: string,
  queryServiceMetricsViewTotalsBody: QueryServiceMetricsViewTotalsBody,
  options?: {
    query?: CreateQueryOptions<
      Awaited<ReturnType<typeof queryServiceMetricsViewTotals>>,
      TError,
      TData
    >;
  },
): CreateQueryResult<TData, TError> & {
  queryKey: QueryKey;
} => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getQueryServiceMetricsViewTotalsQueryKey(
      instanceId,
      metricsViewName,
      queryServiceMetricsViewTotalsBody,
    );

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof queryServiceMetricsViewTotals>>
  > = ({ signal }) =>
    queryServiceMetricsViewTotals(
      instanceId,
      metricsViewName,
      queryServiceMetricsViewTotalsBody,
      signal,
    );

  const query = createQuery<
    Awaited<ReturnType<typeof queryServiceMetricsViewTotals>>,
    TError,
    TData
  >({
    queryKey,
    queryFn,
    enabled: !!(instanceId && metricsViewName),
    ...queryOptions,
  }) as CreateQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryKey;

  return query;
};

/**
 * @summary Get the number of nulls in a column
 */
export const queryServiceColumnNullCount = (
  instanceId: string,
  tableName: string,
  params?: QueryServiceColumnNullCountParams,
  signal?: AbortSignal,
) => {
  return httpClient<V1ColumnNullCountResponse>({
    url: `/v1/instances/${instanceId}/queries/null-count/tables/${tableName}`,
    method: "get",
    params,
    signal,
  });
};

export const getQueryServiceColumnNullCountQueryKey = (
  instanceId: string,
  tableName: string,
  params?: QueryServiceColumnNullCountParams,
) => [
  `/v1/instances/${instanceId}/queries/null-count/tables/${tableName}`,
  ...(params ? [params] : []),
];

export type QueryServiceColumnNullCountQueryResult = NonNullable<
  Awaited<ReturnType<typeof queryServiceColumnNullCount>>
>;
export type QueryServiceColumnNullCountQueryError = ErrorType<RpcStatus>;

export const createQueryServiceColumnNullCount = <
  TData = Awaited<ReturnType<typeof queryServiceColumnNullCount>>,
  TError = ErrorType<RpcStatus>,
>(
  instanceId: string,
  tableName: string,
  params?: QueryServiceColumnNullCountParams,
  options?: {
    query?: CreateQueryOptions<
      Awaited<ReturnType<typeof queryServiceColumnNullCount>>,
      TError,
      TData
    >;
  },
): CreateQueryResult<TData, TError> & {
  queryKey: QueryKey;
} => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getQueryServiceColumnNullCountQueryKey(instanceId, tableName, params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof queryServiceColumnNullCount>>
  > = ({ signal }) =>
    queryServiceColumnNullCount(instanceId, tableName, params, signal);

  const query = createQuery<
    Awaited<ReturnType<typeof queryServiceColumnNullCount>>,
    TError,
    TData
  >({
    queryKey,
    queryFn,
    enabled: !!(instanceId && tableName),
    ...queryOptions,
  }) as CreateQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryKey;

  return query;
};

/**
 * @summary Get the histogram for values in a column
 */
export const queryServiceColumnNumericHistogram = (
  instanceId: string,
  tableName: string,
  params?: QueryServiceColumnNumericHistogramParams,
  signal?: AbortSignal,
) => {
  return httpClient<V1ColumnNumericHistogramResponse>({
    url: `/v1/instances/${instanceId}/queries/numeric-histogram/tables/${tableName}`,
    method: "get",
    params,
    signal,
  });
};

export const getQueryServiceColumnNumericHistogramQueryKey = (
  instanceId: string,
  tableName: string,
  params?: QueryServiceColumnNumericHistogramParams,
) => [
  `/v1/instances/${instanceId}/queries/numeric-histogram/tables/${tableName}`,
  ...(params ? [params] : []),
];

export type QueryServiceColumnNumericHistogramQueryResult = NonNullable<
  Awaited<ReturnType<typeof queryServiceColumnNumericHistogram>>
>;
export type QueryServiceColumnNumericHistogramQueryError = ErrorType<RpcStatus>;

export const createQueryServiceColumnNumericHistogram = <
  TData = Awaited<ReturnType<typeof queryServiceColumnNumericHistogram>>,
  TError = ErrorType<RpcStatus>,
>(
  instanceId: string,
  tableName: string,
  params?: QueryServiceColumnNumericHistogramParams,
  options?: {
    query?: CreateQueryOptions<
      Awaited<ReturnType<typeof queryServiceColumnNumericHistogram>>,
      TError,
      TData
    >;
  },
): CreateQueryResult<TData, TError> & {
  queryKey: QueryKey;
} => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getQueryServiceColumnNumericHistogramQueryKey(
      instanceId,
      tableName,
      params,
    );

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof queryServiceColumnNumericHistogram>>
  > = ({ signal }) =>
    queryServiceColumnNumericHistogram(instanceId, tableName, params, signal);

  const query = createQuery<
    Awaited<ReturnType<typeof queryServiceColumnNumericHistogram>>,
    TError,
    TData
  >({
    queryKey,
    queryFn,
    enabled: !!(instanceId && tableName),
    ...queryOptions,
  }) as CreateQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryKey;

  return query;
};

/**
 * @summary ColumnRollupInterval returns the minimum time granularity (as well as the time range) for a specified timestamp column
 */
export const queryServiceColumnRollupInterval = (
  instanceId: string,
  tableName: string,
  queryServiceColumnRollupIntervalBody: QueryServiceColumnRollupIntervalBody,
  signal?: AbortSignal,
) => {
  return httpClient<V1ColumnRollupIntervalResponse>({
    url: `/v1/instances/${instanceId}/queries/rollup-interval/tables/${tableName}`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: queryServiceColumnRollupIntervalBody,
    signal,
  });
};

export const getQueryServiceColumnRollupIntervalQueryKey = (
  instanceId: string,
  tableName: string,
  queryServiceColumnRollupIntervalBody: QueryServiceColumnRollupIntervalBody,
) => [
  `/v1/instances/${instanceId}/queries/rollup-interval/tables/${tableName}`,
  queryServiceColumnRollupIntervalBody,
];

export type QueryServiceColumnRollupIntervalQueryResult = NonNullable<
  Awaited<ReturnType<typeof queryServiceColumnRollupInterval>>
>;
export type QueryServiceColumnRollupIntervalQueryError = ErrorType<RpcStatus>;

export const createQueryServiceColumnRollupInterval = <
  TData = Awaited<ReturnType<typeof queryServiceColumnRollupInterval>>,
  TError = ErrorType<RpcStatus>,
>(
  instanceId: string,
  tableName: string,
  queryServiceColumnRollupIntervalBody: QueryServiceColumnRollupIntervalBody,
  options?: {
    query?: CreateQueryOptions<
      Awaited<ReturnType<typeof queryServiceColumnRollupInterval>>,
      TError,
      TData
    >;
  },
): CreateQueryResult<TData, TError> & {
  queryKey: QueryKey;
} => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getQueryServiceColumnRollupIntervalQueryKey(
      instanceId,
      tableName,
      queryServiceColumnRollupIntervalBody,
    );

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof queryServiceColumnRollupInterval>>
  > = ({ signal }) =>
    queryServiceColumnRollupInterval(
      instanceId,
      tableName,
      queryServiceColumnRollupIntervalBody,
      signal,
    );

  const query = createQuery<
    Awaited<ReturnType<typeof queryServiceColumnRollupInterval>>,
    TError,
    TData
  >({
    queryKey,
    queryFn,
    enabled: !!(instanceId && tableName),
    ...queryOptions,
  }) as CreateQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryKey;

  return query;
};

/**
 * @summary TableRows returns table rows
 */
export const queryServiceTableRows = (
  instanceId: string,
  tableName: string,
  params?: QueryServiceTableRowsParams,
  signal?: AbortSignal,
) => {
  return httpClient<V1TableRowsResponse>({
    url: `/v1/instances/${instanceId}/queries/rows/tables/${tableName}`,
    method: "get",
    params,
    signal,
  });
};

export const getQueryServiceTableRowsQueryKey = (
  instanceId: string,
  tableName: string,
  params?: QueryServiceTableRowsParams,
) => [
  `/v1/instances/${instanceId}/queries/rows/tables/${tableName}`,
  ...(params ? [params] : []),
];

export type QueryServiceTableRowsQueryResult = NonNullable<
  Awaited<ReturnType<typeof queryServiceTableRows>>
>;
export type QueryServiceTableRowsQueryError = ErrorType<RpcStatus>;

export const createQueryServiceTableRows = <
  TData = Awaited<ReturnType<typeof queryServiceTableRows>>,
  TError = ErrorType<RpcStatus>,
>(
  instanceId: string,
  tableName: string,
  params?: QueryServiceTableRowsParams,
  options?: {
    query?: CreateQueryOptions<
      Awaited<ReturnType<typeof queryServiceTableRows>>,
      TError,
      TData
    >;
  },
): CreateQueryResult<TData, TError> & {
  queryKey: QueryKey;
} => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getQueryServiceTableRowsQueryKey(instanceId, tableName, params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof queryServiceTableRows>>
  > = ({ signal }) =>
    queryServiceTableRows(instanceId, tableName, params, signal);

  const query = createQuery<
    Awaited<ReturnType<typeof queryServiceTableRows>>,
    TError,
    TData
  >({
    queryKey,
    queryFn,
    enabled: !!(instanceId && tableName),
    ...queryOptions,
  }) as CreateQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryKey;

  return query;
};

/**
 * @summary Get outliers for a numeric column
 */
export const queryServiceColumnRugHistogram = (
  instanceId: string,
  tableName: string,
  params?: QueryServiceColumnRugHistogramParams,
  signal?: AbortSignal,
) => {
  return httpClient<V1ColumnRugHistogramResponse>({
    url: `/v1/instances/${instanceId}/queries/rug-histogram/tables/${tableName}`,
    method: "get",
    params,
    signal,
  });
};

export const getQueryServiceColumnRugHistogramQueryKey = (
  instanceId: string,
  tableName: string,
  params?: QueryServiceColumnRugHistogramParams,
) => [
  `/v1/instances/${instanceId}/queries/rug-histogram/tables/${tableName}`,
  ...(params ? [params] : []),
];

export type QueryServiceColumnRugHistogramQueryResult = NonNullable<
  Awaited<ReturnType<typeof queryServiceColumnRugHistogram>>
>;
export type QueryServiceColumnRugHistogramQueryError = ErrorType<RpcStatus>;

export const createQueryServiceColumnRugHistogram = <
  TData = Awaited<ReturnType<typeof queryServiceColumnRugHistogram>>,
  TError = ErrorType<RpcStatus>,
>(
  instanceId: string,
  tableName: string,
  params?: QueryServiceColumnRugHistogramParams,
  options?: {
    query?: CreateQueryOptions<
      Awaited<ReturnType<typeof queryServiceColumnRugHistogram>>,
      TError,
      TData
    >;
  },
): CreateQueryResult<TData, TError> & {
  queryKey: QueryKey;
} => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getQueryServiceColumnRugHistogramQueryKey(instanceId, tableName, params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof queryServiceColumnRugHistogram>>
  > = ({ signal }) =>
    queryServiceColumnRugHistogram(instanceId, tableName, params, signal);

  const query = createQuery<
    Awaited<ReturnType<typeof queryServiceColumnRugHistogram>>,
    TError,
    TData
  >({
    queryKey,
    queryFn,
    enabled: !!(instanceId && tableName),
    ...queryOptions,
  }) as CreateQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryKey;

  return query;
};

/**
 * @summary Estimates the smallest time grain present in the column
 */
export const queryServiceColumnTimeGrain = (
  instanceId: string,
  tableName: string,
  params?: QueryServiceColumnTimeGrainParams,
  signal?: AbortSignal,
) => {
  return httpClient<V1ColumnTimeGrainResponse>({
    url: `/v1/instances/${instanceId}/queries/smallest-time-grain/tables/${tableName}`,
    method: "get",
    params,
    signal,
  });
};

export const getQueryServiceColumnTimeGrainQueryKey = (
  instanceId: string,
  tableName: string,
  params?: QueryServiceColumnTimeGrainParams,
) => [
  `/v1/instances/${instanceId}/queries/smallest-time-grain/tables/${tableName}`,
  ...(params ? [params] : []),
];

export type QueryServiceColumnTimeGrainQueryResult = NonNullable<
  Awaited<ReturnType<typeof queryServiceColumnTimeGrain>>
>;
export type QueryServiceColumnTimeGrainQueryError = ErrorType<RpcStatus>;

export const createQueryServiceColumnTimeGrain = <
  TData = Awaited<ReturnType<typeof queryServiceColumnTimeGrain>>,
  TError = ErrorType<RpcStatus>,
>(
  instanceId: string,
  tableName: string,
  params?: QueryServiceColumnTimeGrainParams,
  options?: {
    query?: CreateQueryOptions<
      Awaited<ReturnType<typeof queryServiceColumnTimeGrain>>,
      TError,
      TData
    >;
  },
): CreateQueryResult<TData, TError> & {
  queryKey: QueryKey;
} => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getQueryServiceColumnTimeGrainQueryKey(instanceId, tableName, params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof queryServiceColumnTimeGrain>>
  > = ({ signal }) =>
    queryServiceColumnTimeGrain(instanceId, tableName, params, signal);

  const query = createQuery<
    Awaited<ReturnType<typeof queryServiceColumnTimeGrain>>,
    TError,
    TData
  >({
    queryKey,
    queryFn,
    enabled: !!(instanceId && tableName),
    ...queryOptions,
  }) as CreateQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryKey;

  return query;
};

/**
 * @summary TableCardinality returns row count
 */
export const queryServiceTableCardinality = (
  instanceId: string,
  tableName: string,
  params?: QueryServiceTableCardinalityParams,
  signal?: AbortSignal,
) => {
  return httpClient<V1TableCardinalityResponse>({
    url: `/v1/instances/${instanceId}/queries/table-cardinality/tables/${tableName}`,
    method: "get",
    params,
    signal,
  });
};

export const getQueryServiceTableCardinalityQueryKey = (
  instanceId: string,
  tableName: string,
  params?: QueryServiceTableCardinalityParams,
) => [
  `/v1/instances/${instanceId}/queries/table-cardinality/tables/${tableName}`,
  ...(params ? [params] : []),
];

export type QueryServiceTableCardinalityQueryResult = NonNullable<
  Awaited<ReturnType<typeof queryServiceTableCardinality>>
>;
export type QueryServiceTableCardinalityQueryError = ErrorType<RpcStatus>;

export const createQueryServiceTableCardinality = <
  TData = Awaited<ReturnType<typeof queryServiceTableCardinality>>,
  TError = ErrorType<RpcStatus>,
>(
  instanceId: string,
  tableName: string,
  params?: QueryServiceTableCardinalityParams,
  options?: {
    query?: CreateQueryOptions<
      Awaited<ReturnType<typeof queryServiceTableCardinality>>,
      TError,
      TData
    >;
  },
): CreateQueryResult<TData, TError> & {
  queryKey: QueryKey;
} => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getQueryServiceTableCardinalityQueryKey(instanceId, tableName, params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof queryServiceTableCardinality>>
  > = ({ signal }) =>
    queryServiceTableCardinality(instanceId, tableName, params, signal);

  const query = createQuery<
    Awaited<ReturnType<typeof queryServiceTableCardinality>>,
    TError,
    TData
  >({
    queryKey,
    queryFn,
    enabled: !!(instanceId && tableName),
    ...queryOptions,
  }) as CreateQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryKey;

  return query;
};

/**
 * @summary Get the time range summaries (min, max) for a column
 */
export const queryServiceColumnTimeRange = (
  instanceId: string,
  tableName: string,
  params?: QueryServiceColumnTimeRangeParams,
  signal?: AbortSignal,
) => {
  return httpClient<V1ColumnTimeRangeResponse>({
    url: `/v1/instances/${instanceId}/queries/time-range-summary/tables/${tableName}`,
    method: "get",
    params,
    signal,
  });
};

export const getQueryServiceColumnTimeRangeQueryKey = (
  instanceId: string,
  tableName: string,
  params?: QueryServiceColumnTimeRangeParams,
) => [
  `/v1/instances/${instanceId}/queries/time-range-summary/tables/${tableName}`,
  ...(params ? [params] : []),
];

export type QueryServiceColumnTimeRangeQueryResult = NonNullable<
  Awaited<ReturnType<typeof queryServiceColumnTimeRange>>
>;
export type QueryServiceColumnTimeRangeQueryError = ErrorType<RpcStatus>;

export const createQueryServiceColumnTimeRange = <
  TData = Awaited<ReturnType<typeof queryServiceColumnTimeRange>>,
  TError = ErrorType<RpcStatus>,
>(
  instanceId: string,
  tableName: string,
  params?: QueryServiceColumnTimeRangeParams,
  options?: {
    query?: CreateQueryOptions<
      Awaited<ReturnType<typeof queryServiceColumnTimeRange>>,
      TError,
      TData
    >;
  },
): CreateQueryResult<TData, TError> & {
  queryKey: QueryKey;
} => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getQueryServiceColumnTimeRangeQueryKey(instanceId, tableName, params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof queryServiceColumnTimeRange>>
  > = ({ signal }) =>
    queryServiceColumnTimeRange(instanceId, tableName, params, signal);

  const query = createQuery<
    Awaited<ReturnType<typeof queryServiceColumnTimeRange>>,
    TError,
    TData
  >({
    queryKey,
    queryFn,
    enabled: !!(instanceId && tableName),
    ...queryOptions,
  }) as CreateQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryKey;

  return query;
};

/**
 * @summary Generate time series for the given measures (aggregation expressions) along with the sparkline timeseries
 */
export const queryServiceColumnTimeSeries = (
  instanceId: string,
  tableName: string,
  queryServiceColumnTimeSeriesBody: QueryServiceColumnTimeSeriesBody,
  signal?: AbortSignal,
) => {
  return httpClient<V1ColumnTimeSeriesResponse>({
    url: `/v1/instances/${instanceId}/queries/timeseries/tables/${tableName}`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: queryServiceColumnTimeSeriesBody,
    signal,
  });
};

export const getQueryServiceColumnTimeSeriesQueryKey = (
  instanceId: string,
  tableName: string,
  queryServiceColumnTimeSeriesBody: QueryServiceColumnTimeSeriesBody,
) => [
  `/v1/instances/${instanceId}/queries/timeseries/tables/${tableName}`,
  queryServiceColumnTimeSeriesBody,
];

export type QueryServiceColumnTimeSeriesQueryResult = NonNullable<
  Awaited<ReturnType<typeof queryServiceColumnTimeSeries>>
>;
export type QueryServiceColumnTimeSeriesQueryError = ErrorType<RpcStatus>;

export const createQueryServiceColumnTimeSeries = <
  TData = Awaited<ReturnType<typeof queryServiceColumnTimeSeries>>,
  TError = ErrorType<RpcStatus>,
>(
  instanceId: string,
  tableName: string,
  queryServiceColumnTimeSeriesBody: QueryServiceColumnTimeSeriesBody,
  options?: {
    query?: CreateQueryOptions<
      Awaited<ReturnType<typeof queryServiceColumnTimeSeries>>,
      TError,
      TData
    >;
  },
): CreateQueryResult<TData, TError> & {
  queryKey: QueryKey;
} => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getQueryServiceColumnTimeSeriesQueryKey(
      instanceId,
      tableName,
      queryServiceColumnTimeSeriesBody,
    );

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof queryServiceColumnTimeSeries>>
  > = ({ signal }) =>
    queryServiceColumnTimeSeries(
      instanceId,
      tableName,
      queryServiceColumnTimeSeriesBody,
      signal,
    );

  const query = createQuery<
    Awaited<ReturnType<typeof queryServiceColumnTimeSeries>>,
    TError,
    TData
  >({
    queryKey,
    queryFn,
    enabled: !!(instanceId && tableName),
    ...queryOptions,
  }) as CreateQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryKey;

  return query;
};

/**
 * @summary Get TopK elements from a table for a column given an agg function
agg function and k are optional, defaults are count(*) and 50 respectively
 */
export const queryServiceColumnTopK = (
  instanceId: string,
  tableName: string,
  queryServiceColumnTopKBody: QueryServiceColumnTopKBody,
  signal?: AbortSignal,
) => {
  return httpClient<V1ColumnTopKResponse>({
    url: `/v1/instances/${instanceId}/queries/topk/tables/${tableName}`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: queryServiceColumnTopKBody,
    signal,
  });
};

export const getQueryServiceColumnTopKQueryKey = (
  instanceId: string,
  tableName: string,
  queryServiceColumnTopKBody: QueryServiceColumnTopKBody,
) => [
  `/v1/instances/${instanceId}/queries/topk/tables/${tableName}`,
  queryServiceColumnTopKBody,
];

export type QueryServiceColumnTopKQueryResult = NonNullable<
  Awaited<ReturnType<typeof queryServiceColumnTopK>>
>;
export type QueryServiceColumnTopKQueryError = ErrorType<RpcStatus>;

export const createQueryServiceColumnTopK = <
  TData = Awaited<ReturnType<typeof queryServiceColumnTopK>>,
  TError = ErrorType<RpcStatus>,
>(
  instanceId: string,
  tableName: string,
  queryServiceColumnTopKBody: QueryServiceColumnTopKBody,
  options?: {
    query?: CreateQueryOptions<
      Awaited<ReturnType<typeof queryServiceColumnTopK>>,
      TError,
      TData
    >;
  },
): CreateQueryResult<TData, TError> & {
  queryKey: QueryKey;
} => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getQueryServiceColumnTopKQueryKey(
      instanceId,
      tableName,
      queryServiceColumnTopKBody,
    );

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof queryServiceColumnTopK>>
  > = ({ signal }) =>
    queryServiceColumnTopK(
      instanceId,
      tableName,
      queryServiceColumnTopKBody,
      signal,
    );

  const query = createQuery<
    Awaited<ReturnType<typeof queryServiceColumnTopK>>,
    TError,
    TData
  >({
    queryKey,
    queryFn,
    enabled: !!(instanceId && tableName),
    ...queryOptions,
  }) as CreateQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryKey;

  return query;
};

/**
 * @summary Query runs a SQL query against the instance's OLAP datastore.
 */
export const queryServiceQuery = (
  instanceId: string,
  queryServiceQueryBody: QueryServiceQueryBody,
) => {
  return httpClient<V1QueryResponse>({
    url: `/v1/instances/${instanceId}/query`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: queryServiceQueryBody,
  });
};

export type QueryServiceQueryMutationResult = NonNullable<
  Awaited<ReturnType<typeof queryServiceQuery>>
>;
export type QueryServiceQueryMutationBody = QueryServiceQueryBody;
export type QueryServiceQueryMutationError = ErrorType<RpcStatus>;

export const createQueryServiceQuery = <
  TError = ErrorType<RpcStatus>,
  TContext = unknown,
>(options?: {
  mutation?: CreateMutationOptions<
    Awaited<ReturnType<typeof queryServiceQuery>>,
    TError,
    {
      instanceId: string;
      data: QueryServiceQueryBody;
    },
    TContext
  >;
}) => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof queryServiceQuery>>,
    {
      instanceId: string;
      data: QueryServiceQueryBody;
    }
  > = (props) => {
    const { instanceId, data } = props ?? {};

    return queryServiceQuery(instanceId, data);
  };

  return createMutation<
    Awaited<ReturnType<typeof queryServiceQuery>>,
    TError,
    {
      instanceId: string;
      data: QueryServiceQueryBody;
    },
    TContext
  >(mutationFn, mutationOptions);
};
/**
 * @summary Batch request with different queries
 */
export const queryServiceQueryBatch = (
  instanceId: string,
  queryServiceQueryBatchBody: QueryServiceQueryBatchBody,
) => {
  return httpClient<QueryServiceQueryBatch200>({
    url: `/v1/instances/${instanceId}/query/batch`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: queryServiceQueryBatchBody,
  });
};

export type QueryServiceQueryBatchMutationResult = NonNullable<
  Awaited<ReturnType<typeof queryServiceQueryBatch>>
>;
export type QueryServiceQueryBatchMutationBody = QueryServiceQueryBatchBody;
export type QueryServiceQueryBatchMutationError = ErrorType<RpcStatus>;

export const createQueryServiceQueryBatch = <
  TError = ErrorType<RpcStatus>,
  TContext = unknown,
>(options?: {
  mutation?: CreateMutationOptions<
    Awaited<ReturnType<typeof queryServiceQueryBatch>>,
    TError,
    {
      instanceId: string;
      data: QueryServiceQueryBatchBody;
    },
    TContext
  >;
}) => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof queryServiceQueryBatch>>,
    {
      instanceId: string;
      data: QueryServiceQueryBatchBody;
    }
  > = (props) => {
    const { instanceId, data } = props ?? {};

    return queryServiceQueryBatch(instanceId, data);
  };

  return createMutation<
    Awaited<ReturnType<typeof queryServiceQueryBatch>>,
    TError,
    {
      instanceId: string;
      data: QueryServiceQueryBatchBody;
    },
    TContext
  >(mutationFn, mutationOptions);
};
/**
 * @summary ExportReport builds a URL to download the results of a query as a file.
 */
export const queryServiceExportReport = (
  instanceId: string,
  report: string,
  queryServiceExportReportBody: QueryServiceExportReportBody,
) => {
  return httpClient<V1ExportReportResponse>({
    url: `/v1/instances/${instanceId}/reports/${report}/export`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: queryServiceExportReportBody,
  });
};

export type QueryServiceExportReportMutationResult = NonNullable<
  Awaited<ReturnType<typeof queryServiceExportReport>>
>;
export type QueryServiceExportReportMutationBody = QueryServiceExportReportBody;
export type QueryServiceExportReportMutationError = ErrorType<RpcStatus>;

export const createQueryServiceExportReport = <
  TError = ErrorType<RpcStatus>,
  TContext = unknown,
>(options?: {
  mutation?: CreateMutationOptions<
    Awaited<ReturnType<typeof queryServiceExportReport>>,
    TError,
    {
      instanceId: string;
      report: string;
      data: QueryServiceExportReportBody;
    },
    TContext
  >;
}) => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof queryServiceExportReport>>,
    {
      instanceId: string;
      report: string;
      data: QueryServiceExportReportBody;
    }
  > = (props) => {
    const { instanceId, report, data } = props ?? {};

    return queryServiceExportReport(instanceId, report, data);
  };

  return createMutation<
    Awaited<ReturnType<typeof queryServiceExportReport>>,
    TError,
    {
      instanceId: string;
      report: string;
      data: QueryServiceExportReportBody;
    },
    TContext
  >(mutationFn, mutationOptions);
};


/**
 * Generated by orval v7.9.0 üç∫
 * Do not edit manually.
 * rill/runtime/v1/schema.proto
 * OpenAPI spec version: version not set
 */
import { createMutation, createQuery } from "@tanstack/svelte-query";
import type {
  CreateMutationOptions,
  CreateMutationResult,
  CreateQueryOptions,
  CreateQueryResult,
  DataTag,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
} from "@tanstack/svelte-query";

import type {
  QueryServiceColumnCardinalityParams,
  QueryServiceColumnDescriptiveStatisticsParams,
  QueryServiceColumnNullCountParams,
  QueryServiceColumnNumericHistogramParams,
  QueryServiceColumnRollupIntervalBody,
  QueryServiceColumnRugHistogramParams,
  QueryServiceColumnTimeGrainParams,
  QueryServiceColumnTimeRangeParams,
  QueryServiceColumnTimeSeriesBody,
  QueryServiceColumnTopKBody,
  QueryServiceExportBody,
  QueryServiceExportReportBody,
  QueryServiceMetricsViewAggregationBody,
  QueryServiceMetricsViewAnnotationsBody,
  QueryServiceMetricsViewComparisonBody,
  QueryServiceMetricsViewRowsBody,
  QueryServiceMetricsViewSchemaParams,
  QueryServiceMetricsViewSearchBody,
  QueryServiceMetricsViewTimeRangeBody,
  QueryServiceMetricsViewTimeRangesBody,
  QueryServiceMetricsViewTimeSeriesBody,
  QueryServiceMetricsViewToplistBody,
  QueryServiceMetricsViewTotalsBody,
  QueryServiceQueryBatch200,
  QueryServiceQueryBatchBody,
  QueryServiceQueryBody,
  QueryServiceResolveCanvasBody,
  QueryServiceResolveComponentBody,
  QueryServiceTableCardinalityParams,
  QueryServiceTableColumnsParams,
  QueryServiceTableRowsParams,
  RpcStatus,
  V1ColumnCardinalityResponse,
  V1ColumnDescriptiveStatisticsResponse,
  V1ColumnNullCountResponse,
  V1ColumnNumericHistogramResponse,
  V1ColumnRollupIntervalResponse,
  V1ColumnRugHistogramResponse,
  V1ColumnTimeGrainResponse,
  V1ColumnTimeRangeResponse,
  V1ColumnTimeSeriesResponse,
  V1ColumnTopKResponse,
  V1ExportReportResponse,
  V1ExportResponse,
  V1MetricsViewAggregationResponse,
  V1MetricsViewAnnotationsResponse,
  V1MetricsViewComparisonResponse,
  V1MetricsViewRowsResponse,
  V1MetricsViewSchemaResponse,
  V1MetricsViewSearchResponse,
  V1MetricsViewTimeRangeResponse,
  V1MetricsViewTimeRangesResponse,
  V1MetricsViewTimeSeriesResponse,
  V1MetricsViewToplistResponse,
  V1MetricsViewTotalsResponse,
  V1QueryResponse,
  V1ResolveCanvasResponse,
  V1ResolveComponentResponse,
  V1TableCardinalityResponse,
  V1TableColumnsResponse,
  V1TableRowsResponse,
} from "../index.schemas";

import { httpClient } from "../../http-client";
import type { ErrorType } from "../../http-client";

type AwaitedInput<T> = PromiseLike<T> | T;

type Awaited<O> = O extends AwaitedInput<infer T> ? T : never;

/**
 * @summary ResolveCanvas is a convenience API that returns a canvas and all its referenced components and metrics views.
 */
export const queryServiceResolveCanvas = (
  instanceId: string,
  canvas: string,
  queryServiceResolveCanvasBody: QueryServiceResolveCanvasBody,
  signal?: AbortSignal,
) => {
  return httpClient<V1ResolveCanvasResponse>({
    url: `/v1/instances/${instanceId}/queries/canvases/${canvas}/resolve`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: queryServiceResolveCanvasBody,
    signal,
  });
};

export const getQueryServiceResolveCanvasQueryKey = (
  instanceId: string,
  canvas: string,
  queryServiceResolveCanvasBody: QueryServiceResolveCanvasBody,
) => {
  return [
    `/v1/instances/${instanceId}/queries/canvases/${canvas}/resolve`,
    queryServiceResolveCanvasBody,
  ] as const;
};

export const getQueryServiceResolveCanvasQueryOptions = <
  TData = Awaited<ReturnType<typeof queryServiceResolveCanvas>>,
  TError = ErrorType<RpcStatus>,
>(
  instanceId: string,
  canvas: string,
  queryServiceResolveCanvasBody: QueryServiceResolveCanvasBody,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof queryServiceResolveCanvas>>,
        TError,
        TData
      >
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getQueryServiceResolveCanvasQueryKey(
      instanceId,
      canvas,
      queryServiceResolveCanvasBody,
    );

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof queryServiceResolveCanvas>>
  > = ({ signal }) =>
    queryServiceResolveCanvas(
      instanceId,
      canvas,
      queryServiceResolveCanvasBody,
      signal,
    );

  return {
    queryKey,
    queryFn,
    enabled: !!(instanceId && canvas),
    ...queryOptions,
  } as CreateQueryOptions<
    Awaited<ReturnType<typeof queryServiceResolveCanvas>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type QueryServiceResolveCanvasQueryResult = NonNullable<
  Awaited<ReturnType<typeof queryServiceResolveCanvas>>
>;
export type QueryServiceResolveCanvasQueryError = ErrorType<RpcStatus>;

/**
 * @summary ResolveCanvas is a convenience API that returns a canvas and all its referenced components and metrics views.
 */

export function createQueryServiceResolveCanvas<
  TData = Awaited<ReturnType<typeof queryServiceResolveCanvas>>,
  TError = ErrorType<RpcStatus>,
>(
  instanceId: string,
  canvas: string,
  queryServiceResolveCanvasBody: QueryServiceResolveCanvasBody,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof queryServiceResolveCanvas>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): CreateQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getQueryServiceResolveCanvasQueryOptions(
    instanceId,
    canvas,
    queryServiceResolveCanvasBody,
    options,
  );

  const query = createQuery(queryOptions, queryClient) as CreateQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Get cardinality for a column
 */
export const queryServiceColumnCardinality = (
  instanceId: string,
  tableName: string,
  params?: QueryServiceColumnCardinalityParams,
  signal?: AbortSignal,
) => {
  return httpClient<V1ColumnCardinalityResponse>({
    url: `/v1/instances/${instanceId}/queries/column-cardinality/tables/${tableName}`,
    method: "GET",
    params,
    signal,
  });
};

export const getQueryServiceColumnCardinalityQueryKey = (
  instanceId: string,
  tableName: string,
  params?: QueryServiceColumnCardinalityParams,
) => {
  return [
    `/v1/instances/${instanceId}/queries/column-cardinality/tables/${tableName}`,
    ...(params ? [params] : []),
  ] as const;
};

export const getQueryServiceColumnCardinalityQueryOptions = <
  TData = Awaited<ReturnType<typeof queryServiceColumnCardinality>>,
  TError = ErrorType<RpcStatus>,
>(
  instanceId: string,
  tableName: string,
  params?: QueryServiceColumnCardinalityParams,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof queryServiceColumnCardinality>>,
        TError,
        TData
      >
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getQueryServiceColumnCardinalityQueryKey(instanceId, tableName, params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof queryServiceColumnCardinality>>
  > = ({ signal }) =>
    queryServiceColumnCardinality(instanceId, tableName, params, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!(instanceId && tableName),
    ...queryOptions,
  } as CreateQueryOptions<
    Awaited<ReturnType<typeof queryServiceColumnCardinality>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type QueryServiceColumnCardinalityQueryResult = NonNullable<
  Awaited<ReturnType<typeof queryServiceColumnCardinality>>
>;
export type QueryServiceColumnCardinalityQueryError = ErrorType<RpcStatus>;

/**
 * @summary Get cardinality for a column
 */

export function createQueryServiceColumnCardinality<
  TData = Awaited<ReturnType<typeof queryServiceColumnCardinality>>,
  TError = ErrorType<RpcStatus>,
>(
  instanceId: string,
  tableName: string,
  params?: QueryServiceColumnCardinalityParams,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof queryServiceColumnCardinality>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): CreateQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getQueryServiceColumnCardinalityQueryOptions(
    instanceId,
    tableName,
    params,
    options,
  );

  const query = createQuery(queryOptions, queryClient) as CreateQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary TableColumns returns column profiles
 */
export const queryServiceTableColumns = (
  instanceId: string,
  tableName: string,
  params?: QueryServiceTableColumnsParams,
  signal?: AbortSignal,
) => {
  return httpClient<V1TableColumnsResponse>({
    url: `/v1/instances/${instanceId}/queries/columns-profile/tables/${tableName}`,
    method: "POST",
    params,
    signal,
  });
};

export const getQueryServiceTableColumnsQueryKey = (
  instanceId: string,
  tableName: string,
  params?: QueryServiceTableColumnsParams,
) => {
  return [
    `/v1/instances/${instanceId}/queries/columns-profile/tables/${tableName}`,
    ...(params ? [params] : []),
  ] as const;
};

export const getQueryServiceTableColumnsQueryOptions = <
  TData = Awaited<ReturnType<typeof queryServiceTableColumns>>,
  TError = ErrorType<RpcStatus>,
>(
  instanceId: string,
  tableName: string,
  params?: QueryServiceTableColumnsParams,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof queryServiceTableColumns>>,
        TError,
        TData
      >
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getQueryServiceTableColumnsQueryKey(instanceId, tableName, params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof queryServiceTableColumns>>
  > = ({ signal }) =>
    queryServiceTableColumns(instanceId, tableName, params, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!(instanceId && tableName),
    ...queryOptions,
  } as CreateQueryOptions<
    Awaited<ReturnType<typeof queryServiceTableColumns>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type QueryServiceTableColumnsQueryResult = NonNullable<
  Awaited<ReturnType<typeof queryServiceTableColumns>>
>;
export type QueryServiceTableColumnsQueryError = ErrorType<RpcStatus>;

/**
 * @summary TableColumns returns column profiles
 */

export function createQueryServiceTableColumns<
  TData = Awaited<ReturnType<typeof queryServiceTableColumns>>,
  TError = ErrorType<RpcStatus>,
>(
  instanceId: string,
  tableName: string,
  params?: QueryServiceTableColumnsParams,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof queryServiceTableColumns>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): CreateQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getQueryServiceTableColumnsQueryOptions(
    instanceId,
    tableName,
    params,
    options,
  );

  const query = createQuery(queryOptions, queryClient) as CreateQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary ResolveComponent resolves renderer for a Component resource.
 */
export const queryServiceResolveComponent = (
  instanceId: string,
  component: string,
  queryServiceResolveComponentBody: QueryServiceResolveComponentBody,
  signal?: AbortSignal,
) => {
  return httpClient<V1ResolveComponentResponse>({
    url: `/v1/instances/${instanceId}/queries/components/${component}/resolve`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: queryServiceResolveComponentBody,
    signal,
  });
};

export const getQueryServiceResolveComponentQueryKey = (
  instanceId: string,
  component: string,
  queryServiceResolveComponentBody: QueryServiceResolveComponentBody,
) => {
  return [
    `/v1/instances/${instanceId}/queries/components/${component}/resolve`,
    queryServiceResolveComponentBody,
  ] as const;
};

export const getQueryServiceResolveComponentQueryOptions = <
  TData = Awaited<ReturnType<typeof queryServiceResolveComponent>>,
  TError = ErrorType<RpcStatus>,
>(
  instanceId: string,
  component: string,
  queryServiceResolveComponentBody: QueryServiceResolveComponentBody,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof queryServiceResolveComponent>>,
        TError,
        TData
      >
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getQueryServiceResolveComponentQueryKey(
      instanceId,
      component,
      queryServiceResolveComponentBody,
    );

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof queryServiceResolveComponent>>
  > = ({ signal }) =>
    queryServiceResolveComponent(
      instanceId,
      component,
      queryServiceResolveComponentBody,
      signal,
    );

  return {
    queryKey,
    queryFn,
    enabled: !!(instanceId && component),
    ...queryOptions,
  } as CreateQueryOptions<
    Awaited<ReturnType<typeof queryServiceResolveComponent>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type QueryServiceResolveComponentQueryResult = NonNullable<
  Awaited<ReturnType<typeof queryServiceResolveComponent>>
>;
export type QueryServiceResolveComponentQueryError = ErrorType<RpcStatus>;

/**
 * @summary ResolveComponent resolves renderer for a Component resource.
 */

export function createQueryServiceResolveComponent<
  TData = Awaited<ReturnType<typeof queryServiceResolveComponent>>,
  TError = ErrorType<RpcStatus>,
>(
  instanceId: string,
  component: string,
  queryServiceResolveComponentBody: QueryServiceResolveComponentBody,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof queryServiceResolveComponent>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): CreateQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getQueryServiceResolveComponentQueryOptions(
    instanceId,
    component,
    queryServiceResolveComponentBody,
    options,
  );

  const query = createQuery(queryOptions, queryClient) as CreateQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Get basic stats for a numeric column like min, max, mean, stddev, etc
 */
export const queryServiceColumnDescriptiveStatistics = (
  instanceId: string,
  tableName: string,
  params?: QueryServiceColumnDescriptiveStatisticsParams,
  signal?: AbortSignal,
) => {
  return httpClient<V1ColumnDescriptiveStatisticsResponse>({
    url: `/v1/instances/${instanceId}/queries/descriptive-statistics/tables/${tableName}`,
    method: "GET",
    params,
    signal,
  });
};

export const getQueryServiceColumnDescriptiveStatisticsQueryKey = (
  instanceId: string,
  tableName: string,
  params?: QueryServiceColumnDescriptiveStatisticsParams,
) => {
  return [
    `/v1/instances/${instanceId}/queries/descriptive-statistics/tables/${tableName}`,
    ...(params ? [params] : []),
  ] as const;
};

export const getQueryServiceColumnDescriptiveStatisticsQueryOptions = <
  TData = Awaited<ReturnType<typeof queryServiceColumnDescriptiveStatistics>>,
  TError = ErrorType<RpcStatus>,
>(
  instanceId: string,
  tableName: string,
  params?: QueryServiceColumnDescriptiveStatisticsParams,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof queryServiceColumnDescriptiveStatistics>>,
        TError,
        TData
      >
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getQueryServiceColumnDescriptiveStatisticsQueryKey(
      instanceId,
      tableName,
      params,
    );

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof queryServiceColumnDescriptiveStatistics>>
  > = ({ signal }) =>
    queryServiceColumnDescriptiveStatistics(
      instanceId,
      tableName,
      params,
      signal,
    );

  return {
    queryKey,
    queryFn,
    enabled: !!(instanceId && tableName),
    ...queryOptions,
  } as CreateQueryOptions<
    Awaited<ReturnType<typeof queryServiceColumnDescriptiveStatistics>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type QueryServiceColumnDescriptiveStatisticsQueryResult = NonNullable<
  Awaited<ReturnType<typeof queryServiceColumnDescriptiveStatistics>>
>;
export type QueryServiceColumnDescriptiveStatisticsQueryError =
  ErrorType<RpcStatus>;

/**
 * @summary Get basic stats for a numeric column like min, max, mean, stddev, etc
 */

export function createQueryServiceColumnDescriptiveStatistics<
  TData = Awaited<ReturnType<typeof queryServiceColumnDescriptiveStatistics>>,
  TError = ErrorType<RpcStatus>,
>(
  instanceId: string,
  tableName: string,
  params?: QueryServiceColumnDescriptiveStatisticsParams,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof queryServiceColumnDescriptiveStatistics>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): CreateQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getQueryServiceColumnDescriptiveStatisticsQueryOptions(
    instanceId,
    tableName,
    params,
    options,
  );

  const query = createQuery(queryOptions, queryClient) as CreateQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Export builds a URL to download the results of a query as a file.
 */
export const queryServiceExport = (
  instanceId: string,
  queryServiceExportBody: QueryServiceExportBody,
  signal?: AbortSignal,
) => {
  return httpClient<V1ExportResponse>({
    url: `/v1/instances/${instanceId}/queries/export`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: queryServiceExportBody,
    signal,
  });
};

export const getQueryServiceExportMutationOptions = <
  TError = ErrorType<RpcStatus>,
  TContext = unknown,
>(options?: {
  mutation?: CreateMutationOptions<
    Awaited<ReturnType<typeof queryServiceExport>>,
    TError,
    { instanceId: string; data: QueryServiceExportBody },
    TContext
  >;
}): CreateMutationOptions<
  Awaited<ReturnType<typeof queryServiceExport>>,
  TError,
  { instanceId: string; data: QueryServiceExportBody },
  TContext
> => {
  const mutationKey = ["queryServiceExport"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof queryServiceExport>>,
    { instanceId: string; data: QueryServiceExportBody }
  > = (props) => {
    const { instanceId, data } = props ?? {};

    return queryServiceExport(instanceId, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type QueryServiceExportMutationResult = NonNullable<
  Awaited<ReturnType<typeof queryServiceExport>>
>;
export type QueryServiceExportMutationBody = QueryServiceExportBody;
export type QueryServiceExportMutationError = ErrorType<RpcStatus>;

/**
 * @summary Export builds a URL to download the results of a query as a file.
 */
export const createQueryServiceExport = <
  TError = ErrorType<RpcStatus>,
  TContext = unknown,
>(
  options?: {
    mutation?: CreateMutationOptions<
      Awaited<ReturnType<typeof queryServiceExport>>,
      TError,
      { instanceId: string; data: QueryServiceExportBody },
      TContext
    >;
  },
  queryClient?: QueryClient,
): CreateMutationResult<
  Awaited<ReturnType<typeof queryServiceExport>>,
  TError,
  { instanceId: string; data: QueryServiceExportBody },
  TContext
> => {
  const mutationOptions = getQueryServiceExportMutationOptions(options);

  return createMutation(mutationOptions, queryClient);
};
/**
 * @summary MetricsViewAggregation is a generic API for running group-by/pivot queries against a metrics view.
 */
export const queryServiceMetricsViewAggregation = (
  instanceId: string,
  metricsView: string,
  queryServiceMetricsViewAggregationBody: QueryServiceMetricsViewAggregationBody,
  signal?: AbortSignal,
) => {
  return httpClient<V1MetricsViewAggregationResponse>({
    url: `/v1/instances/${instanceId}/queries/metrics-views/${metricsView}/aggregation`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: queryServiceMetricsViewAggregationBody,
    signal,
  });
};

export const getQueryServiceMetricsViewAggregationQueryKey = (
  instanceId: string,
  metricsView: string,
  queryServiceMetricsViewAggregationBody: QueryServiceMetricsViewAggregationBody,
) => {
  return [
    `/v1/instances/${instanceId}/queries/metrics-views/${metricsView}/aggregation`,
    queryServiceMetricsViewAggregationBody,
  ] as const;
};

export const getQueryServiceMetricsViewAggregationQueryOptions = <
  TData = Awaited<ReturnType<typeof queryServiceMetricsViewAggregation>>,
  TError = ErrorType<RpcStatus>,
>(
  instanceId: string,
  metricsView: string,
  queryServiceMetricsViewAggregationBody: QueryServiceMetricsViewAggregationBody,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof queryServiceMetricsViewAggregation>>,
        TError,
        TData
      >
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getQueryServiceMetricsViewAggregationQueryKey(
      instanceId,
      metricsView,
      queryServiceMetricsViewAggregationBody,
    );

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof queryServiceMetricsViewAggregation>>
  > = ({ signal }) =>
    queryServiceMetricsViewAggregation(
      instanceId,
      metricsView,
      queryServiceMetricsViewAggregationBody,
      signal,
    );

  return {
    queryKey,
    queryFn,
    enabled: !!(instanceId && metricsView),
    ...queryOptions,
  } as CreateQueryOptions<
    Awaited<ReturnType<typeof queryServiceMetricsViewAggregation>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type QueryServiceMetricsViewAggregationQueryResult = NonNullable<
  Awaited<ReturnType<typeof queryServiceMetricsViewAggregation>>
>;
export type QueryServiceMetricsViewAggregationQueryError = ErrorType<RpcStatus>;

/**
 * @summary MetricsViewAggregation is a generic API for running group-by/pivot queries against a metrics view.
 */

export function createQueryServiceMetricsViewAggregation<
  TData = Awaited<ReturnType<typeof queryServiceMetricsViewAggregation>>,
  TError = ErrorType<RpcStatus>,
>(
  instanceId: string,
  metricsView: string,
  queryServiceMetricsViewAggregationBody: QueryServiceMetricsViewAggregationBody,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof queryServiceMetricsViewAggregation>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): CreateQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getQueryServiceMetricsViewAggregationQueryOptions(
    instanceId,
    metricsView,
    queryServiceMetricsViewAggregationBody,
    options,
  );

  const query = createQuery(queryOptions, queryClient) as CreateQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const queryServiceMetricsViewAnnotations = (
  instanceId: string,
  metricsViewName: string,
  queryServiceMetricsViewAnnotationsBody: QueryServiceMetricsViewAnnotationsBody,
  signal?: AbortSignal,
) => {
  return httpClient<V1MetricsViewAnnotationsResponse>({
    url: `/v1/instances/${instanceId}/queries/metrics-views/${metricsViewName}/annotations`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: queryServiceMetricsViewAnnotationsBody,
    signal,
  });
};

export const getQueryServiceMetricsViewAnnotationsQueryKey = (
  instanceId: string,
  metricsViewName: string,
  queryServiceMetricsViewAnnotationsBody: QueryServiceMetricsViewAnnotationsBody,
) => {
  return [
    `/v1/instances/${instanceId}/queries/metrics-views/${metricsViewName}/annotations`,
    queryServiceMetricsViewAnnotationsBody,
  ] as const;
};

export const getQueryServiceMetricsViewAnnotationsQueryOptions = <
  TData = Awaited<ReturnType<typeof queryServiceMetricsViewAnnotations>>,
  TError = ErrorType<RpcStatus>,
>(
  instanceId: string,
  metricsViewName: string,
  queryServiceMetricsViewAnnotationsBody: QueryServiceMetricsViewAnnotationsBody,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof queryServiceMetricsViewAnnotations>>,
        TError,
        TData
      >
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getQueryServiceMetricsViewAnnotationsQueryKey(
      instanceId,
      metricsViewName,
      queryServiceMetricsViewAnnotationsBody,
    );

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof queryServiceMetricsViewAnnotations>>
  > = ({ signal }) =>
    queryServiceMetricsViewAnnotations(
      instanceId,
      metricsViewName,
      queryServiceMetricsViewAnnotationsBody,
      signal,
    );

  return {
    queryKey,
    queryFn,
    enabled: !!(instanceId && metricsViewName),
    ...queryOptions,
  } as CreateQueryOptions<
    Awaited<ReturnType<typeof queryServiceMetricsViewAnnotations>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type QueryServiceMetricsViewAnnotationsQueryResult = NonNullable<
  Awaited<ReturnType<typeof queryServiceMetricsViewAnnotations>>
>;
export type QueryServiceMetricsViewAnnotationsQueryError = ErrorType<RpcStatus>;

export function createQueryServiceMetricsViewAnnotations<
  TData = Awaited<ReturnType<typeof queryServiceMetricsViewAnnotations>>,
  TError = ErrorType<RpcStatus>,
>(
  instanceId: string,
  metricsViewName: string,
  queryServiceMetricsViewAnnotationsBody: QueryServiceMetricsViewAnnotationsBody,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof queryServiceMetricsViewAnnotations>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): CreateQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getQueryServiceMetricsViewAnnotationsQueryOptions(
    instanceId,
    metricsViewName,
    queryServiceMetricsViewAnnotationsBody,
    options,
  );

  const query = createQuery(queryOptions, queryClient) as CreateQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * ie. comparsion toplist:
| measure1_base | measure1_previous   | measure1__delta_abs | measure1__delta_rel | dimension |
|---------------|---------------------|---------------------|--------------------|-----------|
| 2             | 2                   | 0                   | 0                  | Safari    |
| 1             | 0                   | 1                   | N/A                | Chrome    |
| 0             | 4                   | -4                  | -1.0               | Firefox   |

ie. toplist:
| measure1 | measure2 | dimension |
|----------|----------|-----------|
| 2        | 45       | Safari    |
| 1        | 350      | Chrome    |
| 0        | 25       | Firefox   |
 * @summary MetricsViewComparison returns a toplist containing comparison data of another toplist (same dimension/measure but a different time range).
Returns a toplist without comparison data if comparison time range is omitted.
 */
export const queryServiceMetricsViewComparison = (
  instanceId: string,
  metricsViewName: string,
  queryServiceMetricsViewComparisonBody: QueryServiceMetricsViewComparisonBody,
  signal?: AbortSignal,
) => {
  return httpClient<V1MetricsViewComparisonResponse>({
    url: `/v1/instances/${instanceId}/queries/metrics-views/${metricsViewName}/compare-toplist`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: queryServiceMetricsViewComparisonBody,
    signal,
  });
};

export const getQueryServiceMetricsViewComparisonQueryKey = (
  instanceId: string,
  metricsViewName: string,
  queryServiceMetricsViewComparisonBody: QueryServiceMetricsViewComparisonBody,
) => {
  return [
    `/v1/instances/${instanceId}/queries/metrics-views/${metricsViewName}/compare-toplist`,
    queryServiceMetricsViewComparisonBody,
  ] as const;
};

export const getQueryServiceMetricsViewComparisonQueryOptions = <
  TData = Awaited<ReturnType<typeof queryServiceMetricsViewComparison>>,
  TError = ErrorType<RpcStatus>,
>(
  instanceId: string,
  metricsViewName: string,
  queryServiceMetricsViewComparisonBody: QueryServiceMetricsViewComparisonBody,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof queryServiceMetricsViewComparison>>,
        TError,
        TData
      >
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getQueryServiceMetricsViewComparisonQueryKey(
      instanceId,
      metricsViewName,
      queryServiceMetricsViewComparisonBody,
    );

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof queryServiceMetricsViewComparison>>
  > = ({ signal }) =>
    queryServiceMetricsViewComparison(
      instanceId,
      metricsViewName,
      queryServiceMetricsViewComparisonBody,
      signal,
    );

  return {
    queryKey,
    queryFn,
    enabled: !!(instanceId && metricsViewName),
    ...queryOptions,
  } as CreateQueryOptions<
    Awaited<ReturnType<typeof queryServiceMetricsViewComparison>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type QueryServiceMetricsViewComparisonQueryResult = NonNullable<
  Awaited<ReturnType<typeof queryServiceMetricsViewComparison>>
>;
export type QueryServiceMetricsViewComparisonQueryError = ErrorType<RpcStatus>;

/**
 * @summary MetricsViewComparison returns a toplist containing comparison data of another toplist (same dimension/measure but a different time range).
Returns a toplist without comparison data if comparison time range is omitted.
 */

export function createQueryServiceMetricsViewComparison<
  TData = Awaited<ReturnType<typeof queryServiceMetricsViewComparison>>,
  TError = ErrorType<RpcStatus>,
>(
  instanceId: string,
  metricsViewName: string,
  queryServiceMetricsViewComparisonBody: QueryServiceMetricsViewComparisonBody,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof queryServiceMetricsViewComparison>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): CreateQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getQueryServiceMetricsViewComparisonQueryOptions(
    instanceId,
    metricsViewName,
    queryServiceMetricsViewComparisonBody,
    options,
  );

  const query = createQuery(queryOptions, queryClient) as CreateQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * ie. without granularity
| column1 | column2 | dimension |
|---------|---------|-----------|
| 2       | 2       | Safari    |
| 1       | 0       | Chrome    |
| 0       | 4       | Firefox   |

ie. with granularity
| timestamp__day0      | column1 | column2 | dimension |
|----------------------|---------|---------|-----------|
| 2022-01-01T00:00:00Z | 2       | 2       | Safari    |
| 2022-01-01T00:00:00Z | 1       | 0       | Chrome    |
| 2022-01-01T00:00:00Z | 0       | 4       | Firefox   |
 * @summary MetricsViewRows returns the underlying model rows matching a metrics view time range and filter(s).
 */
export const queryServiceMetricsViewRows = (
  instanceId: string,
  metricsViewName: string,
  queryServiceMetricsViewRowsBody: QueryServiceMetricsViewRowsBody,
  signal?: AbortSignal,
) => {
  return httpClient<V1MetricsViewRowsResponse>({
    url: `/v1/instances/${instanceId}/queries/metrics-views/${metricsViewName}/rows`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: queryServiceMetricsViewRowsBody,
    signal,
  });
};

export const getQueryServiceMetricsViewRowsQueryKey = (
  instanceId: string,
  metricsViewName: string,
  queryServiceMetricsViewRowsBody: QueryServiceMetricsViewRowsBody,
) => {
  return [
    `/v1/instances/${instanceId}/queries/metrics-views/${metricsViewName}/rows`,
    queryServiceMetricsViewRowsBody,
  ] as const;
};

export const getQueryServiceMetricsViewRowsQueryOptions = <
  TData = Awaited<ReturnType<typeof queryServiceMetricsViewRows>>,
  TError = ErrorType<RpcStatus>,
>(
  instanceId: string,
  metricsViewName: string,
  queryServiceMetricsViewRowsBody: QueryServiceMetricsViewRowsBody,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof queryServiceMetricsViewRows>>,
        TError,
        TData
      >
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getQueryServiceMetricsViewRowsQueryKey(
      instanceId,
      metricsViewName,
      queryServiceMetricsViewRowsBody,
    );

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof queryServiceMetricsViewRows>>
  > = ({ signal }) =>
    queryServiceMetricsViewRows(
      instanceId,
      metricsViewName,
      queryServiceMetricsViewRowsBody,
      signal,
    );

  return {
    queryKey,
    queryFn,
    enabled: !!(instanceId && metricsViewName),
    ...queryOptions,
  } as CreateQueryOptions<
    Awaited<ReturnType<typeof queryServiceMetricsViewRows>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type QueryServiceMetricsViewRowsQueryResult = NonNullable<
  Awaited<ReturnType<typeof queryServiceMetricsViewRows>>
>;
export type QueryServiceMetricsViewRowsQueryError = ErrorType<RpcStatus>;

/**
 * @summary MetricsViewRows returns the underlying model rows matching a metrics view time range and filter(s).
 */

export function createQueryServiceMetricsViewRows<
  TData = Awaited<ReturnType<typeof queryServiceMetricsViewRows>>,
  TError = ErrorType<RpcStatus>,
>(
  instanceId: string,
  metricsViewName: string,
  queryServiceMetricsViewRowsBody: QueryServiceMetricsViewRowsBody,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof queryServiceMetricsViewRows>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): CreateQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getQueryServiceMetricsViewRowsQueryOptions(
    instanceId,
    metricsViewName,
    queryServiceMetricsViewRowsBody,
    options,
  );

  const query = createQuery(queryOptions, queryClient) as CreateQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary MetricsViewSchema Get the data types of measures and dimensions
 */
export const queryServiceMetricsViewSchema = (
  instanceId: string,
  metricsViewName: string,
  params?: QueryServiceMetricsViewSchemaParams,
  signal?: AbortSignal,
) => {
  return httpClient<V1MetricsViewSchemaResponse>({
    url: `/v1/instances/${instanceId}/queries/metrics-views/${metricsViewName}/schema`,
    method: "GET",
    params,
    signal,
  });
};

export const getQueryServiceMetricsViewSchemaQueryKey = (
  instanceId: string,
  metricsViewName: string,
  params?: QueryServiceMetricsViewSchemaParams,
) => {
  return [
    `/v1/instances/${instanceId}/queries/metrics-views/${metricsViewName}/schema`,
    ...(params ? [params] : []),
  ] as const;
};

export const getQueryServiceMetricsViewSchemaQueryOptions = <
  TData = Awaited<ReturnType<typeof queryServiceMetricsViewSchema>>,
  TError = ErrorType<RpcStatus>,
>(
  instanceId: string,
  metricsViewName: string,
  params?: QueryServiceMetricsViewSchemaParams,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof queryServiceMetricsViewSchema>>,
        TError,
        TData
      >
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getQueryServiceMetricsViewSchemaQueryKey(
      instanceId,
      metricsViewName,
      params,
    );

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof queryServiceMetricsViewSchema>>
  > = ({ signal }) =>
    queryServiceMetricsViewSchema(instanceId, metricsViewName, params, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!(instanceId && metricsViewName),
    ...queryOptions,
  } as CreateQueryOptions<
    Awaited<ReturnType<typeof queryServiceMetricsViewSchema>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type QueryServiceMetricsViewSchemaQueryResult = NonNullable<
  Awaited<ReturnType<typeof queryServiceMetricsViewSchema>>
>;
export type QueryServiceMetricsViewSchemaQueryError = ErrorType<RpcStatus>;

/**
 * @summary MetricsViewSchema Get the data types of measures and dimensions
 */

export function createQueryServiceMetricsViewSchema<
  TData = Awaited<ReturnType<typeof queryServiceMetricsViewSchema>>,
  TError = ErrorType<RpcStatus>,
>(
  instanceId: string,
  metricsViewName: string,
  params?: QueryServiceMetricsViewSchemaParams,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof queryServiceMetricsViewSchema>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): CreateQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getQueryServiceMetricsViewSchemaQueryOptions(
    instanceId,
    metricsViewName,
    params,
    options,
  );

  const query = createQuery(queryOptions, queryClient) as CreateQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary MetricsViewSearch Get the data types of measures and dimensions
 */
export const queryServiceMetricsViewSearch = (
  instanceId: string,
  metricsViewName: string,
  queryServiceMetricsViewSearchBody: QueryServiceMetricsViewSearchBody,
  signal?: AbortSignal,
) => {
  return httpClient<V1MetricsViewSearchResponse>({
    url: `/v1/instances/${instanceId}/queries/metrics-views/${metricsViewName}/search`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: queryServiceMetricsViewSearchBody,
    signal,
  });
};

export const getQueryServiceMetricsViewSearchQueryKey = (
  instanceId: string,
  metricsViewName: string,
  queryServiceMetricsViewSearchBody: QueryServiceMetricsViewSearchBody,
) => {
  return [
    `/v1/instances/${instanceId}/queries/metrics-views/${metricsViewName}/search`,
    queryServiceMetricsViewSearchBody,
  ] as const;
};

export const getQueryServiceMetricsViewSearchQueryOptions = <
  TData = Awaited<ReturnType<typeof queryServiceMetricsViewSearch>>,
  TError = ErrorType<RpcStatus>,
>(
  instanceId: string,
  metricsViewName: string,
  queryServiceMetricsViewSearchBody: QueryServiceMetricsViewSearchBody,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof queryServiceMetricsViewSearch>>,
        TError,
        TData
      >
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getQueryServiceMetricsViewSearchQueryKey(
      instanceId,
      metricsViewName,
      queryServiceMetricsViewSearchBody,
    );

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof queryServiceMetricsViewSearch>>
  > = ({ signal }) =>
    queryServiceMetricsViewSearch(
      instanceId,
      metricsViewName,
      queryServiceMetricsViewSearchBody,
      signal,
    );

  return {
    queryKey,
    queryFn,
    enabled: !!(instanceId && metricsViewName),
    ...queryOptions,
  } as CreateQueryOptions<
    Awaited<ReturnType<typeof queryServiceMetricsViewSearch>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type QueryServiceMetricsViewSearchQueryResult = NonNullable<
  Awaited<ReturnType<typeof queryServiceMetricsViewSearch>>
>;
export type QueryServiceMetricsViewSearchQueryError = ErrorType<RpcStatus>;

/**
 * @summary MetricsViewSearch Get the data types of measures and dimensions
 */

export function createQueryServiceMetricsViewSearch<
  TData = Awaited<ReturnType<typeof queryServiceMetricsViewSearch>>,
  TError = ErrorType<RpcStatus>,
>(
  instanceId: string,
  metricsViewName: string,
  queryServiceMetricsViewSearchBody: QueryServiceMetricsViewSearchBody,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof queryServiceMetricsViewSearch>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): CreateQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getQueryServiceMetricsViewSearchQueryOptions(
    instanceId,
    metricsViewName,
    queryServiceMetricsViewSearchBody,
    options,
  );

  const query = createQuery(queryOptions, queryClient) as CreateQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary MetricsViewTimeRange Get the time range summaries (min, max) for time column in a metrics view.
Deprecated: use MetricsViewTimeRanges instead.
 */
export const queryServiceMetricsViewTimeRange = (
  instanceId: string,
  metricsViewName: string,
  queryServiceMetricsViewTimeRangeBody: QueryServiceMetricsViewTimeRangeBody,
  signal?: AbortSignal,
) => {
  return httpClient<V1MetricsViewTimeRangeResponse>({
    url: `/v1/instances/${instanceId}/queries/metrics-views/${metricsViewName}/time-range-summary`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: queryServiceMetricsViewTimeRangeBody,
    signal,
  });
};

export const getQueryServiceMetricsViewTimeRangeQueryKey = (
  instanceId: string,
  metricsViewName: string,
  queryServiceMetricsViewTimeRangeBody: QueryServiceMetricsViewTimeRangeBody,
) => {
  return [
    `/v1/instances/${instanceId}/queries/metrics-views/${metricsViewName}/time-range-summary`,
    queryServiceMetricsViewTimeRangeBody,
  ] as const;
};

export const getQueryServiceMetricsViewTimeRangeQueryOptions = <
  TData = Awaited<ReturnType<typeof queryServiceMetricsViewTimeRange>>,
  TError = ErrorType<RpcStatus>,
>(
  instanceId: string,
  metricsViewName: string,
  queryServiceMetricsViewTimeRangeBody: QueryServiceMetricsViewTimeRangeBody,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof queryServiceMetricsViewTimeRange>>,
        TError,
        TData
      >
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getQueryServiceMetricsViewTimeRangeQueryKey(
      instanceId,
      metricsViewName,
      queryServiceMetricsViewTimeRangeBody,
    );

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof queryServiceMetricsViewTimeRange>>
  > = ({ signal }) =>
    queryServiceMetricsViewTimeRange(
      instanceId,
      metricsViewName,
      queryServiceMetricsViewTimeRangeBody,
      signal,
    );

  return {
    queryKey,
    queryFn,
    enabled: !!(instanceId && metricsViewName),
    ...queryOptions,
  } as CreateQueryOptions<
    Awaited<ReturnType<typeof queryServiceMetricsViewTimeRange>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type QueryServiceMetricsViewTimeRangeQueryResult = NonNullable<
  Awaited<ReturnType<typeof queryServiceMetricsViewTimeRange>>
>;
export type QueryServiceMetricsViewTimeRangeQueryError = ErrorType<RpcStatus>;

/**
 * @summary MetricsViewTimeRange Get the time range summaries (min, max) for time column in a metrics view.
Deprecated: use MetricsViewTimeRanges instead.
 */

export function createQueryServiceMetricsViewTimeRange<
  TData = Awaited<ReturnType<typeof queryServiceMetricsViewTimeRange>>,
  TError = ErrorType<RpcStatus>,
>(
  instanceId: string,
  metricsViewName: string,
  queryServiceMetricsViewTimeRangeBody: QueryServiceMetricsViewTimeRangeBody,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof queryServiceMetricsViewTimeRange>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): CreateQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getQueryServiceMetricsViewTimeRangeQueryOptions(
    instanceId,
    metricsViewName,
    queryServiceMetricsViewTimeRangeBody,
    options,
  );

  const query = createQuery(queryOptions, queryClient) as CreateQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary MetricsViewTimeRanges resolves time ranges for a metrics view.
 */
export const queryServiceMetricsViewTimeRanges = (
  instanceId: string,
  metricsViewName: string,
  queryServiceMetricsViewTimeRangesBody: QueryServiceMetricsViewTimeRangesBody,
  signal?: AbortSignal,
) => {
  return httpClient<V1MetricsViewTimeRangesResponse>({
    url: `/v1/instances/${instanceId}/queries/metrics-views/${metricsViewName}/time-ranges`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: queryServiceMetricsViewTimeRangesBody,
    signal,
  });
};

export const getQueryServiceMetricsViewTimeRangesQueryKey = (
  instanceId: string,
  metricsViewName: string,
  queryServiceMetricsViewTimeRangesBody: QueryServiceMetricsViewTimeRangesBody,
) => {
  return [
    `/v1/instances/${instanceId}/queries/metrics-views/${metricsViewName}/time-ranges`,
    queryServiceMetricsViewTimeRangesBody,
  ] as const;
};

export const getQueryServiceMetricsViewTimeRangesQueryOptions = <
  TData = Awaited<ReturnType<typeof queryServiceMetricsViewTimeRanges>>,
  TError = ErrorType<RpcStatus>,
>(
  instanceId: string,
  metricsViewName: string,
  queryServiceMetricsViewTimeRangesBody: QueryServiceMetricsViewTimeRangesBody,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof queryServiceMetricsViewTimeRanges>>,
        TError,
        TData
      >
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getQueryServiceMetricsViewTimeRangesQueryKey(
      instanceId,
      metricsViewName,
      queryServiceMetricsViewTimeRangesBody,
    );

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof queryServiceMetricsViewTimeRanges>>
  > = ({ signal }) =>
    queryServiceMetricsViewTimeRanges(
      instanceId,
      metricsViewName,
      queryServiceMetricsViewTimeRangesBody,
      signal,
    );

  return {
    queryKey,
    queryFn,
    enabled: !!(instanceId && metricsViewName),
    ...queryOptions,
  } as CreateQueryOptions<
    Awaited<ReturnType<typeof queryServiceMetricsViewTimeRanges>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type QueryServiceMetricsViewTimeRangesQueryResult = NonNullable<
  Awaited<ReturnType<typeof queryServiceMetricsViewTimeRanges>>
>;
export type QueryServiceMetricsViewTimeRangesQueryError = ErrorType<RpcStatus>;

/**
 * @summary MetricsViewTimeRanges resolves time ranges for a metrics view.
 */

export function createQueryServiceMetricsViewTimeRanges<
  TData = Awaited<ReturnType<typeof queryServiceMetricsViewTimeRanges>>,
  TError = ErrorType<RpcStatus>,
>(
  instanceId: string,
  metricsViewName: string,
  queryServiceMetricsViewTimeRangesBody: QueryServiceMetricsViewTimeRangesBody,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof queryServiceMetricsViewTimeRanges>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): CreateQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getQueryServiceMetricsViewTimeRangesQueryOptions(
    instanceId,
    metricsViewName,
    queryServiceMetricsViewTimeRangesBody,
    options,
  );

  const query = createQuery(queryOptions, queryClient) as CreateQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary MetricsViewTimeSeries returns time series for the measures in the metrics view.
It's a convenience API for querying a metrics view.
 */
export const queryServiceMetricsViewTimeSeries = (
  instanceId: string,
  metricsViewName: string,
  queryServiceMetricsViewTimeSeriesBody: QueryServiceMetricsViewTimeSeriesBody,
  signal?: AbortSignal,
) => {
  return httpClient<V1MetricsViewTimeSeriesResponse>({
    url: `/v1/instances/${instanceId}/queries/metrics-views/${metricsViewName}/timeseries`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: queryServiceMetricsViewTimeSeriesBody,
    signal,
  });
};

export const getQueryServiceMetricsViewTimeSeriesQueryKey = (
  instanceId: string,
  metricsViewName: string,
  queryServiceMetricsViewTimeSeriesBody: QueryServiceMetricsViewTimeSeriesBody,
) => {
  return [
    `/v1/instances/${instanceId}/queries/metrics-views/${metricsViewName}/timeseries`,
    queryServiceMetricsViewTimeSeriesBody,
  ] as const;
};

export const getQueryServiceMetricsViewTimeSeriesQueryOptions = <
  TData = Awaited<ReturnType<typeof queryServiceMetricsViewTimeSeries>>,
  TError = ErrorType<RpcStatus>,
>(
  instanceId: string,
  metricsViewName: string,
  queryServiceMetricsViewTimeSeriesBody: QueryServiceMetricsViewTimeSeriesBody,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof queryServiceMetricsViewTimeSeries>>,
        TError,
        TData
      >
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getQueryServiceMetricsViewTimeSeriesQueryKey(
      instanceId,
      metricsViewName,
      queryServiceMetricsViewTimeSeriesBody,
    );

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof queryServiceMetricsViewTimeSeries>>
  > = ({ signal }) =>
    queryServiceMetricsViewTimeSeries(
      instanceId,
      metricsViewName,
      queryServiceMetricsViewTimeSeriesBody,
      signal,
    );

  return {
    queryKey,
    queryFn,
    enabled: !!(instanceId && metricsViewName),
    ...queryOptions,
  } as CreateQueryOptions<
    Awaited<ReturnType<typeof queryServiceMetricsViewTimeSeries>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type QueryServiceMetricsViewTimeSeriesQueryResult = NonNullable<
  Awaited<ReturnType<typeof queryServiceMetricsViewTimeSeries>>
>;
export type QueryServiceMetricsViewTimeSeriesQueryError = ErrorType<RpcStatus>;

/**
 * @summary MetricsViewTimeSeries returns time series for the measures in the metrics view.
It's a convenience API for querying a metrics view.
 */

export function createQueryServiceMetricsViewTimeSeries<
  TData = Awaited<ReturnType<typeof queryServiceMetricsViewTimeSeries>>,
  TError = ErrorType<RpcStatus>,
>(
  instanceId: string,
  metricsViewName: string,
  queryServiceMetricsViewTimeSeriesBody: QueryServiceMetricsViewTimeSeriesBody,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof queryServiceMetricsViewTimeSeries>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): CreateQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getQueryServiceMetricsViewTimeSeriesQueryOptions(
    instanceId,
    metricsViewName,
    queryServiceMetricsViewTimeSeriesBody,
    options,
  );

  const query = createQuery(queryOptions, queryClient) as CreateQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Deprecated - use MetricsViewComparison instead.
MetricsViewToplist returns the top dimension values of a metrics view sorted by one or more measures.
It's a convenience API for querying a metrics view.
 */
export const queryServiceMetricsViewToplist = (
  instanceId: string,
  metricsViewName: string,
  queryServiceMetricsViewToplistBody: QueryServiceMetricsViewToplistBody,
  signal?: AbortSignal,
) => {
  return httpClient<V1MetricsViewToplistResponse>({
    url: `/v1/instances/${instanceId}/queries/metrics-views/${metricsViewName}/toplist`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: queryServiceMetricsViewToplistBody,
    signal,
  });
};

export const getQueryServiceMetricsViewToplistQueryKey = (
  instanceId: string,
  metricsViewName: string,
  queryServiceMetricsViewToplistBody: QueryServiceMetricsViewToplistBody,
) => {
  return [
    `/v1/instances/${instanceId}/queries/metrics-views/${metricsViewName}/toplist`,
    queryServiceMetricsViewToplistBody,
  ] as const;
};

export const getQueryServiceMetricsViewToplistQueryOptions = <
  TData = Awaited<ReturnType<typeof queryServiceMetricsViewToplist>>,
  TError = ErrorType<RpcStatus>,
>(
  instanceId: string,
  metricsViewName: string,
  queryServiceMetricsViewToplistBody: QueryServiceMetricsViewToplistBody,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof queryServiceMetricsViewToplist>>,
        TError,
        TData
      >
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getQueryServiceMetricsViewToplistQueryKey(
      instanceId,
      metricsViewName,
      queryServiceMetricsViewToplistBody,
    );

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof queryServiceMetricsViewToplist>>
  > = ({ signal }) =>
    queryServiceMetricsViewToplist(
      instanceId,
      metricsViewName,
      queryServiceMetricsViewToplistBody,
      signal,
    );

  return {
    queryKey,
    queryFn,
    enabled: !!(instanceId && metricsViewName),
    ...queryOptions,
  } as CreateQueryOptions<
    Awaited<ReturnType<typeof queryServiceMetricsViewToplist>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type QueryServiceMetricsViewToplistQueryResult = NonNullable<
  Awaited<ReturnType<typeof queryServiceMetricsViewToplist>>
>;
export type QueryServiceMetricsViewToplistQueryError = ErrorType<RpcStatus>;

/**
 * @summary Deprecated - use MetricsViewComparison instead.
MetricsViewToplist returns the top dimension values of a metrics view sorted by one or more measures.
It's a convenience API for querying a metrics view.
 */

export function createQueryServiceMetricsViewToplist<
  TData = Awaited<ReturnType<typeof queryServiceMetricsViewToplist>>,
  TError = ErrorType<RpcStatus>,
>(
  instanceId: string,
  metricsViewName: string,
  queryServiceMetricsViewToplistBody: QueryServiceMetricsViewToplistBody,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof queryServiceMetricsViewToplist>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): CreateQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getQueryServiceMetricsViewToplistQueryOptions(
    instanceId,
    metricsViewName,
    queryServiceMetricsViewToplistBody,
    options,
  );

  const query = createQuery(queryOptions, queryClient) as CreateQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary MetricsViewTotals returns totals over a time period for the measures in a metrics view.
It's a convenience API for querying a metrics view.
 */
export const queryServiceMetricsViewTotals = (
  instanceId: string,
  metricsViewName: string,
  queryServiceMetricsViewTotalsBody: QueryServiceMetricsViewTotalsBody,
  signal?: AbortSignal,
) => {
  return httpClient<V1MetricsViewTotalsResponse>({
    url: `/v1/instances/${instanceId}/queries/metrics-views/${metricsViewName}/totals`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: queryServiceMetricsViewTotalsBody,
    signal,
  });
};

export const getQueryServiceMetricsViewTotalsQueryKey = (
  instanceId: string,
  metricsViewName: string,
  queryServiceMetricsViewTotalsBody: QueryServiceMetricsViewTotalsBody,
) => {
  return [
    `/v1/instances/${instanceId}/queries/metrics-views/${metricsViewName}/totals`,
    queryServiceMetricsViewTotalsBody,
  ] as const;
};

export const getQueryServiceMetricsViewTotalsQueryOptions = <
  TData = Awaited<ReturnType<typeof queryServiceMetricsViewTotals>>,
  TError = ErrorType<RpcStatus>,
>(
  instanceId: string,
  metricsViewName: string,
  queryServiceMetricsViewTotalsBody: QueryServiceMetricsViewTotalsBody,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof queryServiceMetricsViewTotals>>,
        TError,
        TData
      >
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getQueryServiceMetricsViewTotalsQueryKey(
      instanceId,
      metricsViewName,
      queryServiceMetricsViewTotalsBody,
    );

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof queryServiceMetricsViewTotals>>
  > = ({ signal }) =>
    queryServiceMetricsViewTotals(
      instanceId,
      metricsViewName,
      queryServiceMetricsViewTotalsBody,
      signal,
    );

  return {
    queryKey,
    queryFn,
    enabled: !!(instanceId && metricsViewName),
    ...queryOptions,
  } as CreateQueryOptions<
    Awaited<ReturnType<typeof queryServiceMetricsViewTotals>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type QueryServiceMetricsViewTotalsQueryResult = NonNullable<
  Awaited<ReturnType<typeof queryServiceMetricsViewTotals>>
>;
export type QueryServiceMetricsViewTotalsQueryError = ErrorType<RpcStatus>;

/**
 * @summary MetricsViewTotals returns totals over a time period for the measures in a metrics view.
It's a convenience API for querying a metrics view.
 */

export function createQueryServiceMetricsViewTotals<
  TData = Awaited<ReturnType<typeof queryServiceMetricsViewTotals>>,
  TError = ErrorType<RpcStatus>,
>(
  instanceId: string,
  metricsViewName: string,
  queryServiceMetricsViewTotalsBody: QueryServiceMetricsViewTotalsBody,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof queryServiceMetricsViewTotals>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): CreateQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getQueryServiceMetricsViewTotalsQueryOptions(
    instanceId,
    metricsViewName,
    queryServiceMetricsViewTotalsBody,
    options,
  );

  const query = createQuery(queryOptions, queryClient) as CreateQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Get the number of nulls in a column
 */
export const queryServiceColumnNullCount = (
  instanceId: string,
  tableName: string,
  params?: QueryServiceColumnNullCountParams,
  signal?: AbortSignal,
) => {
  return httpClient<V1ColumnNullCountResponse>({
    url: `/v1/instances/${instanceId}/queries/null-count/tables/${tableName}`,
    method: "GET",
    params,
    signal,
  });
};

export const getQueryServiceColumnNullCountQueryKey = (
  instanceId: string,
  tableName: string,
  params?: QueryServiceColumnNullCountParams,
) => {
  return [
    `/v1/instances/${instanceId}/queries/null-count/tables/${tableName}`,
    ...(params ? [params] : []),
  ] as const;
};

export const getQueryServiceColumnNullCountQueryOptions = <
  TData = Awaited<ReturnType<typeof queryServiceColumnNullCount>>,
  TError = ErrorType<RpcStatus>,
>(
  instanceId: string,
  tableName: string,
  params?: QueryServiceColumnNullCountParams,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof queryServiceColumnNullCount>>,
        TError,
        TData
      >
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getQueryServiceColumnNullCountQueryKey(instanceId, tableName, params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof queryServiceColumnNullCount>>
  > = ({ signal }) =>
    queryServiceColumnNullCount(instanceId, tableName, params, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!(instanceId && tableName),
    ...queryOptions,
  } as CreateQueryOptions<
    Awaited<ReturnType<typeof queryServiceColumnNullCount>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type QueryServiceColumnNullCountQueryResult = NonNullable<
  Awaited<ReturnType<typeof queryServiceColumnNullCount>>
>;
export type QueryServiceColumnNullCountQueryError = ErrorType<RpcStatus>;

/**
 * @summary Get the number of nulls in a column
 */

export function createQueryServiceColumnNullCount<
  TData = Awaited<ReturnType<typeof queryServiceColumnNullCount>>,
  TError = ErrorType<RpcStatus>,
>(
  instanceId: string,
  tableName: string,
  params?: QueryServiceColumnNullCountParams,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof queryServiceColumnNullCount>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): CreateQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getQueryServiceColumnNullCountQueryOptions(
    instanceId,
    tableName,
    params,
    options,
  );

  const query = createQuery(queryOptions, queryClient) as CreateQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Get the histogram for values in a column
 */
export const queryServiceColumnNumericHistogram = (
  instanceId: string,
  tableName: string,
  params?: QueryServiceColumnNumericHistogramParams,
  signal?: AbortSignal,
) => {
  return httpClient<V1ColumnNumericHistogramResponse>({
    url: `/v1/instances/${instanceId}/queries/numeric-histogram/tables/${tableName}`,
    method: "GET",
    params,
    signal,
  });
};

export const getQueryServiceColumnNumericHistogramQueryKey = (
  instanceId: string,
  tableName: string,
  params?: QueryServiceColumnNumericHistogramParams,
) => {
  return [
    `/v1/instances/${instanceId}/queries/numeric-histogram/tables/${tableName}`,
    ...(params ? [params] : []),
  ] as const;
};

export const getQueryServiceColumnNumericHistogramQueryOptions = <
  TData = Awaited<ReturnType<typeof queryServiceColumnNumericHistogram>>,
  TError = ErrorType<RpcStatus>,
>(
  instanceId: string,
  tableName: string,
  params?: QueryServiceColumnNumericHistogramParams,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof queryServiceColumnNumericHistogram>>,
        TError,
        TData
      >
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getQueryServiceColumnNumericHistogramQueryKey(
      instanceId,
      tableName,
      params,
    );

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof queryServiceColumnNumericHistogram>>
  > = ({ signal }) =>
    queryServiceColumnNumericHistogram(instanceId, tableName, params, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!(instanceId && tableName),
    ...queryOptions,
  } as CreateQueryOptions<
    Awaited<ReturnType<typeof queryServiceColumnNumericHistogram>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type QueryServiceColumnNumericHistogramQueryResult = NonNullable<
  Awaited<ReturnType<typeof queryServiceColumnNumericHistogram>>
>;
export type QueryServiceColumnNumericHistogramQueryError = ErrorType<RpcStatus>;

/**
 * @summary Get the histogram for values in a column
 */

export function createQueryServiceColumnNumericHistogram<
  TData = Awaited<ReturnType<typeof queryServiceColumnNumericHistogram>>,
  TError = ErrorType<RpcStatus>,
>(
  instanceId: string,
  tableName: string,
  params?: QueryServiceColumnNumericHistogramParams,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof queryServiceColumnNumericHistogram>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): CreateQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getQueryServiceColumnNumericHistogramQueryOptions(
    instanceId,
    tableName,
    params,
    options,
  );

  const query = createQuery(queryOptions, queryClient) as CreateQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary ColumnRollupInterval returns the minimum time granularity (as well as the time range) for a specified timestamp column
 */
export const queryServiceColumnRollupInterval = (
  instanceId: string,
  tableName: string,
  queryServiceColumnRollupIntervalBody: QueryServiceColumnRollupIntervalBody,
  signal?: AbortSignal,
) => {
  return httpClient<V1ColumnRollupIntervalResponse>({
    url: `/v1/instances/${instanceId}/queries/rollup-interval/tables/${tableName}`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: queryServiceColumnRollupIntervalBody,
    signal,
  });
};

export const getQueryServiceColumnRollupIntervalQueryKey = (
  instanceId: string,
  tableName: string,
  queryServiceColumnRollupIntervalBody: QueryServiceColumnRollupIntervalBody,
) => {
  return [
    `/v1/instances/${instanceId}/queries/rollup-interval/tables/${tableName}`,
    queryServiceColumnRollupIntervalBody,
  ] as const;
};

export const getQueryServiceColumnRollupIntervalQueryOptions = <
  TData = Awaited<ReturnType<typeof queryServiceColumnRollupInterval>>,
  TError = ErrorType<RpcStatus>,
>(
  instanceId: string,
  tableName: string,
  queryServiceColumnRollupIntervalBody: QueryServiceColumnRollupIntervalBody,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof queryServiceColumnRollupInterval>>,
        TError,
        TData
      >
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getQueryServiceColumnRollupIntervalQueryKey(
      instanceId,
      tableName,
      queryServiceColumnRollupIntervalBody,
    );

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof queryServiceColumnRollupInterval>>
  > = ({ signal }) =>
    queryServiceColumnRollupInterval(
      instanceId,
      tableName,
      queryServiceColumnRollupIntervalBody,
      signal,
    );

  return {
    queryKey,
    queryFn,
    enabled: !!(instanceId && tableName),
    ...queryOptions,
  } as CreateQueryOptions<
    Awaited<ReturnType<typeof queryServiceColumnRollupInterval>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type QueryServiceColumnRollupIntervalQueryResult = NonNullable<
  Awaited<ReturnType<typeof queryServiceColumnRollupInterval>>
>;
export type QueryServiceColumnRollupIntervalQueryError = ErrorType<RpcStatus>;

/**
 * @summary ColumnRollupInterval returns the minimum time granularity (as well as the time range) for a specified timestamp column
 */

export function createQueryServiceColumnRollupInterval<
  TData = Awaited<ReturnType<typeof queryServiceColumnRollupInterval>>,
  TError = ErrorType<RpcStatus>,
>(
  instanceId: string,
  tableName: string,
  queryServiceColumnRollupIntervalBody: QueryServiceColumnRollupIntervalBody,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof queryServiceColumnRollupInterval>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): CreateQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getQueryServiceColumnRollupIntervalQueryOptions(
    instanceId,
    tableName,
    queryServiceColumnRollupIntervalBody,
    options,
  );

  const query = createQuery(queryOptions, queryClient) as CreateQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary TableRows returns table rows
 */
export const queryServiceTableRows = (
  instanceId: string,
  tableName: string,
  params?: QueryServiceTableRowsParams,
  signal?: AbortSignal,
) => {
  return httpClient<V1TableRowsResponse>({
    url: `/v1/instances/${instanceId}/queries/rows/tables/${tableName}`,
    method: "GET",
    params,
    signal,
  });
};

export const getQueryServiceTableRowsQueryKey = (
  instanceId: string,
  tableName: string,
  params?: QueryServiceTableRowsParams,
) => {
  return [
    `/v1/instances/${instanceId}/queries/rows/tables/${tableName}`,
    ...(params ? [params] : []),
  ] as const;
};

export const getQueryServiceTableRowsQueryOptions = <
  TData = Awaited<ReturnType<typeof queryServiceTableRows>>,
  TError = ErrorType<RpcStatus>,
>(
  instanceId: string,
  tableName: string,
  params?: QueryServiceTableRowsParams,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof queryServiceTableRows>>,
        TError,
        TData
      >
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getQueryServiceTableRowsQueryKey(instanceId, tableName, params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof queryServiceTableRows>>
  > = ({ signal }) =>
    queryServiceTableRows(instanceId, tableName, params, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!(instanceId && tableName),
    ...queryOptions,
  } as CreateQueryOptions<
    Awaited<ReturnType<typeof queryServiceTableRows>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type QueryServiceTableRowsQueryResult = NonNullable<
  Awaited<ReturnType<typeof queryServiceTableRows>>
>;
export type QueryServiceTableRowsQueryError = ErrorType<RpcStatus>;

/**
 * @summary TableRows returns table rows
 */

export function createQueryServiceTableRows<
  TData = Awaited<ReturnType<typeof queryServiceTableRows>>,
  TError = ErrorType<RpcStatus>,
>(
  instanceId: string,
  tableName: string,
  params?: QueryServiceTableRowsParams,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof queryServiceTableRows>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): CreateQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getQueryServiceTableRowsQueryOptions(
    instanceId,
    tableName,
    params,
    options,
  );

  const query = createQuery(queryOptions, queryClient) as CreateQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Get outliers for a numeric column
 */
export const queryServiceColumnRugHistogram = (
  instanceId: string,
  tableName: string,
  params?: QueryServiceColumnRugHistogramParams,
  signal?: AbortSignal,
) => {
  return httpClient<V1ColumnRugHistogramResponse>({
    url: `/v1/instances/${instanceId}/queries/rug-histogram/tables/${tableName}`,
    method: "GET",
    params,
    signal,
  });
};

export const getQueryServiceColumnRugHistogramQueryKey = (
  instanceId: string,
  tableName: string,
  params?: QueryServiceColumnRugHistogramParams,
) => {
  return [
    `/v1/instances/${instanceId}/queries/rug-histogram/tables/${tableName}`,
    ...(params ? [params] : []),
  ] as const;
};

export const getQueryServiceColumnRugHistogramQueryOptions = <
  TData = Awaited<ReturnType<typeof queryServiceColumnRugHistogram>>,
  TError = ErrorType<RpcStatus>,
>(
  instanceId: string,
  tableName: string,
  params?: QueryServiceColumnRugHistogramParams,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof queryServiceColumnRugHistogram>>,
        TError,
        TData
      >
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getQueryServiceColumnRugHistogramQueryKey(instanceId, tableName, params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof queryServiceColumnRugHistogram>>
  > = ({ signal }) =>
    queryServiceColumnRugHistogram(instanceId, tableName, params, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!(instanceId && tableName),
    ...queryOptions,
  } as CreateQueryOptions<
    Awaited<ReturnType<typeof queryServiceColumnRugHistogram>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type QueryServiceColumnRugHistogramQueryResult = NonNullable<
  Awaited<ReturnType<typeof queryServiceColumnRugHistogram>>
>;
export type QueryServiceColumnRugHistogramQueryError = ErrorType<RpcStatus>;

/**
 * @summary Get outliers for a numeric column
 */

export function createQueryServiceColumnRugHistogram<
  TData = Awaited<ReturnType<typeof queryServiceColumnRugHistogram>>,
  TError = ErrorType<RpcStatus>,
>(
  instanceId: string,
  tableName: string,
  params?: QueryServiceColumnRugHistogramParams,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof queryServiceColumnRugHistogram>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): CreateQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getQueryServiceColumnRugHistogramQueryOptions(
    instanceId,
    tableName,
    params,
    options,
  );

  const query = createQuery(queryOptions, queryClient) as CreateQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Estimates the smallest time grain present in the column
 */
export const queryServiceColumnTimeGrain = (
  instanceId: string,
  tableName: string,
  params?: QueryServiceColumnTimeGrainParams,
  signal?: AbortSignal,
) => {
  return httpClient<V1ColumnTimeGrainResponse>({
    url: `/v1/instances/${instanceId}/queries/smallest-time-grain/tables/${tableName}`,
    method: "GET",
    params,
    signal,
  });
};

export const getQueryServiceColumnTimeGrainQueryKey = (
  instanceId: string,
  tableName: string,
  params?: QueryServiceColumnTimeGrainParams,
) => {
  return [
    `/v1/instances/${instanceId}/queries/smallest-time-grain/tables/${tableName}`,
    ...(params ? [params] : []),
  ] as const;
};

export const getQueryServiceColumnTimeGrainQueryOptions = <
  TData = Awaited<ReturnType<typeof queryServiceColumnTimeGrain>>,
  TError = ErrorType<RpcStatus>,
>(
  instanceId: string,
  tableName: string,
  params?: QueryServiceColumnTimeGrainParams,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof queryServiceColumnTimeGrain>>,
        TError,
        TData
      >
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getQueryServiceColumnTimeGrainQueryKey(instanceId, tableName, params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof queryServiceColumnTimeGrain>>
  > = ({ signal }) =>
    queryServiceColumnTimeGrain(instanceId, tableName, params, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!(instanceId && tableName),
    ...queryOptions,
  } as CreateQueryOptions<
    Awaited<ReturnType<typeof queryServiceColumnTimeGrain>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type QueryServiceColumnTimeGrainQueryResult = NonNullable<
  Awaited<ReturnType<typeof queryServiceColumnTimeGrain>>
>;
export type QueryServiceColumnTimeGrainQueryError = ErrorType<RpcStatus>;

/**
 * @summary Estimates the smallest time grain present in the column
 */

export function createQueryServiceColumnTimeGrain<
  TData = Awaited<ReturnType<typeof queryServiceColumnTimeGrain>>,
  TError = ErrorType<RpcStatus>,
>(
  instanceId: string,
  tableName: string,
  params?: QueryServiceColumnTimeGrainParams,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof queryServiceColumnTimeGrain>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): CreateQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getQueryServiceColumnTimeGrainQueryOptions(
    instanceId,
    tableName,
    params,
    options,
  );

  const query = createQuery(queryOptions, queryClient) as CreateQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary TableCardinality returns row count
 */
export const queryServiceTableCardinality = (
  instanceId: string,
  tableName: string,
  params?: QueryServiceTableCardinalityParams,
  signal?: AbortSignal,
) => {
  return httpClient<V1TableCardinalityResponse>({
    url: `/v1/instances/${instanceId}/queries/table-cardinality/tables/${tableName}`,
    method: "GET",
    params,
    signal,
  });
};

export const getQueryServiceTableCardinalityQueryKey = (
  instanceId: string,
  tableName: string,
  params?: QueryServiceTableCardinalityParams,
) => {
  return [
    `/v1/instances/${instanceId}/queries/table-cardinality/tables/${tableName}`,
    ...(params ? [params] : []),
  ] as const;
};

export const getQueryServiceTableCardinalityQueryOptions = <
  TData = Awaited<ReturnType<typeof queryServiceTableCardinality>>,
  TError = ErrorType<RpcStatus>,
>(
  instanceId: string,
  tableName: string,
  params?: QueryServiceTableCardinalityParams,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof queryServiceTableCardinality>>,
        TError,
        TData
      >
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getQueryServiceTableCardinalityQueryKey(instanceId, tableName, params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof queryServiceTableCardinality>>
  > = ({ signal }) =>
    queryServiceTableCardinality(instanceId, tableName, params, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!(instanceId && tableName),
    ...queryOptions,
  } as CreateQueryOptions<
    Awaited<ReturnType<typeof queryServiceTableCardinality>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type QueryServiceTableCardinalityQueryResult = NonNullable<
  Awaited<ReturnType<typeof queryServiceTableCardinality>>
>;
export type QueryServiceTableCardinalityQueryError = ErrorType<RpcStatus>;

/**
 * @summary TableCardinality returns row count
 */

export function createQueryServiceTableCardinality<
  TData = Awaited<ReturnType<typeof queryServiceTableCardinality>>,
  TError = ErrorType<RpcStatus>,
>(
  instanceId: string,
  tableName: string,
  params?: QueryServiceTableCardinalityParams,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof queryServiceTableCardinality>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): CreateQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getQueryServiceTableCardinalityQueryOptions(
    instanceId,
    tableName,
    params,
    options,
  );

  const query = createQuery(queryOptions, queryClient) as CreateQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Get the time range summaries (min, max) for a column
 */
export const queryServiceColumnTimeRange = (
  instanceId: string,
  tableName: string,
  params?: QueryServiceColumnTimeRangeParams,
  signal?: AbortSignal,
) => {
  return httpClient<V1ColumnTimeRangeResponse>({
    url: `/v1/instances/${instanceId}/queries/time-range-summary/tables/${tableName}`,
    method: "GET",
    params,
    signal,
  });
};

export const getQueryServiceColumnTimeRangeQueryKey = (
  instanceId: string,
  tableName: string,
  params?: QueryServiceColumnTimeRangeParams,
) => {
  return [
    `/v1/instances/${instanceId}/queries/time-range-summary/tables/${tableName}`,
    ...(params ? [params] : []),
  ] as const;
};

export const getQueryServiceColumnTimeRangeQueryOptions = <
  TData = Awaited<ReturnType<typeof queryServiceColumnTimeRange>>,
  TError = ErrorType<RpcStatus>,
>(
  instanceId: string,
  tableName: string,
  params?: QueryServiceColumnTimeRangeParams,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof queryServiceColumnTimeRange>>,
        TError,
        TData
      >
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getQueryServiceColumnTimeRangeQueryKey(instanceId, tableName, params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof queryServiceColumnTimeRange>>
  > = ({ signal }) =>
    queryServiceColumnTimeRange(instanceId, tableName, params, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!(instanceId && tableName),
    ...queryOptions,
  } as CreateQueryOptions<
    Awaited<ReturnType<typeof queryServiceColumnTimeRange>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type QueryServiceColumnTimeRangeQueryResult = NonNullable<
  Awaited<ReturnType<typeof queryServiceColumnTimeRange>>
>;
export type QueryServiceColumnTimeRangeQueryError = ErrorType<RpcStatus>;

/**
 * @summary Get the time range summaries (min, max) for a column
 */

export function createQueryServiceColumnTimeRange<
  TData = Awaited<ReturnType<typeof queryServiceColumnTimeRange>>,
  TError = ErrorType<RpcStatus>,
>(
  instanceId: string,
  tableName: string,
  params?: QueryServiceColumnTimeRangeParams,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof queryServiceColumnTimeRange>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): CreateQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getQueryServiceColumnTimeRangeQueryOptions(
    instanceId,
    tableName,
    params,
    options,
  );

  const query = createQuery(queryOptions, queryClient) as CreateQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Generate time series for the given measures (aggregation expressions) along with the sparkline timeseries
 */
export const queryServiceColumnTimeSeries = (
  instanceId: string,
  tableName: string,
  queryServiceColumnTimeSeriesBody: QueryServiceColumnTimeSeriesBody,
  signal?: AbortSignal,
) => {
  return httpClient<V1ColumnTimeSeriesResponse>({
    url: `/v1/instances/${instanceId}/queries/timeseries/tables/${tableName}`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: queryServiceColumnTimeSeriesBody,
    signal,
  });
};

export const getQueryServiceColumnTimeSeriesQueryKey = (
  instanceId: string,
  tableName: string,
  queryServiceColumnTimeSeriesBody: QueryServiceColumnTimeSeriesBody,
) => {
  return [
    `/v1/instances/${instanceId}/queries/timeseries/tables/${tableName}`,
    queryServiceColumnTimeSeriesBody,
  ] as const;
};

export const getQueryServiceColumnTimeSeriesQueryOptions = <
  TData = Awaited<ReturnType<typeof queryServiceColumnTimeSeries>>,
  TError = ErrorType<RpcStatus>,
>(
  instanceId: string,
  tableName: string,
  queryServiceColumnTimeSeriesBody: QueryServiceColumnTimeSeriesBody,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof queryServiceColumnTimeSeries>>,
        TError,
        TData
      >
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getQueryServiceColumnTimeSeriesQueryKey(
      instanceId,
      tableName,
      queryServiceColumnTimeSeriesBody,
    );

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof queryServiceColumnTimeSeries>>
  > = ({ signal }) =>
    queryServiceColumnTimeSeries(
      instanceId,
      tableName,
      queryServiceColumnTimeSeriesBody,
      signal,
    );

  return {
    queryKey,
    queryFn,
    enabled: !!(instanceId && tableName),
    ...queryOptions,
  } as CreateQueryOptions<
    Awaited<ReturnType<typeof queryServiceColumnTimeSeries>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type QueryServiceColumnTimeSeriesQueryResult = NonNullable<
  Awaited<ReturnType<typeof queryServiceColumnTimeSeries>>
>;
export type QueryServiceColumnTimeSeriesQueryError = ErrorType<RpcStatus>;

/**
 * @summary Generate time series for the given measures (aggregation expressions) along with the sparkline timeseries
 */

export function createQueryServiceColumnTimeSeries<
  TData = Awaited<ReturnType<typeof queryServiceColumnTimeSeries>>,
  TError = ErrorType<RpcStatus>,
>(
  instanceId: string,
  tableName: string,
  queryServiceColumnTimeSeriesBody: QueryServiceColumnTimeSeriesBody,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof queryServiceColumnTimeSeries>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): CreateQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getQueryServiceColumnTimeSeriesQueryOptions(
    instanceId,
    tableName,
    queryServiceColumnTimeSeriesBody,
    options,
  );

  const query = createQuery(queryOptions, queryClient) as CreateQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Get TopK elements from a table for a column given an agg function
agg function and k are optional, defaults are count(*) and 50 respectively
 */
export const queryServiceColumnTopK = (
  instanceId: string,
  tableName: string,
  queryServiceColumnTopKBody: QueryServiceColumnTopKBody,
  signal?: AbortSignal,
) => {
  return httpClient<V1ColumnTopKResponse>({
    url: `/v1/instances/${instanceId}/queries/topk/tables/${tableName}`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: queryServiceColumnTopKBody,
    signal,
  });
};

export const getQueryServiceColumnTopKQueryKey = (
  instanceId: string,
  tableName: string,
  queryServiceColumnTopKBody: QueryServiceColumnTopKBody,
) => {
  return [
    `/v1/instances/${instanceId}/queries/topk/tables/${tableName}`,
    queryServiceColumnTopKBody,
  ] as const;
};

export const getQueryServiceColumnTopKQueryOptions = <
  TData = Awaited<ReturnType<typeof queryServiceColumnTopK>>,
  TError = ErrorType<RpcStatus>,
>(
  instanceId: string,
  tableName: string,
  queryServiceColumnTopKBody: QueryServiceColumnTopKBody,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof queryServiceColumnTopK>>,
        TError,
        TData
      >
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getQueryServiceColumnTopKQueryKey(
      instanceId,
      tableName,
      queryServiceColumnTopKBody,
    );

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof queryServiceColumnTopK>>
  > = ({ signal }) =>
    queryServiceColumnTopK(
      instanceId,
      tableName,
      queryServiceColumnTopKBody,
      signal,
    );

  return {
    queryKey,
    queryFn,
    enabled: !!(instanceId && tableName),
    ...queryOptions,
  } as CreateQueryOptions<
    Awaited<ReturnType<typeof queryServiceColumnTopK>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type QueryServiceColumnTopKQueryResult = NonNullable<
  Awaited<ReturnType<typeof queryServiceColumnTopK>>
>;
export type QueryServiceColumnTopKQueryError = ErrorType<RpcStatus>;

/**
 * @summary Get TopK elements from a table for a column given an agg function
agg function and k are optional, defaults are count(*) and 50 respectively
 */

export function createQueryServiceColumnTopK<
  TData = Awaited<ReturnType<typeof queryServiceColumnTopK>>,
  TError = ErrorType<RpcStatus>,
>(
  instanceId: string,
  tableName: string,
  queryServiceColumnTopKBody: QueryServiceColumnTopKBody,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof queryServiceColumnTopK>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): CreateQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getQueryServiceColumnTopKQueryOptions(
    instanceId,
    tableName,
    queryServiceColumnTopKBody,
    options,
  );

  const query = createQuery(queryOptions, queryClient) as CreateQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Query runs a SQL query against the instance's OLAP datastore.
 */
export const queryServiceQuery = (
  instanceId: string,
  queryServiceQueryBody: QueryServiceQueryBody,
  signal?: AbortSignal,
) => {
  return httpClient<V1QueryResponse>({
    url: `/v1/instances/${instanceId}/query`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: queryServiceQueryBody,
    signal,
  });
};

export const getQueryServiceQueryMutationOptions = <
  TError = ErrorType<RpcStatus>,
  TContext = unknown,
>(options?: {
  mutation?: CreateMutationOptions<
    Awaited<ReturnType<typeof queryServiceQuery>>,
    TError,
    { instanceId: string; data: QueryServiceQueryBody },
    TContext
  >;
}): CreateMutationOptions<
  Awaited<ReturnType<typeof queryServiceQuery>>,
  TError,
  { instanceId: string; data: QueryServiceQueryBody },
  TContext
> => {
  const mutationKey = ["queryServiceQuery"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof queryServiceQuery>>,
    { instanceId: string; data: QueryServiceQueryBody }
  > = (props) => {
    const { instanceId, data } = props ?? {};

    return queryServiceQuery(instanceId, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type QueryServiceQueryMutationResult = NonNullable<
  Awaited<ReturnType<typeof queryServiceQuery>>
>;
export type QueryServiceQueryMutationBody = QueryServiceQueryBody;
export type QueryServiceQueryMutationError = ErrorType<RpcStatus>;

/**
 * @summary Query runs a SQL query against the instance's OLAP datastore.
 */
export const createQueryServiceQuery = <
  TError = ErrorType<RpcStatus>,
  TContext = unknown,
>(
  options?: {
    mutation?: CreateMutationOptions<
      Awaited<ReturnType<typeof queryServiceQuery>>,
      TError,
      { instanceId: string; data: QueryServiceQueryBody },
      TContext
    >;
  },
  queryClient?: QueryClient,
): CreateMutationResult<
  Awaited<ReturnType<typeof queryServiceQuery>>,
  TError,
  { instanceId: string; data: QueryServiceQueryBody },
  TContext
> => {
  const mutationOptions = getQueryServiceQueryMutationOptions(options);

  return createMutation(mutationOptions, queryClient);
};
/**
 * @summary Batch request with different queries
 */
export const queryServiceQueryBatch = (
  instanceId: string,
  queryServiceQueryBatchBody: QueryServiceQueryBatchBody,
  signal?: AbortSignal,
) => {
  return httpClient<QueryServiceQueryBatch200>({
    url: `/v1/instances/${instanceId}/query/batch`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: queryServiceQueryBatchBody,
    signal,
  });
};

export const getQueryServiceQueryBatchMutationOptions = <
  TError = ErrorType<RpcStatus>,
  TContext = unknown,
>(options?: {
  mutation?: CreateMutationOptions<
    Awaited<ReturnType<typeof queryServiceQueryBatch>>,
    TError,
    { instanceId: string; data: QueryServiceQueryBatchBody },
    TContext
  >;
}): CreateMutationOptions<
  Awaited<ReturnType<typeof queryServiceQueryBatch>>,
  TError,
  { instanceId: string; data: QueryServiceQueryBatchBody },
  TContext
> => {
  const mutationKey = ["queryServiceQueryBatch"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof queryServiceQueryBatch>>,
    { instanceId: string; data: QueryServiceQueryBatchBody }
  > = (props) => {
    const { instanceId, data } = props ?? {};

    return queryServiceQueryBatch(instanceId, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type QueryServiceQueryBatchMutationResult = NonNullable<
  Awaited<ReturnType<typeof queryServiceQueryBatch>>
>;
export type QueryServiceQueryBatchMutationBody = QueryServiceQueryBatchBody;
export type QueryServiceQueryBatchMutationError = ErrorType<RpcStatus>;

/**
 * @summary Batch request with different queries
 */
export const createQueryServiceQueryBatch = <
  TError = ErrorType<RpcStatus>,
  TContext = unknown,
>(
  options?: {
    mutation?: CreateMutationOptions<
      Awaited<ReturnType<typeof queryServiceQueryBatch>>,
      TError,
      { instanceId: string; data: QueryServiceQueryBatchBody },
      TContext
    >;
  },
  queryClient?: QueryClient,
): CreateMutationResult<
  Awaited<ReturnType<typeof queryServiceQueryBatch>>,
  TError,
  { instanceId: string; data: QueryServiceQueryBatchBody },
  TContext
> => {
  const mutationOptions = getQueryServiceQueryBatchMutationOptions(options);

  return createMutation(mutationOptions, queryClient);
};
/**
 * @summary ExportReport builds a URL to download the results of a query as a file.
 */
export const queryServiceExportReport = (
  instanceId: string,
  report: string,
  queryServiceExportReportBody: QueryServiceExportReportBody,
  signal?: AbortSignal,
) => {
  return httpClient<V1ExportReportResponse>({
    url: `/v1/instances/${instanceId}/reports/${report}/export`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: queryServiceExportReportBody,
    signal,
  });
};

export const getQueryServiceExportReportMutationOptions = <
  TError = ErrorType<RpcStatus>,
  TContext = unknown,
>(options?: {
  mutation?: CreateMutationOptions<
    Awaited<ReturnType<typeof queryServiceExportReport>>,
    TError,
    { instanceId: string; report: string; data: QueryServiceExportReportBody },
    TContext
  >;
}): CreateMutationOptions<
  Awaited<ReturnType<typeof queryServiceExportReport>>,
  TError,
  { instanceId: string; report: string; data: QueryServiceExportReportBody },
  TContext
> => {
  const mutationKey = ["queryServiceExportReport"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof queryServiceExportReport>>,
    { instanceId: string; report: string; data: QueryServiceExportReportBody }
  > = (props) => {
    const { instanceId, report, data } = props ?? {};

    return queryServiceExportReport(instanceId, report, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type QueryServiceExportReportMutationResult = NonNullable<
  Awaited<ReturnType<typeof queryServiceExportReport>>
>;
export type QueryServiceExportReportMutationBody = QueryServiceExportReportBody;
export type QueryServiceExportReportMutationError = ErrorType<RpcStatus>;

/**
 * @summary ExportReport builds a URL to download the results of a query as a file.
 */
export const createQueryServiceExportReport = <
  TError = ErrorType<RpcStatus>,
  TContext = unknown,
>(
  options?: {
    mutation?: CreateMutationOptions<
      Awaited<ReturnType<typeof queryServiceExportReport>>,
      TError,
      {
        instanceId: string;
        report: string;
        data: QueryServiceExportReportBody;
      },
      TContext
    >;
  },
  queryClient?: QueryClient,
): CreateMutationResult<
  Awaited<ReturnType<typeof queryServiceExportReport>>,
  TError,
  { instanceId: string; report: string; data: QueryServiceExportReportBody },
  TContext
> => {
  const mutationOptions = getQueryServiceExportReportMutationOptions(options);

  return createMutation(mutationOptions, queryClient);
};

/**
 * Generated by orval v8.4.0 üç∫
 * Do not edit manually.
 * rill/runtime/v1/schema.proto
 * OpenAPI spec version: version not set
 */
import { createMutation, createQuery } from "@tanstack/svelte-query";
import type {
  CreateMutationOptions,
  CreateMutationResult,
  CreateQueryOptions,
  CreateQueryResult,
  DataTag,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
} from "@tanstack/svelte-query";

import type {
  QueryServiceColumnCardinalityParams,
  QueryServiceColumnDescriptiveStatisticsParams,
  QueryServiceColumnNullCountParams,
  QueryServiceColumnNumericHistogramParams,
  QueryServiceColumnRollupIntervalBody,
  QueryServiceColumnRugHistogramParams,
  QueryServiceColumnTimeGrainParams,
  QueryServiceColumnTimeRangeParams,
  QueryServiceColumnTimeSeriesBody,
  QueryServiceColumnTopKBody,
  QueryServiceConvertExpressionToMetricsSQLBody,
  QueryServiceExportBody,
  QueryServiceExportReportBody,
  QueryServiceMetricsViewAggregationBody,
  QueryServiceMetricsViewAnnotationsBody,
  QueryServiceMetricsViewComparisonBody,
  QueryServiceMetricsViewRowsBody,
  QueryServiceMetricsViewSchemaParams,
  QueryServiceMetricsViewSearchBody,
  QueryServiceMetricsViewTimeRangeBody,
  QueryServiceMetricsViewTimeRangesBody,
  QueryServiceMetricsViewTimeSeriesBody,
  QueryServiceMetricsViewToplistBody,
  QueryServiceMetricsViewTotalsBody,
  QueryServiceQueryBatch200,
  QueryServiceQueryBatchBody,
  QueryServiceQueryBody,
  QueryServiceResolveCanvasBody,
  QueryServiceResolveComponentBody,
  QueryServiceResolveTemplatedStringBody,
  QueryServiceTableCardinalityParams,
  QueryServiceTableColumnsParams,
  QueryServiceTableRowsParams,
  RpcStatus,
  V1ColumnCardinalityResponse,
  V1ColumnDescriptiveStatisticsResponse,
  V1ColumnNullCountResponse,
  V1ColumnNumericHistogramResponse,
  V1ColumnRollupIntervalResponse,
  V1ColumnRugHistogramResponse,
  V1ColumnTimeGrainResponse,
  V1ColumnTimeRangeResponse,
  V1ColumnTimeSeriesResponse,
  V1ColumnTopKResponse,
  V1ConvertExpressionToMetricsSQLResponse,
  V1ExportReportResponse,
  V1ExportResponse,
  V1MetricsViewAggregationResponse,
  V1MetricsViewAnnotationsResponse,
  V1MetricsViewComparisonResponse,
  V1MetricsViewRowsResponse,
  V1MetricsViewSchemaResponse,
  V1MetricsViewSearchResponse,
  V1MetricsViewTimeRangeResponse,
  V1MetricsViewTimeRangesResponse,
  V1MetricsViewTimeSeriesResponse,
  V1MetricsViewToplistResponse,
  V1MetricsViewTotalsResponse,
  V1QueryResponse,
  V1ResolveCanvasResponse,
  V1ResolveComponentResponse,
  V1ResolveTemplatedStringResponse,
  V1TableCardinalityResponse,
  V1TableColumnsResponse,
  V1TableRowsResponse,
} from "../index.schemas";

import { httpClient } from "../../http-client";
import type { ErrorType } from "../../http-client";

type AwaitedInput<T> = PromiseLike<T> | T;

type Awaited<O> = O extends AwaitedInput<infer T> ? T : never;

export type HTTPStatusCode1xx = 100 | 101 | 102 | 103;
export type HTTPStatusCode2xx = 200 | 201 | 202 | 203 | 204 | 205 | 206 | 207;
export type HTTPStatusCode3xx = 300 | 301 | 302 | 303 | 304 | 305 | 307 | 308;
export type HTTPStatusCode4xx =
  | 400
  | 401
  | 402
  | 403
  | 404
  | 405
  | 406
  | 407
  | 408
  | 409
  | 410
  | 411
  | 412
  | 413
  | 414
  | 415
  | 416
  | 417
  | 418
  | 419
  | 420
  | 421
  | 422
  | 423
  | 424
  | 426
  | 428
  | 429
  | 431
  | 451;
export type HTTPStatusCode5xx = 500 | 501 | 502 | 503 | 504 | 505 | 507 | 511;
export type HTTPStatusCodes =
  | HTTPStatusCode1xx
  | HTTPStatusCode2xx
  | HTTPStatusCode3xx
  | HTTPStatusCode4xx
  | HTTPStatusCode5xx;

/**
 * @summary ResolveCanvas is a convenience API that returns a canvas and all its referenced components and metrics views.
 */
export type queryServiceResolveCanvasResponse200 = {
  data: V1ResolveCanvasResponse;
  status: 200;
};

export type queryServiceResolveCanvasResponseDefault = {
  data: RpcStatus;
  status: Exclude<HTTPStatusCodes, 200>;
};

export type queryServiceResolveCanvasResponseSuccess =
  queryServiceResolveCanvasResponse200 & {
    headers: Headers;
  };
export type queryServiceResolveCanvasResponseError =
  queryServiceResolveCanvasResponseDefault & {
    headers: Headers;
  };

export type queryServiceResolveCanvasResponse =
  | queryServiceResolveCanvasResponseSuccess
  | queryServiceResolveCanvasResponseError;

export const getQueryServiceResolveCanvasUrl = (
  instanceId: string,
  canvas: string,
) => {
  return `/v1/instances/${instanceId}/queries/canvases/${canvas}/resolve`;
};

export const queryServiceResolveCanvas = async (
  instanceId: string,
  canvas: string,
  queryServiceResolveCanvasBody: QueryServiceResolveCanvasBody,
  options?: RequestInit,
): Promise<queryServiceResolveCanvasResponse> => {
  return httpClient<queryServiceResolveCanvasResponse>(
    getQueryServiceResolveCanvasUrl(instanceId, canvas),
    {
      ...options,
      method: "POST",
      headers: { "Content-Type": "application/json", ...options?.headers },
      body: JSON.stringify(queryServiceResolveCanvasBody),
    },
  );
};

export const getQueryServiceResolveCanvasQueryKey = (
  instanceId: string,
  canvas: string,
  queryServiceResolveCanvasBody?: QueryServiceResolveCanvasBody,
) => {
  return [
    `/v1/instances/${instanceId}/queries/canvases/${canvas}/resolve`,
    queryServiceResolveCanvasBody,
  ] as const;
};

export const getQueryServiceResolveCanvasQueryOptions = <
  TData = Awaited<ReturnType<typeof queryServiceResolveCanvas>>,
  TError = ErrorType<RpcStatus>,
>(
  instanceId: string,
  canvas: string,
  queryServiceResolveCanvasBody: QueryServiceResolveCanvasBody,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof queryServiceResolveCanvas>>,
        TError,
        TData
      >
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getQueryServiceResolveCanvasQueryKey(
      instanceId,
      canvas,
      queryServiceResolveCanvasBody,
    );

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof queryServiceResolveCanvas>>
  > = ({ signal }) =>
    queryServiceResolveCanvas(
      instanceId,
      canvas,
      queryServiceResolveCanvasBody,
      { signal },
    );

  return {
    queryKey,
    queryFn,
    enabled: !!(instanceId && canvas),
    ...queryOptions,
  } as CreateQueryOptions<
    Awaited<ReturnType<typeof queryServiceResolveCanvas>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type QueryServiceResolveCanvasQueryResult = NonNullable<
  Awaited<ReturnType<typeof queryServiceResolveCanvas>>
>;
export type QueryServiceResolveCanvasQueryError = ErrorType<RpcStatus>;

/**
 * @summary ResolveCanvas is a convenience API that returns a canvas and all its referenced components and metrics views.
 */

export function createQueryServiceResolveCanvas<
  TData = Awaited<ReturnType<typeof queryServiceResolveCanvas>>,
  TError = ErrorType<RpcStatus>,
>(
  instanceId: () => string,
  canvas: () => string,
  queryServiceResolveCanvasBody: () => QueryServiceResolveCanvasBody,
  options?: () => {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof queryServiceResolveCanvas>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: () => QueryClient,
): CreateQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const query = createQuery(
    () =>
      getQueryServiceResolveCanvasQueryOptions(
        instanceId(),
        canvas(),
        queryServiceResolveCanvasBody(),
        options?.(),
      ),
    queryClient,
  ) as CreateQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  return query;
}

/**
 * @summary Get cardinality for a column
 */
export type queryServiceColumnCardinalityResponse200 = {
  data: V1ColumnCardinalityResponse;
  status: 200;
};

export type queryServiceColumnCardinalityResponseDefault = {
  data: RpcStatus;
  status: Exclude<HTTPStatusCodes, 200>;
};

export type queryServiceColumnCardinalityResponseSuccess =
  queryServiceColumnCardinalityResponse200 & {
    headers: Headers;
  };
export type queryServiceColumnCardinalityResponseError =
  queryServiceColumnCardinalityResponseDefault & {
    headers: Headers;
  };

export type queryServiceColumnCardinalityResponse =
  | queryServiceColumnCardinalityResponseSuccess
  | queryServiceColumnCardinalityResponseError;

export const getQueryServiceColumnCardinalityUrl = (
  instanceId: string,
  tableName: string,
  params?: QueryServiceColumnCardinalityParams,
) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? "null" : value.toString());
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0
    ? `/v1/instances/${instanceId}/queries/column-cardinality/tables/${tableName}?${stringifiedParams}`
    : `/v1/instances/${instanceId}/queries/column-cardinality/tables/${tableName}`;
};

export const queryServiceColumnCardinality = async (
  instanceId: string,
  tableName: string,
  params?: QueryServiceColumnCardinalityParams,
  options?: RequestInit,
): Promise<queryServiceColumnCardinalityResponse> => {
  return httpClient<queryServiceColumnCardinalityResponse>(
    getQueryServiceColumnCardinalityUrl(instanceId, tableName, params),
    {
      ...options,
      method: "GET",
    },
  );
};

export const getQueryServiceColumnCardinalityQueryKey = (
  instanceId: string,
  tableName: string,
  params?: QueryServiceColumnCardinalityParams,
) => {
  return [
    `/v1/instances/${instanceId}/queries/column-cardinality/tables/${tableName}`,
    ...(params ? [params] : []),
  ] as const;
};

export const getQueryServiceColumnCardinalityQueryOptions = <
  TData = Awaited<ReturnType<typeof queryServiceColumnCardinality>>,
  TError = ErrorType<RpcStatus>,
>(
  instanceId: string,
  tableName: string,
  params?: QueryServiceColumnCardinalityParams,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof queryServiceColumnCardinality>>,
        TError,
        TData
      >
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getQueryServiceColumnCardinalityQueryKey(instanceId, tableName, params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof queryServiceColumnCardinality>>
  > = ({ signal }) =>
    queryServiceColumnCardinality(instanceId, tableName, params, { signal });

  return {
    queryKey,
    queryFn,
    enabled: !!(instanceId && tableName),
    ...queryOptions,
  } as CreateQueryOptions<
    Awaited<ReturnType<typeof queryServiceColumnCardinality>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type QueryServiceColumnCardinalityQueryResult = NonNullable<
  Awaited<ReturnType<typeof queryServiceColumnCardinality>>
>;
export type QueryServiceColumnCardinalityQueryError = ErrorType<RpcStatus>;

/**
 * @summary Get cardinality for a column
 */

export function createQueryServiceColumnCardinality<
  TData = Awaited<ReturnType<typeof queryServiceColumnCardinality>>,
  TError = ErrorType<RpcStatus>,
>(
  instanceId: () => string,
  tableName: () => string,
  params?: () => QueryServiceColumnCardinalityParams,
  options?: () => {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof queryServiceColumnCardinality>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: () => QueryClient,
): CreateQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const query = createQuery(
    () =>
      getQueryServiceColumnCardinalityQueryOptions(
        instanceId(),
        tableName(),
        params?.(),
        options?.(),
      ),
    queryClient,
  ) as CreateQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  return query;
}

/**
 * @summary TableColumns returns column profiles
 */
export type queryServiceTableColumnsResponse200 = {
  data: V1TableColumnsResponse;
  status: 200;
};

export type queryServiceTableColumnsResponseDefault = {
  data: RpcStatus;
  status: Exclude<HTTPStatusCodes, 200>;
};

export type queryServiceTableColumnsResponseSuccess =
  queryServiceTableColumnsResponse200 & {
    headers: Headers;
  };
export type queryServiceTableColumnsResponseError =
  queryServiceTableColumnsResponseDefault & {
    headers: Headers;
  };

export type queryServiceTableColumnsResponse =
  | queryServiceTableColumnsResponseSuccess
  | queryServiceTableColumnsResponseError;

export const getQueryServiceTableColumnsUrl = (
  instanceId: string,
  tableName: string,
  params?: QueryServiceTableColumnsParams,
) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? "null" : value.toString());
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0
    ? `/v1/instances/${instanceId}/queries/columns-profile/tables/${tableName}?${stringifiedParams}`
    : `/v1/instances/${instanceId}/queries/columns-profile/tables/${tableName}`;
};

export const queryServiceTableColumns = async (
  instanceId: string,
  tableName: string,
  params?: QueryServiceTableColumnsParams,
  options?: RequestInit,
): Promise<queryServiceTableColumnsResponse> => {
  return httpClient<queryServiceTableColumnsResponse>(
    getQueryServiceTableColumnsUrl(instanceId, tableName, params),
    {
      ...options,
      method: "POST",
    },
  );
};

export const getQueryServiceTableColumnsQueryKey = (
  instanceId: string,
  tableName: string,
  params?: QueryServiceTableColumnsParams,
) => {
  return [
    `/v1/instances/${instanceId}/queries/columns-profile/tables/${tableName}`,
    ...(params ? [params] : []),
  ] as const;
};

export const getQueryServiceTableColumnsQueryOptions = <
  TData = Awaited<ReturnType<typeof queryServiceTableColumns>>,
  TError = ErrorType<RpcStatus>,
>(
  instanceId: string,
  tableName: string,
  params?: QueryServiceTableColumnsParams,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof queryServiceTableColumns>>,
        TError,
        TData
      >
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getQueryServiceTableColumnsQueryKey(instanceId, tableName, params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof queryServiceTableColumns>>
  > = ({ signal }) =>
    queryServiceTableColumns(instanceId, tableName, params, { signal });

  return {
    queryKey,
    queryFn,
    enabled: !!(instanceId && tableName),
    ...queryOptions,
  } as CreateQueryOptions<
    Awaited<ReturnType<typeof queryServiceTableColumns>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type QueryServiceTableColumnsQueryResult = NonNullable<
  Awaited<ReturnType<typeof queryServiceTableColumns>>
>;
export type QueryServiceTableColumnsQueryError = ErrorType<RpcStatus>;

/**
 * @summary TableColumns returns column profiles
 */

export function createQueryServiceTableColumns<
  TData = Awaited<ReturnType<typeof queryServiceTableColumns>>,
  TError = ErrorType<RpcStatus>,
>(
  instanceId: () => string,
  tableName: () => string,
  params?: () => QueryServiceTableColumnsParams,
  options?: () => {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof queryServiceTableColumns>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: () => QueryClient,
): CreateQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const query = createQuery(
    () =>
      getQueryServiceTableColumnsQueryOptions(
        instanceId(),
        tableName(),
        params?.(),
        options?.(),
      ),
    queryClient,
  ) as CreateQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  return query;
}

/**
 * @summary ResolveComponent resolves renderer for a Component resource.
 */
export type queryServiceResolveComponentResponse200 = {
  data: V1ResolveComponentResponse;
  status: 200;
};

export type queryServiceResolveComponentResponseDefault = {
  data: RpcStatus;
  status: Exclude<HTTPStatusCodes, 200>;
};

export type queryServiceResolveComponentResponseSuccess =
  queryServiceResolveComponentResponse200 & {
    headers: Headers;
  };
export type queryServiceResolveComponentResponseError =
  queryServiceResolveComponentResponseDefault & {
    headers: Headers;
  };

export type queryServiceResolveComponentResponse =
  | queryServiceResolveComponentResponseSuccess
  | queryServiceResolveComponentResponseError;

export const getQueryServiceResolveComponentUrl = (
  instanceId: string,
  component: string,
) => {
  return `/v1/instances/${instanceId}/queries/components/${component}/resolve`;
};

export const queryServiceResolveComponent = async (
  instanceId: string,
  component: string,
  queryServiceResolveComponentBody: QueryServiceResolveComponentBody,
  options?: RequestInit,
): Promise<queryServiceResolveComponentResponse> => {
  return httpClient<queryServiceResolveComponentResponse>(
    getQueryServiceResolveComponentUrl(instanceId, component),
    {
      ...options,
      method: "POST",
      headers: { "Content-Type": "application/json", ...options?.headers },
      body: JSON.stringify(queryServiceResolveComponentBody),
    },
  );
};

export const getQueryServiceResolveComponentQueryKey = (
  instanceId: string,
  component: string,
  queryServiceResolveComponentBody?: QueryServiceResolveComponentBody,
) => {
  return [
    `/v1/instances/${instanceId}/queries/components/${component}/resolve`,
    queryServiceResolveComponentBody,
  ] as const;
};

export const getQueryServiceResolveComponentQueryOptions = <
  TData = Awaited<ReturnType<typeof queryServiceResolveComponent>>,
  TError = ErrorType<RpcStatus>,
>(
  instanceId: string,
  component: string,
  queryServiceResolveComponentBody: QueryServiceResolveComponentBody,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof queryServiceResolveComponent>>,
        TError,
        TData
      >
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getQueryServiceResolveComponentQueryKey(
      instanceId,
      component,
      queryServiceResolveComponentBody,
    );

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof queryServiceResolveComponent>>
  > = ({ signal }) =>
    queryServiceResolveComponent(
      instanceId,
      component,
      queryServiceResolveComponentBody,
      { signal },
    );

  return {
    queryKey,
    queryFn,
    enabled: !!(instanceId && component),
    ...queryOptions,
  } as CreateQueryOptions<
    Awaited<ReturnType<typeof queryServiceResolveComponent>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type QueryServiceResolveComponentQueryResult = NonNullable<
  Awaited<ReturnType<typeof queryServiceResolveComponent>>
>;
export type QueryServiceResolveComponentQueryError = ErrorType<RpcStatus>;

/**
 * @summary ResolveComponent resolves renderer for a Component resource.
 */

export function createQueryServiceResolveComponent<
  TData = Awaited<ReturnType<typeof queryServiceResolveComponent>>,
  TError = ErrorType<RpcStatus>,
>(
  instanceId: () => string,
  component: () => string,
  queryServiceResolveComponentBody: () => QueryServiceResolveComponentBody,
  options?: () => {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof queryServiceResolveComponent>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: () => QueryClient,
): CreateQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const query = createQuery(
    () =>
      getQueryServiceResolveComponentQueryOptions(
        instanceId(),
        component(),
        queryServiceResolveComponentBody(),
        options?.(),
      ),
    queryClient,
  ) as CreateQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  return query;
}

/**
 * @summary Get basic stats for a numeric column like min, max, mean, stddev, etc
 */
export type queryServiceColumnDescriptiveStatisticsResponse200 = {
  data: V1ColumnDescriptiveStatisticsResponse;
  status: 200;
};

export type queryServiceColumnDescriptiveStatisticsResponseDefault = {
  data: RpcStatus;
  status: Exclude<HTTPStatusCodes, 200>;
};

export type queryServiceColumnDescriptiveStatisticsResponseSuccess =
  queryServiceColumnDescriptiveStatisticsResponse200 & {
    headers: Headers;
  };
export type queryServiceColumnDescriptiveStatisticsResponseError =
  queryServiceColumnDescriptiveStatisticsResponseDefault & {
    headers: Headers;
  };

export type queryServiceColumnDescriptiveStatisticsResponse =
  | queryServiceColumnDescriptiveStatisticsResponseSuccess
  | queryServiceColumnDescriptiveStatisticsResponseError;

export const getQueryServiceColumnDescriptiveStatisticsUrl = (
  instanceId: string,
  tableName: string,
  params?: QueryServiceColumnDescriptiveStatisticsParams,
) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? "null" : value.toString());
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0
    ? `/v1/instances/${instanceId}/queries/descriptive-statistics/tables/${tableName}?${stringifiedParams}`
    : `/v1/instances/${instanceId}/queries/descriptive-statistics/tables/${tableName}`;
};

export const queryServiceColumnDescriptiveStatistics = async (
  instanceId: string,
  tableName: string,
  params?: QueryServiceColumnDescriptiveStatisticsParams,
  options?: RequestInit,
): Promise<queryServiceColumnDescriptiveStatisticsResponse> => {
  return httpClient<queryServiceColumnDescriptiveStatisticsResponse>(
    getQueryServiceColumnDescriptiveStatisticsUrl(
      instanceId,
      tableName,
      params,
    ),
    {
      ...options,
      method: "GET",
    },
  );
};

export const getQueryServiceColumnDescriptiveStatisticsQueryKey = (
  instanceId: string,
  tableName: string,
  params?: QueryServiceColumnDescriptiveStatisticsParams,
) => {
  return [
    `/v1/instances/${instanceId}/queries/descriptive-statistics/tables/${tableName}`,
    ...(params ? [params] : []),
  ] as const;
};

export const getQueryServiceColumnDescriptiveStatisticsQueryOptions = <
  TData = Awaited<ReturnType<typeof queryServiceColumnDescriptiveStatistics>>,
  TError = ErrorType<RpcStatus>,
>(
  instanceId: string,
  tableName: string,
  params?: QueryServiceColumnDescriptiveStatisticsParams,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof queryServiceColumnDescriptiveStatistics>>,
        TError,
        TData
      >
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getQueryServiceColumnDescriptiveStatisticsQueryKey(
      instanceId,
      tableName,
      params,
    );

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof queryServiceColumnDescriptiveStatistics>>
  > = ({ signal }) =>
    queryServiceColumnDescriptiveStatistics(instanceId, tableName, params, {
      signal,
    });

  return {
    queryKey,
    queryFn,
    enabled: !!(instanceId && tableName),
    ...queryOptions,
  } as CreateQueryOptions<
    Awaited<ReturnType<typeof queryServiceColumnDescriptiveStatistics>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type QueryServiceColumnDescriptiveStatisticsQueryResult = NonNullable<
  Awaited<ReturnType<typeof queryServiceColumnDescriptiveStatistics>>
>;
export type QueryServiceColumnDescriptiveStatisticsQueryError =
  ErrorType<RpcStatus>;

/**
 * @summary Get basic stats for a numeric column like min, max, mean, stddev, etc
 */

export function createQueryServiceColumnDescriptiveStatistics<
  TData = Awaited<ReturnType<typeof queryServiceColumnDescriptiveStatistics>>,
  TError = ErrorType<RpcStatus>,
>(
  instanceId: () => string,
  tableName: () => string,
  params?: () => QueryServiceColumnDescriptiveStatisticsParams,
  options?: () => {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof queryServiceColumnDescriptiveStatistics>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: () => QueryClient,
): CreateQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const query = createQuery(
    () =>
      getQueryServiceColumnDescriptiveStatisticsQueryOptions(
        instanceId(),
        tableName(),
        params?.(),
        options?.(),
      ),
    queryClient,
  ) as CreateQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  return query;
}

/**
 * @summary Export builds a URL to download the results of a query as a file.
 */
export type queryServiceExportResponse200 = {
  data: V1ExportResponse;
  status: 200;
};

export type queryServiceExportResponseDefault = {
  data: RpcStatus;
  status: Exclude<HTTPStatusCodes, 200>;
};

export type queryServiceExportResponseSuccess =
  queryServiceExportResponse200 & {
    headers: Headers;
  };
export type queryServiceExportResponseError =
  queryServiceExportResponseDefault & {
    headers: Headers;
  };

export type queryServiceExportResponse =
  | queryServiceExportResponseSuccess
  | queryServiceExportResponseError;

export const getQueryServiceExportUrl = (instanceId: string) => {
  return `/v1/instances/${instanceId}/queries/export`;
};

export const queryServiceExport = async (
  instanceId: string,
  queryServiceExportBody: QueryServiceExportBody,
  options?: RequestInit,
): Promise<queryServiceExportResponse> => {
  return httpClient<queryServiceExportResponse>(
    getQueryServiceExportUrl(instanceId),
    {
      ...options,
      method: "POST",
      headers: { "Content-Type": "application/json", ...options?.headers },
      body: JSON.stringify(queryServiceExportBody),
    },
  );
};

export const getQueryServiceExportMutationOptions = <
  TError = ErrorType<RpcStatus>,
  TContext = unknown,
>(options?: {
  mutation?: CreateMutationOptions<
    Awaited<ReturnType<typeof queryServiceExport>>,
    TError,
    { instanceId: string; data: QueryServiceExportBody },
    TContext
  >;
}): CreateMutationOptions<
  Awaited<ReturnType<typeof queryServiceExport>>,
  TError,
  { instanceId: string; data: QueryServiceExportBody },
  TContext
> => {
  const mutationKey = ["queryServiceExport"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof queryServiceExport>>,
    { instanceId: string; data: QueryServiceExportBody }
  > = (props) => {
    const { instanceId, data } = props ?? {};

    return queryServiceExport(instanceId, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type QueryServiceExportMutationResult = NonNullable<
  Awaited<ReturnType<typeof queryServiceExport>>
>;
export type QueryServiceExportMutationBody = QueryServiceExportBody;
export type QueryServiceExportMutationError = ErrorType<RpcStatus>;

/**
 * @summary Export builds a URL to download the results of a query as a file.
 */
export const createQueryServiceExport = <
  TError = ErrorType<RpcStatus>,
  TContext = unknown,
>(
  options?: () => {
    mutation?: CreateMutationOptions<
      Awaited<ReturnType<typeof queryServiceExport>>,
      TError,
      { instanceId: string; data: QueryServiceExportBody },
      TContext
    >;
  },
  queryClient?: () => QueryClient,
): CreateMutationResult<
  Awaited<ReturnType<typeof queryServiceExport>>,
  TError,
  { instanceId: string; data: QueryServiceExportBody },
  TContext
> => {
  return createMutation(
    () => ({ ...getQueryServiceExportMutationOptions(options?.()) }),
    queryClient,
  );
};
/**
 * @summary ConvertExpressionToMetricsSQL converts a filter expression to a SQL filter string.
 */
export type queryServiceConvertExpressionToMetricsSQLResponse200 = {
  data: V1ConvertExpressionToMetricsSQLResponse;
  status: 200;
};

export type queryServiceConvertExpressionToMetricsSQLResponseDefault = {
  data: RpcStatus;
  status: Exclude<HTTPStatusCodes, 200>;
};

export type queryServiceConvertExpressionToMetricsSQLResponseSuccess =
  queryServiceConvertExpressionToMetricsSQLResponse200 & {
    headers: Headers;
  };
export type queryServiceConvertExpressionToMetricsSQLResponseError =
  queryServiceConvertExpressionToMetricsSQLResponseDefault & {
    headers: Headers;
  };

export type queryServiceConvertExpressionToMetricsSQLResponse =
  | queryServiceConvertExpressionToMetricsSQLResponseSuccess
  | queryServiceConvertExpressionToMetricsSQLResponseError;

export const getQueryServiceConvertExpressionToMetricsSQLUrl = (
  instanceId: string,
) => {
  return `/v1/instances/${instanceId}/queries/filter-expression/resolve`;
};

export const queryServiceConvertExpressionToMetricsSQL = async (
  instanceId: string,
  queryServiceConvertExpressionToMetricsSQLBody: QueryServiceConvertExpressionToMetricsSQLBody,
  options?: RequestInit,
): Promise<queryServiceConvertExpressionToMetricsSQLResponse> => {
  return httpClient<queryServiceConvertExpressionToMetricsSQLResponse>(
    getQueryServiceConvertExpressionToMetricsSQLUrl(instanceId),
    {
      ...options,
      method: "POST",
      headers: { "Content-Type": "application/json", ...options?.headers },
      body: JSON.stringify(queryServiceConvertExpressionToMetricsSQLBody),
    },
  );
};

export const getQueryServiceConvertExpressionToMetricsSQLMutationOptions = <
  TError = ErrorType<RpcStatus>,
  TContext = unknown,
>(options?: {
  mutation?: CreateMutationOptions<
    Awaited<ReturnType<typeof queryServiceConvertExpressionToMetricsSQL>>,
    TError,
    { instanceId: string; data: QueryServiceConvertExpressionToMetricsSQLBody },
    TContext
  >;
}): CreateMutationOptions<
  Awaited<ReturnType<typeof queryServiceConvertExpressionToMetricsSQL>>,
  TError,
  { instanceId: string; data: QueryServiceConvertExpressionToMetricsSQLBody },
  TContext
> => {
  const mutationKey = ["queryServiceConvertExpressionToMetricsSQL"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof queryServiceConvertExpressionToMetricsSQL>>,
    { instanceId: string; data: QueryServiceConvertExpressionToMetricsSQLBody }
  > = (props) => {
    const { instanceId, data } = props ?? {};

    return queryServiceConvertExpressionToMetricsSQL(instanceId, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type QueryServiceConvertExpressionToMetricsSQLMutationResult =
  NonNullable<
    Awaited<ReturnType<typeof queryServiceConvertExpressionToMetricsSQL>>
  >;
export type QueryServiceConvertExpressionToMetricsSQLMutationBody =
  QueryServiceConvertExpressionToMetricsSQLBody;
export type QueryServiceConvertExpressionToMetricsSQLMutationError =
  ErrorType<RpcStatus>;

/**
 * @summary ConvertExpressionToMetricsSQL converts a filter expression to a SQL filter string.
 */
export const createQueryServiceConvertExpressionToMetricsSQL = <
  TError = ErrorType<RpcStatus>,
  TContext = unknown,
>(
  options?: () => {
    mutation?: CreateMutationOptions<
      Awaited<ReturnType<typeof queryServiceConvertExpressionToMetricsSQL>>,
      TError,
      {
        instanceId: string;
        data: QueryServiceConvertExpressionToMetricsSQLBody;
      },
      TContext
    >;
  },
  queryClient?: () => QueryClient,
): CreateMutationResult<
  Awaited<ReturnType<typeof queryServiceConvertExpressionToMetricsSQL>>,
  TError,
  { instanceId: string; data: QueryServiceConvertExpressionToMetricsSQLBody },
  TContext
> => {
  return createMutation(
    () => ({
      ...getQueryServiceConvertExpressionToMetricsSQLMutationOptions(
        options?.(),
      ),
    }),
    queryClient,
  );
};
/**
 * @summary MetricsViewAggregation is a generic API for running group-by/pivot queries against a metrics view.
 */
export type queryServiceMetricsViewAggregationResponse200 = {
  data: V1MetricsViewAggregationResponse;
  status: 200;
};

export type queryServiceMetricsViewAggregationResponseDefault = {
  data: RpcStatus;
  status: Exclude<HTTPStatusCodes, 200>;
};

export type queryServiceMetricsViewAggregationResponseSuccess =
  queryServiceMetricsViewAggregationResponse200 & {
    headers: Headers;
  };
export type queryServiceMetricsViewAggregationResponseError =
  queryServiceMetricsViewAggregationResponseDefault & {
    headers: Headers;
  };

export type queryServiceMetricsViewAggregationResponse =
  | queryServiceMetricsViewAggregationResponseSuccess
  | queryServiceMetricsViewAggregationResponseError;

export const getQueryServiceMetricsViewAggregationUrl = (
  instanceId: string,
  metricsView: string,
) => {
  return `/v1/instances/${instanceId}/queries/metrics-views/${metricsView}/aggregation`;
};

export const queryServiceMetricsViewAggregation = async (
  instanceId: string,
  metricsView: string,
  queryServiceMetricsViewAggregationBody: QueryServiceMetricsViewAggregationBody,
  options?: RequestInit,
): Promise<queryServiceMetricsViewAggregationResponse> => {
  return httpClient<queryServiceMetricsViewAggregationResponse>(
    getQueryServiceMetricsViewAggregationUrl(instanceId, metricsView),
    {
      ...options,
      method: "POST",
      headers: { "Content-Type": "application/json", ...options?.headers },
      body: JSON.stringify(queryServiceMetricsViewAggregationBody),
    },
  );
};

export const getQueryServiceMetricsViewAggregationQueryKey = (
  instanceId: string,
  metricsView: string,
  queryServiceMetricsViewAggregationBody?: QueryServiceMetricsViewAggregationBody,
) => {
  return [
    `/v1/instances/${instanceId}/queries/metrics-views/${metricsView}/aggregation`,
    queryServiceMetricsViewAggregationBody,
  ] as const;
};

export const getQueryServiceMetricsViewAggregationQueryOptions = <
  TData = Awaited<ReturnType<typeof queryServiceMetricsViewAggregation>>,
  TError = ErrorType<RpcStatus>,
>(
  instanceId: string,
  metricsView: string,
  queryServiceMetricsViewAggregationBody: QueryServiceMetricsViewAggregationBody,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof queryServiceMetricsViewAggregation>>,
        TError,
        TData
      >
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getQueryServiceMetricsViewAggregationQueryKey(
      instanceId,
      metricsView,
      queryServiceMetricsViewAggregationBody,
    );

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof queryServiceMetricsViewAggregation>>
  > = ({ signal }) =>
    queryServiceMetricsViewAggregation(
      instanceId,
      metricsView,
      queryServiceMetricsViewAggregationBody,
      { signal },
    );

  return {
    queryKey,
    queryFn,
    enabled: !!(instanceId && metricsView),
    ...queryOptions,
  } as CreateQueryOptions<
    Awaited<ReturnType<typeof queryServiceMetricsViewAggregation>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type QueryServiceMetricsViewAggregationQueryResult = NonNullable<
  Awaited<ReturnType<typeof queryServiceMetricsViewAggregation>>
>;
export type QueryServiceMetricsViewAggregationQueryError = ErrorType<RpcStatus>;

/**
 * @summary MetricsViewAggregation is a generic API for running group-by/pivot queries against a metrics view.
 */

export function createQueryServiceMetricsViewAggregation<
  TData = Awaited<ReturnType<typeof queryServiceMetricsViewAggregation>>,
  TError = ErrorType<RpcStatus>,
>(
  instanceId: () => string,
  metricsView: () => string,
  queryServiceMetricsViewAggregationBody: () => QueryServiceMetricsViewAggregationBody,
  options?: () => {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof queryServiceMetricsViewAggregation>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: () => QueryClient,
): CreateQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const query = createQuery(
    () =>
      getQueryServiceMetricsViewAggregationQueryOptions(
        instanceId(),
        metricsView(),
        queryServiceMetricsViewAggregationBody(),
        options?.(),
      ),
    queryClient,
  ) as CreateQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  return query;
}

export type queryServiceMetricsViewAnnotationsResponse200 = {
  data: V1MetricsViewAnnotationsResponse;
  status: 200;
};

export type queryServiceMetricsViewAnnotationsResponseDefault = {
  data: RpcStatus;
  status: Exclude<HTTPStatusCodes, 200>;
};

export type queryServiceMetricsViewAnnotationsResponseSuccess =
  queryServiceMetricsViewAnnotationsResponse200 & {
    headers: Headers;
  };
export type queryServiceMetricsViewAnnotationsResponseError =
  queryServiceMetricsViewAnnotationsResponseDefault & {
    headers: Headers;
  };

export type queryServiceMetricsViewAnnotationsResponse =
  | queryServiceMetricsViewAnnotationsResponseSuccess
  | queryServiceMetricsViewAnnotationsResponseError;

export const getQueryServiceMetricsViewAnnotationsUrl = (
  instanceId: string,
  metricsViewName: string,
) => {
  return `/v1/instances/${instanceId}/queries/metrics-views/${metricsViewName}/annotations`;
};

export const queryServiceMetricsViewAnnotations = async (
  instanceId: string,
  metricsViewName: string,
  queryServiceMetricsViewAnnotationsBody: QueryServiceMetricsViewAnnotationsBody,
  options?: RequestInit,
): Promise<queryServiceMetricsViewAnnotationsResponse> => {
  return httpClient<queryServiceMetricsViewAnnotationsResponse>(
    getQueryServiceMetricsViewAnnotationsUrl(instanceId, metricsViewName),
    {
      ...options,
      method: "POST",
      headers: { "Content-Type": "application/json", ...options?.headers },
      body: JSON.stringify(queryServiceMetricsViewAnnotationsBody),
    },
  );
};

export const getQueryServiceMetricsViewAnnotationsQueryKey = (
  instanceId: string,
  metricsViewName: string,
  queryServiceMetricsViewAnnotationsBody?: QueryServiceMetricsViewAnnotationsBody,
) => {
  return [
    `/v1/instances/${instanceId}/queries/metrics-views/${metricsViewName}/annotations`,
    queryServiceMetricsViewAnnotationsBody,
  ] as const;
};

export const getQueryServiceMetricsViewAnnotationsQueryOptions = <
  TData = Awaited<ReturnType<typeof queryServiceMetricsViewAnnotations>>,
  TError = ErrorType<RpcStatus>,
>(
  instanceId: string,
  metricsViewName: string,
  queryServiceMetricsViewAnnotationsBody: QueryServiceMetricsViewAnnotationsBody,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof queryServiceMetricsViewAnnotations>>,
        TError,
        TData
      >
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getQueryServiceMetricsViewAnnotationsQueryKey(
      instanceId,
      metricsViewName,
      queryServiceMetricsViewAnnotationsBody,
    );

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof queryServiceMetricsViewAnnotations>>
  > = ({ signal }) =>
    queryServiceMetricsViewAnnotations(
      instanceId,
      metricsViewName,
      queryServiceMetricsViewAnnotationsBody,
      { signal },
    );

  return {
    queryKey,
    queryFn,
    enabled: !!(instanceId && metricsViewName),
    ...queryOptions,
  } as CreateQueryOptions<
    Awaited<ReturnType<typeof queryServiceMetricsViewAnnotations>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type QueryServiceMetricsViewAnnotationsQueryResult = NonNullable<
  Awaited<ReturnType<typeof queryServiceMetricsViewAnnotations>>
>;
export type QueryServiceMetricsViewAnnotationsQueryError = ErrorType<RpcStatus>;

export function createQueryServiceMetricsViewAnnotations<
  TData = Awaited<ReturnType<typeof queryServiceMetricsViewAnnotations>>,
  TError = ErrorType<RpcStatus>,
>(
  instanceId: () => string,
  metricsViewName: () => string,
  queryServiceMetricsViewAnnotationsBody: () => QueryServiceMetricsViewAnnotationsBody,
  options?: () => {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof queryServiceMetricsViewAnnotations>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: () => QueryClient,
): CreateQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const query = createQuery(
    () =>
      getQueryServiceMetricsViewAnnotationsQueryOptions(
        instanceId(),
        metricsViewName(),
        queryServiceMetricsViewAnnotationsBody(),
        options?.(),
      ),
    queryClient,
  ) as CreateQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  return query;
}

/**
 * ie. comparsion toplist:
| measure1_base | measure1_previous   | measure1__delta_abs | measure1__delta_rel | dimension |
|---------------|---------------------|---------------------|--------------------|-----------|
| 2             | 2                   | 0                   | 0                  | Safari    |
| 1             | 0                   | 1                   | N/A                | Chrome    |
| 0             | 4                   | -4                  | -1.0               | Firefox   |

ie. toplist:
| measure1 | measure2 | dimension |
|----------|----------|-----------|
| 2        | 45       | Safari    |
| 1        | 350      | Chrome    |
| 0        | 25       | Firefox   |
 * @summary MetricsViewComparison returns a toplist containing comparison data of another toplist (same dimension/measure but a different time range).
Returns a toplist without comparison data if comparison time range is omitted.
 */
export type queryServiceMetricsViewComparisonResponse200 = {
  data: V1MetricsViewComparisonResponse;
  status: 200;
};

export type queryServiceMetricsViewComparisonResponseDefault = {
  data: RpcStatus;
  status: Exclude<HTTPStatusCodes, 200>;
};

export type queryServiceMetricsViewComparisonResponseSuccess =
  queryServiceMetricsViewComparisonResponse200 & {
    headers: Headers;
  };
export type queryServiceMetricsViewComparisonResponseError =
  queryServiceMetricsViewComparisonResponseDefault & {
    headers: Headers;
  };

export type queryServiceMetricsViewComparisonResponse =
  | queryServiceMetricsViewComparisonResponseSuccess
  | queryServiceMetricsViewComparisonResponseError;

export const getQueryServiceMetricsViewComparisonUrl = (
  instanceId: string,
  metricsViewName: string,
) => {
  return `/v1/instances/${instanceId}/queries/metrics-views/${metricsViewName}/compare-toplist`;
};

export const queryServiceMetricsViewComparison = async (
  instanceId: string,
  metricsViewName: string,
  queryServiceMetricsViewComparisonBody: QueryServiceMetricsViewComparisonBody,
  options?: RequestInit,
): Promise<queryServiceMetricsViewComparisonResponse> => {
  return httpClient<queryServiceMetricsViewComparisonResponse>(
    getQueryServiceMetricsViewComparisonUrl(instanceId, metricsViewName),
    {
      ...options,
      method: "POST",
      headers: { "Content-Type": "application/json", ...options?.headers },
      body: JSON.stringify(queryServiceMetricsViewComparisonBody),
    },
  );
};

export const getQueryServiceMetricsViewComparisonQueryKey = (
  instanceId: string,
  metricsViewName: string,
  queryServiceMetricsViewComparisonBody?: QueryServiceMetricsViewComparisonBody,
) => {
  return [
    `/v1/instances/${instanceId}/queries/metrics-views/${metricsViewName}/compare-toplist`,
    queryServiceMetricsViewComparisonBody,
  ] as const;
};

export const getQueryServiceMetricsViewComparisonQueryOptions = <
  TData = Awaited<ReturnType<typeof queryServiceMetricsViewComparison>>,
  TError = ErrorType<RpcStatus>,
>(
  instanceId: string,
  metricsViewName: string,
  queryServiceMetricsViewComparisonBody: QueryServiceMetricsViewComparisonBody,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof queryServiceMetricsViewComparison>>,
        TError,
        TData
      >
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getQueryServiceMetricsViewComparisonQueryKey(
      instanceId,
      metricsViewName,
      queryServiceMetricsViewComparisonBody,
    );

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof queryServiceMetricsViewComparison>>
  > = ({ signal }) =>
    queryServiceMetricsViewComparison(
      instanceId,
      metricsViewName,
      queryServiceMetricsViewComparisonBody,
      { signal },
    );

  return {
    queryKey,
    queryFn,
    enabled: !!(instanceId && metricsViewName),
    ...queryOptions,
  } as CreateQueryOptions<
    Awaited<ReturnType<typeof queryServiceMetricsViewComparison>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type QueryServiceMetricsViewComparisonQueryResult = NonNullable<
  Awaited<ReturnType<typeof queryServiceMetricsViewComparison>>
>;
export type QueryServiceMetricsViewComparisonQueryError = ErrorType<RpcStatus>;

/**
 * @summary MetricsViewComparison returns a toplist containing comparison data of another toplist (same dimension/measure but a different time range).
Returns a toplist without comparison data if comparison time range is omitted.
 */

export function createQueryServiceMetricsViewComparison<
  TData = Awaited<ReturnType<typeof queryServiceMetricsViewComparison>>,
  TError = ErrorType<RpcStatus>,
>(
  instanceId: () => string,
  metricsViewName: () => string,
  queryServiceMetricsViewComparisonBody: () => QueryServiceMetricsViewComparisonBody,
  options?: () => {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof queryServiceMetricsViewComparison>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: () => QueryClient,
): CreateQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const query = createQuery(
    () =>
      getQueryServiceMetricsViewComparisonQueryOptions(
        instanceId(),
        metricsViewName(),
        queryServiceMetricsViewComparisonBody(),
        options?.(),
      ),
    queryClient,
  ) as CreateQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  return query;
}

/**
 * ie. without granularity
| column1 | column2 | dimension |
|---------|---------|-----------|
| 2       | 2       | Safari    |
| 1       | 0       | Chrome    |
| 0       | 4       | Firefox   |

ie. with granularity
| timestamp__day0      | column1 | column2 | dimension |
|----------------------|---------|---------|-----------|
| 2022-01-01T00:00:00Z | 2       | 2       | Safari    |
| 2022-01-01T00:00:00Z | 1       | 0       | Chrome    |
| 2022-01-01T00:00:00Z | 0       | 4       | Firefox   |
 * @summary MetricsViewRows returns the underlying model rows matching a metrics view time range and filter(s).
 */
export type queryServiceMetricsViewRowsResponse200 = {
  data: V1MetricsViewRowsResponse;
  status: 200;
};

export type queryServiceMetricsViewRowsResponseDefault = {
  data: RpcStatus;
  status: Exclude<HTTPStatusCodes, 200>;
};

export type queryServiceMetricsViewRowsResponseSuccess =
  queryServiceMetricsViewRowsResponse200 & {
    headers: Headers;
  };
export type queryServiceMetricsViewRowsResponseError =
  queryServiceMetricsViewRowsResponseDefault & {
    headers: Headers;
  };

export type queryServiceMetricsViewRowsResponse =
  | queryServiceMetricsViewRowsResponseSuccess
  | queryServiceMetricsViewRowsResponseError;

export const getQueryServiceMetricsViewRowsUrl = (
  instanceId: string,
  metricsViewName: string,
) => {
  return `/v1/instances/${instanceId}/queries/metrics-views/${metricsViewName}/rows`;
};

export const queryServiceMetricsViewRows = async (
  instanceId: string,
  metricsViewName: string,
  queryServiceMetricsViewRowsBody: QueryServiceMetricsViewRowsBody,
  options?: RequestInit,
): Promise<queryServiceMetricsViewRowsResponse> => {
  return httpClient<queryServiceMetricsViewRowsResponse>(
    getQueryServiceMetricsViewRowsUrl(instanceId, metricsViewName),
    {
      ...options,
      method: "POST",
      headers: { "Content-Type": "application/json", ...options?.headers },
      body: JSON.stringify(queryServiceMetricsViewRowsBody),
    },
  );
};

export const getQueryServiceMetricsViewRowsQueryKey = (
  instanceId: string,
  metricsViewName: string,
  queryServiceMetricsViewRowsBody?: QueryServiceMetricsViewRowsBody,
) => {
  return [
    `/v1/instances/${instanceId}/queries/metrics-views/${metricsViewName}/rows`,
    queryServiceMetricsViewRowsBody,
  ] as const;
};

export const getQueryServiceMetricsViewRowsQueryOptions = <
  TData = Awaited<ReturnType<typeof queryServiceMetricsViewRows>>,
  TError = ErrorType<RpcStatus>,
>(
  instanceId: string,
  metricsViewName: string,
  queryServiceMetricsViewRowsBody: QueryServiceMetricsViewRowsBody,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof queryServiceMetricsViewRows>>,
        TError,
        TData
      >
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getQueryServiceMetricsViewRowsQueryKey(
      instanceId,
      metricsViewName,
      queryServiceMetricsViewRowsBody,
    );

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof queryServiceMetricsViewRows>>
  > = ({ signal }) =>
    queryServiceMetricsViewRows(
      instanceId,
      metricsViewName,
      queryServiceMetricsViewRowsBody,
      { signal },
    );

  return {
    queryKey,
    queryFn,
    enabled: !!(instanceId && metricsViewName),
    ...queryOptions,
  } as CreateQueryOptions<
    Awaited<ReturnType<typeof queryServiceMetricsViewRows>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type QueryServiceMetricsViewRowsQueryResult = NonNullable<
  Awaited<ReturnType<typeof queryServiceMetricsViewRows>>
>;
export type QueryServiceMetricsViewRowsQueryError = ErrorType<RpcStatus>;

/**
 * @summary MetricsViewRows returns the underlying model rows matching a metrics view time range and filter(s).
 */

export function createQueryServiceMetricsViewRows<
  TData = Awaited<ReturnType<typeof queryServiceMetricsViewRows>>,
  TError = ErrorType<RpcStatus>,
>(
  instanceId: () => string,
  metricsViewName: () => string,
  queryServiceMetricsViewRowsBody: () => QueryServiceMetricsViewRowsBody,
  options?: () => {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof queryServiceMetricsViewRows>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: () => QueryClient,
): CreateQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const query = createQuery(
    () =>
      getQueryServiceMetricsViewRowsQueryOptions(
        instanceId(),
        metricsViewName(),
        queryServiceMetricsViewRowsBody(),
        options?.(),
      ),
    queryClient,
  ) as CreateQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  return query;
}

/**
 * @summary MetricsViewSchema Get the data types of measures and dimensions
 */
export type queryServiceMetricsViewSchemaResponse200 = {
  data: V1MetricsViewSchemaResponse;
  status: 200;
};

export type queryServiceMetricsViewSchemaResponseDefault = {
  data: RpcStatus;
  status: Exclude<HTTPStatusCodes, 200>;
};

export type queryServiceMetricsViewSchemaResponseSuccess =
  queryServiceMetricsViewSchemaResponse200 & {
    headers: Headers;
  };
export type queryServiceMetricsViewSchemaResponseError =
  queryServiceMetricsViewSchemaResponseDefault & {
    headers: Headers;
  };

export type queryServiceMetricsViewSchemaResponse =
  | queryServiceMetricsViewSchemaResponseSuccess
  | queryServiceMetricsViewSchemaResponseError;

export const getQueryServiceMetricsViewSchemaUrl = (
  instanceId: string,
  metricsViewName: string,
  params?: QueryServiceMetricsViewSchemaParams,
) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? "null" : value.toString());
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0
    ? `/v1/instances/${instanceId}/queries/metrics-views/${metricsViewName}/schema?${stringifiedParams}`
    : `/v1/instances/${instanceId}/queries/metrics-views/${metricsViewName}/schema`;
};

export const queryServiceMetricsViewSchema = async (
  instanceId: string,
  metricsViewName: string,
  params?: QueryServiceMetricsViewSchemaParams,
  options?: RequestInit,
): Promise<queryServiceMetricsViewSchemaResponse> => {
  return httpClient<queryServiceMetricsViewSchemaResponse>(
    getQueryServiceMetricsViewSchemaUrl(instanceId, metricsViewName, params),
    {
      ...options,
      method: "GET",
    },
  );
};

export const getQueryServiceMetricsViewSchemaQueryKey = (
  instanceId: string,
  metricsViewName: string,
  params?: QueryServiceMetricsViewSchemaParams,
) => {
  return [
    `/v1/instances/${instanceId}/queries/metrics-views/${metricsViewName}/schema`,
    ...(params ? [params] : []),
  ] as const;
};

export const getQueryServiceMetricsViewSchemaQueryOptions = <
  TData = Awaited<ReturnType<typeof queryServiceMetricsViewSchema>>,
  TError = ErrorType<RpcStatus>,
>(
  instanceId: string,
  metricsViewName: string,
  params?: QueryServiceMetricsViewSchemaParams,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof queryServiceMetricsViewSchema>>,
        TError,
        TData
      >
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getQueryServiceMetricsViewSchemaQueryKey(
      instanceId,
      metricsViewName,
      params,
    );

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof queryServiceMetricsViewSchema>>
  > = ({ signal }) =>
    queryServiceMetricsViewSchema(instanceId, metricsViewName, params, {
      signal,
    });

  return {
    queryKey,
    queryFn,
    enabled: !!(instanceId && metricsViewName),
    ...queryOptions,
  } as CreateQueryOptions<
    Awaited<ReturnType<typeof queryServiceMetricsViewSchema>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type QueryServiceMetricsViewSchemaQueryResult = NonNullable<
  Awaited<ReturnType<typeof queryServiceMetricsViewSchema>>
>;
export type QueryServiceMetricsViewSchemaQueryError = ErrorType<RpcStatus>;

/**
 * @summary MetricsViewSchema Get the data types of measures and dimensions
 */

export function createQueryServiceMetricsViewSchema<
  TData = Awaited<ReturnType<typeof queryServiceMetricsViewSchema>>,
  TError = ErrorType<RpcStatus>,
>(
  instanceId: () => string,
  metricsViewName: () => string,
  params?: () => QueryServiceMetricsViewSchemaParams,
  options?: () => {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof queryServiceMetricsViewSchema>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: () => QueryClient,
): CreateQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const query = createQuery(
    () =>
      getQueryServiceMetricsViewSchemaQueryOptions(
        instanceId(),
        metricsViewName(),
        params?.(),
        options?.(),
      ),
    queryClient,
  ) as CreateQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  return query;
}

/**
 * @summary MetricsViewSearch Get the data types of measures and dimensions
 */
export type queryServiceMetricsViewSearchResponse200 = {
  data: V1MetricsViewSearchResponse;
  status: 200;
};

export type queryServiceMetricsViewSearchResponseDefault = {
  data: RpcStatus;
  status: Exclude<HTTPStatusCodes, 200>;
};

export type queryServiceMetricsViewSearchResponseSuccess =
  queryServiceMetricsViewSearchResponse200 & {
    headers: Headers;
  };
export type queryServiceMetricsViewSearchResponseError =
  queryServiceMetricsViewSearchResponseDefault & {
    headers: Headers;
  };

export type queryServiceMetricsViewSearchResponse =
  | queryServiceMetricsViewSearchResponseSuccess
  | queryServiceMetricsViewSearchResponseError;

export const getQueryServiceMetricsViewSearchUrl = (
  instanceId: string,
  metricsViewName: string,
) => {
  return `/v1/instances/${instanceId}/queries/metrics-views/${metricsViewName}/search`;
};

export const queryServiceMetricsViewSearch = async (
  instanceId: string,
  metricsViewName: string,
  queryServiceMetricsViewSearchBody: QueryServiceMetricsViewSearchBody,
  options?: RequestInit,
): Promise<queryServiceMetricsViewSearchResponse> => {
  return httpClient<queryServiceMetricsViewSearchResponse>(
    getQueryServiceMetricsViewSearchUrl(instanceId, metricsViewName),
    {
      ...options,
      method: "POST",
      headers: { "Content-Type": "application/json", ...options?.headers },
      body: JSON.stringify(queryServiceMetricsViewSearchBody),
    },
  );
};

export const getQueryServiceMetricsViewSearchQueryKey = (
  instanceId: string,
  metricsViewName: string,
  queryServiceMetricsViewSearchBody?: QueryServiceMetricsViewSearchBody,
) => {
  return [
    `/v1/instances/${instanceId}/queries/metrics-views/${metricsViewName}/search`,
    queryServiceMetricsViewSearchBody,
  ] as const;
};

export const getQueryServiceMetricsViewSearchQueryOptions = <
  TData = Awaited<ReturnType<typeof queryServiceMetricsViewSearch>>,
  TError = ErrorType<RpcStatus>,
>(
  instanceId: string,
  metricsViewName: string,
  queryServiceMetricsViewSearchBody: QueryServiceMetricsViewSearchBody,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof queryServiceMetricsViewSearch>>,
        TError,
        TData
      >
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getQueryServiceMetricsViewSearchQueryKey(
      instanceId,
      metricsViewName,
      queryServiceMetricsViewSearchBody,
    );

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof queryServiceMetricsViewSearch>>
  > = ({ signal }) =>
    queryServiceMetricsViewSearch(
      instanceId,
      metricsViewName,
      queryServiceMetricsViewSearchBody,
      { signal },
    );

  return {
    queryKey,
    queryFn,
    enabled: !!(instanceId && metricsViewName),
    ...queryOptions,
  } as CreateQueryOptions<
    Awaited<ReturnType<typeof queryServiceMetricsViewSearch>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type QueryServiceMetricsViewSearchQueryResult = NonNullable<
  Awaited<ReturnType<typeof queryServiceMetricsViewSearch>>
>;
export type QueryServiceMetricsViewSearchQueryError = ErrorType<RpcStatus>;

/**
 * @summary MetricsViewSearch Get the data types of measures and dimensions
 */

export function createQueryServiceMetricsViewSearch<
  TData = Awaited<ReturnType<typeof queryServiceMetricsViewSearch>>,
  TError = ErrorType<RpcStatus>,
>(
  instanceId: () => string,
  metricsViewName: () => string,
  queryServiceMetricsViewSearchBody: () => QueryServiceMetricsViewSearchBody,
  options?: () => {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof queryServiceMetricsViewSearch>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: () => QueryClient,
): CreateQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const query = createQuery(
    () =>
      getQueryServiceMetricsViewSearchQueryOptions(
        instanceId(),
        metricsViewName(),
        queryServiceMetricsViewSearchBody(),
        options?.(),
      ),
    queryClient,
  ) as CreateQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  return query;
}

/**
 * @summary MetricsViewTimeRange Get the time range summaries (min, max) for time column in a metrics view.
Deprecated: use MetricsViewTimeRanges instead.
 */
export type queryServiceMetricsViewTimeRangeResponse200 = {
  data: V1MetricsViewTimeRangeResponse;
  status: 200;
};

export type queryServiceMetricsViewTimeRangeResponseDefault = {
  data: RpcStatus;
  status: Exclude<HTTPStatusCodes, 200>;
};

export type queryServiceMetricsViewTimeRangeResponseSuccess =
  queryServiceMetricsViewTimeRangeResponse200 & {
    headers: Headers;
  };
export type queryServiceMetricsViewTimeRangeResponseError =
  queryServiceMetricsViewTimeRangeResponseDefault & {
    headers: Headers;
  };

export type queryServiceMetricsViewTimeRangeResponse =
  | queryServiceMetricsViewTimeRangeResponseSuccess
  | queryServiceMetricsViewTimeRangeResponseError;

export const getQueryServiceMetricsViewTimeRangeUrl = (
  instanceId: string,
  metricsViewName: string,
) => {
  return `/v1/instances/${instanceId}/queries/metrics-views/${metricsViewName}/time-range-summary`;
};

export const queryServiceMetricsViewTimeRange = async (
  instanceId: string,
  metricsViewName: string,
  queryServiceMetricsViewTimeRangeBody: QueryServiceMetricsViewTimeRangeBody,
  options?: RequestInit,
): Promise<queryServiceMetricsViewTimeRangeResponse> => {
  return httpClient<queryServiceMetricsViewTimeRangeResponse>(
    getQueryServiceMetricsViewTimeRangeUrl(instanceId, metricsViewName),
    {
      ...options,
      method: "POST",
      headers: { "Content-Type": "application/json", ...options?.headers },
      body: JSON.stringify(queryServiceMetricsViewTimeRangeBody),
    },
  );
};

export const getQueryServiceMetricsViewTimeRangeQueryKey = (
  instanceId: string,
  metricsViewName: string,
  queryServiceMetricsViewTimeRangeBody?: QueryServiceMetricsViewTimeRangeBody,
) => {
  return [
    `/v1/instances/${instanceId}/queries/metrics-views/${metricsViewName}/time-range-summary`,
    queryServiceMetricsViewTimeRangeBody,
  ] as const;
};

export const getQueryServiceMetricsViewTimeRangeQueryOptions = <
  TData = Awaited<ReturnType<typeof queryServiceMetricsViewTimeRange>>,
  TError = ErrorType<RpcStatus>,
>(
  instanceId: string,
  metricsViewName: string,
  queryServiceMetricsViewTimeRangeBody: QueryServiceMetricsViewTimeRangeBody,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof queryServiceMetricsViewTimeRange>>,
        TError,
        TData
      >
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getQueryServiceMetricsViewTimeRangeQueryKey(
      instanceId,
      metricsViewName,
      queryServiceMetricsViewTimeRangeBody,
    );

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof queryServiceMetricsViewTimeRange>>
  > = ({ signal }) =>
    queryServiceMetricsViewTimeRange(
      instanceId,
      metricsViewName,
      queryServiceMetricsViewTimeRangeBody,
      { signal },
    );

  return {
    queryKey,
    queryFn,
    enabled: !!(instanceId && metricsViewName),
    ...queryOptions,
  } as CreateQueryOptions<
    Awaited<ReturnType<typeof queryServiceMetricsViewTimeRange>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type QueryServiceMetricsViewTimeRangeQueryResult = NonNullable<
  Awaited<ReturnType<typeof queryServiceMetricsViewTimeRange>>
>;
export type QueryServiceMetricsViewTimeRangeQueryError = ErrorType<RpcStatus>;

/**
 * @summary MetricsViewTimeRange Get the time range summaries (min, max) for time column in a metrics view.
Deprecated: use MetricsViewTimeRanges instead.
 */

export function createQueryServiceMetricsViewTimeRange<
  TData = Awaited<ReturnType<typeof queryServiceMetricsViewTimeRange>>,
  TError = ErrorType<RpcStatus>,
>(
  instanceId: () => string,
  metricsViewName: () => string,
  queryServiceMetricsViewTimeRangeBody: () => QueryServiceMetricsViewTimeRangeBody,
  options?: () => {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof queryServiceMetricsViewTimeRange>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: () => QueryClient,
): CreateQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const query = createQuery(
    () =>
      getQueryServiceMetricsViewTimeRangeQueryOptions(
        instanceId(),
        metricsViewName(),
        queryServiceMetricsViewTimeRangeBody(),
        options?.(),
      ),
    queryClient,
  ) as CreateQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  return query;
}

/**
 * @summary MetricsViewTimeRanges resolves time ranges for a metrics view.
 */
export type queryServiceMetricsViewTimeRangesResponse200 = {
  data: V1MetricsViewTimeRangesResponse;
  status: 200;
};

export type queryServiceMetricsViewTimeRangesResponseDefault = {
  data: RpcStatus;
  status: Exclude<HTTPStatusCodes, 200>;
};

export type queryServiceMetricsViewTimeRangesResponseSuccess =
  queryServiceMetricsViewTimeRangesResponse200 & {
    headers: Headers;
  };
export type queryServiceMetricsViewTimeRangesResponseError =
  queryServiceMetricsViewTimeRangesResponseDefault & {
    headers: Headers;
  };

export type queryServiceMetricsViewTimeRangesResponse =
  | queryServiceMetricsViewTimeRangesResponseSuccess
  | queryServiceMetricsViewTimeRangesResponseError;

export const getQueryServiceMetricsViewTimeRangesUrl = (
  instanceId: string,
  metricsViewName: string,
) => {
  return `/v1/instances/${instanceId}/queries/metrics-views/${metricsViewName}/time-ranges`;
};

export const queryServiceMetricsViewTimeRanges = async (
  instanceId: string,
  metricsViewName: string,
  queryServiceMetricsViewTimeRangesBody: QueryServiceMetricsViewTimeRangesBody,
  options?: RequestInit,
): Promise<queryServiceMetricsViewTimeRangesResponse> => {
  return httpClient<queryServiceMetricsViewTimeRangesResponse>(
    getQueryServiceMetricsViewTimeRangesUrl(instanceId, metricsViewName),
    {
      ...options,
      method: "POST",
      headers: { "Content-Type": "application/json", ...options?.headers },
      body: JSON.stringify(queryServiceMetricsViewTimeRangesBody),
    },
  );
};

export const getQueryServiceMetricsViewTimeRangesQueryKey = (
  instanceId: string,
  metricsViewName: string,
  queryServiceMetricsViewTimeRangesBody?: QueryServiceMetricsViewTimeRangesBody,
) => {
  return [
    `/v1/instances/${instanceId}/queries/metrics-views/${metricsViewName}/time-ranges`,
    queryServiceMetricsViewTimeRangesBody,
  ] as const;
};

export const getQueryServiceMetricsViewTimeRangesQueryOptions = <
  TData = Awaited<ReturnType<typeof queryServiceMetricsViewTimeRanges>>,
  TError = ErrorType<RpcStatus>,
>(
  instanceId: string,
  metricsViewName: string,
  queryServiceMetricsViewTimeRangesBody: QueryServiceMetricsViewTimeRangesBody,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof queryServiceMetricsViewTimeRanges>>,
        TError,
        TData
      >
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getQueryServiceMetricsViewTimeRangesQueryKey(
      instanceId,
      metricsViewName,
      queryServiceMetricsViewTimeRangesBody,
    );

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof queryServiceMetricsViewTimeRanges>>
  > = ({ signal }) =>
    queryServiceMetricsViewTimeRanges(
      instanceId,
      metricsViewName,
      queryServiceMetricsViewTimeRangesBody,
      { signal },
    );

  return {
    queryKey,
    queryFn,
    enabled: !!(instanceId && metricsViewName),
    ...queryOptions,
  } as CreateQueryOptions<
    Awaited<ReturnType<typeof queryServiceMetricsViewTimeRanges>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type QueryServiceMetricsViewTimeRangesQueryResult = NonNullable<
  Awaited<ReturnType<typeof queryServiceMetricsViewTimeRanges>>
>;
export type QueryServiceMetricsViewTimeRangesQueryError = ErrorType<RpcStatus>;

/**
 * @summary MetricsViewTimeRanges resolves time ranges for a metrics view.
 */

export function createQueryServiceMetricsViewTimeRanges<
  TData = Awaited<ReturnType<typeof queryServiceMetricsViewTimeRanges>>,
  TError = ErrorType<RpcStatus>,
>(
  instanceId: () => string,
  metricsViewName: () => string,
  queryServiceMetricsViewTimeRangesBody: () => QueryServiceMetricsViewTimeRangesBody,
  options?: () => {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof queryServiceMetricsViewTimeRanges>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: () => QueryClient,
): CreateQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const query = createQuery(
    () =>
      getQueryServiceMetricsViewTimeRangesQueryOptions(
        instanceId(),
        metricsViewName(),
        queryServiceMetricsViewTimeRangesBody(),
        options?.(),
      ),
    queryClient,
  ) as CreateQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  return query;
}

/**
 * @summary MetricsViewTimeSeries returns time series for the measures in the metrics view.
It's a convenience API for querying a metrics view.
 */
export type queryServiceMetricsViewTimeSeriesResponse200 = {
  data: V1MetricsViewTimeSeriesResponse;
  status: 200;
};

export type queryServiceMetricsViewTimeSeriesResponseDefault = {
  data: RpcStatus;
  status: Exclude<HTTPStatusCodes, 200>;
};

export type queryServiceMetricsViewTimeSeriesResponseSuccess =
  queryServiceMetricsViewTimeSeriesResponse200 & {
    headers: Headers;
  };
export type queryServiceMetricsViewTimeSeriesResponseError =
  queryServiceMetricsViewTimeSeriesResponseDefault & {
    headers: Headers;
  };

export type queryServiceMetricsViewTimeSeriesResponse =
  | queryServiceMetricsViewTimeSeriesResponseSuccess
  | queryServiceMetricsViewTimeSeriesResponseError;

export const getQueryServiceMetricsViewTimeSeriesUrl = (
  instanceId: string,
  metricsViewName: string,
) => {
  return `/v1/instances/${instanceId}/queries/metrics-views/${metricsViewName}/timeseries`;
};

export const queryServiceMetricsViewTimeSeries = async (
  instanceId: string,
  metricsViewName: string,
  queryServiceMetricsViewTimeSeriesBody: QueryServiceMetricsViewTimeSeriesBody,
  options?: RequestInit,
): Promise<queryServiceMetricsViewTimeSeriesResponse> => {
  return httpClient<queryServiceMetricsViewTimeSeriesResponse>(
    getQueryServiceMetricsViewTimeSeriesUrl(instanceId, metricsViewName),
    {
      ...options,
      method: "POST",
      headers: { "Content-Type": "application/json", ...options?.headers },
      body: JSON.stringify(queryServiceMetricsViewTimeSeriesBody),
    },
  );
};

export const getQueryServiceMetricsViewTimeSeriesQueryKey = (
  instanceId: string,
  metricsViewName: string,
  queryServiceMetricsViewTimeSeriesBody?: QueryServiceMetricsViewTimeSeriesBody,
) => {
  return [
    `/v1/instances/${instanceId}/queries/metrics-views/${metricsViewName}/timeseries`,
    queryServiceMetricsViewTimeSeriesBody,
  ] as const;
};

export const getQueryServiceMetricsViewTimeSeriesQueryOptions = <
  TData = Awaited<ReturnType<typeof queryServiceMetricsViewTimeSeries>>,
  TError = ErrorType<RpcStatus>,
>(
  instanceId: string,
  metricsViewName: string,
  queryServiceMetricsViewTimeSeriesBody: QueryServiceMetricsViewTimeSeriesBody,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof queryServiceMetricsViewTimeSeries>>,
        TError,
        TData
      >
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getQueryServiceMetricsViewTimeSeriesQueryKey(
      instanceId,
      metricsViewName,
      queryServiceMetricsViewTimeSeriesBody,
    );

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof queryServiceMetricsViewTimeSeries>>
  > = ({ signal }) =>
    queryServiceMetricsViewTimeSeries(
      instanceId,
      metricsViewName,
      queryServiceMetricsViewTimeSeriesBody,
      { signal },
    );

  return {
    queryKey,
    queryFn,
    enabled: !!(instanceId && metricsViewName),
    ...queryOptions,
  } as CreateQueryOptions<
    Awaited<ReturnType<typeof queryServiceMetricsViewTimeSeries>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type QueryServiceMetricsViewTimeSeriesQueryResult = NonNullable<
  Awaited<ReturnType<typeof queryServiceMetricsViewTimeSeries>>
>;
export type QueryServiceMetricsViewTimeSeriesQueryError = ErrorType<RpcStatus>;

/**
 * @summary MetricsViewTimeSeries returns time series for the measures in the metrics view.
It's a convenience API for querying a metrics view.
 */

export function createQueryServiceMetricsViewTimeSeries<
  TData = Awaited<ReturnType<typeof queryServiceMetricsViewTimeSeries>>,
  TError = ErrorType<RpcStatus>,
>(
  instanceId: () => string,
  metricsViewName: () => string,
  queryServiceMetricsViewTimeSeriesBody: () => QueryServiceMetricsViewTimeSeriesBody,
  options?: () => {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof queryServiceMetricsViewTimeSeries>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: () => QueryClient,
): CreateQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const query = createQuery(
    () =>
      getQueryServiceMetricsViewTimeSeriesQueryOptions(
        instanceId(),
        metricsViewName(),
        queryServiceMetricsViewTimeSeriesBody(),
        options?.(),
      ),
    queryClient,
  ) as CreateQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  return query;
}

/**
 * @summary Deprecated - use MetricsViewComparison instead.
MetricsViewToplist returns the top dimension values of a metrics view sorted by one or more measures.
It's a convenience API for querying a metrics view.
 */
export type queryServiceMetricsViewToplistResponse200 = {
  data: V1MetricsViewToplistResponse;
  status: 200;
};

export type queryServiceMetricsViewToplistResponseDefault = {
  data: RpcStatus;
  status: Exclude<HTTPStatusCodes, 200>;
};

export type queryServiceMetricsViewToplistResponseSuccess =
  queryServiceMetricsViewToplistResponse200 & {
    headers: Headers;
  };
export type queryServiceMetricsViewToplistResponseError =
  queryServiceMetricsViewToplistResponseDefault & {
    headers: Headers;
  };

export type queryServiceMetricsViewToplistResponse =
  | queryServiceMetricsViewToplistResponseSuccess
  | queryServiceMetricsViewToplistResponseError;

export const getQueryServiceMetricsViewToplistUrl = (
  instanceId: string,
  metricsViewName: string,
) => {
  return `/v1/instances/${instanceId}/queries/metrics-views/${metricsViewName}/toplist`;
};

export const queryServiceMetricsViewToplist = async (
  instanceId: string,
  metricsViewName: string,
  queryServiceMetricsViewToplistBody: QueryServiceMetricsViewToplistBody,
  options?: RequestInit,
): Promise<queryServiceMetricsViewToplistResponse> => {
  return httpClient<queryServiceMetricsViewToplistResponse>(
    getQueryServiceMetricsViewToplistUrl(instanceId, metricsViewName),
    {
      ...options,
      method: "POST",
      headers: { "Content-Type": "application/json", ...options?.headers },
      body: JSON.stringify(queryServiceMetricsViewToplistBody),
    },
  );
};

export const getQueryServiceMetricsViewToplistQueryKey = (
  instanceId: string,
  metricsViewName: string,
  queryServiceMetricsViewToplistBody?: QueryServiceMetricsViewToplistBody,
) => {
  return [
    `/v1/instances/${instanceId}/queries/metrics-views/${metricsViewName}/toplist`,
    queryServiceMetricsViewToplistBody,
  ] as const;
};

export const getQueryServiceMetricsViewToplistQueryOptions = <
  TData = Awaited<ReturnType<typeof queryServiceMetricsViewToplist>>,
  TError = ErrorType<RpcStatus>,
>(
  instanceId: string,
  metricsViewName: string,
  queryServiceMetricsViewToplistBody: QueryServiceMetricsViewToplistBody,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof queryServiceMetricsViewToplist>>,
        TError,
        TData
      >
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getQueryServiceMetricsViewToplistQueryKey(
      instanceId,
      metricsViewName,
      queryServiceMetricsViewToplistBody,
    );

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof queryServiceMetricsViewToplist>>
  > = ({ signal }) =>
    queryServiceMetricsViewToplist(
      instanceId,
      metricsViewName,
      queryServiceMetricsViewToplistBody,
      { signal },
    );

  return {
    queryKey,
    queryFn,
    enabled: !!(instanceId && metricsViewName),
    ...queryOptions,
  } as CreateQueryOptions<
    Awaited<ReturnType<typeof queryServiceMetricsViewToplist>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type QueryServiceMetricsViewToplistQueryResult = NonNullable<
  Awaited<ReturnType<typeof queryServiceMetricsViewToplist>>
>;
export type QueryServiceMetricsViewToplistQueryError = ErrorType<RpcStatus>;

/**
 * @summary Deprecated - use MetricsViewComparison instead.
MetricsViewToplist returns the top dimension values of a metrics view sorted by one or more measures.
It's a convenience API for querying a metrics view.
 */

export function createQueryServiceMetricsViewToplist<
  TData = Awaited<ReturnType<typeof queryServiceMetricsViewToplist>>,
  TError = ErrorType<RpcStatus>,
>(
  instanceId: () => string,
  metricsViewName: () => string,
  queryServiceMetricsViewToplistBody: () => QueryServiceMetricsViewToplistBody,
  options?: () => {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof queryServiceMetricsViewToplist>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: () => QueryClient,
): CreateQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const query = createQuery(
    () =>
      getQueryServiceMetricsViewToplistQueryOptions(
        instanceId(),
        metricsViewName(),
        queryServiceMetricsViewToplistBody(),
        options?.(),
      ),
    queryClient,
  ) as CreateQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  return query;
}

/**
 * @summary MetricsViewTotals returns totals over a time period for the measures in a metrics view.
It's a convenience API for querying a metrics view.
 */
export type queryServiceMetricsViewTotalsResponse200 = {
  data: V1MetricsViewTotalsResponse;
  status: 200;
};

export type queryServiceMetricsViewTotalsResponseDefault = {
  data: RpcStatus;
  status: Exclude<HTTPStatusCodes, 200>;
};

export type queryServiceMetricsViewTotalsResponseSuccess =
  queryServiceMetricsViewTotalsResponse200 & {
    headers: Headers;
  };
export type queryServiceMetricsViewTotalsResponseError =
  queryServiceMetricsViewTotalsResponseDefault & {
    headers: Headers;
  };

export type queryServiceMetricsViewTotalsResponse =
  | queryServiceMetricsViewTotalsResponseSuccess
  | queryServiceMetricsViewTotalsResponseError;

export const getQueryServiceMetricsViewTotalsUrl = (
  instanceId: string,
  metricsViewName: string,
) => {
  return `/v1/instances/${instanceId}/queries/metrics-views/${metricsViewName}/totals`;
};

export const queryServiceMetricsViewTotals = async (
  instanceId: string,
  metricsViewName: string,
  queryServiceMetricsViewTotalsBody: QueryServiceMetricsViewTotalsBody,
  options?: RequestInit,
): Promise<queryServiceMetricsViewTotalsResponse> => {
  return httpClient<queryServiceMetricsViewTotalsResponse>(
    getQueryServiceMetricsViewTotalsUrl(instanceId, metricsViewName),
    {
      ...options,
      method: "POST",
      headers: { "Content-Type": "application/json", ...options?.headers },
      body: JSON.stringify(queryServiceMetricsViewTotalsBody),
    },
  );
};

export const getQueryServiceMetricsViewTotalsQueryKey = (
  instanceId: string,
  metricsViewName: string,
  queryServiceMetricsViewTotalsBody?: QueryServiceMetricsViewTotalsBody,
) => {
  return [
    `/v1/instances/${instanceId}/queries/metrics-views/${metricsViewName}/totals`,
    queryServiceMetricsViewTotalsBody,
  ] as const;
};

export const getQueryServiceMetricsViewTotalsQueryOptions = <
  TData = Awaited<ReturnType<typeof queryServiceMetricsViewTotals>>,
  TError = ErrorType<RpcStatus>,
>(
  instanceId: string,
  metricsViewName: string,
  queryServiceMetricsViewTotalsBody: QueryServiceMetricsViewTotalsBody,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof queryServiceMetricsViewTotals>>,
        TError,
        TData
      >
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getQueryServiceMetricsViewTotalsQueryKey(
      instanceId,
      metricsViewName,
      queryServiceMetricsViewTotalsBody,
    );

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof queryServiceMetricsViewTotals>>
  > = ({ signal }) =>
    queryServiceMetricsViewTotals(
      instanceId,
      metricsViewName,
      queryServiceMetricsViewTotalsBody,
      { signal },
    );

  return {
    queryKey,
    queryFn,
    enabled: !!(instanceId && metricsViewName),
    ...queryOptions,
  } as CreateQueryOptions<
    Awaited<ReturnType<typeof queryServiceMetricsViewTotals>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type QueryServiceMetricsViewTotalsQueryResult = NonNullable<
  Awaited<ReturnType<typeof queryServiceMetricsViewTotals>>
>;
export type QueryServiceMetricsViewTotalsQueryError = ErrorType<RpcStatus>;

/**
 * @summary MetricsViewTotals returns totals over a time period for the measures in a metrics view.
It's a convenience API for querying a metrics view.
 */

export function createQueryServiceMetricsViewTotals<
  TData = Awaited<ReturnType<typeof queryServiceMetricsViewTotals>>,
  TError = ErrorType<RpcStatus>,
>(
  instanceId: () => string,
  metricsViewName: () => string,
  queryServiceMetricsViewTotalsBody: () => QueryServiceMetricsViewTotalsBody,
  options?: () => {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof queryServiceMetricsViewTotals>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: () => QueryClient,
): CreateQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const query = createQuery(
    () =>
      getQueryServiceMetricsViewTotalsQueryOptions(
        instanceId(),
        metricsViewName(),
        queryServiceMetricsViewTotalsBody(),
        options?.(),
      ),
    queryClient,
  ) as CreateQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  return query;
}

/**
 * @summary Get the number of nulls in a column
 */
export type queryServiceColumnNullCountResponse200 = {
  data: V1ColumnNullCountResponse;
  status: 200;
};

export type queryServiceColumnNullCountResponseDefault = {
  data: RpcStatus;
  status: Exclude<HTTPStatusCodes, 200>;
};

export type queryServiceColumnNullCountResponseSuccess =
  queryServiceColumnNullCountResponse200 & {
    headers: Headers;
  };
export type queryServiceColumnNullCountResponseError =
  queryServiceColumnNullCountResponseDefault & {
    headers: Headers;
  };

export type queryServiceColumnNullCountResponse =
  | queryServiceColumnNullCountResponseSuccess
  | queryServiceColumnNullCountResponseError;

export const getQueryServiceColumnNullCountUrl = (
  instanceId: string,
  tableName: string,
  params?: QueryServiceColumnNullCountParams,
) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? "null" : value.toString());
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0
    ? `/v1/instances/${instanceId}/queries/null-count/tables/${tableName}?${stringifiedParams}`
    : `/v1/instances/${instanceId}/queries/null-count/tables/${tableName}`;
};

export const queryServiceColumnNullCount = async (
  instanceId: string,
  tableName: string,
  params?: QueryServiceColumnNullCountParams,
  options?: RequestInit,
): Promise<queryServiceColumnNullCountResponse> => {
  return httpClient<queryServiceColumnNullCountResponse>(
    getQueryServiceColumnNullCountUrl(instanceId, tableName, params),
    {
      ...options,
      method: "GET",
    },
  );
};

export const getQueryServiceColumnNullCountQueryKey = (
  instanceId: string,
  tableName: string,
  params?: QueryServiceColumnNullCountParams,
) => {
  return [
    `/v1/instances/${instanceId}/queries/null-count/tables/${tableName}`,
    ...(params ? [params] : []),
  ] as const;
};

export const getQueryServiceColumnNullCountQueryOptions = <
  TData = Awaited<ReturnType<typeof queryServiceColumnNullCount>>,
  TError = ErrorType<RpcStatus>,
>(
  instanceId: string,
  tableName: string,
  params?: QueryServiceColumnNullCountParams,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof queryServiceColumnNullCount>>,
        TError,
        TData
      >
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getQueryServiceColumnNullCountQueryKey(instanceId, tableName, params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof queryServiceColumnNullCount>>
  > = ({ signal }) =>
    queryServiceColumnNullCount(instanceId, tableName, params, { signal });

  return {
    queryKey,
    queryFn,
    enabled: !!(instanceId && tableName),
    ...queryOptions,
  } as CreateQueryOptions<
    Awaited<ReturnType<typeof queryServiceColumnNullCount>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type QueryServiceColumnNullCountQueryResult = NonNullable<
  Awaited<ReturnType<typeof queryServiceColumnNullCount>>
>;
export type QueryServiceColumnNullCountQueryError = ErrorType<RpcStatus>;

/**
 * @summary Get the number of nulls in a column
 */

export function createQueryServiceColumnNullCount<
  TData = Awaited<ReturnType<typeof queryServiceColumnNullCount>>,
  TError = ErrorType<RpcStatus>,
>(
  instanceId: () => string,
  tableName: () => string,
  params?: () => QueryServiceColumnNullCountParams,
  options?: () => {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof queryServiceColumnNullCount>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: () => QueryClient,
): CreateQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const query = createQuery(
    () =>
      getQueryServiceColumnNullCountQueryOptions(
        instanceId(),
        tableName(),
        params?.(),
        options?.(),
      ),
    queryClient,
  ) as CreateQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  return query;
}

/**
 * @summary Get the histogram for values in a column
 */
export type queryServiceColumnNumericHistogramResponse200 = {
  data: V1ColumnNumericHistogramResponse;
  status: 200;
};

export type queryServiceColumnNumericHistogramResponseDefault = {
  data: RpcStatus;
  status: Exclude<HTTPStatusCodes, 200>;
};

export type queryServiceColumnNumericHistogramResponseSuccess =
  queryServiceColumnNumericHistogramResponse200 & {
    headers: Headers;
  };
export type queryServiceColumnNumericHistogramResponseError =
  queryServiceColumnNumericHistogramResponseDefault & {
    headers: Headers;
  };

export type queryServiceColumnNumericHistogramResponse =
  | queryServiceColumnNumericHistogramResponseSuccess
  | queryServiceColumnNumericHistogramResponseError;

export const getQueryServiceColumnNumericHistogramUrl = (
  instanceId: string,
  tableName: string,
  params?: QueryServiceColumnNumericHistogramParams,
) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? "null" : value.toString());
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0
    ? `/v1/instances/${instanceId}/queries/numeric-histogram/tables/${tableName}?${stringifiedParams}`
    : `/v1/instances/${instanceId}/queries/numeric-histogram/tables/${tableName}`;
};

export const queryServiceColumnNumericHistogram = async (
  instanceId: string,
  tableName: string,
  params?: QueryServiceColumnNumericHistogramParams,
  options?: RequestInit,
): Promise<queryServiceColumnNumericHistogramResponse> => {
  return httpClient<queryServiceColumnNumericHistogramResponse>(
    getQueryServiceColumnNumericHistogramUrl(instanceId, tableName, params),
    {
      ...options,
      method: "GET",
    },
  );
};

export const getQueryServiceColumnNumericHistogramQueryKey = (
  instanceId: string,
  tableName: string,
  params?: QueryServiceColumnNumericHistogramParams,
) => {
  return [
    `/v1/instances/${instanceId}/queries/numeric-histogram/tables/${tableName}`,
    ...(params ? [params] : []),
  ] as const;
};

export const getQueryServiceColumnNumericHistogramQueryOptions = <
  TData = Awaited<ReturnType<typeof queryServiceColumnNumericHistogram>>,
  TError = ErrorType<RpcStatus>,
>(
  instanceId: string,
  tableName: string,
  params?: QueryServiceColumnNumericHistogramParams,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof queryServiceColumnNumericHistogram>>,
        TError,
        TData
      >
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getQueryServiceColumnNumericHistogramQueryKey(
      instanceId,
      tableName,
      params,
    );

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof queryServiceColumnNumericHistogram>>
  > = ({ signal }) =>
    queryServiceColumnNumericHistogram(instanceId, tableName, params, {
      signal,
    });

  return {
    queryKey,
    queryFn,
    enabled: !!(instanceId && tableName),
    ...queryOptions,
  } as CreateQueryOptions<
    Awaited<ReturnType<typeof queryServiceColumnNumericHistogram>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type QueryServiceColumnNumericHistogramQueryResult = NonNullable<
  Awaited<ReturnType<typeof queryServiceColumnNumericHistogram>>
>;
export type QueryServiceColumnNumericHistogramQueryError = ErrorType<RpcStatus>;

/**
 * @summary Get the histogram for values in a column
 */

export function createQueryServiceColumnNumericHistogram<
  TData = Awaited<ReturnType<typeof queryServiceColumnNumericHistogram>>,
  TError = ErrorType<RpcStatus>,
>(
  instanceId: () => string,
  tableName: () => string,
  params?: () => QueryServiceColumnNumericHistogramParams,
  options?: () => {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof queryServiceColumnNumericHistogram>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: () => QueryClient,
): CreateQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const query = createQuery(
    () =>
      getQueryServiceColumnNumericHistogramQueryOptions(
        instanceId(),
        tableName(),
        params?.(),
        options?.(),
      ),
    queryClient,
  ) as CreateQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  return query;
}

/**
 * @summary ResolveTemplatedString resolves a templated strings.
 */
export type queryServiceResolveTemplatedStringResponse200 = {
  data: V1ResolveTemplatedStringResponse;
  status: 200;
};

export type queryServiceResolveTemplatedStringResponseDefault = {
  data: RpcStatus;
  status: Exclude<HTTPStatusCodes, 200>;
};

export type queryServiceResolveTemplatedStringResponseSuccess =
  queryServiceResolveTemplatedStringResponse200 & {
    headers: Headers;
  };
export type queryServiceResolveTemplatedStringResponseError =
  queryServiceResolveTemplatedStringResponseDefault & {
    headers: Headers;
  };

export type queryServiceResolveTemplatedStringResponse =
  | queryServiceResolveTemplatedStringResponseSuccess
  | queryServiceResolveTemplatedStringResponseError;

export const getQueryServiceResolveTemplatedStringUrl = (
  instanceId: string,
) => {
  return `/v1/instances/${instanceId}/queries/resolve-templated-string`;
};

export const queryServiceResolveTemplatedString = async (
  instanceId: string,
  queryServiceResolveTemplatedStringBody: QueryServiceResolveTemplatedStringBody,
  options?: RequestInit,
): Promise<queryServiceResolveTemplatedStringResponse> => {
  return httpClient<queryServiceResolveTemplatedStringResponse>(
    getQueryServiceResolveTemplatedStringUrl(instanceId),
    {
      ...options,
      method: "POST",
      headers: { "Content-Type": "application/json", ...options?.headers },
      body: JSON.stringify(queryServiceResolveTemplatedStringBody),
    },
  );
};

export const getQueryServiceResolveTemplatedStringQueryKey = (
  instanceId: string,
  queryServiceResolveTemplatedStringBody?: QueryServiceResolveTemplatedStringBody,
) => {
  return [
    `/v1/instances/${instanceId}/queries/resolve-templated-string`,
    queryServiceResolveTemplatedStringBody,
  ] as const;
};

export const getQueryServiceResolveTemplatedStringQueryOptions = <
  TData = Awaited<ReturnType<typeof queryServiceResolveTemplatedString>>,
  TError = ErrorType<RpcStatus>,
>(
  instanceId: string,
  queryServiceResolveTemplatedStringBody: QueryServiceResolveTemplatedStringBody,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof queryServiceResolveTemplatedString>>,
        TError,
        TData
      >
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getQueryServiceResolveTemplatedStringQueryKey(
      instanceId,
      queryServiceResolveTemplatedStringBody,
    );

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof queryServiceResolveTemplatedString>>
  > = ({ signal }) =>
    queryServiceResolveTemplatedString(
      instanceId,
      queryServiceResolveTemplatedStringBody,
      { signal },
    );

  return {
    queryKey,
    queryFn,
    enabled: !!instanceId,
    ...queryOptions,
  } as CreateQueryOptions<
    Awaited<ReturnType<typeof queryServiceResolveTemplatedString>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type QueryServiceResolveTemplatedStringQueryResult = NonNullable<
  Awaited<ReturnType<typeof queryServiceResolveTemplatedString>>
>;
export type QueryServiceResolveTemplatedStringQueryError = ErrorType<RpcStatus>;

/**
 * @summary ResolveTemplatedString resolves a templated strings.
 */

export function createQueryServiceResolveTemplatedString<
  TData = Awaited<ReturnType<typeof queryServiceResolveTemplatedString>>,
  TError = ErrorType<RpcStatus>,
>(
  instanceId: () => string,
  queryServiceResolveTemplatedStringBody: () => QueryServiceResolveTemplatedStringBody,
  options?: () => {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof queryServiceResolveTemplatedString>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: () => QueryClient,
): CreateQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const query = createQuery(
    () =>
      getQueryServiceResolveTemplatedStringQueryOptions(
        instanceId(),
        queryServiceResolveTemplatedStringBody(),
        options?.(),
      ),
    queryClient,
  ) as CreateQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  return query;
}

/**
 * @summary ColumnRollupInterval returns the minimum time granularity (as well as the time range) for a specified timestamp column
 */
export type queryServiceColumnRollupIntervalResponse200 = {
  data: V1ColumnRollupIntervalResponse;
  status: 200;
};

export type queryServiceColumnRollupIntervalResponseDefault = {
  data: RpcStatus;
  status: Exclude<HTTPStatusCodes, 200>;
};

export type queryServiceColumnRollupIntervalResponseSuccess =
  queryServiceColumnRollupIntervalResponse200 & {
    headers: Headers;
  };
export type queryServiceColumnRollupIntervalResponseError =
  queryServiceColumnRollupIntervalResponseDefault & {
    headers: Headers;
  };

export type queryServiceColumnRollupIntervalResponse =
  | queryServiceColumnRollupIntervalResponseSuccess
  | queryServiceColumnRollupIntervalResponseError;

export const getQueryServiceColumnRollupIntervalUrl = (
  instanceId: string,
  tableName: string,
) => {
  return `/v1/instances/${instanceId}/queries/rollup-interval/tables/${tableName}`;
};

export const queryServiceColumnRollupInterval = async (
  instanceId: string,
  tableName: string,
  queryServiceColumnRollupIntervalBody: QueryServiceColumnRollupIntervalBody,
  options?: RequestInit,
): Promise<queryServiceColumnRollupIntervalResponse> => {
  return httpClient<queryServiceColumnRollupIntervalResponse>(
    getQueryServiceColumnRollupIntervalUrl(instanceId, tableName),
    {
      ...options,
      method: "POST",
      headers: { "Content-Type": "application/json", ...options?.headers },
      body: JSON.stringify(queryServiceColumnRollupIntervalBody),
    },
  );
};

export const getQueryServiceColumnRollupIntervalQueryKey = (
  instanceId: string,
  tableName: string,
  queryServiceColumnRollupIntervalBody?: QueryServiceColumnRollupIntervalBody,
) => {
  return [
    `/v1/instances/${instanceId}/queries/rollup-interval/tables/${tableName}`,
    queryServiceColumnRollupIntervalBody,
  ] as const;
};

export const getQueryServiceColumnRollupIntervalQueryOptions = <
  TData = Awaited<ReturnType<typeof queryServiceColumnRollupInterval>>,
  TError = ErrorType<RpcStatus>,
>(
  instanceId: string,
  tableName: string,
  queryServiceColumnRollupIntervalBody: QueryServiceColumnRollupIntervalBody,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof queryServiceColumnRollupInterval>>,
        TError,
        TData
      >
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getQueryServiceColumnRollupIntervalQueryKey(
      instanceId,
      tableName,
      queryServiceColumnRollupIntervalBody,
    );

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof queryServiceColumnRollupInterval>>
  > = ({ signal }) =>
    queryServiceColumnRollupInterval(
      instanceId,
      tableName,
      queryServiceColumnRollupIntervalBody,
      { signal },
    );

  return {
    queryKey,
    queryFn,
    enabled: !!(instanceId && tableName),
    ...queryOptions,
  } as CreateQueryOptions<
    Awaited<ReturnType<typeof queryServiceColumnRollupInterval>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type QueryServiceColumnRollupIntervalQueryResult = NonNullable<
  Awaited<ReturnType<typeof queryServiceColumnRollupInterval>>
>;
export type QueryServiceColumnRollupIntervalQueryError = ErrorType<RpcStatus>;

/**
 * @summary ColumnRollupInterval returns the minimum time granularity (as well as the time range) for a specified timestamp column
 */

export function createQueryServiceColumnRollupInterval<
  TData = Awaited<ReturnType<typeof queryServiceColumnRollupInterval>>,
  TError = ErrorType<RpcStatus>,
>(
  instanceId: () => string,
  tableName: () => string,
  queryServiceColumnRollupIntervalBody: () => QueryServiceColumnRollupIntervalBody,
  options?: () => {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof queryServiceColumnRollupInterval>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: () => QueryClient,
): CreateQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const query = createQuery(
    () =>
      getQueryServiceColumnRollupIntervalQueryOptions(
        instanceId(),
        tableName(),
        queryServiceColumnRollupIntervalBody(),
        options?.(),
      ),
    queryClient,
  ) as CreateQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  return query;
}

/**
 * @summary TableRows returns table rows
 */
export type queryServiceTableRowsResponse200 = {
  data: V1TableRowsResponse;
  status: 200;
};

export type queryServiceTableRowsResponseDefault = {
  data: RpcStatus;
  status: Exclude<HTTPStatusCodes, 200>;
};

export type queryServiceTableRowsResponseSuccess =
  queryServiceTableRowsResponse200 & {
    headers: Headers;
  };
export type queryServiceTableRowsResponseError =
  queryServiceTableRowsResponseDefault & {
    headers: Headers;
  };

export type queryServiceTableRowsResponse =
  | queryServiceTableRowsResponseSuccess
  | queryServiceTableRowsResponseError;

export const getQueryServiceTableRowsUrl = (
  instanceId: string,
  tableName: string,
  params?: QueryServiceTableRowsParams,
) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? "null" : value.toString());
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0
    ? `/v1/instances/${instanceId}/queries/rows/tables/${tableName}?${stringifiedParams}`
    : `/v1/instances/${instanceId}/queries/rows/tables/${tableName}`;
};

export const queryServiceTableRows = async (
  instanceId: string,
  tableName: string,
  params?: QueryServiceTableRowsParams,
  options?: RequestInit,
): Promise<queryServiceTableRowsResponse> => {
  return httpClient<queryServiceTableRowsResponse>(
    getQueryServiceTableRowsUrl(instanceId, tableName, params),
    {
      ...options,
      method: "GET",
    },
  );
};

export const getQueryServiceTableRowsQueryKey = (
  instanceId: string,
  tableName: string,
  params?: QueryServiceTableRowsParams,
) => {
  return [
    `/v1/instances/${instanceId}/queries/rows/tables/${tableName}`,
    ...(params ? [params] : []),
  ] as const;
};

export const getQueryServiceTableRowsQueryOptions = <
  TData = Awaited<ReturnType<typeof queryServiceTableRows>>,
  TError = ErrorType<RpcStatus>,
>(
  instanceId: string,
  tableName: string,
  params?: QueryServiceTableRowsParams,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof queryServiceTableRows>>,
        TError,
        TData
      >
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getQueryServiceTableRowsQueryKey(instanceId, tableName, params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof queryServiceTableRows>>
  > = ({ signal }) =>
    queryServiceTableRows(instanceId, tableName, params, { signal });

  return {
    queryKey,
    queryFn,
    enabled: !!(instanceId && tableName),
    ...queryOptions,
  } as CreateQueryOptions<
    Awaited<ReturnType<typeof queryServiceTableRows>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type QueryServiceTableRowsQueryResult = NonNullable<
  Awaited<ReturnType<typeof queryServiceTableRows>>
>;
export type QueryServiceTableRowsQueryError = ErrorType<RpcStatus>;

/**
 * @summary TableRows returns table rows
 */

export function createQueryServiceTableRows<
  TData = Awaited<ReturnType<typeof queryServiceTableRows>>,
  TError = ErrorType<RpcStatus>,
>(
  instanceId: () => string,
  tableName: () => string,
  params?: () => QueryServiceTableRowsParams,
  options?: () => {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof queryServiceTableRows>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: () => QueryClient,
): CreateQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const query = createQuery(
    () =>
      getQueryServiceTableRowsQueryOptions(
        instanceId(),
        tableName(),
        params?.(),
        options?.(),
      ),
    queryClient,
  ) as CreateQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  return query;
}

/**
 * @summary Get outliers for a numeric column
 */
export type queryServiceColumnRugHistogramResponse200 = {
  data: V1ColumnRugHistogramResponse;
  status: 200;
};

export type queryServiceColumnRugHistogramResponseDefault = {
  data: RpcStatus;
  status: Exclude<HTTPStatusCodes, 200>;
};

export type queryServiceColumnRugHistogramResponseSuccess =
  queryServiceColumnRugHistogramResponse200 & {
    headers: Headers;
  };
export type queryServiceColumnRugHistogramResponseError =
  queryServiceColumnRugHistogramResponseDefault & {
    headers: Headers;
  };

export type queryServiceColumnRugHistogramResponse =
  | queryServiceColumnRugHistogramResponseSuccess
  | queryServiceColumnRugHistogramResponseError;

export const getQueryServiceColumnRugHistogramUrl = (
  instanceId: string,
  tableName: string,
  params?: QueryServiceColumnRugHistogramParams,
) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? "null" : value.toString());
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0
    ? `/v1/instances/${instanceId}/queries/rug-histogram/tables/${tableName}?${stringifiedParams}`
    : `/v1/instances/${instanceId}/queries/rug-histogram/tables/${tableName}`;
};

export const queryServiceColumnRugHistogram = async (
  instanceId: string,
  tableName: string,
  params?: QueryServiceColumnRugHistogramParams,
  options?: RequestInit,
): Promise<queryServiceColumnRugHistogramResponse> => {
  return httpClient<queryServiceColumnRugHistogramResponse>(
    getQueryServiceColumnRugHistogramUrl(instanceId, tableName, params),
    {
      ...options,
      method: "GET",
    },
  );
};

export const getQueryServiceColumnRugHistogramQueryKey = (
  instanceId: string,
  tableName: string,
  params?: QueryServiceColumnRugHistogramParams,
) => {
  return [
    `/v1/instances/${instanceId}/queries/rug-histogram/tables/${tableName}`,
    ...(params ? [params] : []),
  ] as const;
};

export const getQueryServiceColumnRugHistogramQueryOptions = <
  TData = Awaited<ReturnType<typeof queryServiceColumnRugHistogram>>,
  TError = ErrorType<RpcStatus>,
>(
  instanceId: string,
  tableName: string,
  params?: QueryServiceColumnRugHistogramParams,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof queryServiceColumnRugHistogram>>,
        TError,
        TData
      >
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getQueryServiceColumnRugHistogramQueryKey(instanceId, tableName, params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof queryServiceColumnRugHistogram>>
  > = ({ signal }) =>
    queryServiceColumnRugHistogram(instanceId, tableName, params, { signal });

  return {
    queryKey,
    queryFn,
    enabled: !!(instanceId && tableName),
    ...queryOptions,
  } as CreateQueryOptions<
    Awaited<ReturnType<typeof queryServiceColumnRugHistogram>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type QueryServiceColumnRugHistogramQueryResult = NonNullable<
  Awaited<ReturnType<typeof queryServiceColumnRugHistogram>>
>;
export type QueryServiceColumnRugHistogramQueryError = ErrorType<RpcStatus>;

/**
 * @summary Get outliers for a numeric column
 */

export function createQueryServiceColumnRugHistogram<
  TData = Awaited<ReturnType<typeof queryServiceColumnRugHistogram>>,
  TError = ErrorType<RpcStatus>,
>(
  instanceId: () => string,
  tableName: () => string,
  params?: () => QueryServiceColumnRugHistogramParams,
  options?: () => {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof queryServiceColumnRugHistogram>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: () => QueryClient,
): CreateQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const query = createQuery(
    () =>
      getQueryServiceColumnRugHistogramQueryOptions(
        instanceId(),
        tableName(),
        params?.(),
        options?.(),
      ),
    queryClient,
  ) as CreateQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  return query;
}

/**
 * @summary Estimates the smallest time grain present in the column
 */
export type queryServiceColumnTimeGrainResponse200 = {
  data: V1ColumnTimeGrainResponse;
  status: 200;
};

export type queryServiceColumnTimeGrainResponseDefault = {
  data: RpcStatus;
  status: Exclude<HTTPStatusCodes, 200>;
};

export type queryServiceColumnTimeGrainResponseSuccess =
  queryServiceColumnTimeGrainResponse200 & {
    headers: Headers;
  };
export type queryServiceColumnTimeGrainResponseError =
  queryServiceColumnTimeGrainResponseDefault & {
    headers: Headers;
  };

export type queryServiceColumnTimeGrainResponse =
  | queryServiceColumnTimeGrainResponseSuccess
  | queryServiceColumnTimeGrainResponseError;

export const getQueryServiceColumnTimeGrainUrl = (
  instanceId: string,
  tableName: string,
  params?: QueryServiceColumnTimeGrainParams,
) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? "null" : value.toString());
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0
    ? `/v1/instances/${instanceId}/queries/smallest-time-grain/tables/${tableName}?${stringifiedParams}`
    : `/v1/instances/${instanceId}/queries/smallest-time-grain/tables/${tableName}`;
};

export const queryServiceColumnTimeGrain = async (
  instanceId: string,
  tableName: string,
  params?: QueryServiceColumnTimeGrainParams,
  options?: RequestInit,
): Promise<queryServiceColumnTimeGrainResponse> => {
  return httpClient<queryServiceColumnTimeGrainResponse>(
    getQueryServiceColumnTimeGrainUrl(instanceId, tableName, params),
    {
      ...options,
      method: "GET",
    },
  );
};

export const getQueryServiceColumnTimeGrainQueryKey = (
  instanceId: string,
  tableName: string,
  params?: QueryServiceColumnTimeGrainParams,
) => {
  return [
    `/v1/instances/${instanceId}/queries/smallest-time-grain/tables/${tableName}`,
    ...(params ? [params] : []),
  ] as const;
};

export const getQueryServiceColumnTimeGrainQueryOptions = <
  TData = Awaited<ReturnType<typeof queryServiceColumnTimeGrain>>,
  TError = ErrorType<RpcStatus>,
>(
  instanceId: string,
  tableName: string,
  params?: QueryServiceColumnTimeGrainParams,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof queryServiceColumnTimeGrain>>,
        TError,
        TData
      >
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getQueryServiceColumnTimeGrainQueryKey(instanceId, tableName, params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof queryServiceColumnTimeGrain>>
  > = ({ signal }) =>
    queryServiceColumnTimeGrain(instanceId, tableName, params, { signal });

  return {
    queryKey,
    queryFn,
    enabled: !!(instanceId && tableName),
    ...queryOptions,
  } as CreateQueryOptions<
    Awaited<ReturnType<typeof queryServiceColumnTimeGrain>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type QueryServiceColumnTimeGrainQueryResult = NonNullable<
  Awaited<ReturnType<typeof queryServiceColumnTimeGrain>>
>;
export type QueryServiceColumnTimeGrainQueryError = ErrorType<RpcStatus>;

/**
 * @summary Estimates the smallest time grain present in the column
 */

export function createQueryServiceColumnTimeGrain<
  TData = Awaited<ReturnType<typeof queryServiceColumnTimeGrain>>,
  TError = ErrorType<RpcStatus>,
>(
  instanceId: () => string,
  tableName: () => string,
  params?: () => QueryServiceColumnTimeGrainParams,
  options?: () => {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof queryServiceColumnTimeGrain>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: () => QueryClient,
): CreateQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const query = createQuery(
    () =>
      getQueryServiceColumnTimeGrainQueryOptions(
        instanceId(),
        tableName(),
        params?.(),
        options?.(),
      ),
    queryClient,
  ) as CreateQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  return query;
}

/**
 * @summary TableCardinality returns row count
 */
export type queryServiceTableCardinalityResponse200 = {
  data: V1TableCardinalityResponse;
  status: 200;
};

export type queryServiceTableCardinalityResponseDefault = {
  data: RpcStatus;
  status: Exclude<HTTPStatusCodes, 200>;
};

export type queryServiceTableCardinalityResponseSuccess =
  queryServiceTableCardinalityResponse200 & {
    headers: Headers;
  };
export type queryServiceTableCardinalityResponseError =
  queryServiceTableCardinalityResponseDefault & {
    headers: Headers;
  };

export type queryServiceTableCardinalityResponse =
  | queryServiceTableCardinalityResponseSuccess
  | queryServiceTableCardinalityResponseError;

export const getQueryServiceTableCardinalityUrl = (
  instanceId: string,
  tableName: string,
  params?: QueryServiceTableCardinalityParams,
) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? "null" : value.toString());
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0
    ? `/v1/instances/${instanceId}/queries/table-cardinality/tables/${tableName}?${stringifiedParams}`
    : `/v1/instances/${instanceId}/queries/table-cardinality/tables/${tableName}`;
};

export const queryServiceTableCardinality = async (
  instanceId: string,
  tableName: string,
  params?: QueryServiceTableCardinalityParams,
  options?: RequestInit,
): Promise<queryServiceTableCardinalityResponse> => {
  return httpClient<queryServiceTableCardinalityResponse>(
    getQueryServiceTableCardinalityUrl(instanceId, tableName, params),
    {
      ...options,
      method: "GET",
    },
  );
};

export const getQueryServiceTableCardinalityQueryKey = (
  instanceId: string,
  tableName: string,
  params?: QueryServiceTableCardinalityParams,
) => {
  return [
    `/v1/instances/${instanceId}/queries/table-cardinality/tables/${tableName}`,
    ...(params ? [params] : []),
  ] as const;
};

export const getQueryServiceTableCardinalityQueryOptions = <
  TData = Awaited<ReturnType<typeof queryServiceTableCardinality>>,
  TError = ErrorType<RpcStatus>,
>(
  instanceId: string,
  tableName: string,
  params?: QueryServiceTableCardinalityParams,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof queryServiceTableCardinality>>,
        TError,
        TData
      >
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getQueryServiceTableCardinalityQueryKey(instanceId, tableName, params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof queryServiceTableCardinality>>
  > = ({ signal }) =>
    queryServiceTableCardinality(instanceId, tableName, params, { signal });

  return {
    queryKey,
    queryFn,
    enabled: !!(instanceId && tableName),
    ...queryOptions,
  } as CreateQueryOptions<
    Awaited<ReturnType<typeof queryServiceTableCardinality>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type QueryServiceTableCardinalityQueryResult = NonNullable<
  Awaited<ReturnType<typeof queryServiceTableCardinality>>
>;
export type QueryServiceTableCardinalityQueryError = ErrorType<RpcStatus>;

/**
 * @summary TableCardinality returns row count
 */

export function createQueryServiceTableCardinality<
  TData = Awaited<ReturnType<typeof queryServiceTableCardinality>>,
  TError = ErrorType<RpcStatus>,
>(
  instanceId: () => string,
  tableName: () => string,
  params?: () => QueryServiceTableCardinalityParams,
  options?: () => {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof queryServiceTableCardinality>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: () => QueryClient,
): CreateQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const query = createQuery(
    () =>
      getQueryServiceTableCardinalityQueryOptions(
        instanceId(),
        tableName(),
        params?.(),
        options?.(),
      ),
    queryClient,
  ) as CreateQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  return query;
}

/**
 * @summary Get the time range summaries (min, max) for a column
 */
export type queryServiceColumnTimeRangeResponse200 = {
  data: V1ColumnTimeRangeResponse;
  status: 200;
};

export type queryServiceColumnTimeRangeResponseDefault = {
  data: RpcStatus;
  status: Exclude<HTTPStatusCodes, 200>;
};

export type queryServiceColumnTimeRangeResponseSuccess =
  queryServiceColumnTimeRangeResponse200 & {
    headers: Headers;
  };
export type queryServiceColumnTimeRangeResponseError =
  queryServiceColumnTimeRangeResponseDefault & {
    headers: Headers;
  };

export type queryServiceColumnTimeRangeResponse =
  | queryServiceColumnTimeRangeResponseSuccess
  | queryServiceColumnTimeRangeResponseError;

export const getQueryServiceColumnTimeRangeUrl = (
  instanceId: string,
  tableName: string,
  params?: QueryServiceColumnTimeRangeParams,
) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? "null" : value.toString());
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0
    ? `/v1/instances/${instanceId}/queries/time-range-summary/tables/${tableName}?${stringifiedParams}`
    : `/v1/instances/${instanceId}/queries/time-range-summary/tables/${tableName}`;
};

export const queryServiceColumnTimeRange = async (
  instanceId: string,
  tableName: string,
  params?: QueryServiceColumnTimeRangeParams,
  options?: RequestInit,
): Promise<queryServiceColumnTimeRangeResponse> => {
  return httpClient<queryServiceColumnTimeRangeResponse>(
    getQueryServiceColumnTimeRangeUrl(instanceId, tableName, params),
    {
      ...options,
      method: "GET",
    },
  );
};

export const getQueryServiceColumnTimeRangeQueryKey = (
  instanceId: string,
  tableName: string,
  params?: QueryServiceColumnTimeRangeParams,
) => {
  return [
    `/v1/instances/${instanceId}/queries/time-range-summary/tables/${tableName}`,
    ...(params ? [params] : []),
  ] as const;
};

export const getQueryServiceColumnTimeRangeQueryOptions = <
  TData = Awaited<ReturnType<typeof queryServiceColumnTimeRange>>,
  TError = ErrorType<RpcStatus>,
>(
  instanceId: string,
  tableName: string,
  params?: QueryServiceColumnTimeRangeParams,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof queryServiceColumnTimeRange>>,
        TError,
        TData
      >
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getQueryServiceColumnTimeRangeQueryKey(instanceId, tableName, params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof queryServiceColumnTimeRange>>
  > = ({ signal }) =>
    queryServiceColumnTimeRange(instanceId, tableName, params, { signal });

  return {
    queryKey,
    queryFn,
    enabled: !!(instanceId && tableName),
    ...queryOptions,
  } as CreateQueryOptions<
    Awaited<ReturnType<typeof queryServiceColumnTimeRange>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type QueryServiceColumnTimeRangeQueryResult = NonNullable<
  Awaited<ReturnType<typeof queryServiceColumnTimeRange>>
>;
export type QueryServiceColumnTimeRangeQueryError = ErrorType<RpcStatus>;

/**
 * @summary Get the time range summaries (min, max) for a column
 */

export function createQueryServiceColumnTimeRange<
  TData = Awaited<ReturnType<typeof queryServiceColumnTimeRange>>,
  TError = ErrorType<RpcStatus>,
>(
  instanceId: () => string,
  tableName: () => string,
  params?: () => QueryServiceColumnTimeRangeParams,
  options?: () => {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof queryServiceColumnTimeRange>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: () => QueryClient,
): CreateQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const query = createQuery(
    () =>
      getQueryServiceColumnTimeRangeQueryOptions(
        instanceId(),
        tableName(),
        params?.(),
        options?.(),
      ),
    queryClient,
  ) as CreateQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  return query;
}

/**
 * @summary Generate time series for the given measures (aggregation expressions) along with the sparkline timeseries
 */
export type queryServiceColumnTimeSeriesResponse200 = {
  data: V1ColumnTimeSeriesResponse;
  status: 200;
};

export type queryServiceColumnTimeSeriesResponseDefault = {
  data: RpcStatus;
  status: Exclude<HTTPStatusCodes, 200>;
};

export type queryServiceColumnTimeSeriesResponseSuccess =
  queryServiceColumnTimeSeriesResponse200 & {
    headers: Headers;
  };
export type queryServiceColumnTimeSeriesResponseError =
  queryServiceColumnTimeSeriesResponseDefault & {
    headers: Headers;
  };

export type queryServiceColumnTimeSeriesResponse =
  | queryServiceColumnTimeSeriesResponseSuccess
  | queryServiceColumnTimeSeriesResponseError;

export const getQueryServiceColumnTimeSeriesUrl = (
  instanceId: string,
  tableName: string,
) => {
  return `/v1/instances/${instanceId}/queries/timeseries/tables/${tableName}`;
};

export const queryServiceColumnTimeSeries = async (
  instanceId: string,
  tableName: string,
  queryServiceColumnTimeSeriesBody: QueryServiceColumnTimeSeriesBody,
  options?: RequestInit,
): Promise<queryServiceColumnTimeSeriesResponse> => {
  return httpClient<queryServiceColumnTimeSeriesResponse>(
    getQueryServiceColumnTimeSeriesUrl(instanceId, tableName),
    {
      ...options,
      method: "POST",
      headers: { "Content-Type": "application/json", ...options?.headers },
      body: JSON.stringify(queryServiceColumnTimeSeriesBody),
    },
  );
};

export const getQueryServiceColumnTimeSeriesQueryKey = (
  instanceId: string,
  tableName: string,
  queryServiceColumnTimeSeriesBody?: QueryServiceColumnTimeSeriesBody,
) => {
  return [
    `/v1/instances/${instanceId}/queries/timeseries/tables/${tableName}`,
    queryServiceColumnTimeSeriesBody,
  ] as const;
};

export const getQueryServiceColumnTimeSeriesQueryOptions = <
  TData = Awaited<ReturnType<typeof queryServiceColumnTimeSeries>>,
  TError = ErrorType<RpcStatus>,
>(
  instanceId: string,
  tableName: string,
  queryServiceColumnTimeSeriesBody: QueryServiceColumnTimeSeriesBody,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof queryServiceColumnTimeSeries>>,
        TError,
        TData
      >
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getQueryServiceColumnTimeSeriesQueryKey(
      instanceId,
      tableName,
      queryServiceColumnTimeSeriesBody,
    );

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof queryServiceColumnTimeSeries>>
  > = ({ signal }) =>
    queryServiceColumnTimeSeries(
      instanceId,
      tableName,
      queryServiceColumnTimeSeriesBody,
      { signal },
    );

  return {
    queryKey,
    queryFn,
    enabled: !!(instanceId && tableName),
    ...queryOptions,
  } as CreateQueryOptions<
    Awaited<ReturnType<typeof queryServiceColumnTimeSeries>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type QueryServiceColumnTimeSeriesQueryResult = NonNullable<
  Awaited<ReturnType<typeof queryServiceColumnTimeSeries>>
>;
export type QueryServiceColumnTimeSeriesQueryError = ErrorType<RpcStatus>;

/**
 * @summary Generate time series for the given measures (aggregation expressions) along with the sparkline timeseries
 */

export function createQueryServiceColumnTimeSeries<
  TData = Awaited<ReturnType<typeof queryServiceColumnTimeSeries>>,
  TError = ErrorType<RpcStatus>,
>(
  instanceId: () => string,
  tableName: () => string,
  queryServiceColumnTimeSeriesBody: () => QueryServiceColumnTimeSeriesBody,
  options?: () => {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof queryServiceColumnTimeSeries>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: () => QueryClient,
): CreateQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const query = createQuery(
    () =>
      getQueryServiceColumnTimeSeriesQueryOptions(
        instanceId(),
        tableName(),
        queryServiceColumnTimeSeriesBody(),
        options?.(),
      ),
    queryClient,
  ) as CreateQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  return query;
}

/**
 * @summary Get TopK elements from a table for a column given an agg function
agg function and k are optional, defaults are count(*) and 50 respectively
 */
export type queryServiceColumnTopKResponse200 = {
  data: V1ColumnTopKResponse;
  status: 200;
};

export type queryServiceColumnTopKResponseDefault = {
  data: RpcStatus;
  status: Exclude<HTTPStatusCodes, 200>;
};

export type queryServiceColumnTopKResponseSuccess =
  queryServiceColumnTopKResponse200 & {
    headers: Headers;
  };
export type queryServiceColumnTopKResponseError =
  queryServiceColumnTopKResponseDefault & {
    headers: Headers;
  };

export type queryServiceColumnTopKResponse =
  | queryServiceColumnTopKResponseSuccess
  | queryServiceColumnTopKResponseError;

export const getQueryServiceColumnTopKUrl = (
  instanceId: string,
  tableName: string,
) => {
  return `/v1/instances/${instanceId}/queries/topk/tables/${tableName}`;
};

export const queryServiceColumnTopK = async (
  instanceId: string,
  tableName: string,
  queryServiceColumnTopKBody: QueryServiceColumnTopKBody,
  options?: RequestInit,
): Promise<queryServiceColumnTopKResponse> => {
  return httpClient<queryServiceColumnTopKResponse>(
    getQueryServiceColumnTopKUrl(instanceId, tableName),
    {
      ...options,
      method: "POST",
      headers: { "Content-Type": "application/json", ...options?.headers },
      body: JSON.stringify(queryServiceColumnTopKBody),
    },
  );
};

export const getQueryServiceColumnTopKQueryKey = (
  instanceId: string,
  tableName: string,
  queryServiceColumnTopKBody?: QueryServiceColumnTopKBody,
) => {
  return [
    `/v1/instances/${instanceId}/queries/topk/tables/${tableName}`,
    queryServiceColumnTopKBody,
  ] as const;
};

export const getQueryServiceColumnTopKQueryOptions = <
  TData = Awaited<ReturnType<typeof queryServiceColumnTopK>>,
  TError = ErrorType<RpcStatus>,
>(
  instanceId: string,
  tableName: string,
  queryServiceColumnTopKBody: QueryServiceColumnTopKBody,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof queryServiceColumnTopK>>,
        TError,
        TData
      >
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getQueryServiceColumnTopKQueryKey(
      instanceId,
      tableName,
      queryServiceColumnTopKBody,
    );

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof queryServiceColumnTopK>>
  > = ({ signal }) =>
    queryServiceColumnTopK(instanceId, tableName, queryServiceColumnTopKBody, {
      signal,
    });

  return {
    queryKey,
    queryFn,
    enabled: !!(instanceId && tableName),
    ...queryOptions,
  } as CreateQueryOptions<
    Awaited<ReturnType<typeof queryServiceColumnTopK>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type QueryServiceColumnTopKQueryResult = NonNullable<
  Awaited<ReturnType<typeof queryServiceColumnTopK>>
>;
export type QueryServiceColumnTopKQueryError = ErrorType<RpcStatus>;

/**
 * @summary Get TopK elements from a table for a column given an agg function
agg function and k are optional, defaults are count(*) and 50 respectively
 */

export function createQueryServiceColumnTopK<
  TData = Awaited<ReturnType<typeof queryServiceColumnTopK>>,
  TError = ErrorType<RpcStatus>,
>(
  instanceId: () => string,
  tableName: () => string,
  queryServiceColumnTopKBody: () => QueryServiceColumnTopKBody,
  options?: () => {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof queryServiceColumnTopK>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: () => QueryClient,
): CreateQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const query = createQuery(
    () =>
      getQueryServiceColumnTopKQueryOptions(
        instanceId(),
        tableName(),
        queryServiceColumnTopKBody(),
        options?.(),
      ),
    queryClient,
  ) as CreateQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  return query;
}

/**
 * @summary Query runs a SQL query against the instance's OLAP datastore.
 */
export type queryServiceQueryResponse200 = {
  data: V1QueryResponse;
  status: 200;
};

export type queryServiceQueryResponseDefault = {
  data: RpcStatus;
  status: Exclude<HTTPStatusCodes, 200>;
};

export type queryServiceQueryResponseSuccess = queryServiceQueryResponse200 & {
  headers: Headers;
};
export type queryServiceQueryResponseError =
  queryServiceQueryResponseDefault & {
    headers: Headers;
  };

export type queryServiceQueryResponse =
  | queryServiceQueryResponseSuccess
  | queryServiceQueryResponseError;

export const getQueryServiceQueryUrl = (instanceId: string) => {
  return `/v1/instances/${instanceId}/query`;
};

export const queryServiceQuery = async (
  instanceId: string,
  queryServiceQueryBody: QueryServiceQueryBody,
  options?: RequestInit,
): Promise<queryServiceQueryResponse> => {
  return httpClient<queryServiceQueryResponse>(
    getQueryServiceQueryUrl(instanceId),
    {
      ...options,
      method: "POST",
      headers: { "Content-Type": "application/json", ...options?.headers },
      body: JSON.stringify(queryServiceQueryBody),
    },
  );
};

export const getQueryServiceQueryMutationOptions = <
  TError = ErrorType<RpcStatus>,
  TContext = unknown,
>(options?: {
  mutation?: CreateMutationOptions<
    Awaited<ReturnType<typeof queryServiceQuery>>,
    TError,
    { instanceId: string; data: QueryServiceQueryBody },
    TContext
  >;
}): CreateMutationOptions<
  Awaited<ReturnType<typeof queryServiceQuery>>,
  TError,
  { instanceId: string; data: QueryServiceQueryBody },
  TContext
> => {
  const mutationKey = ["queryServiceQuery"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof queryServiceQuery>>,
    { instanceId: string; data: QueryServiceQueryBody }
  > = (props) => {
    const { instanceId, data } = props ?? {};

    return queryServiceQuery(instanceId, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type QueryServiceQueryMutationResult = NonNullable<
  Awaited<ReturnType<typeof queryServiceQuery>>
>;
export type QueryServiceQueryMutationBody = QueryServiceQueryBody;
export type QueryServiceQueryMutationError = ErrorType<RpcStatus>;

/**
 * @summary Query runs a SQL query against the instance's OLAP datastore.
 */
export const createQueryServiceQuery = <
  TError = ErrorType<RpcStatus>,
  TContext = unknown,
>(
  options?: () => {
    mutation?: CreateMutationOptions<
      Awaited<ReturnType<typeof queryServiceQuery>>,
      TError,
      { instanceId: string; data: QueryServiceQueryBody },
      TContext
    >;
  },
  queryClient?: () => QueryClient,
): CreateMutationResult<
  Awaited<ReturnType<typeof queryServiceQuery>>,
  TError,
  { instanceId: string; data: QueryServiceQueryBody },
  TContext
> => {
  return createMutation(
    () => ({ ...getQueryServiceQueryMutationOptions(options?.()) }),
    queryClient,
  );
};
/**
 * @summary Batch request with different queries
 */
export type queryServiceQueryBatchResponse200 = {
  data: QueryServiceQueryBatch200;
  status: 200;
};

export type queryServiceQueryBatchResponseDefault = {
  data: RpcStatus;
  status: Exclude<HTTPStatusCodes, 200>;
};

export type queryServiceQueryBatchResponseSuccess =
  queryServiceQueryBatchResponse200 & {
    headers: Headers;
  };
export type queryServiceQueryBatchResponseError =
  queryServiceQueryBatchResponseDefault & {
    headers: Headers;
  };

export type queryServiceQueryBatchResponse =
  | queryServiceQueryBatchResponseSuccess
  | queryServiceQueryBatchResponseError;

export const getQueryServiceQueryBatchUrl = (instanceId: string) => {
  return `/v1/instances/${instanceId}/query/batch`;
};

export const queryServiceQueryBatch = async (
  instanceId: string,
  queryServiceQueryBatchBody: QueryServiceQueryBatchBody,
  options?: RequestInit,
): Promise<queryServiceQueryBatchResponse> => {
  return httpClient<queryServiceQueryBatchResponse>(
    getQueryServiceQueryBatchUrl(instanceId),
    {
      ...options,
      method: "POST",
      headers: { "Content-Type": "application/json", ...options?.headers },
      body: JSON.stringify(queryServiceQueryBatchBody),
    },
  );
};

export const getQueryServiceQueryBatchMutationOptions = <
  TError = ErrorType<RpcStatus>,
  TContext = unknown,
>(options?: {
  mutation?: CreateMutationOptions<
    Awaited<ReturnType<typeof queryServiceQueryBatch>>,
    TError,
    { instanceId: string; data: QueryServiceQueryBatchBody },
    TContext
  >;
}): CreateMutationOptions<
  Awaited<ReturnType<typeof queryServiceQueryBatch>>,
  TError,
  { instanceId: string; data: QueryServiceQueryBatchBody },
  TContext
> => {
  const mutationKey = ["queryServiceQueryBatch"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof queryServiceQueryBatch>>,
    { instanceId: string; data: QueryServiceQueryBatchBody }
  > = (props) => {
    const { instanceId, data } = props ?? {};

    return queryServiceQueryBatch(instanceId, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type QueryServiceQueryBatchMutationResult = NonNullable<
  Awaited<ReturnType<typeof queryServiceQueryBatch>>
>;
export type QueryServiceQueryBatchMutationBody = QueryServiceQueryBatchBody;
export type QueryServiceQueryBatchMutationError = ErrorType<RpcStatus>;

/**
 * @summary Batch request with different queries
 */
export const createQueryServiceQueryBatch = <
  TError = ErrorType<RpcStatus>,
  TContext = unknown,
>(
  options?: () => {
    mutation?: CreateMutationOptions<
      Awaited<ReturnType<typeof queryServiceQueryBatch>>,
      TError,
      { instanceId: string; data: QueryServiceQueryBatchBody },
      TContext
    >;
  },
  queryClient?: () => QueryClient,
): CreateMutationResult<
  Awaited<ReturnType<typeof queryServiceQueryBatch>>,
  TError,
  { instanceId: string; data: QueryServiceQueryBatchBody },
  TContext
> => {
  return createMutation(
    () => ({ ...getQueryServiceQueryBatchMutationOptions(options?.()) }),
    queryClient,
  );
};
/**
 * @summary ExportReport builds a URL to download the results of a query as a file.
 */
export type queryServiceExportReportResponse200 = {
  data: V1ExportReportResponse;
  status: 200;
};

export type queryServiceExportReportResponseDefault = {
  data: RpcStatus;
  status: Exclude<HTTPStatusCodes, 200>;
};

export type queryServiceExportReportResponseSuccess =
  queryServiceExportReportResponse200 & {
    headers: Headers;
  };
export type queryServiceExportReportResponseError =
  queryServiceExportReportResponseDefault & {
    headers: Headers;
  };

export type queryServiceExportReportResponse =
  | queryServiceExportReportResponseSuccess
  | queryServiceExportReportResponseError;

export const getQueryServiceExportReportUrl = (
  instanceId: string,
  report: string,
) => {
  return `/v1/instances/${instanceId}/reports/${report}/export`;
};

export const queryServiceExportReport = async (
  instanceId: string,
  report: string,
  queryServiceExportReportBody: QueryServiceExportReportBody,
  options?: RequestInit,
): Promise<queryServiceExportReportResponse> => {
  return httpClient<queryServiceExportReportResponse>(
    getQueryServiceExportReportUrl(instanceId, report),
    {
      ...options,
      method: "POST",
      headers: { "Content-Type": "application/json", ...options?.headers },
      body: JSON.stringify(queryServiceExportReportBody),
    },
  );
};

export const getQueryServiceExportReportMutationOptions = <
  TError = ErrorType<RpcStatus>,
  TContext = unknown,
>(options?: {
  mutation?: CreateMutationOptions<
    Awaited<ReturnType<typeof queryServiceExportReport>>,
    TError,
    { instanceId: string; report: string; data: QueryServiceExportReportBody },
    TContext
  >;
}): CreateMutationOptions<
  Awaited<ReturnType<typeof queryServiceExportReport>>,
  TError,
  { instanceId: string; report: string; data: QueryServiceExportReportBody },
  TContext
> => {
  const mutationKey = ["queryServiceExportReport"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof queryServiceExportReport>>,
    { instanceId: string; report: string; data: QueryServiceExportReportBody }
  > = (props) => {
    const { instanceId, report, data } = props ?? {};

    return queryServiceExportReport(instanceId, report, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type QueryServiceExportReportMutationResult = NonNullable<
  Awaited<ReturnType<typeof queryServiceExportReport>>
>;
export type QueryServiceExportReportMutationBody = QueryServiceExportReportBody;
export type QueryServiceExportReportMutationError = ErrorType<RpcStatus>;

/**
 * @summary ExportReport builds a URL to download the results of a query as a file.
 */
export const createQueryServiceExportReport = <
  TError = ErrorType<RpcStatus>,
  TContext = unknown,
>(
  options?: () => {
    mutation?: CreateMutationOptions<
      Awaited<ReturnType<typeof queryServiceExportReport>>,
      TError,
      {
        instanceId: string;
        report: string;
        data: QueryServiceExportReportBody;
      },
      TContext
    >;
  },
  queryClient?: () => QueryClient,
): CreateMutationResult<
  Awaited<ReturnType<typeof queryServiceExportReport>>,
  TError,
  { instanceId: string; report: string; data: QueryServiceExportReportBody },
  TContext
> => {
  return createMutation(
    () => ({ ...getQueryServiceExportReportMutationOptions(options?.()) }),
    queryClient,
  );
};

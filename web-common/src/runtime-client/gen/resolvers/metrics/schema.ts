/* eslint-disable */
/**
 * This file was automatically generated by json-schema-to-typescript.
 * 1. Copy QueryJSONSchema in runtime/metricsview/query.go to a file "schema.json"
 * 2. Run, npx json2ts schema.json > schema.ts
 * 3. Update the generated schema.ts to exclude duplicates.
 * TODO: Create a script for the above
 *
 * json-schema-to-typescript generates duplicate entries for referenced types.
 * For example, Expression would have created Expression1 and Expression2 for where and having.
 * So this is currently edited to remove the duplicates.
 */

/**
 * Optionally configure a derived measure, such as a comparison.
 */
export type MeasureCompute = {
  /**
   * Whether to compute count
   */
  count?: boolean;
  count_distinct?: MeasureComputeCountDistinct;
  comparison_value?: MeasureComputeComparisonValue;
  comparison_delta?: MeasureComputeComparisonDelta;
  comparison_ratio?: MeasureComputeComparisonRatio;
  percent_of_total?: MeasureComputePercentOfTotal;
  uri?: MeasureComputeURI;
  [k: string]: unknown;
} & {
  [k: string]: unknown;
};

export interface Schema {
  /**
   * The metrics view to query.
   */
  metrics_view?: string;
  /**
   * List of dimensions to include in the query. The result will be grouped by these.
   */
  dimensions?: Dimension[];
  /**
   * List of measures to include in the query. These will be aggregated based on the dimensions.
   */
  measures?: Measure[];
  /**
   * Optional dimensions to pivot on. The provided dimensions must be present in the query. If not provided, the query will return a flat result set. Note that pivoting can have poor performance on large result sets.
   */
  pivot_on?: string[];
  spine?: Spine;
  /**
   * Sort order for the results.
   */
  sort?: Sort[];
  time_range?: TimeRange;
  comparison_time_range?: TimeRange;
  where?: Expression;
  having?: Expression;
  /**
   * Maximum number of rows to return. It is required for interactive queries.
   */
  limit?: number;
  /**
   * Optional offset for the query results. This is useful for pagination together with 'limit'.
   */
  offset?: number;
  /**
   * Optional time zone for time_floor operations and dynamic time ranges. Defaults to UTC.
   */
  time_zone?: string;
  /**
   * Optional flag to return results using display names for dimensions and measures instead of their unique names. Defaults to false.
   */
  use_display_names?: boolean;
  /**
   * Optional flag to return the underlying rows instead of aggregated results. This is useful for debugging or exploring the data. Setting it to true is incompatible with the following options: dimensions, measures, sort, comparison_time_range, having, pivot_on.
   */
  rows?: boolean;
  [k: string]: unknown;
}

export interface Dimension {
  /**
   * Name of the dimension
   */
  name: string;
  compute?: DimensionCompute;
  [k: string]: unknown;
}

/**
 * Optionally configure a derived dimension, such as a time floor.
 */
export interface DimensionCompute {
  time_floor?: DimensionComputeTimeFloor;
  [k: string]: unknown;
}

export interface DimensionComputeTimeFloor {
  /**
   * Dimension to apply time floor to
   */
  dimension: string;
  /**
   * Time grain for flooring
   */
  grain: "" | "millisecond" | "second" | "minute" | "hour" | "day" | "week" | "month" | "quarter" | "year";
  [k: string]: unknown;
}

export interface Measure {
  /**
   * Name of the measure
   */
  name: string;
  compute?: MeasureCompute;
  [k: string]: unknown;
}

export interface MeasureComputeCountDistinct {
  /**
   * Dimension to count distinct values for
   */
  dimension: string;
  [k: string]: unknown;
}

export interface MeasureComputeComparisonValue {
  /**
   * Measure to compare
   */
  measure: string;
  [k: string]: unknown;
}

export interface MeasureComputeComparisonDelta {
  /**
   * Measure to compute delta for
   */
  measure: string;
  [k: string]: unknown;
}

export interface MeasureComputeComparisonRatio {
  /**
   * Measure to compute ratio for
   */
  measure: string;
  [k: string]: unknown;
}

export interface MeasureComputePercentOfTotal {
  /**
   * Measure to compute percentage for
   */
  measure: string;
  /**
   * Total value to use for percentage calculation
   */
  total?: number;
  [k: string]: unknown;
}

export interface MeasureComputeURI {
  /**
   * Dimension to generate URI for
   */
  dimension: string;
  [k: string]: unknown;
}

/**
 * Optionally configure a 'spine' of dimension values that should be present in the result regardless of whether they have data. This is for example useful for generating a time series with zero values for missing dates.
 */
export interface Spine {
  where?: WhereSpine;
  time?: TimeSpine;
  [k: string]: unknown;
}

export interface WhereSpine {
  expr?: Expression;
  [k: string]: unknown;
}

export interface Expression {
  /**
   * Expression name
   */
  name?: string;
  /**
   * Expression value
   */
  val?: {
    [k: string]: unknown;
  };
  cond?: Condition;
  subquery?: Subquery;
  [k: string]: unknown;
}

export interface Condition {
  /**
   * Operator for the condition
   */
  op: "" | "eq" | "neq" | "lt" | "lte" | "gt" | "gte" | "in" | "nin" | "ilike" | "nilike" | "or" | "and";
  /**
   * Expressions in the condition
   */
  exprs?: Expression[];
  [k: string]: unknown;
}

export interface Subquery {
  dimension: Dimension;
  measures: Measure[];
  where?: Expression;
  having?: Expression;
  [k: string]: unknown;
}

export interface TimeSpine {
  /**
   * Start time
   */
  start: string;
  /**
   * End time
   */
  end: string;
  /**
   * Time grain for the spine
   */
  grain: "" | "millisecond" | "second" | "minute" | "hour" | "day" | "week" | "month" | "quarter" | "year";
  [k: string]: unknown;
}

export interface Sort {
  /**
   * Field name to sort by
   */
  name: string;
  /**
   * Whether to sort in descending order
   */
  desc?: boolean;
  [k: string]: unknown;
}
/**
 * Time range filter for the query. Time ranges are inclusive of start time and exclusive of end time. Note that for large datasets, querying shorter and/or more recent time ranges has significant performance benefits.
 */
export interface TimeRange {
  /**
   * Start time (inclusive)
   */
  start?: string;
  /**
   * End time (exclusive)
   */
  end?: string;
  /**
   * Time range expression
   */
  expression?: string;
  /**
   * ISO 8601 duration
   */
  iso_duration?: string;
  /**
   * ISO 8601 offset
   */
  iso_offset?: string;
  /**
   * Time grain to round to
   */
  round_to_grain?: "" | "millisecond" | "second" | "minute" | "hour" | "day" | "week" | "month" | "quarter" | "year";
  [k: string]: unknown;
}

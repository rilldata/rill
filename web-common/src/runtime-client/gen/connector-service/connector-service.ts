/**
 * Generated by orval v8.4.0 üç∫
 * Do not edit manually.
 * rill/runtime/v1/schema.proto
 * OpenAPI spec version: version not set
 */
import { createQuery } from "@tanstack/svelte-query";
import type {
  CreateQueryOptions,
  CreateQueryResult,
  DataTag,
  QueryClient,
  QueryFunction,
  QueryKey,
} from "@tanstack/svelte-query";

import type {
  ConnectorServiceGetTableParams,
  ConnectorServiceListBucketsParams,
  ConnectorServiceListDatabaseSchemasParams,
  ConnectorServiceListObjectsParams,
  ConnectorServiceListTablesParams,
  ConnectorServiceOLAPGetTableParams,
  ConnectorServiceOLAPListTablesParams,
  RpcStatus,
  V1GetTableResponse,
  V1ListBucketsResponse,
  V1ListDatabaseSchemasResponse,
  V1ListObjectsResponse,
  V1ListTablesResponse,
  V1OLAPGetTableResponse,
  V1OLAPListTablesResponse,
} from "../index.schemas";

import { httpClient } from "../../http-client";
import type { ErrorType } from "../../http-client";

type AwaitedInput<T> = PromiseLike<T> | T;

type Awaited<O> = O extends AwaitedInput<infer T> ? T : never;

export type HTTPStatusCode1xx = 100 | 101 | 102 | 103;
export type HTTPStatusCode2xx = 200 | 201 | 202 | 203 | 204 | 205 | 206 | 207;
export type HTTPStatusCode3xx = 300 | 301 | 302 | 303 | 304 | 305 | 307 | 308;
export type HTTPStatusCode4xx =
  | 400
  | 401
  | 402
  | 403
  | 404
  | 405
  | 406
  | 407
  | 408
  | 409
  | 410
  | 411
  | 412
  | 413
  | 414
  | 415
  | 416
  | 417
  | 418
  | 419
  | 420
  | 421
  | 422
  | 423
  | 424
  | 426
  | 428
  | 429
  | 431
  | 451;
export type HTTPStatusCode5xx = 500 | 501 | 502 | 503 | 504 | 505 | 507 | 511;
export type HTTPStatusCodes =
  | HTTPStatusCode1xx
  | HTTPStatusCode2xx
  | HTTPStatusCode3xx
  | HTTPStatusCode4xx
  | HTTPStatusCode5xx;

/**
 * @summary ListDatabaseSchemas list all schemas across databases
 */
export type connectorServiceListDatabaseSchemasResponse200 = {
  data: V1ListDatabaseSchemasResponse;
  status: 200;
};

export type connectorServiceListDatabaseSchemasResponseDefault = {
  data: RpcStatus;
  status: Exclude<HTTPStatusCodes, 200>;
};

export type connectorServiceListDatabaseSchemasResponseSuccess =
  connectorServiceListDatabaseSchemasResponse200 & {
    headers: Headers;
  };
export type connectorServiceListDatabaseSchemasResponseError =
  connectorServiceListDatabaseSchemasResponseDefault & {
    headers: Headers;
  };

export type connectorServiceListDatabaseSchemasResponse =
  | connectorServiceListDatabaseSchemasResponseSuccess
  | connectorServiceListDatabaseSchemasResponseError;

export const getConnectorServiceListDatabaseSchemasUrl = (
  params?: ConnectorServiceListDatabaseSchemasParams,
) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? "null" : value.toString());
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0
    ? `/v1/connectors/database_schemas?${stringifiedParams}`
    : `/v1/connectors/database_schemas`;
};

export const connectorServiceListDatabaseSchemas = async (
  params?: ConnectorServiceListDatabaseSchemasParams,
  options?: RequestInit,
): Promise<connectorServiceListDatabaseSchemasResponse> => {
  return httpClient<connectorServiceListDatabaseSchemasResponse>(
    getConnectorServiceListDatabaseSchemasUrl(params),
    {
      ...options,
      method: "GET",
    },
  );
};

export const getConnectorServiceListDatabaseSchemasQueryKey = (
  params?: ConnectorServiceListDatabaseSchemasParams,
) => {
  return [
    `/v1/connectors/database_schemas`,
    ...(params ? [params] : []),
  ] as const;
};

export const getConnectorServiceListDatabaseSchemasQueryOptions = <
  TData = Awaited<ReturnType<typeof connectorServiceListDatabaseSchemas>>,
  TError = ErrorType<RpcStatus>,
>(
  params?: ConnectorServiceListDatabaseSchemasParams,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof connectorServiceListDatabaseSchemas>>,
        TError,
        TData
      >
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getConnectorServiceListDatabaseSchemasQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof connectorServiceListDatabaseSchemas>>
  > = ({ signal }) => connectorServiceListDatabaseSchemas(params, { signal });

  return { queryKey, queryFn, ...queryOptions } as CreateQueryOptions<
    Awaited<ReturnType<typeof connectorServiceListDatabaseSchemas>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type ConnectorServiceListDatabaseSchemasQueryResult = NonNullable<
  Awaited<ReturnType<typeof connectorServiceListDatabaseSchemas>>
>;
export type ConnectorServiceListDatabaseSchemasQueryError =
  ErrorType<RpcStatus>;

/**
 * @summary ListDatabaseSchemas list all schemas across databases
 */

export function createConnectorServiceListDatabaseSchemas<
  TData = Awaited<ReturnType<typeof connectorServiceListDatabaseSchemas>>,
  TError = ErrorType<RpcStatus>,
>(
  params?: () => ConnectorServiceListDatabaseSchemasParams,
  options?: () => {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof connectorServiceListDatabaseSchemas>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: () => QueryClient,
): CreateQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const query = createQuery(
    () =>
      getConnectorServiceListDatabaseSchemasQueryOptions(
        params?.(),
        options?.(),
      ),
    queryClient,
  ) as CreateQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  return query;
}

/**
 * @summary OLAPGetTable returns metadata about a table or view in an OLAP
 */
export type connectorServiceOLAPGetTableResponse200 = {
  data: V1OLAPGetTableResponse;
  status: 200;
};

export type connectorServiceOLAPGetTableResponseDefault = {
  data: RpcStatus;
  status: Exclude<HTTPStatusCodes, 200>;
};

export type connectorServiceOLAPGetTableResponseSuccess =
  connectorServiceOLAPGetTableResponse200 & {
    headers: Headers;
  };
export type connectorServiceOLAPGetTableResponseError =
  connectorServiceOLAPGetTableResponseDefault & {
    headers: Headers;
  };

export type connectorServiceOLAPGetTableResponse =
  | connectorServiceOLAPGetTableResponseSuccess
  | connectorServiceOLAPGetTableResponseError;

export const getConnectorServiceOLAPGetTableUrl = (
  params?: ConnectorServiceOLAPGetTableParams,
) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? "null" : value.toString());
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0
    ? `/v1/connectors/olap/table?${stringifiedParams}`
    : `/v1/connectors/olap/table`;
};

export const connectorServiceOLAPGetTable = async (
  params?: ConnectorServiceOLAPGetTableParams,
  options?: RequestInit,
): Promise<connectorServiceOLAPGetTableResponse> => {
  return httpClient<connectorServiceOLAPGetTableResponse>(
    getConnectorServiceOLAPGetTableUrl(params),
    {
      ...options,
      method: "GET",
    },
  );
};

export const getConnectorServiceOLAPGetTableQueryKey = (
  params?: ConnectorServiceOLAPGetTableParams,
) => {
  return [`/v1/connectors/olap/table`, ...(params ? [params] : [])] as const;
};

export const getConnectorServiceOLAPGetTableQueryOptions = <
  TData = Awaited<ReturnType<typeof connectorServiceOLAPGetTable>>,
  TError = ErrorType<RpcStatus>,
>(
  params?: ConnectorServiceOLAPGetTableParams,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof connectorServiceOLAPGetTable>>,
        TError,
        TData
      >
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getConnectorServiceOLAPGetTableQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof connectorServiceOLAPGetTable>>
  > = ({ signal }) => connectorServiceOLAPGetTable(params, { signal });

  return { queryKey, queryFn, ...queryOptions } as CreateQueryOptions<
    Awaited<ReturnType<typeof connectorServiceOLAPGetTable>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type ConnectorServiceOLAPGetTableQueryResult = NonNullable<
  Awaited<ReturnType<typeof connectorServiceOLAPGetTable>>
>;
export type ConnectorServiceOLAPGetTableQueryError = ErrorType<RpcStatus>;

/**
 * @summary OLAPGetTable returns metadata about a table or view in an OLAP
 */

export function createConnectorServiceOLAPGetTable<
  TData = Awaited<ReturnType<typeof connectorServiceOLAPGetTable>>,
  TError = ErrorType<RpcStatus>,
>(
  params?: () => ConnectorServiceOLAPGetTableParams,
  options?: () => {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof connectorServiceOLAPGetTable>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: () => QueryClient,
): CreateQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const query = createQuery(
    () => getConnectorServiceOLAPGetTableQueryOptions(params?.(), options?.()),
    queryClient,
  ) as CreateQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  return query;
}

/**
 * @summary GetTable returns metadata about a table or view
 */
export type connectorServiceGetTableResponse200 = {
  data: V1GetTableResponse;
  status: 200;
};

export type connectorServiceGetTableResponseDefault = {
  data: RpcStatus;
  status: Exclude<HTTPStatusCodes, 200>;
};

export type connectorServiceGetTableResponseSuccess =
  connectorServiceGetTableResponse200 & {
    headers: Headers;
  };
export type connectorServiceGetTableResponseError =
  connectorServiceGetTableResponseDefault & {
    headers: Headers;
  };

export type connectorServiceGetTableResponse =
  | connectorServiceGetTableResponseSuccess
  | connectorServiceGetTableResponseError;

export const getConnectorServiceGetTableUrl = (
  params?: ConnectorServiceGetTableParams,
) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? "null" : value.toString());
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0
    ? `/v1/connectors/table_metadata?${stringifiedParams}`
    : `/v1/connectors/table_metadata`;
};

export const connectorServiceGetTable = async (
  params?: ConnectorServiceGetTableParams,
  options?: RequestInit,
): Promise<connectorServiceGetTableResponse> => {
  return httpClient<connectorServiceGetTableResponse>(
    getConnectorServiceGetTableUrl(params),
    {
      ...options,
      method: "GET",
    },
  );
};

export const getConnectorServiceGetTableQueryKey = (
  params?: ConnectorServiceGetTableParams,
) => {
  return [
    `/v1/connectors/table_metadata`,
    ...(params ? [params] : []),
  ] as const;
};

export const getConnectorServiceGetTableQueryOptions = <
  TData = Awaited<ReturnType<typeof connectorServiceGetTable>>,
  TError = ErrorType<RpcStatus>,
>(
  params?: ConnectorServiceGetTableParams,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof connectorServiceGetTable>>,
        TError,
        TData
      >
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getConnectorServiceGetTableQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof connectorServiceGetTable>>
  > = ({ signal }) => connectorServiceGetTable(params, { signal });

  return { queryKey, queryFn, ...queryOptions } as CreateQueryOptions<
    Awaited<ReturnType<typeof connectorServiceGetTable>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type ConnectorServiceGetTableQueryResult = NonNullable<
  Awaited<ReturnType<typeof connectorServiceGetTable>>
>;
export type ConnectorServiceGetTableQueryError = ErrorType<RpcStatus>;

/**
 * @summary GetTable returns metadata about a table or view
 */

export function createConnectorServiceGetTable<
  TData = Awaited<ReturnType<typeof connectorServiceGetTable>>,
  TError = ErrorType<RpcStatus>,
>(
  params?: () => ConnectorServiceGetTableParams,
  options?: () => {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof connectorServiceGetTable>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: () => QueryClient,
): CreateQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const query = createQuery(
    () => getConnectorServiceGetTableQueryOptions(params?.(), options?.()),
    queryClient,
  ) as CreateQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  return query;
}

/**
 * @summary ListTables list all tables for database and database_schema provided
 */
export type connectorServiceListTablesResponse200 = {
  data: V1ListTablesResponse;
  status: 200;
};

export type connectorServiceListTablesResponseDefault = {
  data: RpcStatus;
  status: Exclude<HTTPStatusCodes, 200>;
};

export type connectorServiceListTablesResponseSuccess =
  connectorServiceListTablesResponse200 & {
    headers: Headers;
  };
export type connectorServiceListTablesResponseError =
  connectorServiceListTablesResponseDefault & {
    headers: Headers;
  };

export type connectorServiceListTablesResponse =
  | connectorServiceListTablesResponseSuccess
  | connectorServiceListTablesResponseError;

export const getConnectorServiceListTablesUrl = (
  params?: ConnectorServiceListTablesParams,
) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? "null" : value.toString());
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0
    ? `/v1/connectors/tables?${stringifiedParams}`
    : `/v1/connectors/tables`;
};

export const connectorServiceListTables = async (
  params?: ConnectorServiceListTablesParams,
  options?: RequestInit,
): Promise<connectorServiceListTablesResponse> => {
  return httpClient<connectorServiceListTablesResponse>(
    getConnectorServiceListTablesUrl(params),
    {
      ...options,
      method: "GET",
    },
  );
};

export const getConnectorServiceListTablesQueryKey = (
  params?: ConnectorServiceListTablesParams,
) => {
  return [`/v1/connectors/tables`, ...(params ? [params] : [])] as const;
};

export const getConnectorServiceListTablesQueryOptions = <
  TData = Awaited<ReturnType<typeof connectorServiceListTables>>,
  TError = ErrorType<RpcStatus>,
>(
  params?: ConnectorServiceListTablesParams,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof connectorServiceListTables>>,
        TError,
        TData
      >
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getConnectorServiceListTablesQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof connectorServiceListTables>>
  > = ({ signal }) => connectorServiceListTables(params, { signal });

  return { queryKey, queryFn, ...queryOptions } as CreateQueryOptions<
    Awaited<ReturnType<typeof connectorServiceListTables>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type ConnectorServiceListTablesQueryResult = NonNullable<
  Awaited<ReturnType<typeof connectorServiceListTables>>
>;
export type ConnectorServiceListTablesQueryError = ErrorType<RpcStatus>;

/**
 * @summary ListTables list all tables for database and database_schema provided
 */

export function createConnectorServiceListTables<
  TData = Awaited<ReturnType<typeof connectorServiceListTables>>,
  TError = ErrorType<RpcStatus>,
>(
  params?: () => ConnectorServiceListTablesParams,
  options?: () => {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof connectorServiceListTables>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: () => QueryClient,
): CreateQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const query = createQuery(
    () => getConnectorServiceListTablesQueryOptions(params?.(), options?.()),
    queryClient,
  ) as CreateQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  return query;
}

/**
 * @summary ListBuckets lists buckets accessible with the configured credentials.
 */
export type connectorServiceListBucketsResponse200 = {
  data: V1ListBucketsResponse;
  status: 200;
};

export type connectorServiceListBucketsResponseDefault = {
  data: RpcStatus;
  status: Exclude<HTTPStatusCodes, 200>;
};

export type connectorServiceListBucketsResponseSuccess =
  connectorServiceListBucketsResponse200 & {
    headers: Headers;
  };
export type connectorServiceListBucketsResponseError =
  connectorServiceListBucketsResponseDefault & {
    headers: Headers;
  };

export type connectorServiceListBucketsResponse =
  | connectorServiceListBucketsResponseSuccess
  | connectorServiceListBucketsResponseError;

export const getConnectorServiceListBucketsUrl = (
  instanceId: string,
  connector: string,
  params?: ConnectorServiceListBucketsParams,
) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? "null" : value.toString());
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0
    ? `/v1/instances/${instanceId}/connectors/${connector}/buckets?${stringifiedParams}`
    : `/v1/instances/${instanceId}/connectors/${connector}/buckets`;
};

export const connectorServiceListBuckets = async (
  instanceId: string,
  connector: string,
  params?: ConnectorServiceListBucketsParams,
  options?: RequestInit,
): Promise<connectorServiceListBucketsResponse> => {
  return httpClient<connectorServiceListBucketsResponse>(
    getConnectorServiceListBucketsUrl(instanceId, connector, params),
    {
      ...options,
      method: "GET",
    },
  );
};

export const getConnectorServiceListBucketsQueryKey = (
  instanceId: string,
  connector: string,
  params?: ConnectorServiceListBucketsParams,
) => {
  return [
    `/v1/instances/${instanceId}/connectors/${connector}/buckets`,
    ...(params ? [params] : []),
  ] as const;
};

export const getConnectorServiceListBucketsQueryOptions = <
  TData = Awaited<ReturnType<typeof connectorServiceListBuckets>>,
  TError = ErrorType<RpcStatus>,
>(
  instanceId: string,
  connector: string,
  params?: ConnectorServiceListBucketsParams,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof connectorServiceListBuckets>>,
        TError,
        TData
      >
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getConnectorServiceListBucketsQueryKey(instanceId, connector, params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof connectorServiceListBuckets>>
  > = ({ signal }) =>
    connectorServiceListBuckets(instanceId, connector, params, { signal });

  return {
    queryKey,
    queryFn,
    enabled: !!(instanceId && connector),
    ...queryOptions,
  } as CreateQueryOptions<
    Awaited<ReturnType<typeof connectorServiceListBuckets>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type ConnectorServiceListBucketsQueryResult = NonNullable<
  Awaited<ReturnType<typeof connectorServiceListBuckets>>
>;
export type ConnectorServiceListBucketsQueryError = ErrorType<RpcStatus>;

/**
 * @summary ListBuckets lists buckets accessible with the configured credentials.
 */

export function createConnectorServiceListBuckets<
  TData = Awaited<ReturnType<typeof connectorServiceListBuckets>>,
  TError = ErrorType<RpcStatus>,
>(
  instanceId: () => string,
  connector: () => string,
  params?: () => ConnectorServiceListBucketsParams,
  options?: () => {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof connectorServiceListBuckets>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: () => QueryClient,
): CreateQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const query = createQuery(
    () =>
      getConnectorServiceListBucketsQueryOptions(
        instanceId(),
        connector(),
        params?.(),
        options?.(),
      ),
    queryClient,
  ) as CreateQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  return query;
}

/**
 * @summary ListObjects lists objects for the given bucket.
 */
export type connectorServiceListObjectsResponse200 = {
  data: V1ListObjectsResponse;
  status: 200;
};

export type connectorServiceListObjectsResponseDefault = {
  data: RpcStatus;
  status: Exclude<HTTPStatusCodes, 200>;
};

export type connectorServiceListObjectsResponseSuccess =
  connectorServiceListObjectsResponse200 & {
    headers: Headers;
  };
export type connectorServiceListObjectsResponseError =
  connectorServiceListObjectsResponseDefault & {
    headers: Headers;
  };

export type connectorServiceListObjectsResponse =
  | connectorServiceListObjectsResponseSuccess
  | connectorServiceListObjectsResponseError;

export const getConnectorServiceListObjectsUrl = (
  instanceId: string,
  connector: string,
  bucket: string,
  params?: ConnectorServiceListObjectsParams,
) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? "null" : value.toString());
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0
    ? `/v1/instances/${instanceId}/connectors/${connector}/buckets/${bucket}/objects?${stringifiedParams}`
    : `/v1/instances/${instanceId}/connectors/${connector}/buckets/${bucket}/objects`;
};

export const connectorServiceListObjects = async (
  instanceId: string,
  connector: string,
  bucket: string,
  params?: ConnectorServiceListObjectsParams,
  options?: RequestInit,
): Promise<connectorServiceListObjectsResponse> => {
  return httpClient<connectorServiceListObjectsResponse>(
    getConnectorServiceListObjectsUrl(instanceId, connector, bucket, params),
    {
      ...options,
      method: "GET",
    },
  );
};

export const getConnectorServiceListObjectsQueryKey = (
  instanceId: string,
  connector: string,
  bucket: string,
  params?: ConnectorServiceListObjectsParams,
) => {
  return [
    `/v1/instances/${instanceId}/connectors/${connector}/buckets/${bucket}/objects`,
    ...(params ? [params] : []),
  ] as const;
};

export const getConnectorServiceListObjectsQueryOptions = <
  TData = Awaited<ReturnType<typeof connectorServiceListObjects>>,
  TError = ErrorType<RpcStatus>,
>(
  instanceId: string,
  connector: string,
  bucket: string,
  params?: ConnectorServiceListObjectsParams,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof connectorServiceListObjects>>,
        TError,
        TData
      >
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getConnectorServiceListObjectsQueryKey(
      instanceId,
      connector,
      bucket,
      params,
    );

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof connectorServiceListObjects>>
  > = ({ signal }) =>
    connectorServiceListObjects(instanceId, connector, bucket, params, {
      signal,
    });

  return {
    queryKey,
    queryFn,
    enabled: !!(instanceId && connector && bucket),
    ...queryOptions,
  } as CreateQueryOptions<
    Awaited<ReturnType<typeof connectorServiceListObjects>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type ConnectorServiceListObjectsQueryResult = NonNullable<
  Awaited<ReturnType<typeof connectorServiceListObjects>>
>;
export type ConnectorServiceListObjectsQueryError = ErrorType<RpcStatus>;

/**
 * @summary ListObjects lists objects for the given bucket.
 */

export function createConnectorServiceListObjects<
  TData = Awaited<ReturnType<typeof connectorServiceListObjects>>,
  TError = ErrorType<RpcStatus>,
>(
  instanceId: () => string,
  connector: () => string,
  bucket: () => string,
  params?: () => ConnectorServiceListObjectsParams,
  options?: () => {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof connectorServiceListObjects>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: () => QueryClient,
): CreateQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const query = createQuery(
    () =>
      getConnectorServiceListObjectsQueryOptions(
        instanceId(),
        connector(),
        bucket(),
        params?.(),
        options?.(),
      ),
    queryClient,
  ) as CreateQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  return query;
}

/**
 * @summary OLAPListTables list all tables across all databases in an OLAP
 */
export type connectorServiceOLAPListTablesResponse200 = {
  data: V1OLAPListTablesResponse;
  status: 200;
};

export type connectorServiceOLAPListTablesResponseDefault = {
  data: RpcStatus;
  status: Exclude<HTTPStatusCodes, 200>;
};

export type connectorServiceOLAPListTablesResponseSuccess =
  connectorServiceOLAPListTablesResponse200 & {
    headers: Headers;
  };
export type connectorServiceOLAPListTablesResponseError =
  connectorServiceOLAPListTablesResponseDefault & {
    headers: Headers;
  };

export type connectorServiceOLAPListTablesResponse =
  | connectorServiceOLAPListTablesResponseSuccess
  | connectorServiceOLAPListTablesResponseError;

export const getConnectorServiceOLAPListTablesUrl = (
  params?: ConnectorServiceOLAPListTablesParams,
) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? "null" : value.toString());
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0
    ? `/v1/olap/tables?${stringifiedParams}`
    : `/v1/olap/tables`;
};

export const connectorServiceOLAPListTables = async (
  params?: ConnectorServiceOLAPListTablesParams,
  options?: RequestInit,
): Promise<connectorServiceOLAPListTablesResponse> => {
  return httpClient<connectorServiceOLAPListTablesResponse>(
    getConnectorServiceOLAPListTablesUrl(params),
    {
      ...options,
      method: "GET",
    },
  );
};

export const getConnectorServiceOLAPListTablesQueryKey = (
  params?: ConnectorServiceOLAPListTablesParams,
) => {
  return [`/v1/olap/tables`, ...(params ? [params] : [])] as const;
};

export const getConnectorServiceOLAPListTablesQueryOptions = <
  TData = Awaited<ReturnType<typeof connectorServiceOLAPListTables>>,
  TError = ErrorType<RpcStatus>,
>(
  params?: ConnectorServiceOLAPListTablesParams,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof connectorServiceOLAPListTables>>,
        TError,
        TData
      >
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getConnectorServiceOLAPListTablesQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof connectorServiceOLAPListTables>>
  > = ({ signal }) => connectorServiceOLAPListTables(params, { signal });

  return { queryKey, queryFn, ...queryOptions } as CreateQueryOptions<
    Awaited<ReturnType<typeof connectorServiceOLAPListTables>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type ConnectorServiceOLAPListTablesQueryResult = NonNullable<
  Awaited<ReturnType<typeof connectorServiceOLAPListTables>>
>;
export type ConnectorServiceOLAPListTablesQueryError = ErrorType<RpcStatus>;

/**
 * @summary OLAPListTables list all tables across all databases in an OLAP
 */

export function createConnectorServiceOLAPListTables<
  TData = Awaited<ReturnType<typeof connectorServiceOLAPListTables>>,
  TError = ErrorType<RpcStatus>,
>(
  params?: () => ConnectorServiceOLAPListTablesParams,
  options?: () => {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof connectorServiceOLAPListTables>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: () => QueryClient,
): CreateQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const query = createQuery(
    () =>
      getConnectorServiceOLAPListTablesQueryOptions(params?.(), options?.()),
    queryClient,
  ) as CreateQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  return query;
}

/**
 * Generated by orval v8.4.0 üç∫
 * Do not edit manually.
 * rill/runtime/v1/schema.proto
 * OpenAPI spec version: version not set
 */
import {
  createInfiniteQuery,
  createMutation,
  createQuery,
} from "@tanstack/svelte-query";
import type {
  CreateInfiniteQueryOptions,
  CreateInfiniteQueryResult,
  CreateMutationOptions,
  CreateMutationResult,
  CreateQueryOptions,
  CreateQueryResult,
  DataTag,
  InfiniteData,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
} from "@tanstack/svelte-query";

import type {
  RpcStatus,
  RuntimeServiceCompleteBody,
  RuntimeServiceCompleteStreaming200,
  RuntimeServiceCompleteStreamingBody,
  RuntimeServiceCreateDirectoryBody,
  RuntimeServiceCreateTriggerBody,
  RuntimeServiceDeleteFileParams,
  RuntimeServiceDeleteInstanceBody,
  RuntimeServiceEditInstanceBody,
  RuntimeServiceForkConversationBody,
  RuntimeServiceGenerateCanvasFileBody,
  RuntimeServiceGenerateMetricsViewFileBody,
  RuntimeServiceGenerateRendererBody,
  RuntimeServiceGenerateResolverBody,
  RuntimeServiceGetExploreParams,
  RuntimeServiceGetFileParams,
  RuntimeServiceGetInstanceParams,
  RuntimeServiceGetLogsParams,
  RuntimeServiceGetModelPartitionsParams,
  RuntimeServiceGetResourceParams,
  RuntimeServiceGitCommitBody,
  RuntimeServiceGitMergeToBranchBody,
  RuntimeServiceGitPullBody,
  RuntimeServiceGitPushBody,
  RuntimeServiceGitSwitchBranchBody,
  RuntimeServiceListConversationsParams,
  RuntimeServiceListFilesParams,
  RuntimeServiceListGitCommitsParams,
  RuntimeServiceListInstancesParams,
  RuntimeServiceListResourcesParams,
  RuntimeServicePutFileBody,
  RuntimeServiceQueryResolverBody,
  RuntimeServiceReloadConfigBody,
  RuntimeServiceRenameFileBody,
  RuntimeServiceRestoreGitCommitBody,
  RuntimeServiceShareConversationBody,
  RuntimeServiceUnpackEmptyBody,
  RuntimeServiceUnpackExampleBody,
  RuntimeServiceWatchFiles200,
  RuntimeServiceWatchFilesParams,
  RuntimeServiceWatchLogs200,
  RuntimeServiceWatchLogsParams,
  RuntimeServiceWatchResources200,
  RuntimeServiceWatchResourcesParams,
  V1AnalyzeConnectorsResponse,
  V1AnalyzeVariablesResponse,
  V1CompleteResponse,
  V1CreateDirectoryResponse,
  V1CreateInstanceRequest,
  V1CreateInstanceResponse,
  V1CreateTriggerResponse,
  V1DeleteFileResponse,
  V1DeleteInstanceResponse,
  V1EditInstanceResponse,
  V1ForkConversationResponse,
  V1GenerateCanvasFileResponse,
  V1GenerateMetricsViewFileResponse,
  V1GenerateRendererResponse,
  V1GenerateResolverResponse,
  V1GetConversationResponse,
  V1GetExploreResponse,
  V1GetFileResponse,
  V1GetInstanceResponse,
  V1GetLogsResponse,
  V1GetModelPartitionsResponse,
  V1GetResourceResponse,
  V1GitCommitResponse,
  V1GitMergeToBranchResponse,
  V1GitPullResponse,
  V1GitPushResponse,
  V1GitStatusResponse,
  V1GitSwitchBranchResponse,
  V1HealthResponse,
  V1InstanceHealthResponse,
  V1IssueDevJWTRequest,
  V1IssueDevJWTResponse,
  V1ListConnectorDriversResponse,
  V1ListConversationsResponse,
  V1ListExamplesResponse,
  V1ListFilesResponse,
  V1ListGitBranchesResponse,
  V1ListGitCommitsResponse,
  V1ListInstancesResponse,
  V1ListNotifierConnectorsResponse,
  V1ListResourcesResponse,
  V1ListToolsResponse,
  V1PingResponse,
  V1PutFileResponse,
  V1QueryResolverResponse,
  V1ReloadConfigResponse,
  V1RenameFileResponse,
  V1RestoreGitCommitResponse,
  V1ShareConversationResponse,
  V1UnpackEmptyResponse,
  V1UnpackExampleResponse,
} from "../index.schemas";

import { httpClient } from "../../http-client";
import type { ErrorType } from "../../http-client";

type AwaitedInput<T> = PromiseLike<T> | T;

type Awaited<O> = O extends AwaitedInput<infer T> ? T : never;

export type HTTPStatusCode1xx = 100 | 101 | 102 | 103;
export type HTTPStatusCode2xx = 200 | 201 | 202 | 203 | 204 | 205 | 206 | 207;
export type HTTPStatusCode3xx = 300 | 301 | 302 | 303 | 304 | 305 | 307 | 308;
export type HTTPStatusCode4xx =
  | 400
  | 401
  | 402
  | 403
  | 404
  | 405
  | 406
  | 407
  | 408
  | 409
  | 410
  | 411
  | 412
  | 413
  | 414
  | 415
  | 416
  | 417
  | 418
  | 419
  | 420
  | 421
  | 422
  | 423
  | 424
  | 426
  | 428
  | 429
  | 431
  | 451;
export type HTTPStatusCode5xx = 500 | 501 | 502 | 503 | 504 | 505 | 507 | 511;
export type HTTPStatusCodes =
  | HTTPStatusCode1xx
  | HTTPStatusCode2xx
  | HTTPStatusCode3xx
  | HTTPStatusCode4xx
  | HTTPStatusCode5xx;

/**
 * @summary ListConnectorDrivers returns a description of all the connector drivers registed in the runtime,
including their configuration specs and the capabilities they support.
 */
export type runtimeServiceListConnectorDriversResponse200 = {
  data: V1ListConnectorDriversResponse;
  status: 200;
};

export type runtimeServiceListConnectorDriversResponseDefault = {
  data: RpcStatus;
  status: Exclude<HTTPStatusCodes, 200>;
};

export type runtimeServiceListConnectorDriversResponseSuccess =
  runtimeServiceListConnectorDriversResponse200 & {
    headers: Headers;
  };
export type runtimeServiceListConnectorDriversResponseError =
  runtimeServiceListConnectorDriversResponseDefault & {
    headers: Headers;
  };

export type runtimeServiceListConnectorDriversResponse =
  | runtimeServiceListConnectorDriversResponseSuccess
  | runtimeServiceListConnectorDriversResponseError;

export const getRuntimeServiceListConnectorDriversUrl = () => {
  return `/v1/connectors/meta`;
};

export const runtimeServiceListConnectorDrivers = async (
  options?: RequestInit,
): Promise<runtimeServiceListConnectorDriversResponse> => {
  return httpClient<runtimeServiceListConnectorDriversResponse>(
    getRuntimeServiceListConnectorDriversUrl(),
    {
      ...options,
      method: "GET",
    },
  );
};

export const getRuntimeServiceListConnectorDriversQueryKey = () => {
  return [`/v1/connectors/meta`] as const;
};

export const getRuntimeServiceListConnectorDriversQueryOptions = <
  TData = Awaited<ReturnType<typeof runtimeServiceListConnectorDrivers>>,
  TError = ErrorType<RpcStatus>,
>(options?: {
  query?: Partial<
    CreateQueryOptions<
      Awaited<ReturnType<typeof runtimeServiceListConnectorDrivers>>,
      TError,
      TData
    >
  >;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getRuntimeServiceListConnectorDriversQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof runtimeServiceListConnectorDrivers>>
  > = ({ signal }) => runtimeServiceListConnectorDrivers({ signal });

  return { queryKey, queryFn, ...queryOptions } as CreateQueryOptions<
    Awaited<ReturnType<typeof runtimeServiceListConnectorDrivers>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type RuntimeServiceListConnectorDriversQueryResult = NonNullable<
  Awaited<ReturnType<typeof runtimeServiceListConnectorDrivers>>
>;
export type RuntimeServiceListConnectorDriversQueryError = ErrorType<RpcStatus>;

/**
 * @summary ListConnectorDrivers returns a description of all the connector drivers registed in the runtime,
including their configuration specs and the capabilities they support.
 */

export function createRuntimeServiceListConnectorDrivers<
  TData = Awaited<ReturnType<typeof runtimeServiceListConnectorDrivers>>,
  TError = ErrorType<RpcStatus>,
>(
  options?: () => {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof runtimeServiceListConnectorDrivers>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: () => QueryClient,
): CreateQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const query = createQuery(
    () => getRuntimeServiceListConnectorDriversQueryOptions(options?.()),
    queryClient,
  ) as CreateQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  return query;
}

/**
 * @summary IssueDevJWT issues a JWT for mimicking a user in local development.
 */
export type runtimeServiceIssueDevJWTResponse200 = {
  data: V1IssueDevJWTResponse;
  status: 200;
};

export type runtimeServiceIssueDevJWTResponseDefault = {
  data: RpcStatus;
  status: Exclude<HTTPStatusCodes, 200>;
};

export type runtimeServiceIssueDevJWTResponseSuccess =
  runtimeServiceIssueDevJWTResponse200 & {
    headers: Headers;
  };
export type runtimeServiceIssueDevJWTResponseError =
  runtimeServiceIssueDevJWTResponseDefault & {
    headers: Headers;
  };

export type runtimeServiceIssueDevJWTResponse =
  | runtimeServiceIssueDevJWTResponseSuccess
  | runtimeServiceIssueDevJWTResponseError;

export const getRuntimeServiceIssueDevJWTUrl = () => {
  return `/v1/dev-jwt`;
};

export const runtimeServiceIssueDevJWT = async (
  v1IssueDevJWTRequest: V1IssueDevJWTRequest,
  options?: RequestInit,
): Promise<runtimeServiceIssueDevJWTResponse> => {
  return httpClient<runtimeServiceIssueDevJWTResponse>(
    getRuntimeServiceIssueDevJWTUrl(),
    {
      ...options,
      method: "POST",
      headers: { "Content-Type": "application/json", ...options?.headers },
      body: JSON.stringify(v1IssueDevJWTRequest),
    },
  );
};

export const getRuntimeServiceIssueDevJWTQueryKey = (
  v1IssueDevJWTRequest?: V1IssueDevJWTRequest,
) => {
  return [`/v1/dev-jwt`, v1IssueDevJWTRequest] as const;
};

export const getRuntimeServiceIssueDevJWTQueryOptions = <
  TData = Awaited<ReturnType<typeof runtimeServiceIssueDevJWT>>,
  TError = ErrorType<RpcStatus>,
>(
  v1IssueDevJWTRequest: V1IssueDevJWTRequest,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof runtimeServiceIssueDevJWT>>,
        TError,
        TData
      >
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getRuntimeServiceIssueDevJWTQueryKey(v1IssueDevJWTRequest);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof runtimeServiceIssueDevJWT>>
  > = ({ signal }) =>
    runtimeServiceIssueDevJWT(v1IssueDevJWTRequest, { signal });

  return { queryKey, queryFn, ...queryOptions } as CreateQueryOptions<
    Awaited<ReturnType<typeof runtimeServiceIssueDevJWT>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type RuntimeServiceIssueDevJWTQueryResult = NonNullable<
  Awaited<ReturnType<typeof runtimeServiceIssueDevJWT>>
>;
export type RuntimeServiceIssueDevJWTQueryError = ErrorType<RpcStatus>;

/**
 * @summary IssueDevJWT issues a JWT for mimicking a user in local development.
 */

export function createRuntimeServiceIssueDevJWT<
  TData = Awaited<ReturnType<typeof runtimeServiceIssueDevJWT>>,
  TError = ErrorType<RpcStatus>,
>(
  v1IssueDevJWTRequest: () => V1IssueDevJWTRequest,
  options?: () => {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof runtimeServiceIssueDevJWT>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: () => QueryClient,
): CreateQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const query = createQuery(
    () =>
      getRuntimeServiceIssueDevJWTQueryOptions(
        v1IssueDevJWTRequest(),
        options?.(),
      ),
    queryClient,
  ) as CreateQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  return query;
}

/**
 * @summary ListExamples lists all the examples embedded into binary
 */
export type runtimeServiceListExamplesResponse200 = {
  data: V1ListExamplesResponse;
  status: 200;
};

export type runtimeServiceListExamplesResponseDefault = {
  data: RpcStatus;
  status: Exclude<HTTPStatusCodes, 200>;
};

export type runtimeServiceListExamplesResponseSuccess =
  runtimeServiceListExamplesResponse200 & {
    headers: Headers;
  };
export type runtimeServiceListExamplesResponseError =
  runtimeServiceListExamplesResponseDefault & {
    headers: Headers;
  };

export type runtimeServiceListExamplesResponse =
  | runtimeServiceListExamplesResponseSuccess
  | runtimeServiceListExamplesResponseError;

export const getRuntimeServiceListExamplesUrl = () => {
  return `/v1/examples`;
};

export const runtimeServiceListExamples = async (
  options?: RequestInit,
): Promise<runtimeServiceListExamplesResponse> => {
  return httpClient<runtimeServiceListExamplesResponse>(
    getRuntimeServiceListExamplesUrl(),
    {
      ...options,
      method: "GET",
    },
  );
};

export const getRuntimeServiceListExamplesQueryKey = () => {
  return [`/v1/examples`] as const;
};

export const getRuntimeServiceListExamplesQueryOptions = <
  TData = Awaited<ReturnType<typeof runtimeServiceListExamples>>,
  TError = ErrorType<RpcStatus>,
>(options?: {
  query?: Partial<
    CreateQueryOptions<
      Awaited<ReturnType<typeof runtimeServiceListExamples>>,
      TError,
      TData
    >
  >;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getRuntimeServiceListExamplesQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof runtimeServiceListExamples>>
  > = ({ signal }) => runtimeServiceListExamples({ signal });

  return { queryKey, queryFn, ...queryOptions } as CreateQueryOptions<
    Awaited<ReturnType<typeof runtimeServiceListExamples>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type RuntimeServiceListExamplesQueryResult = NonNullable<
  Awaited<ReturnType<typeof runtimeServiceListExamples>>
>;
export type RuntimeServiceListExamplesQueryError = ErrorType<RpcStatus>;

/**
 * @summary ListExamples lists all the examples embedded into binary
 */

export function createRuntimeServiceListExamples<
  TData = Awaited<ReturnType<typeof runtimeServiceListExamples>>,
  TError = ErrorType<RpcStatus>,
>(
  options?: () => {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof runtimeServiceListExamples>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: () => QueryClient,
): CreateQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const query = createQuery(
    () => getRuntimeServiceListExamplesQueryOptions(options?.()),
    queryClient,
  ) as CreateQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  return query;
}

/**
 * @summary Health runs a health check on the runtime.
 */
export type runtimeServiceHealthResponse200 = {
  data: V1HealthResponse;
  status: 200;
};

export type runtimeServiceHealthResponseDefault = {
  data: RpcStatus;
  status: Exclude<HTTPStatusCodes, 200>;
};

export type runtimeServiceHealthResponseSuccess =
  runtimeServiceHealthResponse200 & {
    headers: Headers;
  };
export type runtimeServiceHealthResponseError =
  runtimeServiceHealthResponseDefault & {
    headers: Headers;
  };

export type runtimeServiceHealthResponse =
  | runtimeServiceHealthResponseSuccess
  | runtimeServiceHealthResponseError;

export const getRuntimeServiceHealthUrl = () => {
  return `/v1/health`;
};

export const runtimeServiceHealth = async (
  options?: RequestInit,
): Promise<runtimeServiceHealthResponse> => {
  return httpClient<runtimeServiceHealthResponse>(
    getRuntimeServiceHealthUrl(),
    {
      ...options,
      method: "GET",
    },
  );
};

export const getRuntimeServiceHealthQueryKey = () => {
  return [`/v1/health`] as const;
};

export const getRuntimeServiceHealthQueryOptions = <
  TData = Awaited<ReturnType<typeof runtimeServiceHealth>>,
  TError = ErrorType<RpcStatus>,
>(options?: {
  query?: Partial<
    CreateQueryOptions<
      Awaited<ReturnType<typeof runtimeServiceHealth>>,
      TError,
      TData
    >
  >;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getRuntimeServiceHealthQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof runtimeServiceHealth>>
  > = ({ signal }) => runtimeServiceHealth({ signal });

  return { queryKey, queryFn, ...queryOptions } as CreateQueryOptions<
    Awaited<ReturnType<typeof runtimeServiceHealth>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type RuntimeServiceHealthQueryResult = NonNullable<
  Awaited<ReturnType<typeof runtimeServiceHealth>>
>;
export type RuntimeServiceHealthQueryError = ErrorType<RpcStatus>;

/**
 * @summary Health runs a health check on the runtime.
 */

export function createRuntimeServiceHealth<
  TData = Awaited<ReturnType<typeof runtimeServiceHealth>>,
  TError = ErrorType<RpcStatus>,
>(
  options?: () => {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof runtimeServiceHealth>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: () => QueryClient,
): CreateQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const query = createQuery(
    () => getRuntimeServiceHealthQueryOptions(options?.()),
    queryClient,
  ) as CreateQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  return query;
}

/**
 * @summary InstanceHealth runs a health check on a specific instance.
 */
export type runtimeServiceInstanceHealthResponse200 = {
  data: V1InstanceHealthResponse;
  status: 200;
};

export type runtimeServiceInstanceHealthResponseDefault = {
  data: RpcStatus;
  status: Exclude<HTTPStatusCodes, 200>;
};

export type runtimeServiceInstanceHealthResponseSuccess =
  runtimeServiceInstanceHealthResponse200 & {
    headers: Headers;
  };
export type runtimeServiceInstanceHealthResponseError =
  runtimeServiceInstanceHealthResponseDefault & {
    headers: Headers;
  };

export type runtimeServiceInstanceHealthResponse =
  | runtimeServiceInstanceHealthResponseSuccess
  | runtimeServiceInstanceHealthResponseError;

export const getRuntimeServiceInstanceHealthUrl = (instanceId: string) => {
  return `/v1/health/instances/${instanceId}`;
};

export const runtimeServiceInstanceHealth = async (
  instanceId: string,
  options?: RequestInit,
): Promise<runtimeServiceInstanceHealthResponse> => {
  return httpClient<runtimeServiceInstanceHealthResponse>(
    getRuntimeServiceInstanceHealthUrl(instanceId),
    {
      ...options,
      method: "GET",
    },
  );
};

export const getRuntimeServiceInstanceHealthQueryKey = (instanceId: string) => {
  return [`/v1/health/instances/${instanceId}`] as const;
};

export const getRuntimeServiceInstanceHealthQueryOptions = <
  TData = Awaited<ReturnType<typeof runtimeServiceInstanceHealth>>,
  TError = ErrorType<RpcStatus>,
>(
  instanceId: string,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof runtimeServiceInstanceHealth>>,
        TError,
        TData
      >
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getRuntimeServiceInstanceHealthQueryKey(instanceId);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof runtimeServiceInstanceHealth>>
  > = ({ signal }) => runtimeServiceInstanceHealth(instanceId, { signal });

  return {
    queryKey,
    queryFn,
    enabled: !!instanceId,
    ...queryOptions,
  } as CreateQueryOptions<
    Awaited<ReturnType<typeof runtimeServiceInstanceHealth>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type RuntimeServiceInstanceHealthQueryResult = NonNullable<
  Awaited<ReturnType<typeof runtimeServiceInstanceHealth>>
>;
export type RuntimeServiceInstanceHealthQueryError = ErrorType<RpcStatus>;

/**
 * @summary InstanceHealth runs a health check on a specific instance.
 */

export function createRuntimeServiceInstanceHealth<
  TData = Awaited<ReturnType<typeof runtimeServiceInstanceHealth>>,
  TError = ErrorType<RpcStatus>,
>(
  instanceId: () => string,
  options?: () => {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof runtimeServiceInstanceHealth>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: () => QueryClient,
): CreateQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const query = createQuery(
    () =>
      getRuntimeServiceInstanceHealthQueryOptions(instanceId(), options?.()),
    queryClient,
  ) as CreateQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  return query;
}

/**
 * @summary ListInstances lists all the instances currently managed by the runtime
 */
export type runtimeServiceListInstancesResponse200 = {
  data: V1ListInstancesResponse;
  status: 200;
};

export type runtimeServiceListInstancesResponseDefault = {
  data: RpcStatus;
  status: Exclude<HTTPStatusCodes, 200>;
};

export type runtimeServiceListInstancesResponseSuccess =
  runtimeServiceListInstancesResponse200 & {
    headers: Headers;
  };
export type runtimeServiceListInstancesResponseError =
  runtimeServiceListInstancesResponseDefault & {
    headers: Headers;
  };

export type runtimeServiceListInstancesResponse =
  | runtimeServiceListInstancesResponseSuccess
  | runtimeServiceListInstancesResponseError;

export const getRuntimeServiceListInstancesUrl = (
  params?: RuntimeServiceListInstancesParams,
) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? "null" : value.toString());
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0
    ? `/v1/instances?${stringifiedParams}`
    : `/v1/instances`;
};

export const runtimeServiceListInstances = async (
  params?: RuntimeServiceListInstancesParams,
  options?: RequestInit,
): Promise<runtimeServiceListInstancesResponse> => {
  return httpClient<runtimeServiceListInstancesResponse>(
    getRuntimeServiceListInstancesUrl(params),
    {
      ...options,
      method: "GET",
    },
  );
};

export const getRuntimeServiceListInstancesQueryKey = (
  params?: RuntimeServiceListInstancesParams,
) => {
  return [`/v1/instances`, ...(params ? [params] : [])] as const;
};

export const getRuntimeServiceListInstancesQueryOptions = <
  TData = Awaited<ReturnType<typeof runtimeServiceListInstances>>,
  TError = ErrorType<RpcStatus>,
>(
  params?: RuntimeServiceListInstancesParams,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof runtimeServiceListInstances>>,
        TError,
        TData
      >
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getRuntimeServiceListInstancesQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof runtimeServiceListInstances>>
  > = ({ signal }) => runtimeServiceListInstances(params, { signal });

  return { queryKey, queryFn, ...queryOptions } as CreateQueryOptions<
    Awaited<ReturnType<typeof runtimeServiceListInstances>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type RuntimeServiceListInstancesQueryResult = NonNullable<
  Awaited<ReturnType<typeof runtimeServiceListInstances>>
>;
export type RuntimeServiceListInstancesQueryError = ErrorType<RpcStatus>;

/**
 * @summary ListInstances lists all the instances currently managed by the runtime
 */

export function createRuntimeServiceListInstances<
  TData = Awaited<ReturnType<typeof runtimeServiceListInstances>>,
  TError = ErrorType<RpcStatus>,
>(
  params?: () => RuntimeServiceListInstancesParams,
  options?: () => {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof runtimeServiceListInstances>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: () => QueryClient,
): CreateQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const query = createQuery(
    () => getRuntimeServiceListInstancesQueryOptions(params?.(), options?.()),
    queryClient,
  ) as CreateQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  return query;
}

/**
 * @summary CreateInstance creates a new instance
 */
export type runtimeServiceCreateInstanceResponse200 = {
  data: V1CreateInstanceResponse;
  status: 200;
};

export type runtimeServiceCreateInstanceResponseDefault = {
  data: RpcStatus;
  status: Exclude<HTTPStatusCodes, 200>;
};

export type runtimeServiceCreateInstanceResponseSuccess =
  runtimeServiceCreateInstanceResponse200 & {
    headers: Headers;
  };
export type runtimeServiceCreateInstanceResponseError =
  runtimeServiceCreateInstanceResponseDefault & {
    headers: Headers;
  };

export type runtimeServiceCreateInstanceResponse =
  | runtimeServiceCreateInstanceResponseSuccess
  | runtimeServiceCreateInstanceResponseError;

export const getRuntimeServiceCreateInstanceUrl = () => {
  return `/v1/instances`;
};

export const runtimeServiceCreateInstance = async (
  v1CreateInstanceRequest: V1CreateInstanceRequest,
  options?: RequestInit,
): Promise<runtimeServiceCreateInstanceResponse> => {
  return httpClient<runtimeServiceCreateInstanceResponse>(
    getRuntimeServiceCreateInstanceUrl(),
    {
      ...options,
      method: "POST",
      headers: { "Content-Type": "application/json", ...options?.headers },
      body: JSON.stringify(v1CreateInstanceRequest),
    },
  );
};

export const getRuntimeServiceCreateInstanceMutationOptions = <
  TError = ErrorType<RpcStatus>,
  TContext = unknown,
>(options?: {
  mutation?: CreateMutationOptions<
    Awaited<ReturnType<typeof runtimeServiceCreateInstance>>,
    TError,
    { data: V1CreateInstanceRequest },
    TContext
  >;
}): CreateMutationOptions<
  Awaited<ReturnType<typeof runtimeServiceCreateInstance>>,
  TError,
  { data: V1CreateInstanceRequest },
  TContext
> => {
  const mutationKey = ["runtimeServiceCreateInstance"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof runtimeServiceCreateInstance>>,
    { data: V1CreateInstanceRequest }
  > = (props) => {
    const { data } = props ?? {};

    return runtimeServiceCreateInstance(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type RuntimeServiceCreateInstanceMutationResult = NonNullable<
  Awaited<ReturnType<typeof runtimeServiceCreateInstance>>
>;
export type RuntimeServiceCreateInstanceMutationBody = V1CreateInstanceRequest;
export type RuntimeServiceCreateInstanceMutationError = ErrorType<RpcStatus>;

/**
 * @summary CreateInstance creates a new instance
 */
export const createRuntimeServiceCreateInstance = <
  TError = ErrorType<RpcStatus>,
  TContext = unknown,
>(
  options?: () => {
    mutation?: CreateMutationOptions<
      Awaited<ReturnType<typeof runtimeServiceCreateInstance>>,
      TError,
      { data: V1CreateInstanceRequest },
      TContext
    >;
  },
  queryClient?: () => QueryClient,
): CreateMutationResult<
  Awaited<ReturnType<typeof runtimeServiceCreateInstance>>,
  TError,
  { data: V1CreateInstanceRequest },
  TContext
> => {
  return createMutation(
    () => ({ ...getRuntimeServiceCreateInstanceMutationOptions(options?.()) }),
    queryClient,
  );
};
/**
 * @summary GetInstance returns information about a specific instance
 */
export type runtimeServiceGetInstanceResponse200 = {
  data: V1GetInstanceResponse;
  status: 200;
};

export type runtimeServiceGetInstanceResponseDefault = {
  data: RpcStatus;
  status: Exclude<HTTPStatusCodes, 200>;
};

export type runtimeServiceGetInstanceResponseSuccess =
  runtimeServiceGetInstanceResponse200 & {
    headers: Headers;
  };
export type runtimeServiceGetInstanceResponseError =
  runtimeServiceGetInstanceResponseDefault & {
    headers: Headers;
  };

export type runtimeServiceGetInstanceResponse =
  | runtimeServiceGetInstanceResponseSuccess
  | runtimeServiceGetInstanceResponseError;

export const getRuntimeServiceGetInstanceUrl = (
  instanceId: string,
  params?: RuntimeServiceGetInstanceParams,
) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? "null" : value.toString());
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0
    ? `/v1/instances/${instanceId}?${stringifiedParams}`
    : `/v1/instances/${instanceId}`;
};

export const runtimeServiceGetInstance = async (
  instanceId: string,
  params?: RuntimeServiceGetInstanceParams,
  options?: RequestInit,
): Promise<runtimeServiceGetInstanceResponse> => {
  return httpClient<runtimeServiceGetInstanceResponse>(
    getRuntimeServiceGetInstanceUrl(instanceId, params),
    {
      ...options,
      method: "GET",
    },
  );
};

export const getRuntimeServiceGetInstanceQueryKey = (
  instanceId: string,
  params?: RuntimeServiceGetInstanceParams,
) => {
  return [`/v1/instances/${instanceId}`, ...(params ? [params] : [])] as const;
};

export const getRuntimeServiceGetInstanceQueryOptions = <
  TData = Awaited<ReturnType<typeof runtimeServiceGetInstance>>,
  TError = ErrorType<RpcStatus>,
>(
  instanceId: string,
  params?: RuntimeServiceGetInstanceParams,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof runtimeServiceGetInstance>>,
        TError,
        TData
      >
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getRuntimeServiceGetInstanceQueryKey(instanceId, params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof runtimeServiceGetInstance>>
  > = ({ signal }) => runtimeServiceGetInstance(instanceId, params, { signal });

  return {
    queryKey,
    queryFn,
    enabled: !!instanceId,
    ...queryOptions,
  } as CreateQueryOptions<
    Awaited<ReturnType<typeof runtimeServiceGetInstance>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type RuntimeServiceGetInstanceQueryResult = NonNullable<
  Awaited<ReturnType<typeof runtimeServiceGetInstance>>
>;
export type RuntimeServiceGetInstanceQueryError = ErrorType<RpcStatus>;

/**
 * @summary GetInstance returns information about a specific instance
 */

export function createRuntimeServiceGetInstance<
  TData = Awaited<ReturnType<typeof runtimeServiceGetInstance>>,
  TError = ErrorType<RpcStatus>,
>(
  instanceId: () => string,
  params?: () => RuntimeServiceGetInstanceParams,
  options?: () => {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof runtimeServiceGetInstance>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: () => QueryClient,
): CreateQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const query = createQuery(
    () =>
      getRuntimeServiceGetInstanceQueryOptions(
        instanceId(),
        params?.(),
        options?.(),
      ),
    queryClient,
  ) as CreateQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  return query;
}

/**
 * @summary DeleteInstance deletes an instance
 */
export type runtimeServiceDeleteInstanceResponse200 = {
  data: V1DeleteInstanceResponse;
  status: 200;
};

export type runtimeServiceDeleteInstanceResponseDefault = {
  data: RpcStatus;
  status: Exclude<HTTPStatusCodes, 200>;
};

export type runtimeServiceDeleteInstanceResponseSuccess =
  runtimeServiceDeleteInstanceResponse200 & {
    headers: Headers;
  };
export type runtimeServiceDeleteInstanceResponseError =
  runtimeServiceDeleteInstanceResponseDefault & {
    headers: Headers;
  };

export type runtimeServiceDeleteInstanceResponse =
  | runtimeServiceDeleteInstanceResponseSuccess
  | runtimeServiceDeleteInstanceResponseError;

export const getRuntimeServiceDeleteInstanceUrl = (instanceId: string) => {
  return `/v1/instances/${instanceId}`;
};

export const runtimeServiceDeleteInstance = async (
  instanceId: string,
  runtimeServiceDeleteInstanceBody: RuntimeServiceDeleteInstanceBody,
  options?: RequestInit,
): Promise<runtimeServiceDeleteInstanceResponse> => {
  return httpClient<runtimeServiceDeleteInstanceResponse>(
    getRuntimeServiceDeleteInstanceUrl(instanceId),
    {
      ...options,
      method: "POST",
      headers: { "Content-Type": "application/json", ...options?.headers },
      body: JSON.stringify(runtimeServiceDeleteInstanceBody),
    },
  );
};

export const getRuntimeServiceDeleteInstanceMutationOptions = <
  TError = ErrorType<RpcStatus>,
  TContext = unknown,
>(options?: {
  mutation?: CreateMutationOptions<
    Awaited<ReturnType<typeof runtimeServiceDeleteInstance>>,
    TError,
    { instanceId: string; data: RuntimeServiceDeleteInstanceBody },
    TContext
  >;
}): CreateMutationOptions<
  Awaited<ReturnType<typeof runtimeServiceDeleteInstance>>,
  TError,
  { instanceId: string; data: RuntimeServiceDeleteInstanceBody },
  TContext
> => {
  const mutationKey = ["runtimeServiceDeleteInstance"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof runtimeServiceDeleteInstance>>,
    { instanceId: string; data: RuntimeServiceDeleteInstanceBody }
  > = (props) => {
    const { instanceId, data } = props ?? {};

    return runtimeServiceDeleteInstance(instanceId, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type RuntimeServiceDeleteInstanceMutationResult = NonNullable<
  Awaited<ReturnType<typeof runtimeServiceDeleteInstance>>
>;
export type RuntimeServiceDeleteInstanceMutationBody =
  RuntimeServiceDeleteInstanceBody;
export type RuntimeServiceDeleteInstanceMutationError = ErrorType<RpcStatus>;

/**
 * @summary DeleteInstance deletes an instance
 */
export const createRuntimeServiceDeleteInstance = <
  TError = ErrorType<RpcStatus>,
  TContext = unknown,
>(
  options?: () => {
    mutation?: CreateMutationOptions<
      Awaited<ReturnType<typeof runtimeServiceDeleteInstance>>,
      TError,
      { instanceId: string; data: RuntimeServiceDeleteInstanceBody },
      TContext
    >;
  },
  queryClient?: () => QueryClient,
): CreateMutationResult<
  Awaited<ReturnType<typeof runtimeServiceDeleteInstance>>,
  TError,
  { instanceId: string; data: RuntimeServiceDeleteInstanceBody },
  TContext
> => {
  return createMutation(
    () => ({ ...getRuntimeServiceDeleteInstanceMutationOptions(options?.()) }),
    queryClient,
  );
};
/**
 * @summary EditInstance edits an existing instance
 */
export type runtimeServiceEditInstanceResponse200 = {
  data: V1EditInstanceResponse;
  status: 200;
};

export type runtimeServiceEditInstanceResponseDefault = {
  data: RpcStatus;
  status: Exclude<HTTPStatusCodes, 200>;
};

export type runtimeServiceEditInstanceResponseSuccess =
  runtimeServiceEditInstanceResponse200 & {
    headers: Headers;
  };
export type runtimeServiceEditInstanceResponseError =
  runtimeServiceEditInstanceResponseDefault & {
    headers: Headers;
  };

export type runtimeServiceEditInstanceResponse =
  | runtimeServiceEditInstanceResponseSuccess
  | runtimeServiceEditInstanceResponseError;

export const getRuntimeServiceEditInstanceUrl = (instanceId: string) => {
  return `/v1/instances/${instanceId}`;
};

export const runtimeServiceEditInstance = async (
  instanceId: string,
  runtimeServiceEditInstanceBody: RuntimeServiceEditInstanceBody,
  options?: RequestInit,
): Promise<runtimeServiceEditInstanceResponse> => {
  return httpClient<runtimeServiceEditInstanceResponse>(
    getRuntimeServiceEditInstanceUrl(instanceId),
    {
      ...options,
      method: "PATCH",
      headers: { "Content-Type": "application/json", ...options?.headers },
      body: JSON.stringify(runtimeServiceEditInstanceBody),
    },
  );
};

export const getRuntimeServiceEditInstanceMutationOptions = <
  TError = ErrorType<RpcStatus>,
  TContext = unknown,
>(options?: {
  mutation?: CreateMutationOptions<
    Awaited<ReturnType<typeof runtimeServiceEditInstance>>,
    TError,
    { instanceId: string; data: RuntimeServiceEditInstanceBody },
    TContext
  >;
}): CreateMutationOptions<
  Awaited<ReturnType<typeof runtimeServiceEditInstance>>,
  TError,
  { instanceId: string; data: RuntimeServiceEditInstanceBody },
  TContext
> => {
  const mutationKey = ["runtimeServiceEditInstance"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof runtimeServiceEditInstance>>,
    { instanceId: string; data: RuntimeServiceEditInstanceBody }
  > = (props) => {
    const { instanceId, data } = props ?? {};

    return runtimeServiceEditInstance(instanceId, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type RuntimeServiceEditInstanceMutationResult = NonNullable<
  Awaited<ReturnType<typeof runtimeServiceEditInstance>>
>;
export type RuntimeServiceEditInstanceMutationBody =
  RuntimeServiceEditInstanceBody;
export type RuntimeServiceEditInstanceMutationError = ErrorType<RpcStatus>;

/**
 * @summary EditInstance edits an existing instance
 */
export const createRuntimeServiceEditInstance = <
  TError = ErrorType<RpcStatus>,
  TContext = unknown,
>(
  options?: () => {
    mutation?: CreateMutationOptions<
      Awaited<ReturnType<typeof runtimeServiceEditInstance>>,
      TError,
      { instanceId: string; data: RuntimeServiceEditInstanceBody },
      TContext
    >;
  },
  queryClient?: () => QueryClient,
): CreateMutationResult<
  Awaited<ReturnType<typeof runtimeServiceEditInstance>>,
  TError,
  { instanceId: string; data: RuntimeServiceEditInstanceBody },
  TContext
> => {
  return createMutation(
    () => ({ ...getRuntimeServiceEditInstanceMutationOptions(options?.()) }),
    queryClient,
  );
};
/**
 * @summary Complete runs a language model completion (LLM chat) using the configured AI connector.
 */
export type runtimeServiceCompleteResponse200 = {
  data: V1CompleteResponse;
  status: 200;
};

export type runtimeServiceCompleteResponseDefault = {
  data: RpcStatus;
  status: Exclude<HTTPStatusCodes, 200>;
};

export type runtimeServiceCompleteResponseSuccess =
  runtimeServiceCompleteResponse200 & {
    headers: Headers;
  };
export type runtimeServiceCompleteResponseError =
  runtimeServiceCompleteResponseDefault & {
    headers: Headers;
  };

export type runtimeServiceCompleteResponse =
  | runtimeServiceCompleteResponseSuccess
  | runtimeServiceCompleteResponseError;

export const getRuntimeServiceCompleteUrl = (instanceId: string) => {
  return `/v1/instances/${instanceId}/ai/complete`;
};

export const runtimeServiceComplete = async (
  instanceId: string,
  runtimeServiceCompleteBody: RuntimeServiceCompleteBody,
  options?: RequestInit,
): Promise<runtimeServiceCompleteResponse> => {
  return httpClient<runtimeServiceCompleteResponse>(
    getRuntimeServiceCompleteUrl(instanceId),
    {
      ...options,
      method: "POST",
      headers: { "Content-Type": "application/json", ...options?.headers },
      body: JSON.stringify(runtimeServiceCompleteBody),
    },
  );
};

export const getRuntimeServiceCompleteMutationOptions = <
  TError = ErrorType<RpcStatus>,
  TContext = unknown,
>(options?: {
  mutation?: CreateMutationOptions<
    Awaited<ReturnType<typeof runtimeServiceComplete>>,
    TError,
    { instanceId: string; data: RuntimeServiceCompleteBody },
    TContext
  >;
}): CreateMutationOptions<
  Awaited<ReturnType<typeof runtimeServiceComplete>>,
  TError,
  { instanceId: string; data: RuntimeServiceCompleteBody },
  TContext
> => {
  const mutationKey = ["runtimeServiceComplete"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof runtimeServiceComplete>>,
    { instanceId: string; data: RuntimeServiceCompleteBody }
  > = (props) => {
    const { instanceId, data } = props ?? {};

    return runtimeServiceComplete(instanceId, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type RuntimeServiceCompleteMutationResult = NonNullable<
  Awaited<ReturnType<typeof runtimeServiceComplete>>
>;
export type RuntimeServiceCompleteMutationBody = RuntimeServiceCompleteBody;
export type RuntimeServiceCompleteMutationError = ErrorType<RpcStatus>;

/**
 * @summary Complete runs a language model completion (LLM chat) using the configured AI connector.
 */
export const createRuntimeServiceComplete = <
  TError = ErrorType<RpcStatus>,
  TContext = unknown,
>(
  options?: () => {
    mutation?: CreateMutationOptions<
      Awaited<ReturnType<typeof runtimeServiceComplete>>,
      TError,
      { instanceId: string; data: RuntimeServiceCompleteBody },
      TContext
    >;
  },
  queryClient?: () => QueryClient,
): CreateMutationResult<
  Awaited<ReturnType<typeof runtimeServiceComplete>>,
  TError,
  { instanceId: string; data: RuntimeServiceCompleteBody },
  TContext
> => {
  return createMutation(
    () => ({ ...getRuntimeServiceCompleteMutationOptions(options?.()) }),
    queryClient,
  );
};
/**
 * @summary CompleteStreaming runs an AI-powered chat completion, optionally invoking agents or tool calls available in Rill.
 */
export type runtimeServiceCompleteStreamingResponse200 = {
  data: RuntimeServiceCompleteStreaming200;
  status: 200;
};

export type runtimeServiceCompleteStreamingResponseDefault = {
  data: RpcStatus;
  status: Exclude<HTTPStatusCodes, 200>;
};

export type runtimeServiceCompleteStreamingResponseSuccess =
  runtimeServiceCompleteStreamingResponse200 & {
    headers: Headers;
  };
export type runtimeServiceCompleteStreamingResponseError =
  runtimeServiceCompleteStreamingResponseDefault & {
    headers: Headers;
  };

export type runtimeServiceCompleteStreamingResponse =
  | runtimeServiceCompleteStreamingResponseSuccess
  | runtimeServiceCompleteStreamingResponseError;

export const getRuntimeServiceCompleteStreamingUrl = (instanceId: string) => {
  return `/v1/instances/${instanceId}/ai/complete/stream`;
};

export const runtimeServiceCompleteStreaming = async (
  instanceId: string,
  runtimeServiceCompleteStreamingBody: RuntimeServiceCompleteStreamingBody,
  options?: RequestInit,
): Promise<runtimeServiceCompleteStreamingResponse> => {
  return httpClient<runtimeServiceCompleteStreamingResponse>(
    getRuntimeServiceCompleteStreamingUrl(instanceId),
    {
      ...options,
      method: "POST",
      headers: { "Content-Type": "application/json", ...options?.headers },
      body: JSON.stringify(runtimeServiceCompleteStreamingBody),
    },
  );
};

export const getRuntimeServiceCompleteStreamingMutationOptions = <
  TError = ErrorType<RpcStatus>,
  TContext = unknown,
>(options?: {
  mutation?: CreateMutationOptions<
    Awaited<ReturnType<typeof runtimeServiceCompleteStreaming>>,
    TError,
    { instanceId: string; data: RuntimeServiceCompleteStreamingBody },
    TContext
  >;
}): CreateMutationOptions<
  Awaited<ReturnType<typeof runtimeServiceCompleteStreaming>>,
  TError,
  { instanceId: string; data: RuntimeServiceCompleteStreamingBody },
  TContext
> => {
  const mutationKey = ["runtimeServiceCompleteStreaming"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof runtimeServiceCompleteStreaming>>,
    { instanceId: string; data: RuntimeServiceCompleteStreamingBody }
  > = (props) => {
    const { instanceId, data } = props ?? {};

    return runtimeServiceCompleteStreaming(instanceId, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type RuntimeServiceCompleteStreamingMutationResult = NonNullable<
  Awaited<ReturnType<typeof runtimeServiceCompleteStreaming>>
>;
export type RuntimeServiceCompleteStreamingMutationBody =
  RuntimeServiceCompleteStreamingBody;
export type RuntimeServiceCompleteStreamingMutationError = ErrorType<RpcStatus>;

/**
 * @summary CompleteStreaming runs an AI-powered chat completion, optionally invoking agents or tool calls available in Rill.
 */
export const createRuntimeServiceCompleteStreaming = <
  TError = ErrorType<RpcStatus>,
  TContext = unknown,
>(
  options?: () => {
    mutation?: CreateMutationOptions<
      Awaited<ReturnType<typeof runtimeServiceCompleteStreaming>>,
      TError,
      { instanceId: string; data: RuntimeServiceCompleteStreamingBody },
      TContext
    >;
  },
  queryClient?: () => QueryClient,
): CreateMutationResult<
  Awaited<ReturnType<typeof runtimeServiceCompleteStreaming>>,
  TError,
  { instanceId: string; data: RuntimeServiceCompleteStreamingBody },
  TContext
> => {
  return createMutation(
    () => ({
      ...getRuntimeServiceCompleteStreamingMutationOptions(options?.()),
    }),
    queryClient,
  );
};
/**
 * @summary ListConversations lists all AI chat conversations for an instance.
 */
export type runtimeServiceListConversationsResponse200 = {
  data: V1ListConversationsResponse;
  status: 200;
};

export type runtimeServiceListConversationsResponseDefault = {
  data: RpcStatus;
  status: Exclude<HTTPStatusCodes, 200>;
};

export type runtimeServiceListConversationsResponseSuccess =
  runtimeServiceListConversationsResponse200 & {
    headers: Headers;
  };
export type runtimeServiceListConversationsResponseError =
  runtimeServiceListConversationsResponseDefault & {
    headers: Headers;
  };

export type runtimeServiceListConversationsResponse =
  | runtimeServiceListConversationsResponseSuccess
  | runtimeServiceListConversationsResponseError;

export const getRuntimeServiceListConversationsUrl = (
  instanceId: string,
  params?: RuntimeServiceListConversationsParams,
) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? "null" : value.toString());
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0
    ? `/v1/instances/${instanceId}/ai/conversations?${stringifiedParams}`
    : `/v1/instances/${instanceId}/ai/conversations`;
};

export const runtimeServiceListConversations = async (
  instanceId: string,
  params?: RuntimeServiceListConversationsParams,
  options?: RequestInit,
): Promise<runtimeServiceListConversationsResponse> => {
  return httpClient<runtimeServiceListConversationsResponse>(
    getRuntimeServiceListConversationsUrl(instanceId, params),
    {
      ...options,
      method: "GET",
    },
  );
};

export const getRuntimeServiceListConversationsQueryKey = (
  instanceId: string,
  params?: RuntimeServiceListConversationsParams,
) => {
  return [
    `/v1/instances/${instanceId}/ai/conversations`,
    ...(params ? [params] : []),
  ] as const;
};

export const getRuntimeServiceListConversationsQueryOptions = <
  TData = Awaited<ReturnType<typeof runtimeServiceListConversations>>,
  TError = ErrorType<RpcStatus>,
>(
  instanceId: string,
  params?: RuntimeServiceListConversationsParams,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof runtimeServiceListConversations>>,
        TError,
        TData
      >
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getRuntimeServiceListConversationsQueryKey(instanceId, params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof runtimeServiceListConversations>>
  > = ({ signal }) =>
    runtimeServiceListConversations(instanceId, params, { signal });

  return {
    queryKey,
    queryFn,
    enabled: !!instanceId,
    ...queryOptions,
  } as CreateQueryOptions<
    Awaited<ReturnType<typeof runtimeServiceListConversations>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type RuntimeServiceListConversationsQueryResult = NonNullable<
  Awaited<ReturnType<typeof runtimeServiceListConversations>>
>;
export type RuntimeServiceListConversationsQueryError = ErrorType<RpcStatus>;

/**
 * @summary ListConversations lists all AI chat conversations for an instance.
 */

export function createRuntimeServiceListConversations<
  TData = Awaited<ReturnType<typeof runtimeServiceListConversations>>,
  TError = ErrorType<RpcStatus>,
>(
  instanceId: () => string,
  params?: () => RuntimeServiceListConversationsParams,
  options?: () => {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof runtimeServiceListConversations>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: () => QueryClient,
): CreateQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const query = createQuery(
    () =>
      getRuntimeServiceListConversationsQueryOptions(
        instanceId(),
        params?.(),
        options?.(),
      ),
    queryClient,
  ) as CreateQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  return query;
}

/**
 * @summary GetConversation returns a specific AI chat conversation.
 */
export type runtimeServiceGetConversationResponse200 = {
  data: V1GetConversationResponse;
  status: 200;
};

export type runtimeServiceGetConversationResponseDefault = {
  data: RpcStatus;
  status: Exclude<HTTPStatusCodes, 200>;
};

export type runtimeServiceGetConversationResponseSuccess =
  runtimeServiceGetConversationResponse200 & {
    headers: Headers;
  };
export type runtimeServiceGetConversationResponseError =
  runtimeServiceGetConversationResponseDefault & {
    headers: Headers;
  };

export type runtimeServiceGetConversationResponse =
  | runtimeServiceGetConversationResponseSuccess
  | runtimeServiceGetConversationResponseError;

export const getRuntimeServiceGetConversationUrl = (
  instanceId: string,
  conversationId: string,
) => {
  return `/v1/instances/${instanceId}/ai/conversations/${conversationId}`;
};

export const runtimeServiceGetConversation = async (
  instanceId: string,
  conversationId: string,
  options?: RequestInit,
): Promise<runtimeServiceGetConversationResponse> => {
  return httpClient<runtimeServiceGetConversationResponse>(
    getRuntimeServiceGetConversationUrl(instanceId, conversationId),
    {
      ...options,
      method: "GET",
    },
  );
};

export const getRuntimeServiceGetConversationQueryKey = (
  instanceId: string,
  conversationId: string,
) => {
  return [
    `/v1/instances/${instanceId}/ai/conversations/${conversationId}`,
  ] as const;
};

export const getRuntimeServiceGetConversationQueryOptions = <
  TData = Awaited<ReturnType<typeof runtimeServiceGetConversation>>,
  TError = ErrorType<RpcStatus>,
>(
  instanceId: string,
  conversationId: string,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof runtimeServiceGetConversation>>,
        TError,
        TData
      >
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getRuntimeServiceGetConversationQueryKey(instanceId, conversationId);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof runtimeServiceGetConversation>>
  > = ({ signal }) =>
    runtimeServiceGetConversation(instanceId, conversationId, { signal });

  return {
    queryKey,
    queryFn,
    enabled: !!(instanceId && conversationId),
    ...queryOptions,
  } as CreateQueryOptions<
    Awaited<ReturnType<typeof runtimeServiceGetConversation>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type RuntimeServiceGetConversationQueryResult = NonNullable<
  Awaited<ReturnType<typeof runtimeServiceGetConversation>>
>;
export type RuntimeServiceGetConversationQueryError = ErrorType<RpcStatus>;

/**
 * @summary GetConversation returns a specific AI chat conversation.
 */

export function createRuntimeServiceGetConversation<
  TData = Awaited<ReturnType<typeof runtimeServiceGetConversation>>,
  TError = ErrorType<RpcStatus>,
>(
  instanceId: () => string,
  conversationId: () => string,
  options?: () => {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof runtimeServiceGetConversation>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: () => QueryClient,
): CreateQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const query = createQuery(
    () =>
      getRuntimeServiceGetConversationQueryOptions(
        instanceId(),
        conversationId(),
        options?.(),
      ),
    queryClient,
  ) as CreateQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  return query;
}

/**
 * @summary ForkConversation creates a new conversation by copying messages from an existing one.
If its the owner then all messages will be copied, otherwise only messages up to the session.SharedUntilMessageID are copied.
 */
export type runtimeServiceForkConversationResponse200 = {
  data: V1ForkConversationResponse;
  status: 200;
};

export type runtimeServiceForkConversationResponseDefault = {
  data: RpcStatus;
  status: Exclude<HTTPStatusCodes, 200>;
};

export type runtimeServiceForkConversationResponseSuccess =
  runtimeServiceForkConversationResponse200 & {
    headers: Headers;
  };
export type runtimeServiceForkConversationResponseError =
  runtimeServiceForkConversationResponseDefault & {
    headers: Headers;
  };

export type runtimeServiceForkConversationResponse =
  | runtimeServiceForkConversationResponseSuccess
  | runtimeServiceForkConversationResponseError;

export const getRuntimeServiceForkConversationUrl = (
  instanceId: string,
  conversationId: string,
) => {
  return `/v1/instances/${instanceId}/ai/conversations/${conversationId}/fork`;
};

export const runtimeServiceForkConversation = async (
  instanceId: string,
  conversationId: string,
  runtimeServiceForkConversationBody: RuntimeServiceForkConversationBody,
  options?: RequestInit,
): Promise<runtimeServiceForkConversationResponse> => {
  return httpClient<runtimeServiceForkConversationResponse>(
    getRuntimeServiceForkConversationUrl(instanceId, conversationId),
    {
      ...options,
      method: "POST",
      headers: { "Content-Type": "application/json", ...options?.headers },
      body: JSON.stringify(runtimeServiceForkConversationBody),
    },
  );
};

export const getRuntimeServiceForkConversationMutationOptions = <
  TError = ErrorType<RpcStatus>,
  TContext = unknown,
>(options?: {
  mutation?: CreateMutationOptions<
    Awaited<ReturnType<typeof runtimeServiceForkConversation>>,
    TError,
    {
      instanceId: string;
      conversationId: string;
      data: RuntimeServiceForkConversationBody;
    },
    TContext
  >;
}): CreateMutationOptions<
  Awaited<ReturnType<typeof runtimeServiceForkConversation>>,
  TError,
  {
    instanceId: string;
    conversationId: string;
    data: RuntimeServiceForkConversationBody;
  },
  TContext
> => {
  const mutationKey = ["runtimeServiceForkConversation"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof runtimeServiceForkConversation>>,
    {
      instanceId: string;
      conversationId: string;
      data: RuntimeServiceForkConversationBody;
    }
  > = (props) => {
    const { instanceId, conversationId, data } = props ?? {};

    return runtimeServiceForkConversation(instanceId, conversationId, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type RuntimeServiceForkConversationMutationResult = NonNullable<
  Awaited<ReturnType<typeof runtimeServiceForkConversation>>
>;
export type RuntimeServiceForkConversationMutationBody =
  RuntimeServiceForkConversationBody;
export type RuntimeServiceForkConversationMutationError = ErrorType<RpcStatus>;

/**
 * @summary ForkConversation creates a new conversation by copying messages from an existing one.
If its the owner then all messages will be copied, otherwise only messages up to the session.SharedUntilMessageID are copied.
 */
export const createRuntimeServiceForkConversation = <
  TError = ErrorType<RpcStatus>,
  TContext = unknown,
>(
  options?: () => {
    mutation?: CreateMutationOptions<
      Awaited<ReturnType<typeof runtimeServiceForkConversation>>,
      TError,
      {
        instanceId: string;
        conversationId: string;
        data: RuntimeServiceForkConversationBody;
      },
      TContext
    >;
  },
  queryClient?: () => QueryClient,
): CreateMutationResult<
  Awaited<ReturnType<typeof runtimeServiceForkConversation>>,
  TError,
  {
    instanceId: string;
    conversationId: string;
    data: RuntimeServiceForkConversationBody;
  },
  TContext
> => {
  return createMutation(
    () => ({
      ...getRuntimeServiceForkConversationMutationOptions(options?.()),
    }),
    queryClient,
  );
};
/**
 * @summary ShareConversation enables sharing of the conversation by adding metadata.
 */
export type runtimeServiceShareConversationResponse200 = {
  data: V1ShareConversationResponse;
  status: 200;
};

export type runtimeServiceShareConversationResponseDefault = {
  data: RpcStatus;
  status: Exclude<HTTPStatusCodes, 200>;
};

export type runtimeServiceShareConversationResponseSuccess =
  runtimeServiceShareConversationResponse200 & {
    headers: Headers;
  };
export type runtimeServiceShareConversationResponseError =
  runtimeServiceShareConversationResponseDefault & {
    headers: Headers;
  };

export type runtimeServiceShareConversationResponse =
  | runtimeServiceShareConversationResponseSuccess
  | runtimeServiceShareConversationResponseError;

export const getRuntimeServiceShareConversationUrl = (
  instanceId: string,
  conversationId: string,
) => {
  return `/v1/instances/${instanceId}/ai/conversations/${conversationId}/share`;
};

export const runtimeServiceShareConversation = async (
  instanceId: string,
  conversationId: string,
  runtimeServiceShareConversationBody: RuntimeServiceShareConversationBody,
  options?: RequestInit,
): Promise<runtimeServiceShareConversationResponse> => {
  return httpClient<runtimeServiceShareConversationResponse>(
    getRuntimeServiceShareConversationUrl(instanceId, conversationId),
    {
      ...options,
      method: "POST",
      headers: { "Content-Type": "application/json", ...options?.headers },
      body: JSON.stringify(runtimeServiceShareConversationBody),
    },
  );
};

export const getRuntimeServiceShareConversationMutationOptions = <
  TError = ErrorType<RpcStatus>,
  TContext = unknown,
>(options?: {
  mutation?: CreateMutationOptions<
    Awaited<ReturnType<typeof runtimeServiceShareConversation>>,
    TError,
    {
      instanceId: string;
      conversationId: string;
      data: RuntimeServiceShareConversationBody;
    },
    TContext
  >;
}): CreateMutationOptions<
  Awaited<ReturnType<typeof runtimeServiceShareConversation>>,
  TError,
  {
    instanceId: string;
    conversationId: string;
    data: RuntimeServiceShareConversationBody;
  },
  TContext
> => {
  const mutationKey = ["runtimeServiceShareConversation"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof runtimeServiceShareConversation>>,
    {
      instanceId: string;
      conversationId: string;
      data: RuntimeServiceShareConversationBody;
    }
  > = (props) => {
    const { instanceId, conversationId, data } = props ?? {};

    return runtimeServiceShareConversation(instanceId, conversationId, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type RuntimeServiceShareConversationMutationResult = NonNullable<
  Awaited<ReturnType<typeof runtimeServiceShareConversation>>
>;
export type RuntimeServiceShareConversationMutationBody =
  RuntimeServiceShareConversationBody;
export type RuntimeServiceShareConversationMutationError = ErrorType<RpcStatus>;

/**
 * @summary ShareConversation enables sharing of the conversation by adding metadata.
 */
export const createRuntimeServiceShareConversation = <
  TError = ErrorType<RpcStatus>,
  TContext = unknown,
>(
  options?: () => {
    mutation?: CreateMutationOptions<
      Awaited<ReturnType<typeof runtimeServiceShareConversation>>,
      TError,
      {
        instanceId: string;
        conversationId: string;
        data: RuntimeServiceShareConversationBody;
      },
      TContext
    >;
  },
  queryClient?: () => QueryClient,
): CreateMutationResult<
  Awaited<ReturnType<typeof runtimeServiceShareConversation>>,
  TError,
  {
    instanceId: string;
    conversationId: string;
    data: RuntimeServiceShareConversationBody;
  },
  TContext
> => {
  return createMutation(
    () => ({
      ...getRuntimeServiceShareConversationMutationOptions(options?.()),
    }),
    queryClient,
  );
};
/**
 * @summary ListTools lists metadata about all AI tools that calls to Complete(Streaming) may invoke.
Note that it covers all registered tools, but the current user may not have access to all of them.
 */
export type runtimeServiceListToolsResponse200 = {
  data: V1ListToolsResponse;
  status: 200;
};

export type runtimeServiceListToolsResponseDefault = {
  data: RpcStatus;
  status: Exclude<HTTPStatusCodes, 200>;
};

export type runtimeServiceListToolsResponseSuccess =
  runtimeServiceListToolsResponse200 & {
    headers: Headers;
  };
export type runtimeServiceListToolsResponseError =
  runtimeServiceListToolsResponseDefault & {
    headers: Headers;
  };

export type runtimeServiceListToolsResponse =
  | runtimeServiceListToolsResponseSuccess
  | runtimeServiceListToolsResponseError;

export const getRuntimeServiceListToolsUrl = (instanceId: string) => {
  return `/v1/instances/${instanceId}/ai/tools`;
};

export const runtimeServiceListTools = async (
  instanceId: string,
  options?: RequestInit,
): Promise<runtimeServiceListToolsResponse> => {
  return httpClient<runtimeServiceListToolsResponse>(
    getRuntimeServiceListToolsUrl(instanceId),
    {
      ...options,
      method: "GET",
    },
  );
};

export const getRuntimeServiceListToolsQueryKey = (instanceId: string) => {
  return [`/v1/instances/${instanceId}/ai/tools`] as const;
};

export const getRuntimeServiceListToolsQueryOptions = <
  TData = Awaited<ReturnType<typeof runtimeServiceListTools>>,
  TError = ErrorType<RpcStatus>,
>(
  instanceId: string,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof runtimeServiceListTools>>,
        TError,
        TData
      >
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getRuntimeServiceListToolsQueryKey(instanceId);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof runtimeServiceListTools>>
  > = ({ signal }) => runtimeServiceListTools(instanceId, { signal });

  return {
    queryKey,
    queryFn,
    enabled: !!instanceId,
    ...queryOptions,
  } as CreateQueryOptions<
    Awaited<ReturnType<typeof runtimeServiceListTools>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type RuntimeServiceListToolsQueryResult = NonNullable<
  Awaited<ReturnType<typeof runtimeServiceListTools>>
>;
export type RuntimeServiceListToolsQueryError = ErrorType<RpcStatus>;

/**
 * @summary ListTools lists metadata about all AI tools that calls to Complete(Streaming) may invoke.
Note that it covers all registered tools, but the current user may not have access to all of them.
 */

export function createRuntimeServiceListTools<
  TData = Awaited<ReturnType<typeof runtimeServiceListTools>>,
  TError = ErrorType<RpcStatus>,
>(
  instanceId: () => string,
  options?: () => {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof runtimeServiceListTools>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: () => QueryClient,
): CreateQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const query = createQuery(
    () => getRuntimeServiceListToolsQueryOptions(instanceId(), options?.()),
    queryClient,
  ) as CreateQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  return query;
}

/**
 * @summary AnalyzeConnectors scans all the project files and returns information about all referenced connectors.
 */
export type runtimeServiceAnalyzeConnectorsResponse200 = {
  data: V1AnalyzeConnectorsResponse;
  status: 200;
};

export type runtimeServiceAnalyzeConnectorsResponseDefault = {
  data: RpcStatus;
  status: Exclude<HTTPStatusCodes, 200>;
};

export type runtimeServiceAnalyzeConnectorsResponseSuccess =
  runtimeServiceAnalyzeConnectorsResponse200 & {
    headers: Headers;
  };
export type runtimeServiceAnalyzeConnectorsResponseError =
  runtimeServiceAnalyzeConnectorsResponseDefault & {
    headers: Headers;
  };

export type runtimeServiceAnalyzeConnectorsResponse =
  | runtimeServiceAnalyzeConnectorsResponseSuccess
  | runtimeServiceAnalyzeConnectorsResponseError;

export const getRuntimeServiceAnalyzeConnectorsUrl = (instanceId: string) => {
  return `/v1/instances/${instanceId}/connectors/analyze`;
};

export const runtimeServiceAnalyzeConnectors = async (
  instanceId: string,
  options?: RequestInit,
): Promise<runtimeServiceAnalyzeConnectorsResponse> => {
  return httpClient<runtimeServiceAnalyzeConnectorsResponse>(
    getRuntimeServiceAnalyzeConnectorsUrl(instanceId),
    {
      ...options,
      method: "GET",
    },
  );
};

export const getRuntimeServiceAnalyzeConnectorsQueryKey = (
  instanceId: string,
) => {
  return [`/v1/instances/${instanceId}/connectors/analyze`] as const;
};

export const getRuntimeServiceAnalyzeConnectorsQueryOptions = <
  TData = Awaited<ReturnType<typeof runtimeServiceAnalyzeConnectors>>,
  TError = ErrorType<RpcStatus>,
>(
  instanceId: string,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof runtimeServiceAnalyzeConnectors>>,
        TError,
        TData
      >
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getRuntimeServiceAnalyzeConnectorsQueryKey(instanceId);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof runtimeServiceAnalyzeConnectors>>
  > = ({ signal }) => runtimeServiceAnalyzeConnectors(instanceId, { signal });

  return {
    queryKey,
    queryFn,
    enabled: !!instanceId,
    ...queryOptions,
  } as CreateQueryOptions<
    Awaited<ReturnType<typeof runtimeServiceAnalyzeConnectors>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type RuntimeServiceAnalyzeConnectorsQueryResult = NonNullable<
  Awaited<ReturnType<typeof runtimeServiceAnalyzeConnectors>>
>;
export type RuntimeServiceAnalyzeConnectorsQueryError = ErrorType<RpcStatus>;

/**
 * @summary AnalyzeConnectors scans all the project files and returns information about all referenced connectors.
 */

export function createRuntimeServiceAnalyzeConnectors<
  TData = Awaited<ReturnType<typeof runtimeServiceAnalyzeConnectors>>,
  TError = ErrorType<RpcStatus>,
>(
  instanceId: () => string,
  options?: () => {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof runtimeServiceAnalyzeConnectors>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: () => QueryClient,
): CreateQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const query = createQuery(
    () =>
      getRuntimeServiceAnalyzeConnectorsQueryOptions(instanceId(), options?.()),
    queryClient,
  ) as CreateQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  return query;
}

/**
 * @summary ListNotifierConnectors returns the names of all configured connectors that can be used as notifiers.
This API is much faster than AnalyzeConnectors and can be called without admin-level permissions.
 */
export type runtimeServiceListNotifierConnectorsResponse200 = {
  data: V1ListNotifierConnectorsResponse;
  status: 200;
};

export type runtimeServiceListNotifierConnectorsResponseDefault = {
  data: RpcStatus;
  status: Exclude<HTTPStatusCodes, 200>;
};

export type runtimeServiceListNotifierConnectorsResponseSuccess =
  runtimeServiceListNotifierConnectorsResponse200 & {
    headers: Headers;
  };
export type runtimeServiceListNotifierConnectorsResponseError =
  runtimeServiceListNotifierConnectorsResponseDefault & {
    headers: Headers;
  };

export type runtimeServiceListNotifierConnectorsResponse =
  | runtimeServiceListNotifierConnectorsResponseSuccess
  | runtimeServiceListNotifierConnectorsResponseError;

export const getRuntimeServiceListNotifierConnectorsUrl = (
  instanceId: string,
) => {
  return `/v1/instances/${instanceId}/connectors/notifiers`;
};

export const runtimeServiceListNotifierConnectors = async (
  instanceId: string,
  options?: RequestInit,
): Promise<runtimeServiceListNotifierConnectorsResponse> => {
  return httpClient<runtimeServiceListNotifierConnectorsResponse>(
    getRuntimeServiceListNotifierConnectorsUrl(instanceId),
    {
      ...options,
      method: "GET",
    },
  );
};

export const getRuntimeServiceListNotifierConnectorsQueryKey = (
  instanceId: string,
) => {
  return [`/v1/instances/${instanceId}/connectors/notifiers`] as const;
};

export const getRuntimeServiceListNotifierConnectorsQueryOptions = <
  TData = Awaited<ReturnType<typeof runtimeServiceListNotifierConnectors>>,
  TError = ErrorType<RpcStatus>,
>(
  instanceId: string,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof runtimeServiceListNotifierConnectors>>,
        TError,
        TData
      >
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getRuntimeServiceListNotifierConnectorsQueryKey(instanceId);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof runtimeServiceListNotifierConnectors>>
  > = ({ signal }) =>
    runtimeServiceListNotifierConnectors(instanceId, { signal });

  return {
    queryKey,
    queryFn,
    enabled: !!instanceId,
    ...queryOptions,
  } as CreateQueryOptions<
    Awaited<ReturnType<typeof runtimeServiceListNotifierConnectors>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type RuntimeServiceListNotifierConnectorsQueryResult = NonNullable<
  Awaited<ReturnType<typeof runtimeServiceListNotifierConnectors>>
>;
export type RuntimeServiceListNotifierConnectorsQueryError =
  ErrorType<RpcStatus>;

/**
 * @summary ListNotifierConnectors returns the names of all configured connectors that can be used as notifiers.
This API is much faster than AnalyzeConnectors and can be called without admin-level permissions.
 */

export function createRuntimeServiceListNotifierConnectors<
  TData = Awaited<ReturnType<typeof runtimeServiceListNotifierConnectors>>,
  TError = ErrorType<RpcStatus>,
>(
  instanceId: () => string,
  options?: () => {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof runtimeServiceListNotifierConnectors>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: () => QueryClient,
): CreateQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const query = createQuery(
    () =>
      getRuntimeServiceListNotifierConnectorsQueryOptions(
        instanceId(),
        options?.(),
      ),
    queryClient,
  ) as CreateQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  return query;
}

/**
 * @summary ListFiles lists all the files matching a glob in a repo.
The files are sorted by their full path.
 */
export type runtimeServiceListFilesResponse200 = {
  data: V1ListFilesResponse;
  status: 200;
};

export type runtimeServiceListFilesResponseDefault = {
  data: RpcStatus;
  status: Exclude<HTTPStatusCodes, 200>;
};

export type runtimeServiceListFilesResponseSuccess =
  runtimeServiceListFilesResponse200 & {
    headers: Headers;
  };
export type runtimeServiceListFilesResponseError =
  runtimeServiceListFilesResponseDefault & {
    headers: Headers;
  };

export type runtimeServiceListFilesResponse =
  | runtimeServiceListFilesResponseSuccess
  | runtimeServiceListFilesResponseError;

export const getRuntimeServiceListFilesUrl = (
  instanceId: string,
  params?: RuntimeServiceListFilesParams,
) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? "null" : value.toString());
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0
    ? `/v1/instances/${instanceId}/files?${stringifiedParams}`
    : `/v1/instances/${instanceId}/files`;
};

export const runtimeServiceListFiles = async (
  instanceId: string,
  params?: RuntimeServiceListFilesParams,
  options?: RequestInit,
): Promise<runtimeServiceListFilesResponse> => {
  return httpClient<runtimeServiceListFilesResponse>(
    getRuntimeServiceListFilesUrl(instanceId, params),
    {
      ...options,
      method: "GET",
    },
  );
};

export const getRuntimeServiceListFilesQueryKey = (
  instanceId: string,
  params?: RuntimeServiceListFilesParams,
) => {
  return [
    `/v1/instances/${instanceId}/files`,
    ...(params ? [params] : []),
  ] as const;
};

export const getRuntimeServiceListFilesQueryOptions = <
  TData = Awaited<ReturnType<typeof runtimeServiceListFiles>>,
  TError = ErrorType<RpcStatus>,
>(
  instanceId: string,
  params?: RuntimeServiceListFilesParams,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof runtimeServiceListFiles>>,
        TError,
        TData
      >
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getRuntimeServiceListFilesQueryKey(instanceId, params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof runtimeServiceListFiles>>
  > = ({ signal }) => runtimeServiceListFiles(instanceId, params, { signal });

  return {
    queryKey,
    queryFn,
    enabled: !!instanceId,
    ...queryOptions,
  } as CreateQueryOptions<
    Awaited<ReturnType<typeof runtimeServiceListFiles>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type RuntimeServiceListFilesQueryResult = NonNullable<
  Awaited<ReturnType<typeof runtimeServiceListFiles>>
>;
export type RuntimeServiceListFilesQueryError = ErrorType<RpcStatus>;

/**
 * @summary ListFiles lists all the files matching a glob in a repo.
The files are sorted by their full path.
 */

export function createRuntimeServiceListFiles<
  TData = Awaited<ReturnType<typeof runtimeServiceListFiles>>,
  TError = ErrorType<RpcStatus>,
>(
  instanceId: () => string,
  params?: () => RuntimeServiceListFilesParams,
  options?: () => {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof runtimeServiceListFiles>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: () => QueryClient,
): CreateQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const query = createQuery(
    () =>
      getRuntimeServiceListFilesQueryOptions(
        instanceId(),
        params?.(),
        options?.(),
      ),
    queryClient,
  ) as CreateQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  return query;
}

/**
 * @summary CreateDirectory create a directory for the given path
 */
export type runtimeServiceCreateDirectoryResponse200 = {
  data: V1CreateDirectoryResponse;
  status: 200;
};

export type runtimeServiceCreateDirectoryResponseDefault = {
  data: RpcStatus;
  status: Exclude<HTTPStatusCodes, 200>;
};

export type runtimeServiceCreateDirectoryResponseSuccess =
  runtimeServiceCreateDirectoryResponse200 & {
    headers: Headers;
  };
export type runtimeServiceCreateDirectoryResponseError =
  runtimeServiceCreateDirectoryResponseDefault & {
    headers: Headers;
  };

export type runtimeServiceCreateDirectoryResponse =
  | runtimeServiceCreateDirectoryResponseSuccess
  | runtimeServiceCreateDirectoryResponseError;

export const getRuntimeServiceCreateDirectoryUrl = (instanceId: string) => {
  return `/v1/instances/${instanceId}/files/dir`;
};

export const runtimeServiceCreateDirectory = async (
  instanceId: string,
  runtimeServiceCreateDirectoryBody: RuntimeServiceCreateDirectoryBody,
  options?: RequestInit,
): Promise<runtimeServiceCreateDirectoryResponse> => {
  return httpClient<runtimeServiceCreateDirectoryResponse>(
    getRuntimeServiceCreateDirectoryUrl(instanceId),
    {
      ...options,
      method: "POST",
      headers: { "Content-Type": "application/json", ...options?.headers },
      body: JSON.stringify(runtimeServiceCreateDirectoryBody),
    },
  );
};

export const getRuntimeServiceCreateDirectoryMutationOptions = <
  TError = ErrorType<RpcStatus>,
  TContext = unknown,
>(options?: {
  mutation?: CreateMutationOptions<
    Awaited<ReturnType<typeof runtimeServiceCreateDirectory>>,
    TError,
    { instanceId: string; data: RuntimeServiceCreateDirectoryBody },
    TContext
  >;
}): CreateMutationOptions<
  Awaited<ReturnType<typeof runtimeServiceCreateDirectory>>,
  TError,
  { instanceId: string; data: RuntimeServiceCreateDirectoryBody },
  TContext
> => {
  const mutationKey = ["runtimeServiceCreateDirectory"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof runtimeServiceCreateDirectory>>,
    { instanceId: string; data: RuntimeServiceCreateDirectoryBody }
  > = (props) => {
    const { instanceId, data } = props ?? {};

    return runtimeServiceCreateDirectory(instanceId, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type RuntimeServiceCreateDirectoryMutationResult = NonNullable<
  Awaited<ReturnType<typeof runtimeServiceCreateDirectory>>
>;
export type RuntimeServiceCreateDirectoryMutationBody =
  RuntimeServiceCreateDirectoryBody;
export type RuntimeServiceCreateDirectoryMutationError = ErrorType<RpcStatus>;

/**
 * @summary CreateDirectory create a directory for the given path
 */
export const createRuntimeServiceCreateDirectory = <
  TError = ErrorType<RpcStatus>,
  TContext = unknown,
>(
  options?: () => {
    mutation?: CreateMutationOptions<
      Awaited<ReturnType<typeof runtimeServiceCreateDirectory>>,
      TError,
      { instanceId: string; data: RuntimeServiceCreateDirectoryBody },
      TContext
    >;
  },
  queryClient?: () => QueryClient,
): CreateMutationResult<
  Awaited<ReturnType<typeof runtimeServiceCreateDirectory>>,
  TError,
  { instanceId: string; data: RuntimeServiceCreateDirectoryBody },
  TContext
> => {
  return createMutation(
    () => ({ ...getRuntimeServiceCreateDirectoryMutationOptions(options?.()) }),
    queryClient,
  );
};
/**
 * @summary GetFile returns the contents of a specific file in a repo.
 */
export type runtimeServiceGetFileResponse200 = {
  data: V1GetFileResponse;
  status: 200;
};

export type runtimeServiceGetFileResponseDefault = {
  data: RpcStatus;
  status: Exclude<HTTPStatusCodes, 200>;
};

export type runtimeServiceGetFileResponseSuccess =
  runtimeServiceGetFileResponse200 & {
    headers: Headers;
  };
export type runtimeServiceGetFileResponseError =
  runtimeServiceGetFileResponseDefault & {
    headers: Headers;
  };

export type runtimeServiceGetFileResponse =
  | runtimeServiceGetFileResponseSuccess
  | runtimeServiceGetFileResponseError;

export const getRuntimeServiceGetFileUrl = (
  instanceId: string,
  params?: RuntimeServiceGetFileParams,
) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? "null" : value.toString());
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0
    ? `/v1/instances/${instanceId}/files/entry?${stringifiedParams}`
    : `/v1/instances/${instanceId}/files/entry`;
};

export const runtimeServiceGetFile = async (
  instanceId: string,
  params?: RuntimeServiceGetFileParams,
  options?: RequestInit,
): Promise<runtimeServiceGetFileResponse> => {
  return httpClient<runtimeServiceGetFileResponse>(
    getRuntimeServiceGetFileUrl(instanceId, params),
    {
      ...options,
      method: "GET",
    },
  );
};

export const getRuntimeServiceGetFileQueryKey = (
  instanceId: string,
  params?: RuntimeServiceGetFileParams,
) => {
  return [
    `/v1/instances/${instanceId}/files/entry`,
    ...(params ? [params] : []),
  ] as const;
};

export const getRuntimeServiceGetFileQueryOptions = <
  TData = Awaited<ReturnType<typeof runtimeServiceGetFile>>,
  TError = ErrorType<RpcStatus>,
>(
  instanceId: string,
  params?: RuntimeServiceGetFileParams,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof runtimeServiceGetFile>>,
        TError,
        TData
      >
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getRuntimeServiceGetFileQueryKey(instanceId, params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof runtimeServiceGetFile>>
  > = ({ signal }) => runtimeServiceGetFile(instanceId, params, { signal });

  return {
    queryKey,
    queryFn,
    enabled: !!instanceId,
    ...queryOptions,
  } as CreateQueryOptions<
    Awaited<ReturnType<typeof runtimeServiceGetFile>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type RuntimeServiceGetFileQueryResult = NonNullable<
  Awaited<ReturnType<typeof runtimeServiceGetFile>>
>;
export type RuntimeServiceGetFileQueryError = ErrorType<RpcStatus>;

/**
 * @summary GetFile returns the contents of a specific file in a repo.
 */

export function createRuntimeServiceGetFile<
  TData = Awaited<ReturnType<typeof runtimeServiceGetFile>>,
  TError = ErrorType<RpcStatus>,
>(
  instanceId: () => string,
  params?: () => RuntimeServiceGetFileParams,
  options?: () => {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof runtimeServiceGetFile>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: () => QueryClient,
): CreateQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const query = createQuery(
    () =>
      getRuntimeServiceGetFileQueryOptions(
        instanceId(),
        params?.(),
        options?.(),
      ),
    queryClient,
  ) as CreateQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  return query;
}

/**
 * @summary DeleteFile deletes a file from a repo
 */
export type runtimeServiceDeleteFileResponse200 = {
  data: V1DeleteFileResponse;
  status: 200;
};

export type runtimeServiceDeleteFileResponseDefault = {
  data: RpcStatus;
  status: Exclude<HTTPStatusCodes, 200>;
};

export type runtimeServiceDeleteFileResponseSuccess =
  runtimeServiceDeleteFileResponse200 & {
    headers: Headers;
  };
export type runtimeServiceDeleteFileResponseError =
  runtimeServiceDeleteFileResponseDefault & {
    headers: Headers;
  };

export type runtimeServiceDeleteFileResponse =
  | runtimeServiceDeleteFileResponseSuccess
  | runtimeServiceDeleteFileResponseError;

export const getRuntimeServiceDeleteFileUrl = (
  instanceId: string,
  params?: RuntimeServiceDeleteFileParams,
) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? "null" : value.toString());
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0
    ? `/v1/instances/${instanceId}/files/entry?${stringifiedParams}`
    : `/v1/instances/${instanceId}/files/entry`;
};

export const runtimeServiceDeleteFile = async (
  instanceId: string,
  params?: RuntimeServiceDeleteFileParams,
  options?: RequestInit,
): Promise<runtimeServiceDeleteFileResponse> => {
  return httpClient<runtimeServiceDeleteFileResponse>(
    getRuntimeServiceDeleteFileUrl(instanceId, params),
    {
      ...options,
      method: "DELETE",
    },
  );
};

export const getRuntimeServiceDeleteFileMutationOptions = <
  TError = ErrorType<RpcStatus>,
  TContext = unknown,
>(options?: {
  mutation?: CreateMutationOptions<
    Awaited<ReturnType<typeof runtimeServiceDeleteFile>>,
    TError,
    { instanceId: string; params?: RuntimeServiceDeleteFileParams },
    TContext
  >;
}): CreateMutationOptions<
  Awaited<ReturnType<typeof runtimeServiceDeleteFile>>,
  TError,
  { instanceId: string; params?: RuntimeServiceDeleteFileParams },
  TContext
> => {
  const mutationKey = ["runtimeServiceDeleteFile"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof runtimeServiceDeleteFile>>,
    { instanceId: string; params?: RuntimeServiceDeleteFileParams }
  > = (props) => {
    const { instanceId, params } = props ?? {};

    return runtimeServiceDeleteFile(instanceId, params);
  };

  return { mutationFn, ...mutationOptions };
};

export type RuntimeServiceDeleteFileMutationResult = NonNullable<
  Awaited<ReturnType<typeof runtimeServiceDeleteFile>>
>;

export type RuntimeServiceDeleteFileMutationError = ErrorType<RpcStatus>;

/**
 * @summary DeleteFile deletes a file from a repo
 */
export const createRuntimeServiceDeleteFile = <
  TError = ErrorType<RpcStatus>,
  TContext = unknown,
>(
  options?: () => {
    mutation?: CreateMutationOptions<
      Awaited<ReturnType<typeof runtimeServiceDeleteFile>>,
      TError,
      { instanceId: string; params?: RuntimeServiceDeleteFileParams },
      TContext
    >;
  },
  queryClient?: () => QueryClient,
): CreateMutationResult<
  Awaited<ReturnType<typeof runtimeServiceDeleteFile>>,
  TError,
  { instanceId: string; params?: RuntimeServiceDeleteFileParams },
  TContext
> => {
  return createMutation(
    () => ({ ...getRuntimeServiceDeleteFileMutationOptions(options?.()) }),
    queryClient,
  );
};
/**
 * @summary PutFile creates or updates a file in a repo
 */
export type runtimeServicePutFileResponse200 = {
  data: V1PutFileResponse;
  status: 200;
};

export type runtimeServicePutFileResponseDefault = {
  data: RpcStatus;
  status: Exclude<HTTPStatusCodes, 200>;
};

export type runtimeServicePutFileResponseSuccess =
  runtimeServicePutFileResponse200 & {
    headers: Headers;
  };
export type runtimeServicePutFileResponseError =
  runtimeServicePutFileResponseDefault & {
    headers: Headers;
  };

export type runtimeServicePutFileResponse =
  | runtimeServicePutFileResponseSuccess
  | runtimeServicePutFileResponseError;

export const getRuntimeServicePutFileUrl = (instanceId: string) => {
  return `/v1/instances/${instanceId}/files/entry`;
};

export const runtimeServicePutFile = async (
  instanceId: string,
  runtimeServicePutFileBody: RuntimeServicePutFileBody,
  options?: RequestInit,
): Promise<runtimeServicePutFileResponse> => {
  return httpClient<runtimeServicePutFileResponse>(
    getRuntimeServicePutFileUrl(instanceId),
    {
      ...options,
      method: "POST",
      headers: { "Content-Type": "application/json", ...options?.headers },
      body: JSON.stringify(runtimeServicePutFileBody),
    },
  );
};

export const getRuntimeServicePutFileMutationOptions = <
  TError = ErrorType<RpcStatus>,
  TContext = unknown,
>(options?: {
  mutation?: CreateMutationOptions<
    Awaited<ReturnType<typeof runtimeServicePutFile>>,
    TError,
    { instanceId: string; data: RuntimeServicePutFileBody },
    TContext
  >;
}): CreateMutationOptions<
  Awaited<ReturnType<typeof runtimeServicePutFile>>,
  TError,
  { instanceId: string; data: RuntimeServicePutFileBody },
  TContext
> => {
  const mutationKey = ["runtimeServicePutFile"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof runtimeServicePutFile>>,
    { instanceId: string; data: RuntimeServicePutFileBody }
  > = (props) => {
    const { instanceId, data } = props ?? {};

    return runtimeServicePutFile(instanceId, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type RuntimeServicePutFileMutationResult = NonNullable<
  Awaited<ReturnType<typeof runtimeServicePutFile>>
>;
export type RuntimeServicePutFileMutationBody = RuntimeServicePutFileBody;
export type RuntimeServicePutFileMutationError = ErrorType<RpcStatus>;

/**
 * @summary PutFile creates or updates a file in a repo
 */
export const createRuntimeServicePutFile = <
  TError = ErrorType<RpcStatus>,
  TContext = unknown,
>(
  options?: () => {
    mutation?: CreateMutationOptions<
      Awaited<ReturnType<typeof runtimeServicePutFile>>,
      TError,
      { instanceId: string; data: RuntimeServicePutFileBody },
      TContext
    >;
  },
  queryClient?: () => QueryClient,
): CreateMutationResult<
  Awaited<ReturnType<typeof runtimeServicePutFile>>,
  TError,
  { instanceId: string; data: RuntimeServicePutFileBody },
  TContext
> => {
  return createMutation(
    () => ({ ...getRuntimeServicePutFileMutationOptions(options?.()) }),
    queryClient,
  );
};
/**
 * @summary GenerateCanvasFile generates a canvas YAML file from a metrics view
 */
export type runtimeServiceGenerateCanvasFileResponse200 = {
  data: V1GenerateCanvasFileResponse;
  status: 200;
};

export type runtimeServiceGenerateCanvasFileResponseDefault = {
  data: RpcStatus;
  status: Exclude<HTTPStatusCodes, 200>;
};

export type runtimeServiceGenerateCanvasFileResponseSuccess =
  runtimeServiceGenerateCanvasFileResponse200 & {
    headers: Headers;
  };
export type runtimeServiceGenerateCanvasFileResponseError =
  runtimeServiceGenerateCanvasFileResponseDefault & {
    headers: Headers;
  };

export type runtimeServiceGenerateCanvasFileResponse =
  | runtimeServiceGenerateCanvasFileResponseSuccess
  | runtimeServiceGenerateCanvasFileResponseError;

export const getRuntimeServiceGenerateCanvasFileUrl = (instanceId: string) => {
  return `/v1/instances/${instanceId}/files/generate-canvas`;
};

export const runtimeServiceGenerateCanvasFile = async (
  instanceId: string,
  runtimeServiceGenerateCanvasFileBody: RuntimeServiceGenerateCanvasFileBody,
  options?: RequestInit,
): Promise<runtimeServiceGenerateCanvasFileResponse> => {
  return httpClient<runtimeServiceGenerateCanvasFileResponse>(
    getRuntimeServiceGenerateCanvasFileUrl(instanceId),
    {
      ...options,
      method: "POST",
      headers: { "Content-Type": "application/json", ...options?.headers },
      body: JSON.stringify(runtimeServiceGenerateCanvasFileBody),
    },
  );
};

export const getRuntimeServiceGenerateCanvasFileMutationOptions = <
  TError = ErrorType<RpcStatus>,
  TContext = unknown,
>(options?: {
  mutation?: CreateMutationOptions<
    Awaited<ReturnType<typeof runtimeServiceGenerateCanvasFile>>,
    TError,
    { instanceId: string; data: RuntimeServiceGenerateCanvasFileBody },
    TContext
  >;
}): CreateMutationOptions<
  Awaited<ReturnType<typeof runtimeServiceGenerateCanvasFile>>,
  TError,
  { instanceId: string; data: RuntimeServiceGenerateCanvasFileBody },
  TContext
> => {
  const mutationKey = ["runtimeServiceGenerateCanvasFile"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof runtimeServiceGenerateCanvasFile>>,
    { instanceId: string; data: RuntimeServiceGenerateCanvasFileBody }
  > = (props) => {
    const { instanceId, data } = props ?? {};

    return runtimeServiceGenerateCanvasFile(instanceId, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type RuntimeServiceGenerateCanvasFileMutationResult = NonNullable<
  Awaited<ReturnType<typeof runtimeServiceGenerateCanvasFile>>
>;
export type RuntimeServiceGenerateCanvasFileMutationBody =
  RuntimeServiceGenerateCanvasFileBody;
export type RuntimeServiceGenerateCanvasFileMutationError =
  ErrorType<RpcStatus>;

/**
 * @summary GenerateCanvasFile generates a canvas YAML file from a metrics view
 */
export const createRuntimeServiceGenerateCanvasFile = <
  TError = ErrorType<RpcStatus>,
  TContext = unknown,
>(
  options?: () => {
    mutation?: CreateMutationOptions<
      Awaited<ReturnType<typeof runtimeServiceGenerateCanvasFile>>,
      TError,
      { instanceId: string; data: RuntimeServiceGenerateCanvasFileBody },
      TContext
    >;
  },
  queryClient?: () => QueryClient,
): CreateMutationResult<
  Awaited<ReturnType<typeof runtimeServiceGenerateCanvasFile>>,
  TError,
  { instanceId: string; data: RuntimeServiceGenerateCanvasFileBody },
  TContext
> => {
  return createMutation(
    () => ({
      ...getRuntimeServiceGenerateCanvasFileMutationOptions(options?.()),
    }),
    queryClient,
  );
};
/**
 * @summary GenerateMetricsViewFile generates a metrics view YAML file from a table in an OLAP database
 */
export type runtimeServiceGenerateMetricsViewFileResponse200 = {
  data: V1GenerateMetricsViewFileResponse;
  status: 200;
};

export type runtimeServiceGenerateMetricsViewFileResponseDefault = {
  data: RpcStatus;
  status: Exclude<HTTPStatusCodes, 200>;
};

export type runtimeServiceGenerateMetricsViewFileResponseSuccess =
  runtimeServiceGenerateMetricsViewFileResponse200 & {
    headers: Headers;
  };
export type runtimeServiceGenerateMetricsViewFileResponseError =
  runtimeServiceGenerateMetricsViewFileResponseDefault & {
    headers: Headers;
  };

export type runtimeServiceGenerateMetricsViewFileResponse =
  | runtimeServiceGenerateMetricsViewFileResponseSuccess
  | runtimeServiceGenerateMetricsViewFileResponseError;

export const getRuntimeServiceGenerateMetricsViewFileUrl = (
  instanceId: string,
) => {
  return `/v1/instances/${instanceId}/files/generate-metrics-view`;
};

export const runtimeServiceGenerateMetricsViewFile = async (
  instanceId: string,
  runtimeServiceGenerateMetricsViewFileBody: RuntimeServiceGenerateMetricsViewFileBody,
  options?: RequestInit,
): Promise<runtimeServiceGenerateMetricsViewFileResponse> => {
  return httpClient<runtimeServiceGenerateMetricsViewFileResponse>(
    getRuntimeServiceGenerateMetricsViewFileUrl(instanceId),
    {
      ...options,
      method: "POST",
      headers: { "Content-Type": "application/json", ...options?.headers },
      body: JSON.stringify(runtimeServiceGenerateMetricsViewFileBody),
    },
  );
};

export const getRuntimeServiceGenerateMetricsViewFileMutationOptions = <
  TError = ErrorType<RpcStatus>,
  TContext = unknown,
>(options?: {
  mutation?: CreateMutationOptions<
    Awaited<ReturnType<typeof runtimeServiceGenerateMetricsViewFile>>,
    TError,
    { instanceId: string; data: RuntimeServiceGenerateMetricsViewFileBody },
    TContext
  >;
}): CreateMutationOptions<
  Awaited<ReturnType<typeof runtimeServiceGenerateMetricsViewFile>>,
  TError,
  { instanceId: string; data: RuntimeServiceGenerateMetricsViewFileBody },
  TContext
> => {
  const mutationKey = ["runtimeServiceGenerateMetricsViewFile"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof runtimeServiceGenerateMetricsViewFile>>,
    { instanceId: string; data: RuntimeServiceGenerateMetricsViewFileBody }
  > = (props) => {
    const { instanceId, data } = props ?? {};

    return runtimeServiceGenerateMetricsViewFile(instanceId, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type RuntimeServiceGenerateMetricsViewFileMutationResult = NonNullable<
  Awaited<ReturnType<typeof runtimeServiceGenerateMetricsViewFile>>
>;
export type RuntimeServiceGenerateMetricsViewFileMutationBody =
  RuntimeServiceGenerateMetricsViewFileBody;
export type RuntimeServiceGenerateMetricsViewFileMutationError =
  ErrorType<RpcStatus>;

/**
 * @summary GenerateMetricsViewFile generates a metrics view YAML file from a table in an OLAP database
 */
export const createRuntimeServiceGenerateMetricsViewFile = <
  TError = ErrorType<RpcStatus>,
  TContext = unknown,
>(
  options?: () => {
    mutation?: CreateMutationOptions<
      Awaited<ReturnType<typeof runtimeServiceGenerateMetricsViewFile>>,
      TError,
      { instanceId: string; data: RuntimeServiceGenerateMetricsViewFileBody },
      TContext
    >;
  },
  queryClient?: () => QueryClient,
): CreateMutationResult<
  Awaited<ReturnType<typeof runtimeServiceGenerateMetricsViewFile>>,
  TError,
  { instanceId: string; data: RuntimeServiceGenerateMetricsViewFileBody },
  TContext
> => {
  return createMutation(
    () => ({
      ...getRuntimeServiceGenerateMetricsViewFileMutationOptions(options?.()),
    }),
    queryClient,
  );
};
/**
 * @summary RenameFile renames a file in a repo
 */
export type runtimeServiceRenameFileResponse200 = {
  data: V1RenameFileResponse;
  status: 200;
};

export type runtimeServiceRenameFileResponseDefault = {
  data: RpcStatus;
  status: Exclude<HTTPStatusCodes, 200>;
};

export type runtimeServiceRenameFileResponseSuccess =
  runtimeServiceRenameFileResponse200 & {
    headers: Headers;
  };
export type runtimeServiceRenameFileResponseError =
  runtimeServiceRenameFileResponseDefault & {
    headers: Headers;
  };

export type runtimeServiceRenameFileResponse =
  | runtimeServiceRenameFileResponseSuccess
  | runtimeServiceRenameFileResponseError;

export const getRuntimeServiceRenameFileUrl = (instanceId: string) => {
  return `/v1/instances/${instanceId}/files/rename`;
};

export const runtimeServiceRenameFile = async (
  instanceId: string,
  runtimeServiceRenameFileBody: RuntimeServiceRenameFileBody,
  options?: RequestInit,
): Promise<runtimeServiceRenameFileResponse> => {
  return httpClient<runtimeServiceRenameFileResponse>(
    getRuntimeServiceRenameFileUrl(instanceId),
    {
      ...options,
      method: "POST",
      headers: { "Content-Type": "application/json", ...options?.headers },
      body: JSON.stringify(runtimeServiceRenameFileBody),
    },
  );
};

export const getRuntimeServiceRenameFileMutationOptions = <
  TError = ErrorType<RpcStatus>,
  TContext = unknown,
>(options?: {
  mutation?: CreateMutationOptions<
    Awaited<ReturnType<typeof runtimeServiceRenameFile>>,
    TError,
    { instanceId: string; data: RuntimeServiceRenameFileBody },
    TContext
  >;
}): CreateMutationOptions<
  Awaited<ReturnType<typeof runtimeServiceRenameFile>>,
  TError,
  { instanceId: string; data: RuntimeServiceRenameFileBody },
  TContext
> => {
  const mutationKey = ["runtimeServiceRenameFile"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof runtimeServiceRenameFile>>,
    { instanceId: string; data: RuntimeServiceRenameFileBody }
  > = (props) => {
    const { instanceId, data } = props ?? {};

    return runtimeServiceRenameFile(instanceId, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type RuntimeServiceRenameFileMutationResult = NonNullable<
  Awaited<ReturnType<typeof runtimeServiceRenameFile>>
>;
export type RuntimeServiceRenameFileMutationBody = RuntimeServiceRenameFileBody;
export type RuntimeServiceRenameFileMutationError = ErrorType<RpcStatus>;

/**
 * @summary RenameFile renames a file in a repo
 */
export const createRuntimeServiceRenameFile = <
  TError = ErrorType<RpcStatus>,
  TContext = unknown,
>(
  options?: () => {
    mutation?: CreateMutationOptions<
      Awaited<ReturnType<typeof runtimeServiceRenameFile>>,
      TError,
      { instanceId: string; data: RuntimeServiceRenameFileBody },
      TContext
    >;
  },
  queryClient?: () => QueryClient,
): CreateMutationResult<
  Awaited<ReturnType<typeof runtimeServiceRenameFile>>,
  TError,
  { instanceId: string; data: RuntimeServiceRenameFileBody },
  TContext
> => {
  return createMutation(
    () => ({ ...getRuntimeServiceRenameFileMutationOptions(options?.()) }),
    queryClient,
  );
};
/**
 * @summary UnpackEmpty unpacks an empty project
 */
export type runtimeServiceUnpackEmptyResponse200 = {
  data: V1UnpackEmptyResponse;
  status: 200;
};

export type runtimeServiceUnpackEmptyResponseDefault = {
  data: RpcStatus;
  status: Exclude<HTTPStatusCodes, 200>;
};

export type runtimeServiceUnpackEmptyResponseSuccess =
  runtimeServiceUnpackEmptyResponse200 & {
    headers: Headers;
  };
export type runtimeServiceUnpackEmptyResponseError =
  runtimeServiceUnpackEmptyResponseDefault & {
    headers: Headers;
  };

export type runtimeServiceUnpackEmptyResponse =
  | runtimeServiceUnpackEmptyResponseSuccess
  | runtimeServiceUnpackEmptyResponseError;

export const getRuntimeServiceUnpackEmptyUrl = (instanceId: string) => {
  return `/v1/instances/${instanceId}/files/unpack-empty`;
};

export const runtimeServiceUnpackEmpty = async (
  instanceId: string,
  runtimeServiceUnpackEmptyBody: RuntimeServiceUnpackEmptyBody,
  options?: RequestInit,
): Promise<runtimeServiceUnpackEmptyResponse> => {
  return httpClient<runtimeServiceUnpackEmptyResponse>(
    getRuntimeServiceUnpackEmptyUrl(instanceId),
    {
      ...options,
      method: "POST",
      headers: { "Content-Type": "application/json", ...options?.headers },
      body: JSON.stringify(runtimeServiceUnpackEmptyBody),
    },
  );
};

export const getRuntimeServiceUnpackEmptyMutationOptions = <
  TError = ErrorType<RpcStatus>,
  TContext = unknown,
>(options?: {
  mutation?: CreateMutationOptions<
    Awaited<ReturnType<typeof runtimeServiceUnpackEmpty>>,
    TError,
    { instanceId: string; data: RuntimeServiceUnpackEmptyBody },
    TContext
  >;
}): CreateMutationOptions<
  Awaited<ReturnType<typeof runtimeServiceUnpackEmpty>>,
  TError,
  { instanceId: string; data: RuntimeServiceUnpackEmptyBody },
  TContext
> => {
  const mutationKey = ["runtimeServiceUnpackEmpty"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof runtimeServiceUnpackEmpty>>,
    { instanceId: string; data: RuntimeServiceUnpackEmptyBody }
  > = (props) => {
    const { instanceId, data } = props ?? {};

    return runtimeServiceUnpackEmpty(instanceId, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type RuntimeServiceUnpackEmptyMutationResult = NonNullable<
  Awaited<ReturnType<typeof runtimeServiceUnpackEmpty>>
>;
export type RuntimeServiceUnpackEmptyMutationBody =
  RuntimeServiceUnpackEmptyBody;
export type RuntimeServiceUnpackEmptyMutationError = ErrorType<RpcStatus>;

/**
 * @summary UnpackEmpty unpacks an empty project
 */
export const createRuntimeServiceUnpackEmpty = <
  TError = ErrorType<RpcStatus>,
  TContext = unknown,
>(
  options?: () => {
    mutation?: CreateMutationOptions<
      Awaited<ReturnType<typeof runtimeServiceUnpackEmpty>>,
      TError,
      { instanceId: string; data: RuntimeServiceUnpackEmptyBody },
      TContext
    >;
  },
  queryClient?: () => QueryClient,
): CreateMutationResult<
  Awaited<ReturnType<typeof runtimeServiceUnpackEmpty>>,
  TError,
  { instanceId: string; data: RuntimeServiceUnpackEmptyBody },
  TContext
> => {
  return createMutation(
    () => ({ ...getRuntimeServiceUnpackEmptyMutationOptions(options?.()) }),
    queryClient,
  );
};
/**
 * @summary UnpackExample unpacks an example project
 */
export type runtimeServiceUnpackExampleResponse200 = {
  data: V1UnpackExampleResponse;
  status: 200;
};

export type runtimeServiceUnpackExampleResponseDefault = {
  data: RpcStatus;
  status: Exclude<HTTPStatusCodes, 200>;
};

export type runtimeServiceUnpackExampleResponseSuccess =
  runtimeServiceUnpackExampleResponse200 & {
    headers: Headers;
  };
export type runtimeServiceUnpackExampleResponseError =
  runtimeServiceUnpackExampleResponseDefault & {
    headers: Headers;
  };

export type runtimeServiceUnpackExampleResponse =
  | runtimeServiceUnpackExampleResponseSuccess
  | runtimeServiceUnpackExampleResponseError;

export const getRuntimeServiceUnpackExampleUrl = (instanceId: string) => {
  return `/v1/instances/${instanceId}/files/unpack-example`;
};

export const runtimeServiceUnpackExample = async (
  instanceId: string,
  runtimeServiceUnpackExampleBody: RuntimeServiceUnpackExampleBody,
  options?: RequestInit,
): Promise<runtimeServiceUnpackExampleResponse> => {
  return httpClient<runtimeServiceUnpackExampleResponse>(
    getRuntimeServiceUnpackExampleUrl(instanceId),
    {
      ...options,
      method: "POST",
      headers: { "Content-Type": "application/json", ...options?.headers },
      body: JSON.stringify(runtimeServiceUnpackExampleBody),
    },
  );
};

export const getRuntimeServiceUnpackExampleMutationOptions = <
  TError = ErrorType<RpcStatus>,
  TContext = unknown,
>(options?: {
  mutation?: CreateMutationOptions<
    Awaited<ReturnType<typeof runtimeServiceUnpackExample>>,
    TError,
    { instanceId: string; data: RuntimeServiceUnpackExampleBody },
    TContext
  >;
}): CreateMutationOptions<
  Awaited<ReturnType<typeof runtimeServiceUnpackExample>>,
  TError,
  { instanceId: string; data: RuntimeServiceUnpackExampleBody },
  TContext
> => {
  const mutationKey = ["runtimeServiceUnpackExample"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof runtimeServiceUnpackExample>>,
    { instanceId: string; data: RuntimeServiceUnpackExampleBody }
  > = (props) => {
    const { instanceId, data } = props ?? {};

    return runtimeServiceUnpackExample(instanceId, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type RuntimeServiceUnpackExampleMutationResult = NonNullable<
  Awaited<ReturnType<typeof runtimeServiceUnpackExample>>
>;
export type RuntimeServiceUnpackExampleMutationBody =
  RuntimeServiceUnpackExampleBody;
export type RuntimeServiceUnpackExampleMutationError = ErrorType<RpcStatus>;

/**
 * @summary UnpackExample unpacks an example project
 */
export const createRuntimeServiceUnpackExample = <
  TError = ErrorType<RpcStatus>,
  TContext = unknown,
>(
  options?: () => {
    mutation?: CreateMutationOptions<
      Awaited<ReturnType<typeof runtimeServiceUnpackExample>>,
      TError,
      { instanceId: string; data: RuntimeServiceUnpackExampleBody },
      TContext
    >;
  },
  queryClient?: () => QueryClient,
): CreateMutationResult<
  Awaited<ReturnType<typeof runtimeServiceUnpackExample>>,
  TError,
  { instanceId: string; data: RuntimeServiceUnpackExampleBody },
  TContext
> => {
  return createMutation(
    () => ({ ...getRuntimeServiceUnpackExampleMutationOptions(options?.()) }),
    queryClient,
  );
};
/**
 * @summary WatchFiles streams repo file update events. It is not supported on all backends.
 */
export type runtimeServiceWatchFilesResponse200 = {
  data: RuntimeServiceWatchFiles200;
  status: 200;
};

export type runtimeServiceWatchFilesResponseDefault = {
  data: RpcStatus;
  status: Exclude<HTTPStatusCodes, 200>;
};

export type runtimeServiceWatchFilesResponseSuccess =
  runtimeServiceWatchFilesResponse200 & {
    headers: Headers;
  };
export type runtimeServiceWatchFilesResponseError =
  runtimeServiceWatchFilesResponseDefault & {
    headers: Headers;
  };

export type runtimeServiceWatchFilesResponse =
  | runtimeServiceWatchFilesResponseSuccess
  | runtimeServiceWatchFilesResponseError;

export const getRuntimeServiceWatchFilesUrl = (
  instanceId: string,
  params?: RuntimeServiceWatchFilesParams,
) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? "null" : value.toString());
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0
    ? `/v1/instances/${instanceId}/files/watch?${stringifiedParams}`
    : `/v1/instances/${instanceId}/files/watch`;
};

export const runtimeServiceWatchFiles = async (
  instanceId: string,
  params?: RuntimeServiceWatchFilesParams,
  options?: RequestInit,
): Promise<runtimeServiceWatchFilesResponse> => {
  return httpClient<runtimeServiceWatchFilesResponse>(
    getRuntimeServiceWatchFilesUrl(instanceId, params),
    {
      ...options,
      method: "GET",
    },
  );
};

export const getRuntimeServiceWatchFilesQueryKey = (
  instanceId: string,
  params?: RuntimeServiceWatchFilesParams,
) => {
  return [
    `/v1/instances/${instanceId}/files/watch`,
    ...(params ? [params] : []),
  ] as const;
};

export const getRuntimeServiceWatchFilesQueryOptions = <
  TData = Awaited<ReturnType<typeof runtimeServiceWatchFiles>>,
  TError = ErrorType<RpcStatus>,
>(
  instanceId: string,
  params?: RuntimeServiceWatchFilesParams,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof runtimeServiceWatchFiles>>,
        TError,
        TData
      >
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getRuntimeServiceWatchFilesQueryKey(instanceId, params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof runtimeServiceWatchFiles>>
  > = ({ signal }) => runtimeServiceWatchFiles(instanceId, params, { signal });

  return {
    queryKey,
    queryFn,
    enabled: !!instanceId,
    ...queryOptions,
  } as CreateQueryOptions<
    Awaited<ReturnType<typeof runtimeServiceWatchFiles>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type RuntimeServiceWatchFilesQueryResult = NonNullable<
  Awaited<ReturnType<typeof runtimeServiceWatchFiles>>
>;
export type RuntimeServiceWatchFilesQueryError = ErrorType<RpcStatus>;

/**
 * @summary WatchFiles streams repo file update events. It is not supported on all backends.
 */

export function createRuntimeServiceWatchFiles<
  TData = Awaited<ReturnType<typeof runtimeServiceWatchFiles>>,
  TError = ErrorType<RpcStatus>,
>(
  instanceId: () => string,
  params?: () => RuntimeServiceWatchFilesParams,
  options?: () => {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof runtimeServiceWatchFiles>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: () => QueryClient,
): CreateQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const query = createQuery(
    () =>
      getRuntimeServiceWatchFilesQueryOptions(
        instanceId(),
        params?.(),
        options?.(),
      ),
    queryClient,
  ) as CreateQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  return query;
}

/**
 * @summary GenerateRenderer generates a component renderer and renderer properties from a resolver and resolver properties
 */
export type runtimeServiceGenerateRendererResponse200 = {
  data: V1GenerateRendererResponse;
  status: 200;
};

export type runtimeServiceGenerateRendererResponseDefault = {
  data: RpcStatus;
  status: Exclude<HTTPStatusCodes, 200>;
};

export type runtimeServiceGenerateRendererResponseSuccess =
  runtimeServiceGenerateRendererResponse200 & {
    headers: Headers;
  };
export type runtimeServiceGenerateRendererResponseError =
  runtimeServiceGenerateRendererResponseDefault & {
    headers: Headers;
  };

export type runtimeServiceGenerateRendererResponse =
  | runtimeServiceGenerateRendererResponseSuccess
  | runtimeServiceGenerateRendererResponseError;

export const getRuntimeServiceGenerateRendererUrl = (instanceId: string) => {
  return `/v1/instances/${instanceId}/generate/renderer`;
};

export const runtimeServiceGenerateRenderer = async (
  instanceId: string,
  runtimeServiceGenerateRendererBody: RuntimeServiceGenerateRendererBody,
  options?: RequestInit,
): Promise<runtimeServiceGenerateRendererResponse> => {
  return httpClient<runtimeServiceGenerateRendererResponse>(
    getRuntimeServiceGenerateRendererUrl(instanceId),
    {
      ...options,
      method: "POST",
      headers: { "Content-Type": "application/json", ...options?.headers },
      body: JSON.stringify(runtimeServiceGenerateRendererBody),
    },
  );
};

export const getRuntimeServiceGenerateRendererMutationOptions = <
  TError = ErrorType<RpcStatus>,
  TContext = unknown,
>(options?: {
  mutation?: CreateMutationOptions<
    Awaited<ReturnType<typeof runtimeServiceGenerateRenderer>>,
    TError,
    { instanceId: string; data: RuntimeServiceGenerateRendererBody },
    TContext
  >;
}): CreateMutationOptions<
  Awaited<ReturnType<typeof runtimeServiceGenerateRenderer>>,
  TError,
  { instanceId: string; data: RuntimeServiceGenerateRendererBody },
  TContext
> => {
  const mutationKey = ["runtimeServiceGenerateRenderer"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof runtimeServiceGenerateRenderer>>,
    { instanceId: string; data: RuntimeServiceGenerateRendererBody }
  > = (props) => {
    const { instanceId, data } = props ?? {};

    return runtimeServiceGenerateRenderer(instanceId, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type RuntimeServiceGenerateRendererMutationResult = NonNullable<
  Awaited<ReturnType<typeof runtimeServiceGenerateRenderer>>
>;
export type RuntimeServiceGenerateRendererMutationBody =
  RuntimeServiceGenerateRendererBody;
export type RuntimeServiceGenerateRendererMutationError = ErrorType<RpcStatus>;

/**
 * @summary GenerateRenderer generates a component renderer and renderer properties from a resolver and resolver properties
 */
export const createRuntimeServiceGenerateRenderer = <
  TError = ErrorType<RpcStatus>,
  TContext = unknown,
>(
  options?: () => {
    mutation?: CreateMutationOptions<
      Awaited<ReturnType<typeof runtimeServiceGenerateRenderer>>,
      TError,
      { instanceId: string; data: RuntimeServiceGenerateRendererBody },
      TContext
    >;
  },
  queryClient?: () => QueryClient,
): CreateMutationResult<
  Awaited<ReturnType<typeof runtimeServiceGenerateRenderer>>,
  TError,
  { instanceId: string; data: RuntimeServiceGenerateRendererBody },
  TContext
> => {
  return createMutation(
    () => ({
      ...getRuntimeServiceGenerateRendererMutationOptions(options?.()),
    }),
    queryClient,
  );
};
/**
 * @summary GenerateResolver generates resolver and resolver properties from a table or a metrics view
 */
export type runtimeServiceGenerateResolverResponse200 = {
  data: V1GenerateResolverResponse;
  status: 200;
};

export type runtimeServiceGenerateResolverResponseDefault = {
  data: RpcStatus;
  status: Exclude<HTTPStatusCodes, 200>;
};

export type runtimeServiceGenerateResolverResponseSuccess =
  runtimeServiceGenerateResolverResponse200 & {
    headers: Headers;
  };
export type runtimeServiceGenerateResolverResponseError =
  runtimeServiceGenerateResolverResponseDefault & {
    headers: Headers;
  };

export type runtimeServiceGenerateResolverResponse =
  | runtimeServiceGenerateResolverResponseSuccess
  | runtimeServiceGenerateResolverResponseError;

export const getRuntimeServiceGenerateResolverUrl = (instanceId: string) => {
  return `/v1/instances/${instanceId}/generate/resolver`;
};

export const runtimeServiceGenerateResolver = async (
  instanceId: string,
  runtimeServiceGenerateResolverBody: RuntimeServiceGenerateResolverBody,
  options?: RequestInit,
): Promise<runtimeServiceGenerateResolverResponse> => {
  return httpClient<runtimeServiceGenerateResolverResponse>(
    getRuntimeServiceGenerateResolverUrl(instanceId),
    {
      ...options,
      method: "POST",
      headers: { "Content-Type": "application/json", ...options?.headers },
      body: JSON.stringify(runtimeServiceGenerateResolverBody),
    },
  );
};

export const getRuntimeServiceGenerateResolverMutationOptions = <
  TError = ErrorType<RpcStatus>,
  TContext = unknown,
>(options?: {
  mutation?: CreateMutationOptions<
    Awaited<ReturnType<typeof runtimeServiceGenerateResolver>>,
    TError,
    { instanceId: string; data: RuntimeServiceGenerateResolverBody },
    TContext
  >;
}): CreateMutationOptions<
  Awaited<ReturnType<typeof runtimeServiceGenerateResolver>>,
  TError,
  { instanceId: string; data: RuntimeServiceGenerateResolverBody },
  TContext
> => {
  const mutationKey = ["runtimeServiceGenerateResolver"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof runtimeServiceGenerateResolver>>,
    { instanceId: string; data: RuntimeServiceGenerateResolverBody }
  > = (props) => {
    const { instanceId, data } = props ?? {};

    return runtimeServiceGenerateResolver(instanceId, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type RuntimeServiceGenerateResolverMutationResult = NonNullable<
  Awaited<ReturnType<typeof runtimeServiceGenerateResolver>>
>;
export type RuntimeServiceGenerateResolverMutationBody =
  RuntimeServiceGenerateResolverBody;
export type RuntimeServiceGenerateResolverMutationError = ErrorType<RpcStatus>;

/**
 * @summary GenerateResolver generates resolver and resolver properties from a table or a metrics view
 */
export const createRuntimeServiceGenerateResolver = <
  TError = ErrorType<RpcStatus>,
  TContext = unknown,
>(
  options?: () => {
    mutation?: CreateMutationOptions<
      Awaited<ReturnType<typeof runtimeServiceGenerateResolver>>,
      TError,
      { instanceId: string; data: RuntimeServiceGenerateResolverBody },
      TContext
    >;
  },
  queryClient?: () => QueryClient,
): CreateMutationResult<
  Awaited<ReturnType<typeof runtimeServiceGenerateResolver>>,
  TError,
  { instanceId: string; data: RuntimeServiceGenerateResolverBody },
  TContext
> => {
  return createMutation(
    () => ({
      ...getRuntimeServiceGenerateResolverMutationOptions(options?.()),
    }),
    queryClient,
  );
};
export type runtimeServiceListGitBranchesResponse200 = {
  data: V1ListGitBranchesResponse;
  status: 200;
};

export type runtimeServiceListGitBranchesResponseDefault = {
  data: RpcStatus;
  status: Exclude<HTTPStatusCodes, 200>;
};

export type runtimeServiceListGitBranchesResponseSuccess =
  runtimeServiceListGitBranchesResponse200 & {
    headers: Headers;
  };
export type runtimeServiceListGitBranchesResponseError =
  runtimeServiceListGitBranchesResponseDefault & {
    headers: Headers;
  };

export type runtimeServiceListGitBranchesResponse =
  | runtimeServiceListGitBranchesResponseSuccess
  | runtimeServiceListGitBranchesResponseError;

export const getRuntimeServiceListGitBranchesUrl = (instanceId: string) => {
  return `/v1/instances/${instanceId}/git/branches`;
};

export const runtimeServiceListGitBranches = async (
  instanceId: string,
  options?: RequestInit,
): Promise<runtimeServiceListGitBranchesResponse> => {
  return httpClient<runtimeServiceListGitBranchesResponse>(
    getRuntimeServiceListGitBranchesUrl(instanceId),
    {
      ...options,
      method: "GET",
    },
  );
};

export const getRuntimeServiceListGitBranchesQueryKey = (
  instanceId: string,
) => {
  return [`/v1/instances/${instanceId}/git/branches`] as const;
};

export const getRuntimeServiceListGitBranchesQueryOptions = <
  TData = Awaited<ReturnType<typeof runtimeServiceListGitBranches>>,
  TError = ErrorType<RpcStatus>,
>(
  instanceId: string,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof runtimeServiceListGitBranches>>,
        TError,
        TData
      >
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getRuntimeServiceListGitBranchesQueryKey(instanceId);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof runtimeServiceListGitBranches>>
  > = ({ signal }) => runtimeServiceListGitBranches(instanceId, { signal });

  return {
    queryKey,
    queryFn,
    enabled: !!instanceId,
    ...queryOptions,
  } as CreateQueryOptions<
    Awaited<ReturnType<typeof runtimeServiceListGitBranches>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type RuntimeServiceListGitBranchesQueryResult = NonNullable<
  Awaited<ReturnType<typeof runtimeServiceListGitBranches>>
>;
export type RuntimeServiceListGitBranchesQueryError = ErrorType<RpcStatus>;

export function createRuntimeServiceListGitBranches<
  TData = Awaited<ReturnType<typeof runtimeServiceListGitBranches>>,
  TError = ErrorType<RpcStatus>,
>(
  instanceId: () => string,
  options?: () => {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof runtimeServiceListGitBranches>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: () => QueryClient,
): CreateQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const query = createQuery(
    () =>
      getRuntimeServiceListGitBranchesQueryOptions(instanceId(), options?.()),
    queryClient,
  ) as CreateQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  return query;
}

export type runtimeServiceGitSwitchBranchResponse200 = {
  data: V1GitSwitchBranchResponse;
  status: 200;
};

export type runtimeServiceGitSwitchBranchResponseDefault = {
  data: RpcStatus;
  status: Exclude<HTTPStatusCodes, 200>;
};

export type runtimeServiceGitSwitchBranchResponseSuccess =
  runtimeServiceGitSwitchBranchResponse200 & {
    headers: Headers;
  };
export type runtimeServiceGitSwitchBranchResponseError =
  runtimeServiceGitSwitchBranchResponseDefault & {
    headers: Headers;
  };

export type runtimeServiceGitSwitchBranchResponse =
  | runtimeServiceGitSwitchBranchResponseSuccess
  | runtimeServiceGitSwitchBranchResponseError;

export const getRuntimeServiceGitSwitchBranchUrl = (instanceId: string) => {
  return `/v1/instances/${instanceId}/git/branches/switch`;
};

export const runtimeServiceGitSwitchBranch = async (
  instanceId: string,
  runtimeServiceGitSwitchBranchBody: RuntimeServiceGitSwitchBranchBody,
  options?: RequestInit,
): Promise<runtimeServiceGitSwitchBranchResponse> => {
  return httpClient<runtimeServiceGitSwitchBranchResponse>(
    getRuntimeServiceGitSwitchBranchUrl(instanceId),
    {
      ...options,
      method: "POST",
      headers: { "Content-Type": "application/json", ...options?.headers },
      body: JSON.stringify(runtimeServiceGitSwitchBranchBody),
    },
  );
};

export const getRuntimeServiceGitSwitchBranchMutationOptions = <
  TError = ErrorType<RpcStatus>,
  TContext = unknown,
>(options?: {
  mutation?: CreateMutationOptions<
    Awaited<ReturnType<typeof runtimeServiceGitSwitchBranch>>,
    TError,
    { instanceId: string; data: RuntimeServiceGitSwitchBranchBody },
    TContext
  >;
}): CreateMutationOptions<
  Awaited<ReturnType<typeof runtimeServiceGitSwitchBranch>>,
  TError,
  { instanceId: string; data: RuntimeServiceGitSwitchBranchBody },
  TContext
> => {
  const mutationKey = ["runtimeServiceGitSwitchBranch"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof runtimeServiceGitSwitchBranch>>,
    { instanceId: string; data: RuntimeServiceGitSwitchBranchBody }
  > = (props) => {
    const { instanceId, data } = props ?? {};

    return runtimeServiceGitSwitchBranch(instanceId, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type RuntimeServiceGitSwitchBranchMutationResult = NonNullable<
  Awaited<ReturnType<typeof runtimeServiceGitSwitchBranch>>
>;
export type RuntimeServiceGitSwitchBranchMutationBody =
  RuntimeServiceGitSwitchBranchBody;
export type RuntimeServiceGitSwitchBranchMutationError = ErrorType<RpcStatus>;

export const createRuntimeServiceGitSwitchBranch = <
  TError = ErrorType<RpcStatus>,
  TContext = unknown,
>(
  options?: () => {
    mutation?: CreateMutationOptions<
      Awaited<ReturnType<typeof runtimeServiceGitSwitchBranch>>,
      TError,
      { instanceId: string; data: RuntimeServiceGitSwitchBranchBody },
      TContext
    >;
  },
  queryClient?: () => QueryClient,
): CreateMutationResult<
  Awaited<ReturnType<typeof runtimeServiceGitSwitchBranch>>,
  TError,
  { instanceId: string; data: RuntimeServiceGitSwitchBranchBody },
  TContext
> => {
  return createMutation(
    () => ({ ...getRuntimeServiceGitSwitchBranchMutationOptions(options?.()) }),
    queryClient,
  );
};
/**
 * @summary GitCommit commits the local changes to the git repo equivalent to `git commit -am <message>` command.
 */
export type runtimeServiceGitCommitResponse200 = {
  data: V1GitCommitResponse;
  status: 200;
};

export type runtimeServiceGitCommitResponseDefault = {
  data: RpcStatus;
  status: Exclude<HTTPStatusCodes, 200>;
};

export type runtimeServiceGitCommitResponseSuccess =
  runtimeServiceGitCommitResponse200 & {
    headers: Headers;
  };
export type runtimeServiceGitCommitResponseError =
  runtimeServiceGitCommitResponseDefault & {
    headers: Headers;
  };

export type runtimeServiceGitCommitResponse =
  | runtimeServiceGitCommitResponseSuccess
  | runtimeServiceGitCommitResponseError;

export const getRuntimeServiceGitCommitUrl = (instanceId: string) => {
  return `/v1/instances/${instanceId}/git/commit`;
};

export const runtimeServiceGitCommit = async (
  instanceId: string,
  runtimeServiceGitCommitBody: RuntimeServiceGitCommitBody,
  options?: RequestInit,
): Promise<runtimeServiceGitCommitResponse> => {
  return httpClient<runtimeServiceGitCommitResponse>(
    getRuntimeServiceGitCommitUrl(instanceId),
    {
      ...options,
      method: "POST",
      headers: { "Content-Type": "application/json", ...options?.headers },
      body: JSON.stringify(runtimeServiceGitCommitBody),
    },
  );
};

export const getRuntimeServiceGitCommitMutationOptions = <
  TError = ErrorType<RpcStatus>,
  TContext = unknown,
>(options?: {
  mutation?: CreateMutationOptions<
    Awaited<ReturnType<typeof runtimeServiceGitCommit>>,
    TError,
    { instanceId: string; data: RuntimeServiceGitCommitBody },
    TContext
  >;
}): CreateMutationOptions<
  Awaited<ReturnType<typeof runtimeServiceGitCommit>>,
  TError,
  { instanceId: string; data: RuntimeServiceGitCommitBody },
  TContext
> => {
  const mutationKey = ["runtimeServiceGitCommit"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof runtimeServiceGitCommit>>,
    { instanceId: string; data: RuntimeServiceGitCommitBody }
  > = (props) => {
    const { instanceId, data } = props ?? {};

    return runtimeServiceGitCommit(instanceId, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type RuntimeServiceGitCommitMutationResult = NonNullable<
  Awaited<ReturnType<typeof runtimeServiceGitCommit>>
>;
export type RuntimeServiceGitCommitMutationBody = RuntimeServiceGitCommitBody;
export type RuntimeServiceGitCommitMutationError = ErrorType<RpcStatus>;

/**
 * @summary GitCommit commits the local changes to the git repo equivalent to `git commit -am <message>` command.
 */
export const createRuntimeServiceGitCommit = <
  TError = ErrorType<RpcStatus>,
  TContext = unknown,
>(
  options?: () => {
    mutation?: CreateMutationOptions<
      Awaited<ReturnType<typeof runtimeServiceGitCommit>>,
      TError,
      { instanceId: string; data: RuntimeServiceGitCommitBody },
      TContext
    >;
  },
  queryClient?: () => QueryClient,
): CreateMutationResult<
  Awaited<ReturnType<typeof runtimeServiceGitCommit>>,
  TError,
  { instanceId: string; data: RuntimeServiceGitCommitBody },
  TContext
> => {
  return createMutation(
    () => ({ ...getRuntimeServiceGitCommitMutationOptions(options?.()) }),
    queryClient,
  );
};
export type runtimeServiceListGitCommitsResponse200 = {
  data: V1ListGitCommitsResponse;
  status: 200;
};

export type runtimeServiceListGitCommitsResponseDefault = {
  data: RpcStatus;
  status: Exclude<HTTPStatusCodes, 200>;
};

export type runtimeServiceListGitCommitsResponseSuccess =
  runtimeServiceListGitCommitsResponse200 & {
    headers: Headers;
  };
export type runtimeServiceListGitCommitsResponseError =
  runtimeServiceListGitCommitsResponseDefault & {
    headers: Headers;
  };

export type runtimeServiceListGitCommitsResponse =
  | runtimeServiceListGitCommitsResponseSuccess
  | runtimeServiceListGitCommitsResponseError;

export const getRuntimeServiceListGitCommitsUrl = (
  instanceId: string,
  params?: RuntimeServiceListGitCommitsParams,
) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? "null" : value.toString());
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0
    ? `/v1/instances/${instanceId}/git/commits?${stringifiedParams}`
    : `/v1/instances/${instanceId}/git/commits`;
};

export const runtimeServiceListGitCommits = async (
  instanceId: string,
  params?: RuntimeServiceListGitCommitsParams,
  options?: RequestInit,
): Promise<runtimeServiceListGitCommitsResponse> => {
  return httpClient<runtimeServiceListGitCommitsResponse>(
    getRuntimeServiceListGitCommitsUrl(instanceId, params),
    {
      ...options,
      method: "GET",
    },
  );
};

export const getRuntimeServiceListGitCommitsQueryKey = (
  instanceId: string,
  params?: RuntimeServiceListGitCommitsParams,
) => {
  return [
    `/v1/instances/${instanceId}/git/commits`,
    ...(params ? [params] : []),
  ] as const;
};

export const getRuntimeServiceListGitCommitsQueryOptions = <
  TData = Awaited<ReturnType<typeof runtimeServiceListGitCommits>>,
  TError = ErrorType<RpcStatus>,
>(
  instanceId: string,
  params?: RuntimeServiceListGitCommitsParams,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof runtimeServiceListGitCommits>>,
        TError,
        TData
      >
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getRuntimeServiceListGitCommitsQueryKey(instanceId, params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof runtimeServiceListGitCommits>>
  > = ({ signal }) =>
    runtimeServiceListGitCommits(instanceId, params, { signal });

  return {
    queryKey,
    queryFn,
    enabled: !!instanceId,
    ...queryOptions,
  } as CreateQueryOptions<
    Awaited<ReturnType<typeof runtimeServiceListGitCommits>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type RuntimeServiceListGitCommitsQueryResult = NonNullable<
  Awaited<ReturnType<typeof runtimeServiceListGitCommits>>
>;
export type RuntimeServiceListGitCommitsQueryError = ErrorType<RpcStatus>;

export function createRuntimeServiceListGitCommits<
  TData = Awaited<ReturnType<typeof runtimeServiceListGitCommits>>,
  TError = ErrorType<RpcStatus>,
>(
  instanceId: () => string,
  params?: () => RuntimeServiceListGitCommitsParams,
  options?: () => {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof runtimeServiceListGitCommits>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: () => QueryClient,
): CreateQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const query = createQuery(
    () =>
      getRuntimeServiceListGitCommitsQueryOptions(
        instanceId(),
        params?.(),
        options?.(),
      ),
    queryClient,
  ) as CreateQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  return query;
}

/**
 * @summary GitMergeToBranch merges current branch to the specified branch.
Note: this is not the same as `git merge <branch>`, but rather `git checkout <branch>` followed by `git merge <current-branch>`.
It restores back to the original branch after the merge.
 */
export type runtimeServiceGitMergeToBranchResponse200 = {
  data: V1GitMergeToBranchResponse;
  status: 200;
};

export type runtimeServiceGitMergeToBranchResponseDefault = {
  data: RpcStatus;
  status: Exclude<HTTPStatusCodes, 200>;
};

export type runtimeServiceGitMergeToBranchResponseSuccess =
  runtimeServiceGitMergeToBranchResponse200 & {
    headers: Headers;
  };
export type runtimeServiceGitMergeToBranchResponseError =
  runtimeServiceGitMergeToBranchResponseDefault & {
    headers: Headers;
  };

export type runtimeServiceGitMergeToBranchResponse =
  | runtimeServiceGitMergeToBranchResponseSuccess
  | runtimeServiceGitMergeToBranchResponseError;

export const getRuntimeServiceGitMergeToBranchUrl = (instanceId: string) => {
  return `/v1/instances/${instanceId}/git/merge`;
};

export const runtimeServiceGitMergeToBranch = async (
  instanceId: string,
  runtimeServiceGitMergeToBranchBody: RuntimeServiceGitMergeToBranchBody,
  options?: RequestInit,
): Promise<runtimeServiceGitMergeToBranchResponse> => {
  return httpClient<runtimeServiceGitMergeToBranchResponse>(
    getRuntimeServiceGitMergeToBranchUrl(instanceId),
    {
      ...options,
      method: "POST",
      headers: { "Content-Type": "application/json", ...options?.headers },
      body: JSON.stringify(runtimeServiceGitMergeToBranchBody),
    },
  );
};

export const getRuntimeServiceGitMergeToBranchMutationOptions = <
  TError = ErrorType<RpcStatus>,
  TContext = unknown,
>(options?: {
  mutation?: CreateMutationOptions<
    Awaited<ReturnType<typeof runtimeServiceGitMergeToBranch>>,
    TError,
    { instanceId: string; data: RuntimeServiceGitMergeToBranchBody },
    TContext
  >;
}): CreateMutationOptions<
  Awaited<ReturnType<typeof runtimeServiceGitMergeToBranch>>,
  TError,
  { instanceId: string; data: RuntimeServiceGitMergeToBranchBody },
  TContext
> => {
  const mutationKey = ["runtimeServiceGitMergeToBranch"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof runtimeServiceGitMergeToBranch>>,
    { instanceId: string; data: RuntimeServiceGitMergeToBranchBody }
  > = (props) => {
    const { instanceId, data } = props ?? {};

    return runtimeServiceGitMergeToBranch(instanceId, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type RuntimeServiceGitMergeToBranchMutationResult = NonNullable<
  Awaited<ReturnType<typeof runtimeServiceGitMergeToBranch>>
>;
export type RuntimeServiceGitMergeToBranchMutationBody =
  RuntimeServiceGitMergeToBranchBody;
export type RuntimeServiceGitMergeToBranchMutationError = ErrorType<RpcStatus>;

/**
 * @summary GitMergeToBranch merges current branch to the specified branch.
Note: this is not the same as `git merge <branch>`, but rather `git checkout <branch>` followed by `git merge <current-branch>`.
It restores back to the original branch after the merge.
 */
export const createRuntimeServiceGitMergeToBranch = <
  TError = ErrorType<RpcStatus>,
  TContext = unknown,
>(
  options?: () => {
    mutation?: CreateMutationOptions<
      Awaited<ReturnType<typeof runtimeServiceGitMergeToBranch>>,
      TError,
      { instanceId: string; data: RuntimeServiceGitMergeToBranchBody },
      TContext
    >;
  },
  queryClient?: () => QueryClient,
): CreateMutationResult<
  Awaited<ReturnType<typeof runtimeServiceGitMergeToBranch>>,
  TError,
  { instanceId: string; data: RuntimeServiceGitMergeToBranchBody },
  TContext
> => {
  return createMutation(
    () => ({
      ...getRuntimeServiceGitMergeToBranchMutationOptions(options?.()),
    }),
    queryClient,
  );
};
/**
 * @summary GitPull fetches the latest changes from the remote git repo equivalent to `git pull` command.
If there are any merge conflicts the pull is aborted.
Force can be set to true to force the pull and overwrite any local changes.
 */
export type runtimeServiceGitPullResponse200 = {
  data: V1GitPullResponse;
  status: 200;
};

export type runtimeServiceGitPullResponseDefault = {
  data: RpcStatus;
  status: Exclude<HTTPStatusCodes, 200>;
};

export type runtimeServiceGitPullResponseSuccess =
  runtimeServiceGitPullResponse200 & {
    headers: Headers;
  };
export type runtimeServiceGitPullResponseError =
  runtimeServiceGitPullResponseDefault & {
    headers: Headers;
  };

export type runtimeServiceGitPullResponse =
  | runtimeServiceGitPullResponseSuccess
  | runtimeServiceGitPullResponseError;

export const getRuntimeServiceGitPullUrl = (instanceId: string) => {
  return `/v1/instances/${instanceId}/git/pull`;
};

export const runtimeServiceGitPull = async (
  instanceId: string,
  runtimeServiceGitPullBody: RuntimeServiceGitPullBody,
  options?: RequestInit,
): Promise<runtimeServiceGitPullResponse> => {
  return httpClient<runtimeServiceGitPullResponse>(
    getRuntimeServiceGitPullUrl(instanceId),
    {
      ...options,
      method: "POST",
      headers: { "Content-Type": "application/json", ...options?.headers },
      body: JSON.stringify(runtimeServiceGitPullBody),
    },
  );
};

export const getRuntimeServiceGitPullMutationOptions = <
  TError = ErrorType<RpcStatus>,
  TContext = unknown,
>(options?: {
  mutation?: CreateMutationOptions<
    Awaited<ReturnType<typeof runtimeServiceGitPull>>,
    TError,
    { instanceId: string; data: RuntimeServiceGitPullBody },
    TContext
  >;
}): CreateMutationOptions<
  Awaited<ReturnType<typeof runtimeServiceGitPull>>,
  TError,
  { instanceId: string; data: RuntimeServiceGitPullBody },
  TContext
> => {
  const mutationKey = ["runtimeServiceGitPull"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof runtimeServiceGitPull>>,
    { instanceId: string; data: RuntimeServiceGitPullBody }
  > = (props) => {
    const { instanceId, data } = props ?? {};

    return runtimeServiceGitPull(instanceId, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type RuntimeServiceGitPullMutationResult = NonNullable<
  Awaited<ReturnType<typeof runtimeServiceGitPull>>
>;
export type RuntimeServiceGitPullMutationBody = RuntimeServiceGitPullBody;
export type RuntimeServiceGitPullMutationError = ErrorType<RpcStatus>;

/**
 * @summary GitPull fetches the latest changes from the remote git repo equivalent to `git pull` command.
If there are any merge conflicts the pull is aborted.
Force can be set to true to force the pull and overwrite any local changes.
 */
export const createRuntimeServiceGitPull = <
  TError = ErrorType<RpcStatus>,
  TContext = unknown,
>(
  options?: () => {
    mutation?: CreateMutationOptions<
      Awaited<ReturnType<typeof runtimeServiceGitPull>>,
      TError,
      { instanceId: string; data: RuntimeServiceGitPullBody },
      TContext
    >;
  },
  queryClient?: () => QueryClient,
): CreateMutationResult<
  Awaited<ReturnType<typeof runtimeServiceGitPull>>,
  TError,
  { instanceId: string; data: RuntimeServiceGitPullBody },
  TContext
> => {
  return createMutation(
    () => ({ ...getRuntimeServiceGitPullMutationOptions(options?.()) }),
    queryClient,
  );
};
/**
 * @summary GitPush pushes the local changes to the remote git repo equivalent to `git push` command.
It only pushes the changes to the existing remote repo.
 */
export type runtimeServiceGitPushResponse200 = {
  data: V1GitPushResponse;
  status: 200;
};

export type runtimeServiceGitPushResponseDefault = {
  data: RpcStatus;
  status: Exclude<HTTPStatusCodes, 200>;
};

export type runtimeServiceGitPushResponseSuccess =
  runtimeServiceGitPushResponse200 & {
    headers: Headers;
  };
export type runtimeServiceGitPushResponseError =
  runtimeServiceGitPushResponseDefault & {
    headers: Headers;
  };

export type runtimeServiceGitPushResponse =
  | runtimeServiceGitPushResponseSuccess
  | runtimeServiceGitPushResponseError;

export const getRuntimeServiceGitPushUrl = (instanceId: string) => {
  return `/v1/instances/${instanceId}/git/push`;
};

export const runtimeServiceGitPush = async (
  instanceId: string,
  runtimeServiceGitPushBody: RuntimeServiceGitPushBody,
  options?: RequestInit,
): Promise<runtimeServiceGitPushResponse> => {
  return httpClient<runtimeServiceGitPushResponse>(
    getRuntimeServiceGitPushUrl(instanceId),
    {
      ...options,
      method: "POST",
      headers: { "Content-Type": "application/json", ...options?.headers },
      body: JSON.stringify(runtimeServiceGitPushBody),
    },
  );
};

export const getRuntimeServiceGitPushMutationOptions = <
  TError = ErrorType<RpcStatus>,
  TContext = unknown,
>(options?: {
  mutation?: CreateMutationOptions<
    Awaited<ReturnType<typeof runtimeServiceGitPush>>,
    TError,
    { instanceId: string; data: RuntimeServiceGitPushBody },
    TContext
  >;
}): CreateMutationOptions<
  Awaited<ReturnType<typeof runtimeServiceGitPush>>,
  TError,
  { instanceId: string; data: RuntimeServiceGitPushBody },
  TContext
> => {
  const mutationKey = ["runtimeServiceGitPush"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof runtimeServiceGitPush>>,
    { instanceId: string; data: RuntimeServiceGitPushBody }
  > = (props) => {
    const { instanceId, data } = props ?? {};

    return runtimeServiceGitPush(instanceId, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type RuntimeServiceGitPushMutationResult = NonNullable<
  Awaited<ReturnType<typeof runtimeServiceGitPush>>
>;
export type RuntimeServiceGitPushMutationBody = RuntimeServiceGitPushBody;
export type RuntimeServiceGitPushMutationError = ErrorType<RpcStatus>;

/**
 * @summary GitPush pushes the local changes to the remote git repo equivalent to `git push` command.
It only pushes the changes to the existing remote repo.
 */
export const createRuntimeServiceGitPush = <
  TError = ErrorType<RpcStatus>,
  TContext = unknown,
>(
  options?: () => {
    mutation?: CreateMutationOptions<
      Awaited<ReturnType<typeof runtimeServiceGitPush>>,
      TError,
      { instanceId: string; data: RuntimeServiceGitPushBody },
      TContext
    >;
  },
  queryClient?: () => QueryClient,
): CreateMutationResult<
  Awaited<ReturnType<typeof runtimeServiceGitPush>>,
  TError,
  { instanceId: string; data: RuntimeServiceGitPushBody },
  TContext
> => {
  return createMutation(
    () => ({ ...getRuntimeServiceGitPushMutationOptions(options?.()) }),
    queryClient,
  );
};
/**
 * @summary RestoreGitCommit creates a new commit that restores the state of the repo to the specified commit SHA.
This effectively discards all the changes made after the specified commit.
 */
export type runtimeServiceRestoreGitCommitResponse200 = {
  data: V1RestoreGitCommitResponse;
  status: 200;
};

export type runtimeServiceRestoreGitCommitResponseDefault = {
  data: RpcStatus;
  status: Exclude<HTTPStatusCodes, 200>;
};

export type runtimeServiceRestoreGitCommitResponseSuccess =
  runtimeServiceRestoreGitCommitResponse200 & {
    headers: Headers;
  };
export type runtimeServiceRestoreGitCommitResponseError =
  runtimeServiceRestoreGitCommitResponseDefault & {
    headers: Headers;
  };

export type runtimeServiceRestoreGitCommitResponse =
  | runtimeServiceRestoreGitCommitResponseSuccess
  | runtimeServiceRestoreGitCommitResponseError;

export const getRuntimeServiceRestoreGitCommitUrl = (
  instanceId: string,
  commitSha: string,
) => {
  return `/v1/instances/${instanceId}/git/restore/${commitSha}`;
};

export const runtimeServiceRestoreGitCommit = async (
  instanceId: string,
  commitSha: string,
  runtimeServiceRestoreGitCommitBody: RuntimeServiceRestoreGitCommitBody,
  options?: RequestInit,
): Promise<runtimeServiceRestoreGitCommitResponse> => {
  return httpClient<runtimeServiceRestoreGitCommitResponse>(
    getRuntimeServiceRestoreGitCommitUrl(instanceId, commitSha),
    {
      ...options,
      method: "POST",
      headers: { "Content-Type": "application/json", ...options?.headers },
      body: JSON.stringify(runtimeServiceRestoreGitCommitBody),
    },
  );
};

export const getRuntimeServiceRestoreGitCommitMutationOptions = <
  TError = ErrorType<RpcStatus>,
  TContext = unknown,
>(options?: {
  mutation?: CreateMutationOptions<
    Awaited<ReturnType<typeof runtimeServiceRestoreGitCommit>>,
    TError,
    {
      instanceId: string;
      commitSha: string;
      data: RuntimeServiceRestoreGitCommitBody;
    },
    TContext
  >;
}): CreateMutationOptions<
  Awaited<ReturnType<typeof runtimeServiceRestoreGitCommit>>,
  TError,
  {
    instanceId: string;
    commitSha: string;
    data: RuntimeServiceRestoreGitCommitBody;
  },
  TContext
> => {
  const mutationKey = ["runtimeServiceRestoreGitCommit"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof runtimeServiceRestoreGitCommit>>,
    {
      instanceId: string;
      commitSha: string;
      data: RuntimeServiceRestoreGitCommitBody;
    }
  > = (props) => {
    const { instanceId, commitSha, data } = props ?? {};

    return runtimeServiceRestoreGitCommit(instanceId, commitSha, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type RuntimeServiceRestoreGitCommitMutationResult = NonNullable<
  Awaited<ReturnType<typeof runtimeServiceRestoreGitCommit>>
>;
export type RuntimeServiceRestoreGitCommitMutationBody =
  RuntimeServiceRestoreGitCommitBody;
export type RuntimeServiceRestoreGitCommitMutationError = ErrorType<RpcStatus>;

/**
 * @summary RestoreGitCommit creates a new commit that restores the state of the repo to the specified commit SHA.
This effectively discards all the changes made after the specified commit.
 */
export const createRuntimeServiceRestoreGitCommit = <
  TError = ErrorType<RpcStatus>,
  TContext = unknown,
>(
  options?: () => {
    mutation?: CreateMutationOptions<
      Awaited<ReturnType<typeof runtimeServiceRestoreGitCommit>>,
      TError,
      {
        instanceId: string;
        commitSha: string;
        data: RuntimeServiceRestoreGitCommitBody;
      },
      TContext
    >;
  },
  queryClient?: () => QueryClient,
): CreateMutationResult<
  Awaited<ReturnType<typeof runtimeServiceRestoreGitCommit>>,
  TError,
  {
    instanceId: string;
    commitSha: string;
    data: RuntimeServiceRestoreGitCommitBody;
  },
  TContext
> => {
  return createMutation(
    () => ({
      ...getRuntimeServiceRestoreGitCommitMutationOptions(options?.()),
    }),
    queryClient,
  );
};
/**
 * @summary GitStatus returns the current status of the local git repo. This is equivalent to doing a `git fetch` followed by running `git status`.
 */
export type runtimeServiceGitStatusResponse200 = {
  data: V1GitStatusResponse;
  status: 200;
};

export type runtimeServiceGitStatusResponseDefault = {
  data: RpcStatus;
  status: Exclude<HTTPStatusCodes, 200>;
};

export type runtimeServiceGitStatusResponseSuccess =
  runtimeServiceGitStatusResponse200 & {
    headers: Headers;
  };
export type runtimeServiceGitStatusResponseError =
  runtimeServiceGitStatusResponseDefault & {
    headers: Headers;
  };

export type runtimeServiceGitStatusResponse =
  | runtimeServiceGitStatusResponseSuccess
  | runtimeServiceGitStatusResponseError;

export const getRuntimeServiceGitStatusUrl = (instanceId: string) => {
  return `/v1/instances/${instanceId}/git/status`;
};

export const runtimeServiceGitStatus = async (
  instanceId: string,
  options?: RequestInit,
): Promise<runtimeServiceGitStatusResponse> => {
  return httpClient<runtimeServiceGitStatusResponse>(
    getRuntimeServiceGitStatusUrl(instanceId),
    {
      ...options,
      method: "GET",
    },
  );
};

export const getRuntimeServiceGitStatusQueryKey = (instanceId: string) => {
  return [`/v1/instances/${instanceId}/git/status`] as const;
};

export const getRuntimeServiceGitStatusQueryOptions = <
  TData = Awaited<ReturnType<typeof runtimeServiceGitStatus>>,
  TError = ErrorType<RpcStatus>,
>(
  instanceId: string,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof runtimeServiceGitStatus>>,
        TError,
        TData
      >
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getRuntimeServiceGitStatusQueryKey(instanceId);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof runtimeServiceGitStatus>>
  > = ({ signal }) => runtimeServiceGitStatus(instanceId, { signal });

  return {
    queryKey,
    queryFn,
    enabled: !!instanceId,
    ...queryOptions,
  } as CreateQueryOptions<
    Awaited<ReturnType<typeof runtimeServiceGitStatus>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type RuntimeServiceGitStatusQueryResult = NonNullable<
  Awaited<ReturnType<typeof runtimeServiceGitStatus>>
>;
export type RuntimeServiceGitStatusQueryError = ErrorType<RpcStatus>;

/**
 * @summary GitStatus returns the current status of the local git repo. This is equivalent to doing a `git fetch` followed by running `git status`.
 */

export function createRuntimeServiceGitStatus<
  TData = Awaited<ReturnType<typeof runtimeServiceGitStatus>>,
  TError = ErrorType<RpcStatus>,
>(
  instanceId: () => string,
  options?: () => {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof runtimeServiceGitStatus>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: () => QueryClient,
): CreateQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const query = createQuery(
    () => getRuntimeServiceGitStatusQueryOptions(instanceId(), options?.()),
    queryClient,
  ) as CreateQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  return query;
}

/**
 * @summary GetLogs returns recent logs from a controller
 */
export type runtimeServiceGetLogsResponse200 = {
  data: V1GetLogsResponse;
  status: 200;
};

export type runtimeServiceGetLogsResponseDefault = {
  data: RpcStatus;
  status: Exclude<HTTPStatusCodes, 200>;
};

export type runtimeServiceGetLogsResponseSuccess =
  runtimeServiceGetLogsResponse200 & {
    headers: Headers;
  };
export type runtimeServiceGetLogsResponseError =
  runtimeServiceGetLogsResponseDefault & {
    headers: Headers;
  };

export type runtimeServiceGetLogsResponse =
  | runtimeServiceGetLogsResponseSuccess
  | runtimeServiceGetLogsResponseError;

export const getRuntimeServiceGetLogsUrl = (
  instanceId: string,
  params?: RuntimeServiceGetLogsParams,
) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? "null" : value.toString());
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0
    ? `/v1/instances/${instanceId}/logs?${stringifiedParams}`
    : `/v1/instances/${instanceId}/logs`;
};

export const runtimeServiceGetLogs = async (
  instanceId: string,
  params?: RuntimeServiceGetLogsParams,
  options?: RequestInit,
): Promise<runtimeServiceGetLogsResponse> => {
  return httpClient<runtimeServiceGetLogsResponse>(
    getRuntimeServiceGetLogsUrl(instanceId, params),
    {
      ...options,
      method: "GET",
    },
  );
};

export const getRuntimeServiceGetLogsQueryKey = (
  instanceId: string,
  params?: RuntimeServiceGetLogsParams,
) => {
  return [
    `/v1/instances/${instanceId}/logs`,
    ...(params ? [params] : []),
  ] as const;
};

export const getRuntimeServiceGetLogsQueryOptions = <
  TData = Awaited<ReturnType<typeof runtimeServiceGetLogs>>,
  TError = ErrorType<RpcStatus>,
>(
  instanceId: string,
  params?: RuntimeServiceGetLogsParams,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof runtimeServiceGetLogs>>,
        TError,
        TData
      >
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getRuntimeServiceGetLogsQueryKey(instanceId, params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof runtimeServiceGetLogs>>
  > = ({ signal }) => runtimeServiceGetLogs(instanceId, params, { signal });

  return {
    queryKey,
    queryFn,
    enabled: !!instanceId,
    ...queryOptions,
  } as CreateQueryOptions<
    Awaited<ReturnType<typeof runtimeServiceGetLogs>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type RuntimeServiceGetLogsQueryResult = NonNullable<
  Awaited<ReturnType<typeof runtimeServiceGetLogs>>
>;
export type RuntimeServiceGetLogsQueryError = ErrorType<RpcStatus>;

/**
 * @summary GetLogs returns recent logs from a controller
 */

export function createRuntimeServiceGetLogs<
  TData = Awaited<ReturnType<typeof runtimeServiceGetLogs>>,
  TError = ErrorType<RpcStatus>,
>(
  instanceId: () => string,
  params?: () => RuntimeServiceGetLogsParams,
  options?: () => {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof runtimeServiceGetLogs>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: () => QueryClient,
): CreateQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const query = createQuery(
    () =>
      getRuntimeServiceGetLogsQueryOptions(
        instanceId(),
        params?.(),
        options?.(),
      ),
    queryClient,
  ) as CreateQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  return query;
}

/**
 * @summary WatchLogs streams new logs emitted from a controller
 */
export type runtimeServiceWatchLogsResponse200 = {
  data: RuntimeServiceWatchLogs200;
  status: 200;
};

export type runtimeServiceWatchLogsResponseDefault = {
  data: RpcStatus;
  status: Exclude<HTTPStatusCodes, 200>;
};

export type runtimeServiceWatchLogsResponseSuccess =
  runtimeServiceWatchLogsResponse200 & {
    headers: Headers;
  };
export type runtimeServiceWatchLogsResponseError =
  runtimeServiceWatchLogsResponseDefault & {
    headers: Headers;
  };

export type runtimeServiceWatchLogsResponse =
  | runtimeServiceWatchLogsResponseSuccess
  | runtimeServiceWatchLogsResponseError;

export const getRuntimeServiceWatchLogsUrl = (
  instanceId: string,
  params?: RuntimeServiceWatchLogsParams,
) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? "null" : value.toString());
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0
    ? `/v1/instances/${instanceId}/logs/watch?${stringifiedParams}`
    : `/v1/instances/${instanceId}/logs/watch`;
};

export const runtimeServiceWatchLogs = async (
  instanceId: string,
  params?: RuntimeServiceWatchLogsParams,
  options?: RequestInit,
): Promise<runtimeServiceWatchLogsResponse> => {
  return httpClient<runtimeServiceWatchLogsResponse>(
    getRuntimeServiceWatchLogsUrl(instanceId, params),
    {
      ...options,
      method: "GET",
    },
  );
};

export const getRuntimeServiceWatchLogsQueryKey = (
  instanceId: string,
  params?: RuntimeServiceWatchLogsParams,
) => {
  return [
    `/v1/instances/${instanceId}/logs/watch`,
    ...(params ? [params] : []),
  ] as const;
};

export const getRuntimeServiceWatchLogsQueryOptions = <
  TData = Awaited<ReturnType<typeof runtimeServiceWatchLogs>>,
  TError = ErrorType<RpcStatus>,
>(
  instanceId: string,
  params?: RuntimeServiceWatchLogsParams,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof runtimeServiceWatchLogs>>,
        TError,
        TData
      >
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getRuntimeServiceWatchLogsQueryKey(instanceId, params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof runtimeServiceWatchLogs>>
  > = ({ signal }) => runtimeServiceWatchLogs(instanceId, params, { signal });

  return {
    queryKey,
    queryFn,
    enabled: !!instanceId,
    ...queryOptions,
  } as CreateQueryOptions<
    Awaited<ReturnType<typeof runtimeServiceWatchLogs>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type RuntimeServiceWatchLogsQueryResult = NonNullable<
  Awaited<ReturnType<typeof runtimeServiceWatchLogs>>
>;
export type RuntimeServiceWatchLogsQueryError = ErrorType<RpcStatus>;

/**
 * @summary WatchLogs streams new logs emitted from a controller
 */

export function createRuntimeServiceWatchLogs<
  TData = Awaited<ReturnType<typeof runtimeServiceWatchLogs>>,
  TError = ErrorType<RpcStatus>,
>(
  instanceId: () => string,
  params?: () => RuntimeServiceWatchLogsParams,
  options?: () => {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof runtimeServiceWatchLogs>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: () => QueryClient,
): CreateQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const query = createQuery(
    () =>
      getRuntimeServiceWatchLogsQueryOptions(
        instanceId(),
        params?.(),
        options?.(),
      ),
    queryClient,
  ) as CreateQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  return query;
}

/**
 * @summary GetModelPartitions returns the partitions of a model
 */
export type runtimeServiceGetModelPartitionsResponse200 = {
  data: V1GetModelPartitionsResponse;
  status: 200;
};

export type runtimeServiceGetModelPartitionsResponseDefault = {
  data: RpcStatus;
  status: Exclude<HTTPStatusCodes, 200>;
};

export type runtimeServiceGetModelPartitionsResponseSuccess =
  runtimeServiceGetModelPartitionsResponse200 & {
    headers: Headers;
  };
export type runtimeServiceGetModelPartitionsResponseError =
  runtimeServiceGetModelPartitionsResponseDefault & {
    headers: Headers;
  };

export type runtimeServiceGetModelPartitionsResponse =
  | runtimeServiceGetModelPartitionsResponseSuccess
  | runtimeServiceGetModelPartitionsResponseError;

export const getRuntimeServiceGetModelPartitionsUrl = (
  instanceId: string,
  model: string,
  params?: RuntimeServiceGetModelPartitionsParams,
) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? "null" : value.toString());
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0
    ? `/v1/instances/${instanceId}/models/${model}/partitions?${stringifiedParams}`
    : `/v1/instances/${instanceId}/models/${model}/partitions`;
};

export const runtimeServiceGetModelPartitions = async (
  instanceId: string,
  model: string,
  params?: RuntimeServiceGetModelPartitionsParams,
  options?: RequestInit,
): Promise<runtimeServiceGetModelPartitionsResponse> => {
  return httpClient<runtimeServiceGetModelPartitionsResponse>(
    getRuntimeServiceGetModelPartitionsUrl(instanceId, model, params),
    {
      ...options,
      method: "GET",
    },
  );
};

export const getRuntimeServiceGetModelPartitionsInfiniteQueryKey = (
  instanceId: string,
  model: string,
  params?: RuntimeServiceGetModelPartitionsParams,
) => {
  return [
    "infinite",
    `/v1/instances/${instanceId}/models/${model}/partitions`,
    ...(params ? [params] : []),
  ] as const;
};

export const getRuntimeServiceGetModelPartitionsQueryKey = (
  instanceId: string,
  model: string,
  params?: RuntimeServiceGetModelPartitionsParams,
) => {
  return [
    `/v1/instances/${instanceId}/models/${model}/partitions`,
    ...(params ? [params] : []),
  ] as const;
};

export const getRuntimeServiceGetModelPartitionsInfiniteQueryOptions = <
  TData = InfiniteData<
    Awaited<ReturnType<typeof runtimeServiceGetModelPartitions>>,
    RuntimeServiceGetModelPartitionsParams["pageToken"]
  >,
  TError = ErrorType<RpcStatus>,
>(
  instanceId: string,
  model: string,
  params?: RuntimeServiceGetModelPartitionsParams,
  options?: {
    query?: Partial<
      CreateInfiniteQueryOptions<
        Awaited<ReturnType<typeof runtimeServiceGetModelPartitions>>,
        TError,
        TData,
        QueryKey,
        RuntimeServiceGetModelPartitionsParams["pageToken"]
      >
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getRuntimeServiceGetModelPartitionsInfiniteQueryKey(
      instanceId,
      model,
      params,
    );

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof runtimeServiceGetModelPartitions>>,
    QueryKey,
    RuntimeServiceGetModelPartitionsParams["pageToken"]
  > = ({ signal, pageParam }) =>
    runtimeServiceGetModelPartitions(
      instanceId,
      model,
      { ...params, pageToken: pageParam || params?.["pageToken"] },
      { signal },
    );

  return {
    queryKey,
    queryFn,
    enabled: !!(instanceId && model),
    ...queryOptions,
  } as CreateInfiniteQueryOptions<
    Awaited<ReturnType<typeof runtimeServiceGetModelPartitions>>,
    TError,
    TData,
    QueryKey,
    RuntimeServiceGetModelPartitionsParams["pageToken"]
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type RuntimeServiceGetModelPartitionsInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof runtimeServiceGetModelPartitions>>
>;
export type RuntimeServiceGetModelPartitionsInfiniteQueryError =
  ErrorType<RpcStatus>;

/**
 * @summary GetModelPartitions returns the partitions of a model
 */

export function createRuntimeServiceGetModelPartitionsInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof runtimeServiceGetModelPartitions>>,
    RuntimeServiceGetModelPartitionsParams["pageToken"]
  >,
  TError = ErrorType<RpcStatus>,
>(
  instanceId: () => string,
  model: () => string,
  params?: () => RuntimeServiceGetModelPartitionsParams,
  options?: () => {
    query?: Partial<
      CreateInfiniteQueryOptions<
        Awaited<ReturnType<typeof runtimeServiceGetModelPartitions>>,
        TError,
        TData,
        QueryKey,
        RuntimeServiceGetModelPartitionsParams["pageToken"]
      >
    >;
  },
  queryClient?: () => QueryClient,
): CreateInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const query = createInfiniteQuery(
    () =>
      getRuntimeServiceGetModelPartitionsInfiniteQueryOptions(
        instanceId(),
        model(),
        params?.(),
        options?.(),
      ),
    queryClient,
  ) as CreateInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  return query;
}

export const getRuntimeServiceGetModelPartitionsQueryOptions = <
  TData = Awaited<ReturnType<typeof runtimeServiceGetModelPartitions>>,
  TError = ErrorType<RpcStatus>,
>(
  instanceId: string,
  model: string,
  params?: RuntimeServiceGetModelPartitionsParams,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof runtimeServiceGetModelPartitions>>,
        TError,
        TData
      >
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getRuntimeServiceGetModelPartitionsQueryKey(instanceId, model, params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof runtimeServiceGetModelPartitions>>
  > = ({ signal }) =>
    runtimeServiceGetModelPartitions(instanceId, model, params, { signal });

  return {
    queryKey,
    queryFn,
    enabled: !!(instanceId && model),
    ...queryOptions,
  } as CreateQueryOptions<
    Awaited<ReturnType<typeof runtimeServiceGetModelPartitions>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type RuntimeServiceGetModelPartitionsQueryResult = NonNullable<
  Awaited<ReturnType<typeof runtimeServiceGetModelPartitions>>
>;
export type RuntimeServiceGetModelPartitionsQueryError = ErrorType<RpcStatus>;

/**
 * @summary GetModelPartitions returns the partitions of a model
 */

export function createRuntimeServiceGetModelPartitions<
  TData = Awaited<ReturnType<typeof runtimeServiceGetModelPartitions>>,
  TError = ErrorType<RpcStatus>,
>(
  instanceId: () => string,
  model: () => string,
  params?: () => RuntimeServiceGetModelPartitionsParams,
  options?: () => {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof runtimeServiceGetModelPartitions>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: () => QueryClient,
): CreateQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const query = createQuery(
    () =>
      getRuntimeServiceGetModelPartitionsQueryOptions(
        instanceId(),
        model(),
        params?.(),
        options?.(),
      ),
    queryClient,
  ) as CreateQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  return query;
}

/**
 * @summary QueryResolver queries a resolver with the given properties and arguments
 */
export type runtimeServiceQueryResolverResponse200 = {
  data: V1QueryResolverResponse;
  status: 200;
};

export type runtimeServiceQueryResolverResponseDefault = {
  data: RpcStatus;
  status: Exclude<HTTPStatusCodes, 200>;
};

export type runtimeServiceQueryResolverResponseSuccess =
  runtimeServiceQueryResolverResponse200 & {
    headers: Headers;
  };
export type runtimeServiceQueryResolverResponseError =
  runtimeServiceQueryResolverResponseDefault & {
    headers: Headers;
  };

export type runtimeServiceQueryResolverResponse =
  | runtimeServiceQueryResolverResponseSuccess
  | runtimeServiceQueryResolverResponseError;

export const getRuntimeServiceQueryResolverUrl = (instanceId: string) => {
  return `/v1/instances/${instanceId}/query/resolver`;
};

export const runtimeServiceQueryResolver = async (
  instanceId: string,
  runtimeServiceQueryResolverBody: RuntimeServiceQueryResolverBody,
  options?: RequestInit,
): Promise<runtimeServiceQueryResolverResponse> => {
  return httpClient<runtimeServiceQueryResolverResponse>(
    getRuntimeServiceQueryResolverUrl(instanceId),
    {
      ...options,
      method: "POST",
      headers: { "Content-Type": "application/json", ...options?.headers },
      body: JSON.stringify(runtimeServiceQueryResolverBody),
    },
  );
};

export const getRuntimeServiceQueryResolverMutationOptions = <
  TError = ErrorType<RpcStatus>,
  TContext = unknown,
>(options?: {
  mutation?: CreateMutationOptions<
    Awaited<ReturnType<typeof runtimeServiceQueryResolver>>,
    TError,
    { instanceId: string; data: RuntimeServiceQueryResolverBody },
    TContext
  >;
}): CreateMutationOptions<
  Awaited<ReturnType<typeof runtimeServiceQueryResolver>>,
  TError,
  { instanceId: string; data: RuntimeServiceQueryResolverBody },
  TContext
> => {
  const mutationKey = ["runtimeServiceQueryResolver"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof runtimeServiceQueryResolver>>,
    { instanceId: string; data: RuntimeServiceQueryResolverBody }
  > = (props) => {
    const { instanceId, data } = props ?? {};

    return runtimeServiceQueryResolver(instanceId, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type RuntimeServiceQueryResolverMutationResult = NonNullable<
  Awaited<ReturnType<typeof runtimeServiceQueryResolver>>
>;
export type RuntimeServiceQueryResolverMutationBody =
  RuntimeServiceQueryResolverBody;
export type RuntimeServiceQueryResolverMutationError = ErrorType<RpcStatus>;

/**
 * @summary QueryResolver queries a resolver with the given properties and arguments
 */
export const createRuntimeServiceQueryResolver = <
  TError = ErrorType<RpcStatus>,
  TContext = unknown,
>(
  options?: () => {
    mutation?: CreateMutationOptions<
      Awaited<ReturnType<typeof runtimeServiceQueryResolver>>,
      TError,
      { instanceId: string; data: RuntimeServiceQueryResolverBody },
      TContext
    >;
  },
  queryClient?: () => QueryClient,
): CreateMutationResult<
  Awaited<ReturnType<typeof runtimeServiceQueryResolver>>,
  TError,
  { instanceId: string; data: RuntimeServiceQueryResolverBody },
  TContext
> => {
  return createMutation(
    () => ({ ...getRuntimeServiceQueryResolverMutationOptions(options?.()) }),
    queryClient,
  );
};
/**
 * @summary ReloadConfig pulls the latest configuration from the admin service and triggers a repo pull.
If the instance doesn't have an admin connector, this RPC does nothing.
 */
export type runtimeServiceReloadConfigResponse200 = {
  data: V1ReloadConfigResponse;
  status: 200;
};

export type runtimeServiceReloadConfigResponseDefault = {
  data: RpcStatus;
  status: Exclude<HTTPStatusCodes, 200>;
};

export type runtimeServiceReloadConfigResponseSuccess =
  runtimeServiceReloadConfigResponse200 & {
    headers: Headers;
  };
export type runtimeServiceReloadConfigResponseError =
  runtimeServiceReloadConfigResponseDefault & {
    headers: Headers;
  };

export type runtimeServiceReloadConfigResponse =
  | runtimeServiceReloadConfigResponseSuccess
  | runtimeServiceReloadConfigResponseError;

export const getRuntimeServiceReloadConfigUrl = (instanceId: string) => {
  return `/v1/instances/${instanceId}/reload-config`;
};

export const runtimeServiceReloadConfig = async (
  instanceId: string,
  runtimeServiceReloadConfigBody: RuntimeServiceReloadConfigBody,
  options?: RequestInit,
): Promise<runtimeServiceReloadConfigResponse> => {
  return httpClient<runtimeServiceReloadConfigResponse>(
    getRuntimeServiceReloadConfigUrl(instanceId),
    {
      ...options,
      method: "POST",
      headers: { "Content-Type": "application/json", ...options?.headers },
      body: JSON.stringify(runtimeServiceReloadConfigBody),
    },
  );
};

export const getRuntimeServiceReloadConfigMutationOptions = <
  TError = ErrorType<RpcStatus>,
  TContext = unknown,
>(options?: {
  mutation?: CreateMutationOptions<
    Awaited<ReturnType<typeof runtimeServiceReloadConfig>>,
    TError,
    { instanceId: string; data: RuntimeServiceReloadConfigBody },
    TContext
  >;
}): CreateMutationOptions<
  Awaited<ReturnType<typeof runtimeServiceReloadConfig>>,
  TError,
  { instanceId: string; data: RuntimeServiceReloadConfigBody },
  TContext
> => {
  const mutationKey = ["runtimeServiceReloadConfig"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof runtimeServiceReloadConfig>>,
    { instanceId: string; data: RuntimeServiceReloadConfigBody }
  > = (props) => {
    const { instanceId, data } = props ?? {};

    return runtimeServiceReloadConfig(instanceId, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type RuntimeServiceReloadConfigMutationResult = NonNullable<
  Awaited<ReturnType<typeof runtimeServiceReloadConfig>>
>;
export type RuntimeServiceReloadConfigMutationBody =
  RuntimeServiceReloadConfigBody;
export type RuntimeServiceReloadConfigMutationError = ErrorType<RpcStatus>;

/**
 * @summary ReloadConfig pulls the latest configuration from the admin service and triggers a repo pull.
If the instance doesn't have an admin connector, this RPC does nothing.
 */
export const createRuntimeServiceReloadConfig = <
  TError = ErrorType<RpcStatus>,
  TContext = unknown,
>(
  options?: () => {
    mutation?: CreateMutationOptions<
      Awaited<ReturnType<typeof runtimeServiceReloadConfig>>,
      TError,
      { instanceId: string; data: RuntimeServiceReloadConfigBody },
      TContext
    >;
  },
  queryClient?: () => QueryClient,
): CreateMutationResult<
  Awaited<ReturnType<typeof runtimeServiceReloadConfig>>,
  TError,
  { instanceId: string; data: RuntimeServiceReloadConfigBody },
  TContext
> => {
  return createMutation(
    () => ({ ...getRuntimeServiceReloadConfigMutationOptions(options?.()) }),
    queryClient,
  );
};
/**
 * @summary GetResource looks up a specific catalog resource
 */
export type runtimeServiceGetResourceResponse200 = {
  data: V1GetResourceResponse;
  status: 200;
};

export type runtimeServiceGetResourceResponseDefault = {
  data: RpcStatus;
  status: Exclude<HTTPStatusCodes, 200>;
};

export type runtimeServiceGetResourceResponseSuccess =
  runtimeServiceGetResourceResponse200 & {
    headers: Headers;
  };
export type runtimeServiceGetResourceResponseError =
  runtimeServiceGetResourceResponseDefault & {
    headers: Headers;
  };

export type runtimeServiceGetResourceResponse =
  | runtimeServiceGetResourceResponseSuccess
  | runtimeServiceGetResourceResponseError;

export const getRuntimeServiceGetResourceUrl = (
  instanceId: string,
  params?: RuntimeServiceGetResourceParams,
) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? "null" : value.toString());
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0
    ? `/v1/instances/${instanceId}/resource?${stringifiedParams}`
    : `/v1/instances/${instanceId}/resource`;
};

export const runtimeServiceGetResource = async (
  instanceId: string,
  params?: RuntimeServiceGetResourceParams,
  options?: RequestInit,
): Promise<runtimeServiceGetResourceResponse> => {
  return httpClient<runtimeServiceGetResourceResponse>(
    getRuntimeServiceGetResourceUrl(instanceId, params),
    {
      ...options,
      method: "GET",
    },
  );
};

export const getRuntimeServiceGetResourceQueryKey = (
  instanceId: string,
  params?: RuntimeServiceGetResourceParams,
) => {
  return [
    `/v1/instances/${instanceId}/resource`,
    ...(params ? [params] : []),
  ] as const;
};

export const getRuntimeServiceGetResourceQueryOptions = <
  TData = Awaited<ReturnType<typeof runtimeServiceGetResource>>,
  TError = ErrorType<RpcStatus>,
>(
  instanceId: string,
  params?: RuntimeServiceGetResourceParams,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof runtimeServiceGetResource>>,
        TError,
        TData
      >
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getRuntimeServiceGetResourceQueryKey(instanceId, params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof runtimeServiceGetResource>>
  > = ({ signal }) => runtimeServiceGetResource(instanceId, params, { signal });

  return {
    queryKey,
    queryFn,
    enabled: !!instanceId,
    ...queryOptions,
  } as CreateQueryOptions<
    Awaited<ReturnType<typeof runtimeServiceGetResource>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type RuntimeServiceGetResourceQueryResult = NonNullable<
  Awaited<ReturnType<typeof runtimeServiceGetResource>>
>;
export type RuntimeServiceGetResourceQueryError = ErrorType<RpcStatus>;

/**
 * @summary GetResource looks up a specific catalog resource
 */

export function createRuntimeServiceGetResource<
  TData = Awaited<ReturnType<typeof runtimeServiceGetResource>>,
  TError = ErrorType<RpcStatus>,
>(
  instanceId: () => string,
  params?: () => RuntimeServiceGetResourceParams,
  options?: () => {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof runtimeServiceGetResource>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: () => QueryClient,
): CreateQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const query = createQuery(
    () =>
      getRuntimeServiceGetResourceQueryOptions(
        instanceId(),
        params?.(),
        options?.(),
      ),
    queryClient,
  ) as CreateQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  return query;
}

/**
 * @summary ListResources lists the resources stored in the catalog
 */
export type runtimeServiceListResourcesResponse200 = {
  data: V1ListResourcesResponse;
  status: 200;
};

export type runtimeServiceListResourcesResponseDefault = {
  data: RpcStatus;
  status: Exclude<HTTPStatusCodes, 200>;
};

export type runtimeServiceListResourcesResponseSuccess =
  runtimeServiceListResourcesResponse200 & {
    headers: Headers;
  };
export type runtimeServiceListResourcesResponseError =
  runtimeServiceListResourcesResponseDefault & {
    headers: Headers;
  };

export type runtimeServiceListResourcesResponse =
  | runtimeServiceListResourcesResponseSuccess
  | runtimeServiceListResourcesResponseError;

export const getRuntimeServiceListResourcesUrl = (
  instanceId: string,
  params?: RuntimeServiceListResourcesParams,
) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? "null" : value.toString());
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0
    ? `/v1/instances/${instanceId}/resources?${stringifiedParams}`
    : `/v1/instances/${instanceId}/resources`;
};

export const runtimeServiceListResources = async (
  instanceId: string,
  params?: RuntimeServiceListResourcesParams,
  options?: RequestInit,
): Promise<runtimeServiceListResourcesResponse> => {
  return httpClient<runtimeServiceListResourcesResponse>(
    getRuntimeServiceListResourcesUrl(instanceId, params),
    {
      ...options,
      method: "GET",
    },
  );
};

export const getRuntimeServiceListResourcesQueryKey = (
  instanceId: string,
  params?: RuntimeServiceListResourcesParams,
) => {
  return [
    `/v1/instances/${instanceId}/resources`,
    ...(params ? [params] : []),
  ] as const;
};

export const getRuntimeServiceListResourcesQueryOptions = <
  TData = Awaited<ReturnType<typeof runtimeServiceListResources>>,
  TError = ErrorType<RpcStatus>,
>(
  instanceId: string,
  params?: RuntimeServiceListResourcesParams,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof runtimeServiceListResources>>,
        TError,
        TData
      >
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getRuntimeServiceListResourcesQueryKey(instanceId, params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof runtimeServiceListResources>>
  > = ({ signal }) =>
    runtimeServiceListResources(instanceId, params, { signal });

  return {
    queryKey,
    queryFn,
    enabled: !!instanceId,
    ...queryOptions,
  } as CreateQueryOptions<
    Awaited<ReturnType<typeof runtimeServiceListResources>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type RuntimeServiceListResourcesQueryResult = NonNullable<
  Awaited<ReturnType<typeof runtimeServiceListResources>>
>;
export type RuntimeServiceListResourcesQueryError = ErrorType<RpcStatus>;

/**
 * @summary ListResources lists the resources stored in the catalog
 */

export function createRuntimeServiceListResources<
  TData = Awaited<ReturnType<typeof runtimeServiceListResources>>,
  TError = ErrorType<RpcStatus>,
>(
  instanceId: () => string,
  params?: () => RuntimeServiceListResourcesParams,
  options?: () => {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof runtimeServiceListResources>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: () => QueryClient,
): CreateQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const query = createQuery(
    () =>
      getRuntimeServiceListResourcesQueryOptions(
        instanceId(),
        params?.(),
        options?.(),
      ),
    queryClient,
  ) as CreateQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  return query;
}

/**
 * @summary WatchResources streams updates to catalog resources (including creation and deletion events)
 */
export type runtimeServiceWatchResourcesResponse200 = {
  data: RuntimeServiceWatchResources200;
  status: 200;
};

export type runtimeServiceWatchResourcesResponseDefault = {
  data: RpcStatus;
  status: Exclude<HTTPStatusCodes, 200>;
};

export type runtimeServiceWatchResourcesResponseSuccess =
  runtimeServiceWatchResourcesResponse200 & {
    headers: Headers;
  };
export type runtimeServiceWatchResourcesResponseError =
  runtimeServiceWatchResourcesResponseDefault & {
    headers: Headers;
  };

export type runtimeServiceWatchResourcesResponse =
  | runtimeServiceWatchResourcesResponseSuccess
  | runtimeServiceWatchResourcesResponseError;

export const getRuntimeServiceWatchResourcesUrl = (
  instanceId: string,
  params?: RuntimeServiceWatchResourcesParams,
) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? "null" : value.toString());
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0
    ? `/v1/instances/${instanceId}/resources/-/watch?${stringifiedParams}`
    : `/v1/instances/${instanceId}/resources/-/watch`;
};

export const runtimeServiceWatchResources = async (
  instanceId: string,
  params?: RuntimeServiceWatchResourcesParams,
  options?: RequestInit,
): Promise<runtimeServiceWatchResourcesResponse> => {
  return httpClient<runtimeServiceWatchResourcesResponse>(
    getRuntimeServiceWatchResourcesUrl(instanceId, params),
    {
      ...options,
      method: "GET",
    },
  );
};

export const getRuntimeServiceWatchResourcesQueryKey = (
  instanceId: string,
  params?: RuntimeServiceWatchResourcesParams,
) => {
  return [
    `/v1/instances/${instanceId}/resources/-/watch`,
    ...(params ? [params] : []),
  ] as const;
};

export const getRuntimeServiceWatchResourcesQueryOptions = <
  TData = Awaited<ReturnType<typeof runtimeServiceWatchResources>>,
  TError = ErrorType<RpcStatus>,
>(
  instanceId: string,
  params?: RuntimeServiceWatchResourcesParams,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof runtimeServiceWatchResources>>,
        TError,
        TData
      >
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getRuntimeServiceWatchResourcesQueryKey(instanceId, params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof runtimeServiceWatchResources>>
  > = ({ signal }) =>
    runtimeServiceWatchResources(instanceId, params, { signal });

  return {
    queryKey,
    queryFn,
    enabled: !!instanceId,
    ...queryOptions,
  } as CreateQueryOptions<
    Awaited<ReturnType<typeof runtimeServiceWatchResources>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type RuntimeServiceWatchResourcesQueryResult = NonNullable<
  Awaited<ReturnType<typeof runtimeServiceWatchResources>>
>;
export type RuntimeServiceWatchResourcesQueryError = ErrorType<RpcStatus>;

/**
 * @summary WatchResources streams updates to catalog resources (including creation and deletion events)
 */

export function createRuntimeServiceWatchResources<
  TData = Awaited<ReturnType<typeof runtimeServiceWatchResources>>,
  TError = ErrorType<RpcStatus>,
>(
  instanceId: () => string,
  params?: () => RuntimeServiceWatchResourcesParams,
  options?: () => {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof runtimeServiceWatchResources>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: () => QueryClient,
): CreateQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const query = createQuery(
    () =>
      getRuntimeServiceWatchResourcesQueryOptions(
        instanceId(),
        params?.(),
        options?.(),
      ),
    queryClient,
  ) as CreateQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  return query;
}

/**
 * @summary GetExplore is a convenience RPC that combines looking up an Explore resource and its underlying MetricsView into one network call.
 */
export type runtimeServiceGetExploreResponse200 = {
  data: V1GetExploreResponse;
  status: 200;
};

export type runtimeServiceGetExploreResponseDefault = {
  data: RpcStatus;
  status: Exclude<HTTPStatusCodes, 200>;
};

export type runtimeServiceGetExploreResponseSuccess =
  runtimeServiceGetExploreResponse200 & {
    headers: Headers;
  };
export type runtimeServiceGetExploreResponseError =
  runtimeServiceGetExploreResponseDefault & {
    headers: Headers;
  };

export type runtimeServiceGetExploreResponse =
  | runtimeServiceGetExploreResponseSuccess
  | runtimeServiceGetExploreResponseError;

export const getRuntimeServiceGetExploreUrl = (
  instanceId: string,
  params?: RuntimeServiceGetExploreParams,
) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? "null" : value.toString());
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0
    ? `/v1/instances/${instanceId}/resources/explore?${stringifiedParams}`
    : `/v1/instances/${instanceId}/resources/explore`;
};

export const runtimeServiceGetExplore = async (
  instanceId: string,
  params?: RuntimeServiceGetExploreParams,
  options?: RequestInit,
): Promise<runtimeServiceGetExploreResponse> => {
  return httpClient<runtimeServiceGetExploreResponse>(
    getRuntimeServiceGetExploreUrl(instanceId, params),
    {
      ...options,
      method: "GET",
    },
  );
};

export const getRuntimeServiceGetExploreQueryKey = (
  instanceId: string,
  params?: RuntimeServiceGetExploreParams,
) => {
  return [
    `/v1/instances/${instanceId}/resources/explore`,
    ...(params ? [params] : []),
  ] as const;
};

export const getRuntimeServiceGetExploreQueryOptions = <
  TData = Awaited<ReturnType<typeof runtimeServiceGetExplore>>,
  TError = ErrorType<RpcStatus>,
>(
  instanceId: string,
  params?: RuntimeServiceGetExploreParams,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof runtimeServiceGetExplore>>,
        TError,
        TData
      >
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getRuntimeServiceGetExploreQueryKey(instanceId, params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof runtimeServiceGetExplore>>
  > = ({ signal }) => runtimeServiceGetExplore(instanceId, params, { signal });

  return {
    queryKey,
    queryFn,
    enabled: !!instanceId,
    ...queryOptions,
  } as CreateQueryOptions<
    Awaited<ReturnType<typeof runtimeServiceGetExplore>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type RuntimeServiceGetExploreQueryResult = NonNullable<
  Awaited<ReturnType<typeof runtimeServiceGetExplore>>
>;
export type RuntimeServiceGetExploreQueryError = ErrorType<RpcStatus>;

/**
 * @summary GetExplore is a convenience RPC that combines looking up an Explore resource and its underlying MetricsView into one network call.
 */

export function createRuntimeServiceGetExplore<
  TData = Awaited<ReturnType<typeof runtimeServiceGetExplore>>,
  TError = ErrorType<RpcStatus>,
>(
  instanceId: () => string,
  params?: () => RuntimeServiceGetExploreParams,
  options?: () => {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof runtimeServiceGetExplore>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: () => QueryClient,
): CreateQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const query = createQuery(
    () =>
      getRuntimeServiceGetExploreQueryOptions(
        instanceId(),
        params?.(),
        options?.(),
      ),
    queryClient,
  ) as CreateQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  return query;
}

/**
 * @summary CreateTrigger submits a refresh trigger, which will asynchronously refresh the specified resources.
Triggers are ephemeral resources that will be cleaned up by the controller.
 */
export type runtimeServiceCreateTriggerResponse200 = {
  data: V1CreateTriggerResponse;
  status: 200;
};

export type runtimeServiceCreateTriggerResponseDefault = {
  data: RpcStatus;
  status: Exclude<HTTPStatusCodes, 200>;
};

export type runtimeServiceCreateTriggerResponseSuccess =
  runtimeServiceCreateTriggerResponse200 & {
    headers: Headers;
  };
export type runtimeServiceCreateTriggerResponseError =
  runtimeServiceCreateTriggerResponseDefault & {
    headers: Headers;
  };

export type runtimeServiceCreateTriggerResponse =
  | runtimeServiceCreateTriggerResponseSuccess
  | runtimeServiceCreateTriggerResponseError;

export const getRuntimeServiceCreateTriggerUrl = (instanceId: string) => {
  return `/v1/instances/${instanceId}/trigger`;
};

export const runtimeServiceCreateTrigger = async (
  instanceId: string,
  runtimeServiceCreateTriggerBody: RuntimeServiceCreateTriggerBody,
  options?: RequestInit,
): Promise<runtimeServiceCreateTriggerResponse> => {
  return httpClient<runtimeServiceCreateTriggerResponse>(
    getRuntimeServiceCreateTriggerUrl(instanceId),
    {
      ...options,
      method: "POST",
      headers: { "Content-Type": "application/json", ...options?.headers },
      body: JSON.stringify(runtimeServiceCreateTriggerBody),
    },
  );
};

export const getRuntimeServiceCreateTriggerMutationOptions = <
  TError = ErrorType<RpcStatus>,
  TContext = unknown,
>(options?: {
  mutation?: CreateMutationOptions<
    Awaited<ReturnType<typeof runtimeServiceCreateTrigger>>,
    TError,
    { instanceId: string; data: RuntimeServiceCreateTriggerBody },
    TContext
  >;
}): CreateMutationOptions<
  Awaited<ReturnType<typeof runtimeServiceCreateTrigger>>,
  TError,
  { instanceId: string; data: RuntimeServiceCreateTriggerBody },
  TContext
> => {
  const mutationKey = ["runtimeServiceCreateTrigger"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof runtimeServiceCreateTrigger>>,
    { instanceId: string; data: RuntimeServiceCreateTriggerBody }
  > = (props) => {
    const { instanceId, data } = props ?? {};

    return runtimeServiceCreateTrigger(instanceId, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type RuntimeServiceCreateTriggerMutationResult = NonNullable<
  Awaited<ReturnType<typeof runtimeServiceCreateTrigger>>
>;
export type RuntimeServiceCreateTriggerMutationBody =
  RuntimeServiceCreateTriggerBody;
export type RuntimeServiceCreateTriggerMutationError = ErrorType<RpcStatus>;

/**
 * @summary CreateTrigger submits a refresh trigger, which will asynchronously refresh the specified resources.
Triggers are ephemeral resources that will be cleaned up by the controller.
 */
export const createRuntimeServiceCreateTrigger = <
  TError = ErrorType<RpcStatus>,
  TContext = unknown,
>(
  options?: () => {
    mutation?: CreateMutationOptions<
      Awaited<ReturnType<typeof runtimeServiceCreateTrigger>>,
      TError,
      { instanceId: string; data: RuntimeServiceCreateTriggerBody },
      TContext
    >;
  },
  queryClient?: () => QueryClient,
): CreateMutationResult<
  Awaited<ReturnType<typeof runtimeServiceCreateTrigger>>,
  TError,
  { instanceId: string; data: RuntimeServiceCreateTriggerBody },
  TContext
> => {
  return createMutation(
    () => ({ ...getRuntimeServiceCreateTriggerMutationOptions(options?.()) }),
    queryClient,
  );
};
/**
 * @summary AnalyzeVariables scans `Source`, `Model` and `Connector` resources in the catalog for use of an environment variable
 */
export type runtimeServiceAnalyzeVariablesResponse200 = {
  data: V1AnalyzeVariablesResponse;
  status: 200;
};

export type runtimeServiceAnalyzeVariablesResponseDefault = {
  data: RpcStatus;
  status: Exclude<HTTPStatusCodes, 200>;
};

export type runtimeServiceAnalyzeVariablesResponseSuccess =
  runtimeServiceAnalyzeVariablesResponse200 & {
    headers: Headers;
  };
export type runtimeServiceAnalyzeVariablesResponseError =
  runtimeServiceAnalyzeVariablesResponseDefault & {
    headers: Headers;
  };

export type runtimeServiceAnalyzeVariablesResponse =
  | runtimeServiceAnalyzeVariablesResponseSuccess
  | runtimeServiceAnalyzeVariablesResponseError;

export const getRuntimeServiceAnalyzeVariablesUrl = (instanceId: string) => {
  return `/v1/instances/${instanceId}/variables/analyze`;
};

export const runtimeServiceAnalyzeVariables = async (
  instanceId: string,
  options?: RequestInit,
): Promise<runtimeServiceAnalyzeVariablesResponse> => {
  return httpClient<runtimeServiceAnalyzeVariablesResponse>(
    getRuntimeServiceAnalyzeVariablesUrl(instanceId),
    {
      ...options,
      method: "GET",
    },
  );
};

export const getRuntimeServiceAnalyzeVariablesQueryKey = (
  instanceId: string,
) => {
  return [`/v1/instances/${instanceId}/variables/analyze`] as const;
};

export const getRuntimeServiceAnalyzeVariablesQueryOptions = <
  TData = Awaited<ReturnType<typeof runtimeServiceAnalyzeVariables>>,
  TError = ErrorType<RpcStatus>,
>(
  instanceId: string,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof runtimeServiceAnalyzeVariables>>,
        TError,
        TData
      >
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getRuntimeServiceAnalyzeVariablesQueryKey(instanceId);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof runtimeServiceAnalyzeVariables>>
  > = ({ signal }) => runtimeServiceAnalyzeVariables(instanceId, { signal });

  return {
    queryKey,
    queryFn,
    enabled: !!instanceId,
    ...queryOptions,
  } as CreateQueryOptions<
    Awaited<ReturnType<typeof runtimeServiceAnalyzeVariables>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type RuntimeServiceAnalyzeVariablesQueryResult = NonNullable<
  Awaited<ReturnType<typeof runtimeServiceAnalyzeVariables>>
>;
export type RuntimeServiceAnalyzeVariablesQueryError = ErrorType<RpcStatus>;

/**
 * @summary AnalyzeVariables scans `Source`, `Model` and `Connector` resources in the catalog for use of an environment variable
 */

export function createRuntimeServiceAnalyzeVariables<
  TData = Awaited<ReturnType<typeof runtimeServiceAnalyzeVariables>>,
  TError = ErrorType<RpcStatus>,
>(
  instanceId: () => string,
  options?: () => {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof runtimeServiceAnalyzeVariables>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: () => QueryClient,
): CreateQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const query = createQuery(
    () =>
      getRuntimeServiceAnalyzeVariablesQueryOptions(instanceId(), options?.()),
    queryClient,
  ) as CreateQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  return query;
}

/**
 * @summary Ping returns information about the runtime
 */
export type runtimeServicePingResponse200 = {
  data: V1PingResponse;
  status: 200;
};

export type runtimeServicePingResponseDefault = {
  data: RpcStatus;
  status: Exclude<HTTPStatusCodes, 200>;
};

export type runtimeServicePingResponseSuccess =
  runtimeServicePingResponse200 & {
    headers: Headers;
  };
export type runtimeServicePingResponseError =
  runtimeServicePingResponseDefault & {
    headers: Headers;
  };

export type runtimeServicePingResponse =
  | runtimeServicePingResponseSuccess
  | runtimeServicePingResponseError;

export const getRuntimeServicePingUrl = () => {
  return `/v1/ping`;
};

export const runtimeServicePing = async (
  options?: RequestInit,
): Promise<runtimeServicePingResponse> => {
  return httpClient<runtimeServicePingResponse>(getRuntimeServicePingUrl(), {
    ...options,
    method: "GET",
  });
};

export const getRuntimeServicePingQueryKey = () => {
  return [`/v1/ping`] as const;
};

export const getRuntimeServicePingQueryOptions = <
  TData = Awaited<ReturnType<typeof runtimeServicePing>>,
  TError = ErrorType<RpcStatus>,
>(options?: {
  query?: Partial<
    CreateQueryOptions<
      Awaited<ReturnType<typeof runtimeServicePing>>,
      TError,
      TData
    >
  >;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getRuntimeServicePingQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof runtimeServicePing>>
  > = ({ signal }) => runtimeServicePing({ signal });

  return { queryKey, queryFn, ...queryOptions } as CreateQueryOptions<
    Awaited<ReturnType<typeof runtimeServicePing>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type RuntimeServicePingQueryResult = NonNullable<
  Awaited<ReturnType<typeof runtimeServicePing>>
>;
export type RuntimeServicePingQueryError = ErrorType<RpcStatus>;

/**
 * @summary Ping returns information about the runtime
 */

export function createRuntimeServicePing<
  TData = Awaited<ReturnType<typeof runtimeServicePing>>,
  TError = ErrorType<RpcStatus>,
>(
  options?: () => {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof runtimeServicePing>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: () => QueryClient,
): CreateQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const query = createQuery(
    () => getRuntimeServicePingQueryOptions(options?.()),
    queryClient,
  ) as CreateQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  return query;
}

/**
 * Generated by orval v6.10.1 ðŸº
 * Do not edit manually.
 * rill/runtime/v1/schema.proto
 * OpenAPI spec version: version not set
 */
import { useQuery, useMutation } from "@sveltestack/svelte-query";
import type {
  UseQueryOptions,
  UseMutationOptions,
  QueryFunction,
  MutationFunction,
  UseQueryStoreResult,
  QueryKey,
} from "@sveltestack/svelte-query";
import type {
  V1ListConnectorsResponse,
  RpcStatus,
  V1DeleteFileAndMigrateResponse,
  V1DeleteFileAndMigrateRequest,
  V1ListInstancesResponse,
  RuntimeServiceListInstancesParams,
  V1CreateInstanceResponse,
  V1CreateInstanceRequest,
  V1GetInstanceResponse,
  V1DeleteInstanceResponse,
  V1ListCatalogEntriesResponse,
  RuntimeServiceListCatalogEntriesParams,
  V1GetCatalogEntryResponse,
  V1TriggerRefreshResponse,
  V1MetricsViewTimeSeriesResponse,
  RuntimeServiceMetricsViewTimeSeriesBody,
  V1MetricsViewToplistResponse,
  RuntimeServiceMetricsViewToplistBody,
  V1MetricsViewTotalsResponse,
  RuntimeServiceMetricsViewTotalsBody,
  V1MigrateResponse,
  RuntimeServiceMigrateBody,
  V1GetTableCardinalityResponse,
  V1GetCardinalityOfColumnResponse,
  V1ProfileColumnsResponse,
  V1GetDescriptiveStatisticsResponse,
  V1GetNullCountResponse,
  V1GetNumericHistogramResponse,
  V1EstimateRollupIntervalResponse,
  RuntimeServiceEstimateRollupIntervalBody,
  V1GetTableRowsResponse,
  RuntimeServiceGetTableRowsParams,
  V1GetRugHistogramResponse,
  V1EstimateSmallestTimeGrainResponse,
  V1GetTimeRangeSummaryResponse,
  V1GenerateTimeSeriesResponse,
  RuntimeServiceGenerateTimeSeriesBody,
  V1GetTopKResponse,
  RuntimeServiceGetTopKBody,
  V1QueryResponse,
  RuntimeServiceQueryBody,
  V1QueryDirectResponse,
  RuntimeServiceQueryDirectBody,
  V1TriggerSyncResponse,
  V1PingResponse,
  V1PutFileAndMigrateResponse,
  V1PutFileAndMigrateRequest,
  V1RenameFileAndMigrateResponse,
  V1RenameFileAndMigrateRequest,
  V1ListReposResponse,
  RuntimeServiceListReposParams,
  V1CreateRepoResponse,
  V1CreateRepoRequest,
  V1GetRepoResponse,
  V1DeleteRepoResponse,
  V1ListFilesResponse,
  RuntimeServiceListFilesParams,
  V1GetFileResponse,
  V1DeleteFileResponse,
  V1PutFileResponse,
  RuntimeServicePutFileBody,
  V1RenameFileResponse,
  RuntimeServiceRenameFileBody,
} from "../index.schemas";
import { httpClient } from "../../http-client";

/**
 * @summary ListConnectors returns a description of all the connectors implemented in the runtime,
including their schema and validation rules
 */
export const runtimeServiceListConnectors = (signal?: AbortSignal) => {
  return httpClient<V1ListConnectorsResponse>({
    url: `/v1/connectors/meta`,
    method: "get",
    signal,
  });
};

export const getRuntimeServiceListConnectorsQueryKey = () => [
  `/v1/connectors/meta`,
];

export type RuntimeServiceListConnectorsQueryResult = NonNullable<
  Awaited<ReturnType<typeof runtimeServiceListConnectors>>
>;
export type RuntimeServiceListConnectorsQueryError = RpcStatus;

export const useRuntimeServiceListConnectors = <
  TData = Awaited<ReturnType<typeof runtimeServiceListConnectors>>,
  TError = RpcStatus
>(options?: {
  query?: UseQueryOptions<
    Awaited<ReturnType<typeof runtimeServiceListConnectors>>,
    TError,
    TData
  >;
}): UseQueryStoreResult<
  Awaited<ReturnType<typeof runtimeServiceListConnectors>>,
  TError,
  TData,
  QueryKey
> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getRuntimeServiceListConnectorsQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof runtimeServiceListConnectors>>
  > = ({ signal }) => runtimeServiceListConnectors(signal);

  const query = useQuery<
    Awaited<ReturnType<typeof runtimeServiceListConnectors>>,
    TError,
    TData
  >(queryKey, queryFn, queryOptions) as UseQueryStoreResult<
    Awaited<ReturnType<typeof runtimeServiceListConnectors>>,
    TError,
    TData,
    QueryKey
  > & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
};

/**
 * @summary DeleteFileAndMigrate combines RenameFile and Migrate in a single endpoint to reduce latency.
 */
export const runtimeServiceDeleteFileAndMigrate = (
  v1DeleteFileAndMigrateRequest: V1DeleteFileAndMigrateRequest
) => {
  return httpClient<V1DeleteFileAndMigrateResponse>({
    url: `/v1/delete-and-migrate`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: v1DeleteFileAndMigrateRequest,
  });
};

export type RuntimeServiceDeleteFileAndMigrateMutationResult = NonNullable<
  Awaited<ReturnType<typeof runtimeServiceDeleteFileAndMigrate>>
>;
export type RuntimeServiceDeleteFileAndMigrateMutationBody =
  V1DeleteFileAndMigrateRequest;
export type RuntimeServiceDeleteFileAndMigrateMutationError = RpcStatus;

export const useRuntimeServiceDeleteFileAndMigrate = <
  TError = RpcStatus,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof runtimeServiceDeleteFileAndMigrate>>,
    TError,
    { data: V1DeleteFileAndMigrateRequest },
    TContext
  >;
}) => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof runtimeServiceDeleteFileAndMigrate>>,
    { data: V1DeleteFileAndMigrateRequest }
  > = (props) => {
    const { data } = props ?? {};

    return runtimeServiceDeleteFileAndMigrate(data);
  };

  return useMutation<
    Awaited<ReturnType<typeof runtimeServiceDeleteFileAndMigrate>>,
    TError,
    { data: V1DeleteFileAndMigrateRequest },
    TContext
  >(mutationFn, mutationOptions);
};
/**
 * @summary ListInstances lists all the instances currently managed by the runtime
 */
export const runtimeServiceListInstances = (
  params?: RuntimeServiceListInstancesParams,
  signal?: AbortSignal
) => {
  return httpClient<V1ListInstancesResponse>({
    url: `/v1/instances`,
    method: "get",
    params,
    signal,
  });
};

export const getRuntimeServiceListInstancesQueryKey = (
  params?: RuntimeServiceListInstancesParams
) => [`/v1/instances`, ...(params ? [params] : [])];

export type RuntimeServiceListInstancesQueryResult = NonNullable<
  Awaited<ReturnType<typeof runtimeServiceListInstances>>
>;
export type RuntimeServiceListInstancesQueryError = RpcStatus;

export const useRuntimeServiceListInstances = <
  TData = Awaited<ReturnType<typeof runtimeServiceListInstances>>,
  TError = RpcStatus
>(
  params?: RuntimeServiceListInstancesParams,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof runtimeServiceListInstances>>,
      TError,
      TData
    >;
  }
): UseQueryStoreResult<
  Awaited<ReturnType<typeof runtimeServiceListInstances>>,
  TError,
  TData,
  QueryKey
> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getRuntimeServiceListInstancesQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof runtimeServiceListInstances>>
  > = ({ signal }) => runtimeServiceListInstances(params, signal);

  const query = useQuery<
    Awaited<ReturnType<typeof runtimeServiceListInstances>>,
    TError,
    TData
  >(queryKey, queryFn, queryOptions) as UseQueryStoreResult<
    Awaited<ReturnType<typeof runtimeServiceListInstances>>,
    TError,
    TData,
    QueryKey
  > & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
};

/**
 * @summary CreateInstance creates a new instance
 */
export const runtimeServiceCreateInstance = (
  v1CreateInstanceRequest: V1CreateInstanceRequest
) => {
  return httpClient<V1CreateInstanceResponse>({
    url: `/v1/instances`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: v1CreateInstanceRequest,
  });
};

export type RuntimeServiceCreateInstanceMutationResult = NonNullable<
  Awaited<ReturnType<typeof runtimeServiceCreateInstance>>
>;
export type RuntimeServiceCreateInstanceMutationBody = V1CreateInstanceRequest;
export type RuntimeServiceCreateInstanceMutationError = RpcStatus;

export const useRuntimeServiceCreateInstance = <
  TError = RpcStatus,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof runtimeServiceCreateInstance>>,
    TError,
    { data: V1CreateInstanceRequest },
    TContext
  >;
}) => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof runtimeServiceCreateInstance>>,
    { data: V1CreateInstanceRequest }
  > = (props) => {
    const { data } = props ?? {};

    return runtimeServiceCreateInstance(data);
  };

  return useMutation<
    Awaited<ReturnType<typeof runtimeServiceCreateInstance>>,
    TError,
    { data: V1CreateInstanceRequest },
    TContext
  >(mutationFn, mutationOptions);
};
/**
 * @summary GetInstance returns information about a specific instance
 */
export const runtimeServiceGetInstance = (
  instanceId: string,
  signal?: AbortSignal
) => {
  return httpClient<V1GetInstanceResponse>({
    url: `/v1/instances/${instanceId}`,
    method: "get",
    signal,
  });
};

export const getRuntimeServiceGetInstanceQueryKey = (instanceId: string) => [
  `/v1/instances/${instanceId}`,
];

export type RuntimeServiceGetInstanceQueryResult = NonNullable<
  Awaited<ReturnType<typeof runtimeServiceGetInstance>>
>;
export type RuntimeServiceGetInstanceQueryError = RpcStatus;

export const useRuntimeServiceGetInstance = <
  TData = Awaited<ReturnType<typeof runtimeServiceGetInstance>>,
  TError = RpcStatus
>(
  instanceId: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof runtimeServiceGetInstance>>,
      TError,
      TData
    >;
  }
): UseQueryStoreResult<
  Awaited<ReturnType<typeof runtimeServiceGetInstance>>,
  TError,
  TData,
  QueryKey
> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getRuntimeServiceGetInstanceQueryKey(instanceId);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof runtimeServiceGetInstance>>
  > = ({ signal }) => runtimeServiceGetInstance(instanceId, signal);

  const query = useQuery<
    Awaited<ReturnType<typeof runtimeServiceGetInstance>>,
    TError,
    TData
  >(queryKey, queryFn, {
    enabled: !!instanceId,
    ...queryOptions,
  }) as UseQueryStoreResult<
    Awaited<ReturnType<typeof runtimeServiceGetInstance>>,
    TError,
    TData,
    QueryKey
  > & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
};

/**
 * @summary DeleteInstance deletes an instance
 */
export const runtimeServiceDeleteInstance = (instanceId: string) => {
  return httpClient<V1DeleteInstanceResponse>({
    url: `/v1/instances/${instanceId}`,
    method: "delete",
  });
};

export type RuntimeServiceDeleteInstanceMutationResult = NonNullable<
  Awaited<ReturnType<typeof runtimeServiceDeleteInstance>>
>;

export type RuntimeServiceDeleteInstanceMutationError = RpcStatus;

export const useRuntimeServiceDeleteInstance = <
  TError = RpcStatus,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof runtimeServiceDeleteInstance>>,
    TError,
    { instanceId: string },
    TContext
  >;
}) => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof runtimeServiceDeleteInstance>>,
    { instanceId: string }
  > = (props) => {
    const { instanceId } = props ?? {};

    return runtimeServiceDeleteInstance(instanceId);
  };

  return useMutation<
    Awaited<ReturnType<typeof runtimeServiceDeleteInstance>>,
    TError,
    { instanceId: string },
    TContext
  >(mutationFn, mutationOptions);
};
/**
 * @summary ListCatalogEntries lists all the entries registered in an instance's catalog (like tables, sources or metrics views)
 */
export const runtimeServiceListCatalogEntries = (
  instanceId: string,
  params?: RuntimeServiceListCatalogEntriesParams,
  signal?: AbortSignal
) => {
  return httpClient<V1ListCatalogEntriesResponse>({
    url: `/v1/instances/${instanceId}/catalog`,
    method: "get",
    params,
    signal,
  });
};

export const getRuntimeServiceListCatalogEntriesQueryKey = (
  instanceId: string,
  params?: RuntimeServiceListCatalogEntriesParams
) => [`/v1/instances/${instanceId}/catalog`, ...(params ? [params] : [])];

export type RuntimeServiceListCatalogEntriesQueryResult = NonNullable<
  Awaited<ReturnType<typeof runtimeServiceListCatalogEntries>>
>;
export type RuntimeServiceListCatalogEntriesQueryError = RpcStatus;

export const useRuntimeServiceListCatalogEntries = <
  TData = Awaited<ReturnType<typeof runtimeServiceListCatalogEntries>>,
  TError = RpcStatus
>(
  instanceId: string,
  params?: RuntimeServiceListCatalogEntriesParams,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof runtimeServiceListCatalogEntries>>,
      TError,
      TData
    >;
  }
): UseQueryStoreResult<
  Awaited<ReturnType<typeof runtimeServiceListCatalogEntries>>,
  TError,
  TData,
  QueryKey
> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getRuntimeServiceListCatalogEntriesQueryKey(instanceId, params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof runtimeServiceListCatalogEntries>>
  > = ({ signal }) =>
    runtimeServiceListCatalogEntries(instanceId, params, signal);

  const query = useQuery<
    Awaited<ReturnType<typeof runtimeServiceListCatalogEntries>>,
    TError,
    TData
  >(queryKey, queryFn, {
    enabled: !!instanceId,
    ...queryOptions,
  }) as UseQueryStoreResult<
    Awaited<ReturnType<typeof runtimeServiceListCatalogEntries>>,
    TError,
    TData,
    QueryKey
  > & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
};

/**
 * @summary GetCatalogEntry returns information about a specific entry in the catalog
 */
export const runtimeServiceGetCatalogEntry = (
  instanceId: string,
  name: string,
  signal?: AbortSignal
) => {
  return httpClient<V1GetCatalogEntryResponse>({
    url: `/v1/instances/${instanceId}/catalog/${name}`,
    method: "get",
    signal,
  });
};

export const getRuntimeServiceGetCatalogEntryQueryKey = (
  instanceId: string,
  name: string
) => [`/v1/instances/${instanceId}/catalog/${name}`];

export type RuntimeServiceGetCatalogEntryQueryResult = NonNullable<
  Awaited<ReturnType<typeof runtimeServiceGetCatalogEntry>>
>;
export type RuntimeServiceGetCatalogEntryQueryError = RpcStatus;

export const useRuntimeServiceGetCatalogEntry = <
  TData = Awaited<ReturnType<typeof runtimeServiceGetCatalogEntry>>,
  TError = RpcStatus
>(
  instanceId: string,
  name: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof runtimeServiceGetCatalogEntry>>,
      TError,
      TData
    >;
  }
): UseQueryStoreResult<
  Awaited<ReturnType<typeof runtimeServiceGetCatalogEntry>>,
  TError,
  TData,
  QueryKey
> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getRuntimeServiceGetCatalogEntryQueryKey(instanceId, name);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof runtimeServiceGetCatalogEntry>>
  > = ({ signal }) => runtimeServiceGetCatalogEntry(instanceId, name, signal);

  const query = useQuery<
    Awaited<ReturnType<typeof runtimeServiceGetCatalogEntry>>,
    TError,
    TData
  >(queryKey, queryFn, {
    enabled: !!(instanceId && name),
    ...queryOptions,
  }) as UseQueryStoreResult<
    Awaited<ReturnType<typeof runtimeServiceGetCatalogEntry>>,
    TError,
    TData,
    QueryKey
  > & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
};

/**
 * @summary TriggerRefresh triggers a refresh of a refreshable catalog object.
It currently only supports sources (which will be re-ingested), but will also support materialized models in the future.
It does not respond until the refresh has completed (will move to async jobs when the task scheduler is in place).
 */
export const runtimeServiceTriggerRefresh = (
  instanceId: string,
  name: string
) => {
  return httpClient<V1TriggerRefreshResponse>({
    url: `/v1/instances/${instanceId}/catalog/${name}/refresh`,
    method: "post",
  });
};

export type RuntimeServiceTriggerRefreshMutationResult = NonNullable<
  Awaited<ReturnType<typeof runtimeServiceTriggerRefresh>>
>;

export type RuntimeServiceTriggerRefreshMutationError = RpcStatus;

export const useRuntimeServiceTriggerRefresh = <
  TError = RpcStatus,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof runtimeServiceTriggerRefresh>>,
    TError,
    { instanceId: string; name: string },
    TContext
  >;
}) => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof runtimeServiceTriggerRefresh>>,
    { instanceId: string; name: string }
  > = (props) => {
    const { instanceId, name } = props ?? {};

    return runtimeServiceTriggerRefresh(instanceId, name);
  };

  return useMutation<
    Awaited<ReturnType<typeof runtimeServiceTriggerRefresh>>,
    TError,
    { instanceId: string; name: string },
    TContext
  >(mutationFn, mutationOptions);
};
/**
 * @summary MetricsViewTimeSeries returns time series for the measures in the metrics view.
It's a convenience API for querying a metrics view.
 */
export const runtimeServiceMetricsViewTimeSeries = (
  instanceId: string,
  metricsViewName: string,
  runtimeServiceMetricsViewTimeSeriesBody: RuntimeServiceMetricsViewTimeSeriesBody
) => {
  return httpClient<V1MetricsViewTimeSeriesResponse>({
    url: `/v1/instances/${instanceId}/metrics-views/${metricsViewName}/timeseries`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: runtimeServiceMetricsViewTimeSeriesBody,
  });
};

export type RuntimeServiceMetricsViewTimeSeriesMutationResult = NonNullable<
  Awaited<ReturnType<typeof runtimeServiceMetricsViewTimeSeries>>
>;
export type RuntimeServiceMetricsViewTimeSeriesMutationBody =
  RuntimeServiceMetricsViewTimeSeriesBody;
export type RuntimeServiceMetricsViewTimeSeriesMutationError = RpcStatus;

export const useRuntimeServiceMetricsViewTimeSeries = <
  TError = RpcStatus,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof runtimeServiceMetricsViewTimeSeries>>,
    TError,
    {
      instanceId: string;
      metricsViewName: string;
      data: RuntimeServiceMetricsViewTimeSeriesBody;
    },
    TContext
  >;
}) => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof runtimeServiceMetricsViewTimeSeries>>,
    {
      instanceId: string;
      metricsViewName: string;
      data: RuntimeServiceMetricsViewTimeSeriesBody;
    }
  > = (props) => {
    const { instanceId, metricsViewName, data } = props ?? {};

    return runtimeServiceMetricsViewTimeSeries(
      instanceId,
      metricsViewName,
      data
    );
  };

  return useMutation<
    Awaited<ReturnType<typeof runtimeServiceMetricsViewTimeSeries>>,
    TError,
    {
      instanceId: string;
      metricsViewName: string;
      data: RuntimeServiceMetricsViewTimeSeriesBody;
    },
    TContext
  >(mutationFn, mutationOptions);
};
/**
 * @summary MetricsViewToplist returns the top dimension values of a metrics view sorted by one or more measures.
It's a convenience API for querying a metrics view.
 */
export const runtimeServiceMetricsViewToplist = (
  instanceId: string,
  metricsViewName: string,
  dimensionName: string,
  runtimeServiceMetricsViewToplistBody: RuntimeServiceMetricsViewToplistBody
) => {
  return httpClient<V1MetricsViewToplistResponse>({
    url: `/v1/instances/${instanceId}/metrics-views/${metricsViewName}/toplist/${dimensionName}`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: runtimeServiceMetricsViewToplistBody,
  });
};

export type RuntimeServiceMetricsViewToplistMutationResult = NonNullable<
  Awaited<ReturnType<typeof runtimeServiceMetricsViewToplist>>
>;
export type RuntimeServiceMetricsViewToplistMutationBody =
  RuntimeServiceMetricsViewToplistBody;
export type RuntimeServiceMetricsViewToplistMutationError = RpcStatus;

export const useRuntimeServiceMetricsViewToplist = <
  TError = RpcStatus,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof runtimeServiceMetricsViewToplist>>,
    TError,
    {
      instanceId: string;
      metricsViewName: string;
      dimensionName: string;
      data: RuntimeServiceMetricsViewToplistBody;
    },
    TContext
  >;
}) => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof runtimeServiceMetricsViewToplist>>,
    {
      instanceId: string;
      metricsViewName: string;
      dimensionName: string;
      data: RuntimeServiceMetricsViewToplistBody;
    }
  > = (props) => {
    const { instanceId, metricsViewName, dimensionName, data } = props ?? {};

    return runtimeServiceMetricsViewToplist(
      instanceId,
      metricsViewName,
      dimensionName,
      data
    );
  };

  return useMutation<
    Awaited<ReturnType<typeof runtimeServiceMetricsViewToplist>>,
    TError,
    {
      instanceId: string;
      metricsViewName: string;
      dimensionName: string;
      data: RuntimeServiceMetricsViewToplistBody;
    },
    TContext
  >(mutationFn, mutationOptions);
};
/**
 * @summary MetricsViewTotals returns totals over a time period for the measures in a metrics view.
It's a convenience API for querying a metrics view.
 */
export const runtimeServiceMetricsViewTotals = (
  instanceId: string,
  metricsViewName: string,
  runtimeServiceMetricsViewTotalsBody: RuntimeServiceMetricsViewTotalsBody
) => {
  return httpClient<V1MetricsViewTotalsResponse>({
    url: `/v1/instances/${instanceId}/metrics-views/${metricsViewName}/totals`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: runtimeServiceMetricsViewTotalsBody,
  });
};

export type RuntimeServiceMetricsViewTotalsMutationResult = NonNullable<
  Awaited<ReturnType<typeof runtimeServiceMetricsViewTotals>>
>;
export type RuntimeServiceMetricsViewTotalsMutationBody =
  RuntimeServiceMetricsViewTotalsBody;
export type RuntimeServiceMetricsViewTotalsMutationError = RpcStatus;

export const useRuntimeServiceMetricsViewTotals = <
  TError = RpcStatus,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof runtimeServiceMetricsViewTotals>>,
    TError,
    {
      instanceId: string;
      metricsViewName: string;
      data: RuntimeServiceMetricsViewTotalsBody;
    },
    TContext
  >;
}) => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof runtimeServiceMetricsViewTotals>>,
    {
      instanceId: string;
      metricsViewName: string;
      data: RuntimeServiceMetricsViewTotalsBody;
    }
  > = (props) => {
    const { instanceId, metricsViewName, data } = props ?? {};

    return runtimeServiceMetricsViewTotals(instanceId, metricsViewName, data);
  };

  return useMutation<
    Awaited<ReturnType<typeof runtimeServiceMetricsViewTotals>>,
    TError,
    {
      instanceId: string;
      metricsViewName: string;
      data: RuntimeServiceMetricsViewTotalsBody;
    },
    TContext
  >(mutationFn, mutationOptions);
};
/**
 * @summary Migrate applies a full set of artifacts from a repo to the catalog and infra.
It attempts to infer a minimal number of migrations to apply to reconcile the current state with
the desired state expressed in the artifacts. Any existing objects not described in the submitted
artifacts will be deleted.
 */
export const runtimeServiceMigrate = (
  instanceId: string,
  runtimeServiceMigrateBody: RuntimeServiceMigrateBody
) => {
  return httpClient<V1MigrateResponse>({
    url: `/v1/instances/${instanceId}/migrate`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: runtimeServiceMigrateBody,
  });
};

export type RuntimeServiceMigrateMutationResult = NonNullable<
  Awaited<ReturnType<typeof runtimeServiceMigrate>>
>;
export type RuntimeServiceMigrateMutationBody = RuntimeServiceMigrateBody;
export type RuntimeServiceMigrateMutationError = RpcStatus;

export const useRuntimeServiceMigrate = <
  TError = RpcStatus,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof runtimeServiceMigrate>>,
    TError,
    { instanceId: string; data: RuntimeServiceMigrateBody },
    TContext
  >;
}) => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof runtimeServiceMigrate>>,
    { instanceId: string; data: RuntimeServiceMigrateBody }
  > = (props) => {
    const { instanceId, data } = props ?? {};

    return runtimeServiceMigrate(instanceId, data);
  };

  return useMutation<
    Awaited<ReturnType<typeof runtimeServiceMigrate>>,
    TError,
    { instanceId: string; data: RuntimeServiceMigrateBody },
    TContext
  >(mutationFn, mutationOptions);
};
/**
 * @summary TableCardinality (TODO: add description)
 */
export const runtimeServiceGetTableCardinality = (
  instanceId: string,
  tableName: string,
  signal?: AbortSignal
) => {
  return httpClient<V1GetTableCardinalityResponse>({
    url: `/v1/instances/${instanceId}/queries/cardinality/tables/${tableName}`,
    method: "get",
    signal,
  });
};

export const getRuntimeServiceGetTableCardinalityQueryKey = (
  instanceId: string,
  tableName: string
) => [`/v1/instances/${instanceId}/queries/cardinality/tables/${tableName}`];

export type RuntimeServiceGetTableCardinalityQueryResult = NonNullable<
  Awaited<ReturnType<typeof runtimeServiceGetTableCardinality>>
>;
export type RuntimeServiceGetTableCardinalityQueryError = RpcStatus;

export const useRuntimeServiceGetTableCardinality = <
  TData = Awaited<ReturnType<typeof runtimeServiceGetTableCardinality>>,
  TError = RpcStatus
>(
  instanceId: string,
  tableName: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof runtimeServiceGetTableCardinality>>,
      TError,
      TData
    >;
  }
): UseQueryStoreResult<
  Awaited<ReturnType<typeof runtimeServiceGetTableCardinality>>,
  TError,
  TData,
  QueryKey
> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getRuntimeServiceGetTableCardinalityQueryKey(instanceId, tableName);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof runtimeServiceGetTableCardinality>>
  > = ({ signal }) =>
    runtimeServiceGetTableCardinality(instanceId, tableName, signal);

  const query = useQuery<
    Awaited<ReturnType<typeof runtimeServiceGetTableCardinality>>,
    TError,
    TData
  >(queryKey, queryFn, {
    enabled: !!(instanceId && tableName),
    ...queryOptions,
  }) as UseQueryStoreResult<
    Awaited<ReturnType<typeof runtimeServiceGetTableCardinality>>,
    TError,
    TData,
    QueryKey
  > & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
};

/**
 * @summary Get cardinality for a column
 */
export const runtimeServiceGetCardinalityOfColumn = (
  instanceId: string,
  tableName: string,
  columnName: string,
  signal?: AbortSignal
) => {
  return httpClient<V1GetCardinalityOfColumnResponse>({
    url: `/v1/instances/${instanceId}/queries/cardinality/tables/${tableName}/columns/${columnName}`,
    method: "get",
    signal,
  });
};

export const getRuntimeServiceGetCardinalityOfColumnQueryKey = (
  instanceId: string,
  tableName: string,
  columnName: string
) => [
  `/v1/instances/${instanceId}/queries/cardinality/tables/${tableName}/columns/${columnName}`,
];

export type RuntimeServiceGetCardinalityOfColumnQueryResult = NonNullable<
  Awaited<ReturnType<typeof runtimeServiceGetCardinalityOfColumn>>
>;
export type RuntimeServiceGetCardinalityOfColumnQueryError = RpcStatus;

export const useRuntimeServiceGetCardinalityOfColumn = <
  TData = Awaited<ReturnType<typeof runtimeServiceGetCardinalityOfColumn>>,
  TError = RpcStatus
>(
  instanceId: string,
  tableName: string,
  columnName: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof runtimeServiceGetCardinalityOfColumn>>,
      TError,
      TData
    >;
  }
): UseQueryStoreResult<
  Awaited<ReturnType<typeof runtimeServiceGetCardinalityOfColumn>>,
  TError,
  TData,
  QueryKey
> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getRuntimeServiceGetCardinalityOfColumnQueryKey(
      instanceId,
      tableName,
      columnName
    );

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof runtimeServiceGetCardinalityOfColumn>>
  > = ({ signal }) =>
    runtimeServiceGetCardinalityOfColumn(
      instanceId,
      tableName,
      columnName,
      signal
    );

  const query = useQuery<
    Awaited<ReturnType<typeof runtimeServiceGetCardinalityOfColumn>>,
    TError,
    TData
  >(queryKey, queryFn, {
    enabled: !!(instanceId && tableName && columnName),
    ...queryOptions,
  }) as UseQueryStoreResult<
    Awaited<ReturnType<typeof runtimeServiceGetCardinalityOfColumn>>,
    TError,
    TData,
    QueryKey
  > & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
};

/**
 * @summary ProfileColumns (TODO: add description)
 */
export const runtimeServiceProfileColumns = (
  instanceId: string,
  tableName: string
) => {
  return httpClient<V1ProfileColumnsResponse>({
    url: `/v1/instances/${instanceId}/queries/columns-profile/tables/${tableName}`,
    method: "post",
  });
};

export const getRuntimeServiceProfileColumnsQueryKey = (
  instanceId: string,
  tableName: string
) => [
  `/v1/instances/${instanceId}/queries/columns-profile/tables/${tableName}`,
];

export type RuntimeServiceProfileColumnsQueryResult = NonNullable<
  Awaited<ReturnType<typeof runtimeServiceProfileColumns>>
>;
export type RuntimeServiceProfileColumnsQueryError = RpcStatus;

export const useRuntimeServiceProfileColumns = <
  TData = Awaited<ReturnType<typeof runtimeServiceProfileColumns>>,
  TError = RpcStatus
>(
  instanceId: string,
  tableName: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof runtimeServiceProfileColumns>>,
      TError,
      TData
    >;
  }
): UseQueryStoreResult<
  Awaited<ReturnType<typeof runtimeServiceProfileColumns>>,
  TError,
  TData,
  QueryKey
> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getRuntimeServiceProfileColumnsQueryKey(instanceId, tableName);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof runtimeServiceProfileColumns>>
  > = () => runtimeServiceProfileColumns(instanceId, tableName);

  const query = useQuery<
    Awaited<ReturnType<typeof runtimeServiceProfileColumns>>,
    TError,
    TData
  >(queryKey, queryFn, {
    enabled: !!(instanceId && tableName),
    ...queryOptions,
  }) as UseQueryStoreResult<
    Awaited<ReturnType<typeof runtimeServiceProfileColumns>>,
    TError,
    TData,
    QueryKey
  > & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
};

/**
 * @summary Get basic stats for a numeric column like min, max, mean, stddev, etc
 */
export const runtimeServiceGetDescriptiveStatistics = (
  instanceId: string,
  tableName: string,
  columnName: string,
  signal?: AbortSignal
) => {
  return httpClient<V1GetDescriptiveStatisticsResponse>({
    url: `/v1/instances/${instanceId}/queries/descriptive-statistics/tables/${tableName}/columns/${columnName}`,
    method: "get",
    signal,
  });
};

export const getRuntimeServiceGetDescriptiveStatisticsQueryKey = (
  instanceId: string,
  tableName: string,
  columnName: string
) => [
  `/v1/instances/${instanceId}/queries/descriptive-statistics/tables/${tableName}/columns/${columnName}`,
];

export type RuntimeServiceGetDescriptiveStatisticsQueryResult = NonNullable<
  Awaited<ReturnType<typeof runtimeServiceGetDescriptiveStatistics>>
>;
export type RuntimeServiceGetDescriptiveStatisticsQueryError = RpcStatus;

export const useRuntimeServiceGetDescriptiveStatistics = <
  TData = Awaited<ReturnType<typeof runtimeServiceGetDescriptiveStatistics>>,
  TError = RpcStatus
>(
  instanceId: string,
  tableName: string,
  columnName: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof runtimeServiceGetDescriptiveStatistics>>,
      TError,
      TData
    >;
  }
): UseQueryStoreResult<
  Awaited<ReturnType<typeof runtimeServiceGetDescriptiveStatistics>>,
  TError,
  TData,
  QueryKey
> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getRuntimeServiceGetDescriptiveStatisticsQueryKey(
      instanceId,
      tableName,
      columnName
    );

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof runtimeServiceGetDescriptiveStatistics>>
  > = ({ signal }) =>
    runtimeServiceGetDescriptiveStatistics(
      instanceId,
      tableName,
      columnName,
      signal
    );

  const query = useQuery<
    Awaited<ReturnType<typeof runtimeServiceGetDescriptiveStatistics>>,
    TError,
    TData
  >(queryKey, queryFn, {
    enabled: !!(instanceId && tableName && columnName),
    ...queryOptions,
  }) as UseQueryStoreResult<
    Awaited<ReturnType<typeof runtimeServiceGetDescriptiveStatistics>>,
    TError,
    TData,
    QueryKey
  > & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
};

/**
 * @summary Get the number of nulls in a column
 */
export const runtimeServiceGetNullCount = (
  instanceId: string,
  tableName: string,
  columnName: string,
  signal?: AbortSignal
) => {
  return httpClient<V1GetNullCountResponse>({
    url: `/v1/instances/${instanceId}/queries/null-count/tables/${tableName}/columns/${columnName}`,
    method: "get",
    signal,
  });
};

export const getRuntimeServiceGetNullCountQueryKey = (
  instanceId: string,
  tableName: string,
  columnName: string
) => [
  `/v1/instances/${instanceId}/queries/null-count/tables/${tableName}/columns/${columnName}`,
];

export type RuntimeServiceGetNullCountQueryResult = NonNullable<
  Awaited<ReturnType<typeof runtimeServiceGetNullCount>>
>;
export type RuntimeServiceGetNullCountQueryError = RpcStatus;

export const useRuntimeServiceGetNullCount = <
  TData = Awaited<ReturnType<typeof runtimeServiceGetNullCount>>,
  TError = RpcStatus
>(
  instanceId: string,
  tableName: string,
  columnName: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof runtimeServiceGetNullCount>>,
      TError,
      TData
    >;
  }
): UseQueryStoreResult<
  Awaited<ReturnType<typeof runtimeServiceGetNullCount>>,
  TError,
  TData,
  QueryKey
> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getRuntimeServiceGetNullCountQueryKey(instanceId, tableName, columnName);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof runtimeServiceGetNullCount>>
  > = ({ signal }) =>
    runtimeServiceGetNullCount(instanceId, tableName, columnName, signal);

  const query = useQuery<
    Awaited<ReturnType<typeof runtimeServiceGetNullCount>>,
    TError,
    TData
  >(queryKey, queryFn, {
    enabled: !!(instanceId && tableName && columnName),
    ...queryOptions,
  }) as UseQueryStoreResult<
    Awaited<ReturnType<typeof runtimeServiceGetNullCount>>,
    TError,
    TData,
    QueryKey
  > & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
};

/**
 * @summary Get the histogram for values in a column
 */
export const runtimeServiceGetNumericHistogram = (
  instanceId: string,
  tableName: string,
  columnName: string,
  signal?: AbortSignal
) => {
  return httpClient<V1GetNumericHistogramResponse>({
    url: `/v1/instances/${instanceId}/queries/numeric-histogram/tables/${tableName}/columns/${columnName}`,
    method: "get",
    signal,
  });
};

export const getRuntimeServiceGetNumericHistogramQueryKey = (
  instanceId: string,
  tableName: string,
  columnName: string
) => [
  `/v1/instances/${instanceId}/queries/numeric-histogram/tables/${tableName}/columns/${columnName}`,
];

export type RuntimeServiceGetNumericHistogramQueryResult = NonNullable<
  Awaited<ReturnType<typeof runtimeServiceGetNumericHistogram>>
>;
export type RuntimeServiceGetNumericHistogramQueryError = RpcStatus;

export const useRuntimeServiceGetNumericHistogram = <
  TData = Awaited<ReturnType<typeof runtimeServiceGetNumericHistogram>>,
  TError = RpcStatus
>(
  instanceId: string,
  tableName: string,
  columnName: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof runtimeServiceGetNumericHistogram>>,
      TError,
      TData
    >;
  }
): UseQueryStoreResult<
  Awaited<ReturnType<typeof runtimeServiceGetNumericHistogram>>,
  TError,
  TData,
  QueryKey
> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getRuntimeServiceGetNumericHistogramQueryKey(
      instanceId,
      tableName,
      columnName
    );

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof runtimeServiceGetNumericHistogram>>
  > = ({ signal }) =>
    runtimeServiceGetNumericHistogram(
      instanceId,
      tableName,
      columnName,
      signal
    );

  const query = useQuery<
    Awaited<ReturnType<typeof runtimeServiceGetNumericHistogram>>,
    TError,
    TData
  >(queryKey, queryFn, {
    enabled: !!(instanceId && tableName && columnName),
    ...queryOptions,
  }) as UseQueryStoreResult<
    Awaited<ReturnType<typeof runtimeServiceGetNumericHistogram>>,
    TError,
    TData,
    QueryKey
  > & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
};

/**
 * @summary EstimateRollupInterval (TODO: add description)
 */
export const runtimeServiceEstimateRollupInterval = (
  instanceId: string,
  tableName: string,
  runtimeServiceEstimateRollupIntervalBody: RuntimeServiceEstimateRollupIntervalBody
) => {
  return httpClient<V1EstimateRollupIntervalResponse>({
    url: `/v1/instances/${instanceId}/queries/rollup-interval/tables/${tableName}`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: runtimeServiceEstimateRollupIntervalBody,
  });
};

export const getRuntimeServiceEstimateRollupIntervalQueryKey = (
  instanceId: string,
  tableName: string,
  runtimeServiceEstimateRollupIntervalBody: RuntimeServiceEstimateRollupIntervalBody
) => [
  `/v1/instances/${instanceId}/queries/rollup-interval/tables/${tableName}`,
  runtimeServiceEstimateRollupIntervalBody,
];

export type RuntimeServiceEstimateRollupIntervalQueryResult = NonNullable<
  Awaited<ReturnType<typeof runtimeServiceEstimateRollupInterval>>
>;
export type RuntimeServiceEstimateRollupIntervalQueryError = RpcStatus;

export const useRuntimeServiceEstimateRollupInterval = <
  TData = Awaited<ReturnType<typeof runtimeServiceEstimateRollupInterval>>,
  TError = RpcStatus
>(
  instanceId: string,
  tableName: string,
  runtimeServiceEstimateRollupIntervalBody: RuntimeServiceEstimateRollupIntervalBody,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof runtimeServiceEstimateRollupInterval>>,
      TError,
      TData
    >;
  }
): UseQueryStoreResult<
  Awaited<ReturnType<typeof runtimeServiceEstimateRollupInterval>>,
  TError,
  TData,
  QueryKey
> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getRuntimeServiceEstimateRollupIntervalQueryKey(
      instanceId,
      tableName,
      runtimeServiceEstimateRollupIntervalBody
    );

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof runtimeServiceEstimateRollupInterval>>
  > = () =>
    runtimeServiceEstimateRollupInterval(
      instanceId,
      tableName,
      runtimeServiceEstimateRollupIntervalBody
    );

  const query = useQuery<
    Awaited<ReturnType<typeof runtimeServiceEstimateRollupInterval>>,
    TError,
    TData
  >(queryKey, queryFn, {
    enabled: !!(instanceId && tableName),
    ...queryOptions,
  }) as UseQueryStoreResult<
    Awaited<ReturnType<typeof runtimeServiceEstimateRollupInterval>>,
    TError,
    TData,
    QueryKey
  > & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
};

/**
 * @summary TableRows (TODO: add description)
 */
export const runtimeServiceGetTableRows = (
  instanceId: string,
  tableName: string,
  params?: RuntimeServiceGetTableRowsParams,
  signal?: AbortSignal
) => {
  return httpClient<V1GetTableRowsResponse>({
    url: `/v1/instances/${instanceId}/queries/rows/tables/${tableName}`,
    method: "get",
    params,
    signal,
  });
};

export const getRuntimeServiceGetTableRowsQueryKey = (
  instanceId: string,
  tableName: string,
  params?: RuntimeServiceGetTableRowsParams
) => [
  `/v1/instances/${instanceId}/queries/rows/tables/${tableName}`,
  ...(params ? [params] : []),
];

export type RuntimeServiceGetTableRowsQueryResult = NonNullable<
  Awaited<ReturnType<typeof runtimeServiceGetTableRows>>
>;
export type RuntimeServiceGetTableRowsQueryError = RpcStatus;

export const useRuntimeServiceGetTableRows = <
  TData = Awaited<ReturnType<typeof runtimeServiceGetTableRows>>,
  TError = RpcStatus
>(
  instanceId: string,
  tableName: string,
  params?: RuntimeServiceGetTableRowsParams,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof runtimeServiceGetTableRows>>,
      TError,
      TData
    >;
  }
): UseQueryStoreResult<
  Awaited<ReturnType<typeof runtimeServiceGetTableRows>>,
  TError,
  TData,
  QueryKey
> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getRuntimeServiceGetTableRowsQueryKey(instanceId, tableName, params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof runtimeServiceGetTableRows>>
  > = ({ signal }) =>
    runtimeServiceGetTableRows(instanceId, tableName, params, signal);

  const query = useQuery<
    Awaited<ReturnType<typeof runtimeServiceGetTableRows>>,
    TError,
    TData
  >(queryKey, queryFn, {
    enabled: !!(instanceId && tableName),
    ...queryOptions,
  }) as UseQueryStoreResult<
    Awaited<ReturnType<typeof runtimeServiceGetTableRows>>,
    TError,
    TData,
    QueryKey
  > & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
};

/**
 * @summary Get outliers for a numeric column
 */
export const runtimeServiceGetRugHistogram = (
  instanceId: string,
  tableName: string,
  columnName: string,
  signal?: AbortSignal
) => {
  return httpClient<V1GetRugHistogramResponse>({
    url: `/v1/instances/${instanceId}/queries/rug-histogram/tables/${tableName}/columns/${columnName}`,
    method: "get",
    signal,
  });
};

export const getRuntimeServiceGetRugHistogramQueryKey = (
  instanceId: string,
  tableName: string,
  columnName: string
) => [
  `/v1/instances/${instanceId}/queries/rug-histogram/tables/${tableName}/columns/${columnName}`,
];

export type RuntimeServiceGetRugHistogramQueryResult = NonNullable<
  Awaited<ReturnType<typeof runtimeServiceGetRugHistogram>>
>;
export type RuntimeServiceGetRugHistogramQueryError = RpcStatus;

export const useRuntimeServiceGetRugHistogram = <
  TData = Awaited<ReturnType<typeof runtimeServiceGetRugHistogram>>,
  TError = RpcStatus
>(
  instanceId: string,
  tableName: string,
  columnName: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof runtimeServiceGetRugHistogram>>,
      TError,
      TData
    >;
  }
): UseQueryStoreResult<
  Awaited<ReturnType<typeof runtimeServiceGetRugHistogram>>,
  TError,
  TData,
  QueryKey
> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getRuntimeServiceGetRugHistogramQueryKey(instanceId, tableName, columnName);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof runtimeServiceGetRugHistogram>>
  > = ({ signal }) =>
    runtimeServiceGetRugHistogram(instanceId, tableName, columnName, signal);

  const query = useQuery<
    Awaited<ReturnType<typeof runtimeServiceGetRugHistogram>>,
    TError,
    TData
  >(queryKey, queryFn, {
    enabled: !!(instanceId && tableName && columnName),
    ...queryOptions,
  }) as UseQueryStoreResult<
    Awaited<ReturnType<typeof runtimeServiceGetRugHistogram>>,
    TError,
    TData,
    QueryKey
  > & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
};

/**
 * @summary Estimates the smallest time grain present in the column
 */
export const runtimeServiceEstimateSmallestTimeGrain = (
  instanceId: string,
  tableName: string,
  columnName: string,
  signal?: AbortSignal
) => {
  return httpClient<V1EstimateSmallestTimeGrainResponse>({
    url: `/v1/instances/${instanceId}/queries/smallest-time-grain/tables/${tableName}/columns/${columnName}`,
    method: "get",
    signal,
  });
};

export const getRuntimeServiceEstimateSmallestTimeGrainQueryKey = (
  instanceId: string,
  tableName: string,
  columnName: string
) => [
  `/v1/instances/${instanceId}/queries/smallest-time-grain/tables/${tableName}/columns/${columnName}`,
];

export type RuntimeServiceEstimateSmallestTimeGrainQueryResult = NonNullable<
  Awaited<ReturnType<typeof runtimeServiceEstimateSmallestTimeGrain>>
>;
export type RuntimeServiceEstimateSmallestTimeGrainQueryError = RpcStatus;

export const useRuntimeServiceEstimateSmallestTimeGrain = <
  TData = Awaited<ReturnType<typeof runtimeServiceEstimateSmallestTimeGrain>>,
  TError = RpcStatus
>(
  instanceId: string,
  tableName: string,
  columnName: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof runtimeServiceEstimateSmallestTimeGrain>>,
      TError,
      TData
    >;
  }
): UseQueryStoreResult<
  Awaited<ReturnType<typeof runtimeServiceEstimateSmallestTimeGrain>>,
  TError,
  TData,
  QueryKey
> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getRuntimeServiceEstimateSmallestTimeGrainQueryKey(
      instanceId,
      tableName,
      columnName
    );

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof runtimeServiceEstimateSmallestTimeGrain>>
  > = ({ signal }) =>
    runtimeServiceEstimateSmallestTimeGrain(
      instanceId,
      tableName,
      columnName,
      signal
    );

  const query = useQuery<
    Awaited<ReturnType<typeof runtimeServiceEstimateSmallestTimeGrain>>,
    TError,
    TData
  >(queryKey, queryFn, {
    enabled: !!(instanceId && tableName && columnName),
    ...queryOptions,
  }) as UseQueryStoreResult<
    Awaited<ReturnType<typeof runtimeServiceEstimateSmallestTimeGrain>>,
    TError,
    TData,
    QueryKey
  > & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
};

/**
 * @summary Get the time range summaries (min, max) for a column
 */
export const runtimeServiceGetTimeRangeSummary = (
  instanceId: string,
  tableName: string,
  columnName: string,
  signal?: AbortSignal
) => {
  return httpClient<V1GetTimeRangeSummaryResponse>({
    url: `/v1/instances/${instanceId}/queries/time-range-summary/tables/${tableName}/columns/${columnName}`,
    method: "get",
    signal,
  });
};

export const getRuntimeServiceGetTimeRangeSummaryQueryKey = (
  instanceId: string,
  tableName: string,
  columnName: string
) => [
  `/v1/instances/${instanceId}/queries/time-range-summary/tables/${tableName}/columns/${columnName}`,
];

export type RuntimeServiceGetTimeRangeSummaryQueryResult = NonNullable<
  Awaited<ReturnType<typeof runtimeServiceGetTimeRangeSummary>>
>;
export type RuntimeServiceGetTimeRangeSummaryQueryError = RpcStatus;

export const useRuntimeServiceGetTimeRangeSummary = <
  TData = Awaited<ReturnType<typeof runtimeServiceGetTimeRangeSummary>>,
  TError = RpcStatus
>(
  instanceId: string,
  tableName: string,
  columnName: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof runtimeServiceGetTimeRangeSummary>>,
      TError,
      TData
    >;
  }
): UseQueryStoreResult<
  Awaited<ReturnType<typeof runtimeServiceGetTimeRangeSummary>>,
  TError,
  TData,
  QueryKey
> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getRuntimeServiceGetTimeRangeSummaryQueryKey(
      instanceId,
      tableName,
      columnName
    );

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof runtimeServiceGetTimeRangeSummary>>
  > = ({ signal }) =>
    runtimeServiceGetTimeRangeSummary(
      instanceId,
      tableName,
      columnName,
      signal
    );

  const query = useQuery<
    Awaited<ReturnType<typeof runtimeServiceGetTimeRangeSummary>>,
    TError,
    TData
  >(queryKey, queryFn, {
    enabled: !!(instanceId && tableName && columnName),
    ...queryOptions,
  }) as UseQueryStoreResult<
    Awaited<ReturnType<typeof runtimeServiceGetTimeRangeSummary>>,
    TError,
    TData,
    QueryKey
  > & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
};

/**
 * @summary Generate time series
 */
export const runtimeServiceGenerateTimeSeries = (
  instanceId: string,
  runtimeServiceGenerateTimeSeriesBody: RuntimeServiceGenerateTimeSeriesBody
) => {
  return httpClient<V1GenerateTimeSeriesResponse>({
    url: `/v1/instances/${instanceId}/queries/timeseries`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: runtimeServiceGenerateTimeSeriesBody,
  });
};

export const getRuntimeServiceGenerateTimeSeriesQueryKey = (
  instanceId: string,
  runtimeServiceGenerateTimeSeriesBody: RuntimeServiceGenerateTimeSeriesBody
) => [
  `/v1/instances/${instanceId}/queries/timeseries`,
  runtimeServiceGenerateTimeSeriesBody,
];

export type RuntimeServiceGenerateTimeSeriesQueryResult = NonNullable<
  Awaited<ReturnType<typeof runtimeServiceGenerateTimeSeries>>
>;
export type RuntimeServiceGenerateTimeSeriesQueryError = RpcStatus;

export const useRuntimeServiceGenerateTimeSeries = <
  TData = Awaited<ReturnType<typeof runtimeServiceGenerateTimeSeries>>,
  TError = RpcStatus
>(
  instanceId: string,
  runtimeServiceGenerateTimeSeriesBody: RuntimeServiceGenerateTimeSeriesBody,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof runtimeServiceGenerateTimeSeries>>,
      TError,
      TData
    >;
  }
): UseQueryStoreResult<
  Awaited<ReturnType<typeof runtimeServiceGenerateTimeSeries>>,
  TError,
  TData,
  QueryKey
> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getRuntimeServiceGenerateTimeSeriesQueryKey(
      instanceId,
      runtimeServiceGenerateTimeSeriesBody
    );

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof runtimeServiceGenerateTimeSeries>>
  > = () =>
    runtimeServiceGenerateTimeSeries(
      instanceId,
      runtimeServiceGenerateTimeSeriesBody
    );

  const query = useQuery<
    Awaited<ReturnType<typeof runtimeServiceGenerateTimeSeries>>,
    TError,
    TData
  >(queryKey, queryFn, {
    enabled: !!instanceId,
    ...queryOptions,
  }) as UseQueryStoreResult<
    Awaited<ReturnType<typeof runtimeServiceGenerateTimeSeries>>,
    TError,
    TData,
    QueryKey
  > & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
};

/**
 * @summary Get TopK elements from a table for a column given an agg function
agg function and k are optional, defaults are count(*) and 50 respectively
 */
export const runtimeServiceGetTopK = (
  instanceId: string,
  tableName: string,
  columnName: string,
  runtimeServiceGetTopKBody: RuntimeServiceGetTopKBody
) => {
  return httpClient<V1GetTopKResponse>({
    url: `/v1/instances/${instanceId}/queries/topk/tables/${tableName}/columns/${columnName}`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: runtimeServiceGetTopKBody,
  });
};

export const getRuntimeServiceGetTopKQueryKey = (
  instanceId: string,
  tableName: string,
  columnName: string,
  runtimeServiceGetTopKBody: RuntimeServiceGetTopKBody
) => [
  `/v1/instances/${instanceId}/queries/topk/tables/${tableName}/columns/${columnName}`,
  runtimeServiceGetTopKBody,
];

export type RuntimeServiceGetTopKQueryResult = NonNullable<
  Awaited<ReturnType<typeof runtimeServiceGetTopK>>
>;
export type RuntimeServiceGetTopKQueryError = RpcStatus;

export const useRuntimeServiceGetTopK = <
  TData = Awaited<ReturnType<typeof runtimeServiceGetTopK>>,
  TError = RpcStatus
>(
  instanceId: string,
  tableName: string,
  columnName: string,
  runtimeServiceGetTopKBody: RuntimeServiceGetTopKBody,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof runtimeServiceGetTopK>>,
      TError,
      TData
    >;
  }
): UseQueryStoreResult<
  Awaited<ReturnType<typeof runtimeServiceGetTopK>>,
  TError,
  TData,
  QueryKey
> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getRuntimeServiceGetTopKQueryKey(
      instanceId,
      tableName,
      columnName,
      runtimeServiceGetTopKBody
    );

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof runtimeServiceGetTopK>>
  > = () =>
    runtimeServiceGetTopK(
      instanceId,
      tableName,
      columnName,
      runtimeServiceGetTopKBody
    );

  const query = useQuery<
    Awaited<ReturnType<typeof runtimeServiceGetTopK>>,
    TError,
    TData
  >(queryKey, queryFn, {
    enabled: !!(instanceId && tableName && columnName),
    ...queryOptions,
  }) as UseQueryStoreResult<
    Awaited<ReturnType<typeof runtimeServiceGetTopK>>,
    TError,
    TData,
    QueryKey
  > & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
};

/**
 * @summary Query runs a SQL query against the instance's OLAP datastore.
 */
export const runtimeServiceQuery = (
  instanceId: string,
  runtimeServiceQueryBody: RuntimeServiceQueryBody
) => {
  return httpClient<V1QueryResponse>({
    url: `/v1/instances/${instanceId}/query`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: runtimeServiceQueryBody,
  });
};

export type RuntimeServiceQueryMutationResult = NonNullable<
  Awaited<ReturnType<typeof runtimeServiceQuery>>
>;
export type RuntimeServiceQueryMutationBody = RuntimeServiceQueryBody;
export type RuntimeServiceQueryMutationError = RpcStatus;

export const useRuntimeServiceQuery = <
  TError = RpcStatus,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof runtimeServiceQuery>>,
    TError,
    { instanceId: string; data: RuntimeServiceQueryBody },
    TContext
  >;
}) => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof runtimeServiceQuery>>,
    { instanceId: string; data: RuntimeServiceQueryBody }
  > = (props) => {
    const { instanceId, data } = props ?? {};

    return runtimeServiceQuery(instanceId, data);
  };

  return useMutation<
    Awaited<ReturnType<typeof runtimeServiceQuery>>,
    TError,
    { instanceId: string; data: RuntimeServiceQueryBody },
    TContext
  >(mutationFn, mutationOptions);
};
/**
 * @summary DEPRECATED: QueryDirect runs a SQL query by directly executing it against the instance's OLAP datastore.
 */
export const runtimeServiceQueryDirect = (
  instanceId: string,
  runtimeServiceQueryDirectBody: RuntimeServiceQueryDirectBody
) => {
  return httpClient<V1QueryDirectResponse>({
    url: `/v1/instances/${instanceId}/query/direct`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: runtimeServiceQueryDirectBody,
  });
};

export type RuntimeServiceQueryDirectMutationResult = NonNullable<
  Awaited<ReturnType<typeof runtimeServiceQueryDirect>>
>;
export type RuntimeServiceQueryDirectMutationBody =
  RuntimeServiceQueryDirectBody;
export type RuntimeServiceQueryDirectMutationError = RpcStatus;

export const useRuntimeServiceQueryDirect = <
  TError = RpcStatus,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof runtimeServiceQueryDirect>>,
    TError,
    { instanceId: string; data: RuntimeServiceQueryDirectBody },
    TContext
  >;
}) => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof runtimeServiceQueryDirect>>,
    { instanceId: string; data: RuntimeServiceQueryDirectBody }
  > = (props) => {
    const { instanceId, data } = props ?? {};

    return runtimeServiceQueryDirect(instanceId, data);
  };

  return useMutation<
    Awaited<ReturnType<typeof runtimeServiceQueryDirect>>,
    TError,
    { instanceId: string; data: RuntimeServiceQueryDirectBody },
    TContext
  >(mutationFn, mutationOptions);
};
/**
 * @summary TriggerSync syncronizes the instance's catalog with the underlying OLAP's information schema.
If the instance has exposed=true, tables found in the information schema will be added to the catalog.
 */
export const runtimeServiceTriggerSync = (instanceId: string) => {
  return httpClient<V1TriggerSyncResponse>({
    url: `/v1/instances/${instanceId}/sync`,
    method: "post",
  });
};

export type RuntimeServiceTriggerSyncMutationResult = NonNullable<
  Awaited<ReturnType<typeof runtimeServiceTriggerSync>>
>;

export type RuntimeServiceTriggerSyncMutationError = RpcStatus;

export const useRuntimeServiceTriggerSync = <
  TError = RpcStatus,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof runtimeServiceTriggerSync>>,
    TError,
    { instanceId: string },
    TContext
  >;
}) => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof runtimeServiceTriggerSync>>,
    { instanceId: string }
  > = (props) => {
    const { instanceId } = props ?? {};

    return runtimeServiceTriggerSync(instanceId);
  };

  return useMutation<
    Awaited<ReturnType<typeof runtimeServiceTriggerSync>>,
    TError,
    { instanceId: string },
    TContext
  >(mutationFn, mutationOptions);
};
/**
 * @summary Ping returns information about the runtime
 */
export const runtimeServicePing = (signal?: AbortSignal) => {
  return httpClient<V1PingResponse>({ url: `/v1/ping`, method: "get", signal });
};

export const getRuntimeServicePingQueryKey = () => [`/v1/ping`];

export type RuntimeServicePingQueryResult = NonNullable<
  Awaited<ReturnType<typeof runtimeServicePing>>
>;
export type RuntimeServicePingQueryError = RpcStatus;

export const useRuntimeServicePing = <
  TData = Awaited<ReturnType<typeof runtimeServicePing>>,
  TError = RpcStatus
>(options?: {
  query?: UseQueryOptions<
    Awaited<ReturnType<typeof runtimeServicePing>>,
    TError,
    TData
  >;
}): UseQueryStoreResult<
  Awaited<ReturnType<typeof runtimeServicePing>>,
  TError,
  TData,
  QueryKey
> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getRuntimeServicePingQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof runtimeServicePing>>
  > = ({ signal }) => runtimeServicePing(signal);

  const query = useQuery<
    Awaited<ReturnType<typeof runtimeServicePing>>,
    TError,
    TData
  >(queryKey, queryFn, queryOptions) as UseQueryStoreResult<
    Awaited<ReturnType<typeof runtimeServicePing>>,
    TError,
    TData,
    QueryKey
  > & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
};

/**
 * @summary PutFileAndMigrate combines PutFile and Migrate in a single endpoint to reduce latency.
It is equivalent to calling the two RPCs sequentially.
 */
export const runtimeServicePutFileAndMigrate = (
  v1PutFileAndMigrateRequest: V1PutFileAndMigrateRequest
) => {
  return httpClient<V1PutFileAndMigrateResponse>({
    url: `/v1/put-and-migrate`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: v1PutFileAndMigrateRequest,
  });
};

export type RuntimeServicePutFileAndMigrateMutationResult = NonNullable<
  Awaited<ReturnType<typeof runtimeServicePutFileAndMigrate>>
>;
export type RuntimeServicePutFileAndMigrateMutationBody =
  V1PutFileAndMigrateRequest;
export type RuntimeServicePutFileAndMigrateMutationError = RpcStatus;

export const useRuntimeServicePutFileAndMigrate = <
  TError = RpcStatus,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof runtimeServicePutFileAndMigrate>>,
    TError,
    { data: V1PutFileAndMigrateRequest },
    TContext
  >;
}) => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof runtimeServicePutFileAndMigrate>>,
    { data: V1PutFileAndMigrateRequest }
  > = (props) => {
    const { data } = props ?? {};

    return runtimeServicePutFileAndMigrate(data);
  };

  return useMutation<
    Awaited<ReturnType<typeof runtimeServicePutFileAndMigrate>>,
    TError,
    { data: V1PutFileAndMigrateRequest },
    TContext
  >(mutationFn, mutationOptions);
};
/**
 * @summary RenameFileAndMigrate combines RenameFile and Migrate in a single endpoint to reduce latency.
 */
export const runtimeServiceRenameFileAndMigrate = (
  v1RenameFileAndMigrateRequest: V1RenameFileAndMigrateRequest
) => {
  return httpClient<V1RenameFileAndMigrateResponse>({
    url: `/v1/rename-and-migrate`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: v1RenameFileAndMigrateRequest,
  });
};

export type RuntimeServiceRenameFileAndMigrateMutationResult = NonNullable<
  Awaited<ReturnType<typeof runtimeServiceRenameFileAndMigrate>>
>;
export type RuntimeServiceRenameFileAndMigrateMutationBody =
  V1RenameFileAndMigrateRequest;
export type RuntimeServiceRenameFileAndMigrateMutationError = RpcStatus;

export const useRuntimeServiceRenameFileAndMigrate = <
  TError = RpcStatus,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof runtimeServiceRenameFileAndMigrate>>,
    TError,
    { data: V1RenameFileAndMigrateRequest },
    TContext
  >;
}) => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof runtimeServiceRenameFileAndMigrate>>,
    { data: V1RenameFileAndMigrateRequest }
  > = (props) => {
    const { data } = props ?? {};

    return runtimeServiceRenameFileAndMigrate(data);
  };

  return useMutation<
    Awaited<ReturnType<typeof runtimeServiceRenameFileAndMigrate>>,
    TError,
    { data: V1RenameFileAndMigrateRequest },
    TContext
  >(mutationFn, mutationOptions);
};
/**
 * @summary ListRepos lists all the repos currently managed by the runtime
 */
export const runtimeServiceListRepos = (
  params?: RuntimeServiceListReposParams,
  signal?: AbortSignal
) => {
  return httpClient<V1ListReposResponse>({
    url: `/v1/repos`,
    method: "get",
    params,
    signal,
  });
};

export const getRuntimeServiceListReposQueryKey = (
  params?: RuntimeServiceListReposParams
) => [`/v1/repos`, ...(params ? [params] : [])];

export type RuntimeServiceListReposQueryResult = NonNullable<
  Awaited<ReturnType<typeof runtimeServiceListRepos>>
>;
export type RuntimeServiceListReposQueryError = RpcStatus;

export const useRuntimeServiceListRepos = <
  TData = Awaited<ReturnType<typeof runtimeServiceListRepos>>,
  TError = RpcStatus
>(
  params?: RuntimeServiceListReposParams,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof runtimeServiceListRepos>>,
      TError,
      TData
    >;
  }
): UseQueryStoreResult<
  Awaited<ReturnType<typeof runtimeServiceListRepos>>,
  TError,
  TData,
  QueryKey
> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getRuntimeServiceListReposQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof runtimeServiceListRepos>>
  > = ({ signal }) => runtimeServiceListRepos(params, signal);

  const query = useQuery<
    Awaited<ReturnType<typeof runtimeServiceListRepos>>,
    TError,
    TData
  >(queryKey, queryFn, queryOptions) as UseQueryStoreResult<
    Awaited<ReturnType<typeof runtimeServiceListRepos>>,
    TError,
    TData,
    QueryKey
  > & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
};

/**
 * @summary CreateRepo creates a new repo. See the Repo message for an explanation of repos.
 */
export const runtimeServiceCreateRepo = (
  v1CreateRepoRequest: V1CreateRepoRequest
) => {
  return httpClient<V1CreateRepoResponse>({
    url: `/v1/repos`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: v1CreateRepoRequest,
  });
};

export type RuntimeServiceCreateRepoMutationResult = NonNullable<
  Awaited<ReturnType<typeof runtimeServiceCreateRepo>>
>;
export type RuntimeServiceCreateRepoMutationBody = V1CreateRepoRequest;
export type RuntimeServiceCreateRepoMutationError = RpcStatus;

export const useRuntimeServiceCreateRepo = <
  TError = RpcStatus,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof runtimeServiceCreateRepo>>,
    TError,
    { data: V1CreateRepoRequest },
    TContext
  >;
}) => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof runtimeServiceCreateRepo>>,
    { data: V1CreateRepoRequest }
  > = (props) => {
    const { data } = props ?? {};

    return runtimeServiceCreateRepo(data);
  };

  return useMutation<
    Awaited<ReturnType<typeof runtimeServiceCreateRepo>>,
    TError,
    { data: V1CreateRepoRequest },
    TContext
  >(mutationFn, mutationOptions);
};
/**
 * @summary GetRepo returns info about a specific repo
 */
export const runtimeServiceGetRepo = (repoId: string, signal?: AbortSignal) => {
  return httpClient<V1GetRepoResponse>({
    url: `/v1/repos/${repoId}`,
    method: "get",
    signal,
  });
};

export const getRuntimeServiceGetRepoQueryKey = (repoId: string) => [
  `/v1/repos/${repoId}`,
];

export type RuntimeServiceGetRepoQueryResult = NonNullable<
  Awaited<ReturnType<typeof runtimeServiceGetRepo>>
>;
export type RuntimeServiceGetRepoQueryError = RpcStatus;

export const useRuntimeServiceGetRepo = <
  TData = Awaited<ReturnType<typeof runtimeServiceGetRepo>>,
  TError = RpcStatus
>(
  repoId: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof runtimeServiceGetRepo>>,
      TError,
      TData
    >;
  }
): UseQueryStoreResult<
  Awaited<ReturnType<typeof runtimeServiceGetRepo>>,
  TError,
  TData,
  QueryKey
> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getRuntimeServiceGetRepoQueryKey(repoId);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof runtimeServiceGetRepo>>
  > = ({ signal }) => runtimeServiceGetRepo(repoId, signal);

  const query = useQuery<
    Awaited<ReturnType<typeof runtimeServiceGetRepo>>,
    TError,
    TData
  >(queryKey, queryFn, {
    enabled: !!repoId,
    ...queryOptions,
  }) as UseQueryStoreResult<
    Awaited<ReturnType<typeof runtimeServiceGetRepo>>,
    TError,
    TData,
    QueryKey
  > & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
};

/**
 * @summary DeleteRepo deletes a repo
 */
export const runtimeServiceDeleteRepo = (repoId: string) => {
  return httpClient<V1DeleteRepoResponse>({
    url: `/v1/repos/${repoId}`,
    method: "delete",
  });
};

export type RuntimeServiceDeleteRepoMutationResult = NonNullable<
  Awaited<ReturnType<typeof runtimeServiceDeleteRepo>>
>;

export type RuntimeServiceDeleteRepoMutationError = RpcStatus;

export const useRuntimeServiceDeleteRepo = <
  TError = RpcStatus,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof runtimeServiceDeleteRepo>>,
    TError,
    { repoId: string },
    TContext
  >;
}) => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof runtimeServiceDeleteRepo>>,
    { repoId: string }
  > = (props) => {
    const { repoId } = props ?? {};

    return runtimeServiceDeleteRepo(repoId);
  };

  return useMutation<
    Awaited<ReturnType<typeof runtimeServiceDeleteRepo>>,
    TError,
    { repoId: string },
    TContext
  >(mutationFn, mutationOptions);
};
/**
 * @summary ListFiles lists all the files matching a glob in a repo.
The files are sorted by their full path.
 */
export const runtimeServiceListFiles = (
  repoId: string,
  params?: RuntimeServiceListFilesParams,
  signal?: AbortSignal
) => {
  return httpClient<V1ListFilesResponse>({
    url: `/v1/repos/${repoId}/files`,
    method: "get",
    params,
    signal,
  });
};

export const getRuntimeServiceListFilesQueryKey = (
  repoId: string,
  params?: RuntimeServiceListFilesParams
) => [`/v1/repos/${repoId}/files`, ...(params ? [params] : [])];

export type RuntimeServiceListFilesQueryResult = NonNullable<
  Awaited<ReturnType<typeof runtimeServiceListFiles>>
>;
export type RuntimeServiceListFilesQueryError = RpcStatus;

export const useRuntimeServiceListFiles = <
  TData = Awaited<ReturnType<typeof runtimeServiceListFiles>>,
  TError = RpcStatus
>(
  repoId: string,
  params?: RuntimeServiceListFilesParams,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof runtimeServiceListFiles>>,
      TError,
      TData
    >;
  }
): UseQueryStoreResult<
  Awaited<ReturnType<typeof runtimeServiceListFiles>>,
  TError,
  TData,
  QueryKey
> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getRuntimeServiceListFilesQueryKey(repoId, params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof runtimeServiceListFiles>>
  > = ({ signal }) => runtimeServiceListFiles(repoId, params, signal);

  const query = useQuery<
    Awaited<ReturnType<typeof runtimeServiceListFiles>>,
    TError,
    TData
  >(queryKey, queryFn, {
    enabled: !!repoId,
    ...queryOptions,
  }) as UseQueryStoreResult<
    Awaited<ReturnType<typeof runtimeServiceListFiles>>,
    TError,
    TData,
    QueryKey
  > & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
};

/**
 * @summary GetFile returns the contents of a specific file in a repo.
 */
export const runtimeServiceGetFile = (
  repoId: string,
  path: string,
  signal?: AbortSignal
) => {
  return httpClient<V1GetFileResponse>({
    url: `/v1/repos/${repoId}/files/-/${path}`,
    method: "get",
    signal,
  });
};

export const getRuntimeServiceGetFileQueryKey = (
  repoId: string,
  path: string
) => [`/v1/repos/${repoId}/files/-/${path}`];

export type RuntimeServiceGetFileQueryResult = NonNullable<
  Awaited<ReturnType<typeof runtimeServiceGetFile>>
>;
export type RuntimeServiceGetFileQueryError = RpcStatus;

export const useRuntimeServiceGetFile = <
  TData = Awaited<ReturnType<typeof runtimeServiceGetFile>>,
  TError = RpcStatus
>(
  repoId: string,
  path: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof runtimeServiceGetFile>>,
      TError,
      TData
    >;
  }
): UseQueryStoreResult<
  Awaited<ReturnType<typeof runtimeServiceGetFile>>,
  TError,
  TData,
  QueryKey
> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getRuntimeServiceGetFileQueryKey(repoId, path);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof runtimeServiceGetFile>>
  > = ({ signal }) => runtimeServiceGetFile(repoId, path, signal);

  const query = useQuery<
    Awaited<ReturnType<typeof runtimeServiceGetFile>>,
    TError,
    TData
  >(queryKey, queryFn, {
    enabled: !!(repoId && path),
    ...queryOptions,
  }) as UseQueryStoreResult<
    Awaited<ReturnType<typeof runtimeServiceGetFile>>,
    TError,
    TData,
    QueryKey
  > & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
};

/**
 * @summary DeleteFile deletes a file from a repo
 */
export const runtimeServiceDeleteFile = (repoId: string, path: string) => {
  return httpClient<V1DeleteFileResponse>({
    url: `/v1/repos/${repoId}/files/-/${path}`,
    method: "delete",
  });
};

export type RuntimeServiceDeleteFileMutationResult = NonNullable<
  Awaited<ReturnType<typeof runtimeServiceDeleteFile>>
>;

export type RuntimeServiceDeleteFileMutationError = RpcStatus;

export const useRuntimeServiceDeleteFile = <
  TError = RpcStatus,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof runtimeServiceDeleteFile>>,
    TError,
    { repoId: string; path: string },
    TContext
  >;
}) => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof runtimeServiceDeleteFile>>,
    { repoId: string; path: string }
  > = (props) => {
    const { repoId, path } = props ?? {};

    return runtimeServiceDeleteFile(repoId, path);
  };

  return useMutation<
    Awaited<ReturnType<typeof runtimeServiceDeleteFile>>,
    TError,
    { repoId: string; path: string },
    TContext
  >(mutationFn, mutationOptions);
};
/**
 * @summary PutFile creates or updates a file in a repo
 */
export const runtimeServicePutFile = (
  repoId: string,
  path: string,
  runtimeServicePutFileBody: RuntimeServicePutFileBody
) => {
  return httpClient<V1PutFileResponse>({
    url: `/v1/repos/${repoId}/files/-/${path}`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: runtimeServicePutFileBody,
  });
};

export type RuntimeServicePutFileMutationResult = NonNullable<
  Awaited<ReturnType<typeof runtimeServicePutFile>>
>;
export type RuntimeServicePutFileMutationBody = RuntimeServicePutFileBody;
export type RuntimeServicePutFileMutationError = RpcStatus;

export const useRuntimeServicePutFile = <
  TError = RpcStatus,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof runtimeServicePutFile>>,
    TError,
    { repoId: string; path: string; data: RuntimeServicePutFileBody },
    TContext
  >;
}) => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof runtimeServicePutFile>>,
    { repoId: string; path: string; data: RuntimeServicePutFileBody }
  > = (props) => {
    const { repoId, path, data } = props ?? {};

    return runtimeServicePutFile(repoId, path, data);
  };

  return useMutation<
    Awaited<ReturnType<typeof runtimeServicePutFile>>,
    TError,
    { repoId: string; path: string; data: RuntimeServicePutFileBody },
    TContext
  >(mutationFn, mutationOptions);
};
/**
 * @summary RenameFile renames a file in a repo
 */
export const runtimeServiceRenameFile = (
  repoId: string,
  runtimeServiceRenameFileBody: RuntimeServiceRenameFileBody
) => {
  return httpClient<V1RenameFileResponse>({
    url: `/v1/repos/${repoId}/files/rename`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: runtimeServiceRenameFileBody,
  });
};

export type RuntimeServiceRenameFileMutationResult = NonNullable<
  Awaited<ReturnType<typeof runtimeServiceRenameFile>>
>;
export type RuntimeServiceRenameFileMutationBody = RuntimeServiceRenameFileBody;
export type RuntimeServiceRenameFileMutationError = RpcStatus;

export const useRuntimeServiceRenameFile = <
  TError = RpcStatus,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof runtimeServiceRenameFile>>,
    TError,
    { repoId: string; data: RuntimeServiceRenameFileBody },
    TContext
  >;
}) => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof runtimeServiceRenameFile>>,
    { repoId: string; data: RuntimeServiceRenameFileBody }
  > = (props) => {
    const { repoId, data } = props ?? {};

    return runtimeServiceRenameFile(repoId, data);
  };

  return useMutation<
    Awaited<ReturnType<typeof runtimeServiceRenameFile>>,
    TError,
    { repoId: string; data: RuntimeServiceRenameFileBody },
    TContext
  >(mutationFn, mutationOptions);
};

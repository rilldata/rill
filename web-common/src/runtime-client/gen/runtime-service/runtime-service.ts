/**
 * Generated by orval v7.8.0 üç∫
 * Do not edit manually.
 * rill/runtime/v1/schema.proto
 * OpenAPI spec version: version not set
 */
import {
  createInfiniteQuery,
  createMutation,
  createQuery,
} from "@tanstack/svelte-query";
import type {
  CreateInfiniteQueryOptions,
  CreateInfiniteQueryResult,
  CreateMutationOptions,
  CreateMutationResult,
  CreateQueryOptions,
  CreateQueryResult,
  DataTag,
  InfiniteData,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
} from "@tanstack/svelte-query";

import type {
  RpcStatus,
  RuntimeServiceCreateDirectoryBody,
  RuntimeServiceCreateTriggerBody,
  RuntimeServiceDeleteFileParams,
  RuntimeServiceDeleteInstanceBody,
  RuntimeServiceEditInstanceBody,
  RuntimeServiceGenerateMetricsViewFileBody,
  RuntimeServiceGenerateRendererBody,
  RuntimeServiceGenerateResolverBody,
  RuntimeServiceGetExploreParams,
  RuntimeServiceGetFileParams,
  RuntimeServiceGetInstanceParams,
  RuntimeServiceGetLogsParams,
  RuntimeServiceGetModelPartitionsParams,
  RuntimeServiceGetResourceParams,
  RuntimeServiceListFilesParams,
  RuntimeServiceListInstancesParams,
  RuntimeServiceListResourcesParams,
  RuntimeServicePutFileBody,
  RuntimeServiceQueryResolverBody,
  RuntimeServiceRenameFileBody,
  RuntimeServiceUnpackEmptyBody,
  RuntimeServiceUnpackExampleBody,
  RuntimeServiceWatchFiles200,
  RuntimeServiceWatchFilesParams,
  RuntimeServiceWatchLogs200,
  RuntimeServiceWatchLogsParams,
  RuntimeServiceWatchResources200,
  RuntimeServiceWatchResourcesParams,
  V1AnalyzeConnectorsResponse,
  V1AnalyzeVariablesResponse,
  V1CreateDirectoryResponse,
  V1CreateInstanceRequest,
  V1CreateInstanceResponse,
  V1CreateTriggerResponse,
  V1DeleteFileResponse,
  V1DeleteInstanceResponse,
  V1EditInstanceResponse,
  V1GenerateMetricsViewFileResponse,
  V1GenerateRendererResponse,
  V1GenerateResolverResponse,
  V1GetExploreResponse,
  V1GetFileResponse,
  V1GetInstanceResponse,
  V1GetLogsResponse,
  V1GetModelPartitionsResponse,
  V1GetResourceResponse,
  V1HealthResponse,
  V1InstanceHealthResponse,
  V1IssueDevJWTRequest,
  V1IssueDevJWTResponse,
  V1ListConnectorDriversResponse,
  V1ListExamplesResponse,
  V1ListFilesResponse,
  V1ListInstancesResponse,
  V1ListNotifierConnectorsResponse,
  V1ListResourcesResponse,
  V1PingResponse,
  V1PutFileResponse,
  V1QueryResolverResponse,
  V1RenameFileResponse,
  V1UnpackEmptyResponse,
  V1UnpackExampleResponse,
} from "../index.schemas";

import { httpClient } from "../../http-client";
import type { ErrorType } from "../../http-client";

type AwaitedInput<T> = PromiseLike<T> | T;

type Awaited<O> = O extends AwaitedInput<infer T> ? T : never;

/**
 * @summary ListConnectorDrivers returns a description of all the connector drivers registed in the runtime,
including their configuration specs and the capabilities they support.
 */
export const runtimeServiceListConnectorDrivers = (signal?: AbortSignal) => {
  return httpClient<V1ListConnectorDriversResponse>({
    url: `/v1/connectors/meta`,
    method: "GET",
    signal,
  });
};

export const getRuntimeServiceListConnectorDriversQueryKey = () => {
  return [`/v1/connectors/meta`] as const;
};

export const getRuntimeServiceListConnectorDriversQueryOptions = <
  TData = Awaited<ReturnType<typeof runtimeServiceListConnectorDrivers>>,
  TError = ErrorType<RpcStatus>,
>(options?: {
  query?: Partial<
    CreateQueryOptions<
      Awaited<ReturnType<typeof runtimeServiceListConnectorDrivers>>,
      TError,
      TData
    >
  >;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getRuntimeServiceListConnectorDriversQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof runtimeServiceListConnectorDrivers>>
  > = ({ signal }) => runtimeServiceListConnectorDrivers(signal);

  return { queryKey, queryFn, ...queryOptions } as CreateQueryOptions<
    Awaited<ReturnType<typeof runtimeServiceListConnectorDrivers>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type RuntimeServiceListConnectorDriversQueryResult = NonNullable<
  Awaited<ReturnType<typeof runtimeServiceListConnectorDrivers>>
>;
export type RuntimeServiceListConnectorDriversQueryError = ErrorType<RpcStatus>;

/**
 * @summary ListConnectorDrivers returns a description of all the connector drivers registed in the runtime,
including their configuration specs and the capabilities they support.
 */

export function createRuntimeServiceListConnectorDrivers<
  TData = Awaited<ReturnType<typeof runtimeServiceListConnectorDrivers>>,
  TError = ErrorType<RpcStatus>,
>(
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof runtimeServiceListConnectorDrivers>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): CreateQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions =
    getRuntimeServiceListConnectorDriversQueryOptions(options);

  const query = createQuery(queryOptions, queryClient) as CreateQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary IssueDevJWT issues a JWT for mimicking a user in local development.
 */
export const runtimeServiceIssueDevJWT = (
  v1IssueDevJWTRequest: V1IssueDevJWTRequest,
  signal?: AbortSignal,
) => {
  return httpClient<V1IssueDevJWTResponse>({
    url: `/v1/dev-jwt`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: v1IssueDevJWTRequest,
    signal,
  });
};

export const getRuntimeServiceIssueDevJWTQueryKey = (
  v1IssueDevJWTRequest: V1IssueDevJWTRequest,
) => {
  return [`/v1/dev-jwt`, v1IssueDevJWTRequest] as const;
};

export const getRuntimeServiceIssueDevJWTQueryOptions = <
  TData = Awaited<ReturnType<typeof runtimeServiceIssueDevJWT>>,
  TError = ErrorType<RpcStatus>,
>(
  v1IssueDevJWTRequest: V1IssueDevJWTRequest,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof runtimeServiceIssueDevJWT>>,
        TError,
        TData
      >
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getRuntimeServiceIssueDevJWTQueryKey(v1IssueDevJWTRequest);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof runtimeServiceIssueDevJWT>>
  > = ({ signal }) => runtimeServiceIssueDevJWT(v1IssueDevJWTRequest, signal);

  return { queryKey, queryFn, ...queryOptions } as CreateQueryOptions<
    Awaited<ReturnType<typeof runtimeServiceIssueDevJWT>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type RuntimeServiceIssueDevJWTQueryResult = NonNullable<
  Awaited<ReturnType<typeof runtimeServiceIssueDevJWT>>
>;
export type RuntimeServiceIssueDevJWTQueryError = ErrorType<RpcStatus>;

/**
 * @summary IssueDevJWT issues a JWT for mimicking a user in local development.
 */

export function createRuntimeServiceIssueDevJWT<
  TData = Awaited<ReturnType<typeof runtimeServiceIssueDevJWT>>,
  TError = ErrorType<RpcStatus>,
>(
  v1IssueDevJWTRequest: V1IssueDevJWTRequest,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof runtimeServiceIssueDevJWT>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): CreateQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getRuntimeServiceIssueDevJWTQueryOptions(
    v1IssueDevJWTRequest,
    options,
  );

  const query = createQuery(queryOptions, queryClient) as CreateQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary ListExamples lists all the examples embedded into binary
 */
export const runtimeServiceListExamples = (signal?: AbortSignal) => {
  return httpClient<V1ListExamplesResponse>({
    url: `/v1/examples`,
    method: "GET",
    signal,
  });
};

export const getRuntimeServiceListExamplesQueryKey = () => {
  return [`/v1/examples`] as const;
};

export const getRuntimeServiceListExamplesQueryOptions = <
  TData = Awaited<ReturnType<typeof runtimeServiceListExamples>>,
  TError = ErrorType<RpcStatus>,
>(options?: {
  query?: Partial<
    CreateQueryOptions<
      Awaited<ReturnType<typeof runtimeServiceListExamples>>,
      TError,
      TData
    >
  >;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getRuntimeServiceListExamplesQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof runtimeServiceListExamples>>
  > = ({ signal }) => runtimeServiceListExamples(signal);

  return { queryKey, queryFn, ...queryOptions } as CreateQueryOptions<
    Awaited<ReturnType<typeof runtimeServiceListExamples>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type RuntimeServiceListExamplesQueryResult = NonNullable<
  Awaited<ReturnType<typeof runtimeServiceListExamples>>
>;
export type RuntimeServiceListExamplesQueryError = ErrorType<RpcStatus>;

/**
 * @summary ListExamples lists all the examples embedded into binary
 */

export function createRuntimeServiceListExamples<
  TData = Awaited<ReturnType<typeof runtimeServiceListExamples>>,
  TError = ErrorType<RpcStatus>,
>(
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof runtimeServiceListExamples>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): CreateQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getRuntimeServiceListExamplesQueryOptions(options);

  const query = createQuery(queryOptions, queryClient) as CreateQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Health runs a health check on the runtime.
 */
export const runtimeServiceHealth = (signal?: AbortSignal) => {
  return httpClient<V1HealthResponse>({
    url: `/v1/health`,
    method: "GET",
    signal,
  });
};

export const getRuntimeServiceHealthQueryKey = () => {
  return [`/v1/health`] as const;
};

export const getRuntimeServiceHealthQueryOptions = <
  TData = Awaited<ReturnType<typeof runtimeServiceHealth>>,
  TError = ErrorType<RpcStatus>,
>(options?: {
  query?: Partial<
    CreateQueryOptions<
      Awaited<ReturnType<typeof runtimeServiceHealth>>,
      TError,
      TData
    >
  >;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getRuntimeServiceHealthQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof runtimeServiceHealth>>
  > = ({ signal }) => runtimeServiceHealth(signal);

  return { queryKey, queryFn, ...queryOptions } as CreateQueryOptions<
    Awaited<ReturnType<typeof runtimeServiceHealth>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type RuntimeServiceHealthQueryResult = NonNullable<
  Awaited<ReturnType<typeof runtimeServiceHealth>>
>;
export type RuntimeServiceHealthQueryError = ErrorType<RpcStatus>;

/**
 * @summary Health runs a health check on the runtime.
 */

export function createRuntimeServiceHealth<
  TData = Awaited<ReturnType<typeof runtimeServiceHealth>>,
  TError = ErrorType<RpcStatus>,
>(
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof runtimeServiceHealth>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): CreateQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getRuntimeServiceHealthQueryOptions(options);

  const query = createQuery(queryOptions, queryClient) as CreateQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary InstanceHealth runs a health check on a specific instance.
 */
export const runtimeServiceInstanceHealth = (
  instanceId: string,
  signal?: AbortSignal,
) => {
  return httpClient<V1InstanceHealthResponse>({
    url: `/v1/health/instances/${instanceId}`,
    method: "GET",
    signal,
  });
};

export const getRuntimeServiceInstanceHealthQueryKey = (instanceId: string) => {
  return [`/v1/health/instances/${instanceId}`] as const;
};

export const getRuntimeServiceInstanceHealthQueryOptions = <
  TData = Awaited<ReturnType<typeof runtimeServiceInstanceHealth>>,
  TError = ErrorType<RpcStatus>,
>(
  instanceId: string,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof runtimeServiceInstanceHealth>>,
        TError,
        TData
      >
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getRuntimeServiceInstanceHealthQueryKey(instanceId);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof runtimeServiceInstanceHealth>>
  > = ({ signal }) => runtimeServiceInstanceHealth(instanceId, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!instanceId,
    ...queryOptions,
  } as CreateQueryOptions<
    Awaited<ReturnType<typeof runtimeServiceInstanceHealth>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type RuntimeServiceInstanceHealthQueryResult = NonNullable<
  Awaited<ReturnType<typeof runtimeServiceInstanceHealth>>
>;
export type RuntimeServiceInstanceHealthQueryError = ErrorType<RpcStatus>;

/**
 * @summary InstanceHealth runs a health check on a specific instance.
 */

export function createRuntimeServiceInstanceHealth<
  TData = Awaited<ReturnType<typeof runtimeServiceInstanceHealth>>,
  TError = ErrorType<RpcStatus>,
>(
  instanceId: string,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof runtimeServiceInstanceHealth>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): CreateQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getRuntimeServiceInstanceHealthQueryOptions(
    instanceId,
    options,
  );

  const query = createQuery(queryOptions, queryClient) as CreateQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary ListInstances lists all the instances currently managed by the runtime
 */
export const runtimeServiceListInstances = (
  params?: RuntimeServiceListInstancesParams,
  signal?: AbortSignal,
) => {
  return httpClient<V1ListInstancesResponse>({
    url: `/v1/instances`,
    method: "GET",
    params,
    signal,
  });
};

export const getRuntimeServiceListInstancesQueryKey = (
  params?: RuntimeServiceListInstancesParams,
) => {
  return [`/v1/instances`, ...(params ? [params] : [])] as const;
};

export const getRuntimeServiceListInstancesQueryOptions = <
  TData = Awaited<ReturnType<typeof runtimeServiceListInstances>>,
  TError = ErrorType<RpcStatus>,
>(
  params?: RuntimeServiceListInstancesParams,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof runtimeServiceListInstances>>,
        TError,
        TData
      >
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getRuntimeServiceListInstancesQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof runtimeServiceListInstances>>
  > = ({ signal }) => runtimeServiceListInstances(params, signal);

  return { queryKey, queryFn, ...queryOptions } as CreateQueryOptions<
    Awaited<ReturnType<typeof runtimeServiceListInstances>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type RuntimeServiceListInstancesQueryResult = NonNullable<
  Awaited<ReturnType<typeof runtimeServiceListInstances>>
>;
export type RuntimeServiceListInstancesQueryError = ErrorType<RpcStatus>;

/**
 * @summary ListInstances lists all the instances currently managed by the runtime
 */

export function createRuntimeServiceListInstances<
  TData = Awaited<ReturnType<typeof runtimeServiceListInstances>>,
  TError = ErrorType<RpcStatus>,
>(
  params?: RuntimeServiceListInstancesParams,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof runtimeServiceListInstances>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): CreateQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getRuntimeServiceListInstancesQueryOptions(
    params,
    options,
  );

  const query = createQuery(queryOptions, queryClient) as CreateQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary CreateInstance creates a new instance
 */
export const runtimeServiceCreateInstance = (
  v1CreateInstanceRequest: V1CreateInstanceRequest,
  signal?: AbortSignal,
) => {
  return httpClient<V1CreateInstanceResponse>({
    url: `/v1/instances`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: v1CreateInstanceRequest,
    signal,
  });
};

export const getRuntimeServiceCreateInstanceMutationOptions = <
  TError = ErrorType<RpcStatus>,
  TContext = unknown,
>(options?: {
  mutation?: CreateMutationOptions<
    Awaited<ReturnType<typeof runtimeServiceCreateInstance>>,
    TError,
    { data: V1CreateInstanceRequest },
    TContext
  >;
}): CreateMutationOptions<
  Awaited<ReturnType<typeof runtimeServiceCreateInstance>>,
  TError,
  { data: V1CreateInstanceRequest },
  TContext
> => {
  const mutationKey = ["runtimeServiceCreateInstance"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof runtimeServiceCreateInstance>>,
    { data: V1CreateInstanceRequest }
  > = (props) => {
    const { data } = props ?? {};

    return runtimeServiceCreateInstance(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type RuntimeServiceCreateInstanceMutationResult = NonNullable<
  Awaited<ReturnType<typeof runtimeServiceCreateInstance>>
>;
export type RuntimeServiceCreateInstanceMutationBody = V1CreateInstanceRequest;
export type RuntimeServiceCreateInstanceMutationError = ErrorType<RpcStatus>;

/**
 * @summary CreateInstance creates a new instance
 */
export const createRuntimeServiceCreateInstance = <
  TError = ErrorType<RpcStatus>,
  TContext = unknown,
>(
  options?: {
    mutation?: CreateMutationOptions<
      Awaited<ReturnType<typeof runtimeServiceCreateInstance>>,
      TError,
      { data: V1CreateInstanceRequest },
      TContext
    >;
  },
  queryClient?: QueryClient,
): CreateMutationResult<
  Awaited<ReturnType<typeof runtimeServiceCreateInstance>>,
  TError,
  { data: V1CreateInstanceRequest },
  TContext
> => {
  const mutationOptions =
    getRuntimeServiceCreateInstanceMutationOptions(options);

  return createMutation(mutationOptions, queryClient);
};
/**
 * @summary GetInstance returns information about a specific instance
 */
export const runtimeServiceGetInstance = (
  instanceId: string,
  params?: RuntimeServiceGetInstanceParams,
  signal?: AbortSignal,
) => {
  return httpClient<V1GetInstanceResponse>({
    url: `/v1/instances/${instanceId}`,
    method: "GET",
    params,
    signal,
  });
};

export const getRuntimeServiceGetInstanceQueryKey = (
  instanceId: string,
  params?: RuntimeServiceGetInstanceParams,
) => {
  return [`/v1/instances/${instanceId}`, ...(params ? [params] : [])] as const;
};

export const getRuntimeServiceGetInstanceQueryOptions = <
  TData = Awaited<ReturnType<typeof runtimeServiceGetInstance>>,
  TError = ErrorType<RpcStatus>,
>(
  instanceId: string,
  params?: RuntimeServiceGetInstanceParams,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof runtimeServiceGetInstance>>,
        TError,
        TData
      >
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getRuntimeServiceGetInstanceQueryKey(instanceId, params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof runtimeServiceGetInstance>>
  > = ({ signal }) => runtimeServiceGetInstance(instanceId, params, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!instanceId,
    ...queryOptions,
  } as CreateQueryOptions<
    Awaited<ReturnType<typeof runtimeServiceGetInstance>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type RuntimeServiceGetInstanceQueryResult = NonNullable<
  Awaited<ReturnType<typeof runtimeServiceGetInstance>>
>;
export type RuntimeServiceGetInstanceQueryError = ErrorType<RpcStatus>;

/**
 * @summary GetInstance returns information about a specific instance
 */

export function createRuntimeServiceGetInstance<
  TData = Awaited<ReturnType<typeof runtimeServiceGetInstance>>,
  TError = ErrorType<RpcStatus>,
>(
  instanceId: string,
  params?: RuntimeServiceGetInstanceParams,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof runtimeServiceGetInstance>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): CreateQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getRuntimeServiceGetInstanceQueryOptions(
    instanceId,
    params,
    options,
  );

  const query = createQuery(queryOptions, queryClient) as CreateQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary DeleteInstance deletes an instance
 */
export const runtimeServiceDeleteInstance = (
  instanceId: string,
  runtimeServiceDeleteInstanceBody: RuntimeServiceDeleteInstanceBody,
  signal?: AbortSignal,
) => {
  return httpClient<V1DeleteInstanceResponse>({
    url: `/v1/instances/${instanceId}`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: runtimeServiceDeleteInstanceBody,
    signal,
  });
};

export const getRuntimeServiceDeleteInstanceMutationOptions = <
  TError = ErrorType<RpcStatus>,
  TContext = unknown,
>(options?: {
  mutation?: CreateMutationOptions<
    Awaited<ReturnType<typeof runtimeServiceDeleteInstance>>,
    TError,
    { instanceId: string; data: RuntimeServiceDeleteInstanceBody },
    TContext
  >;
}): CreateMutationOptions<
  Awaited<ReturnType<typeof runtimeServiceDeleteInstance>>,
  TError,
  { instanceId: string; data: RuntimeServiceDeleteInstanceBody },
  TContext
> => {
  const mutationKey = ["runtimeServiceDeleteInstance"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof runtimeServiceDeleteInstance>>,
    { instanceId: string; data: RuntimeServiceDeleteInstanceBody }
  > = (props) => {
    const { instanceId, data } = props ?? {};

    return runtimeServiceDeleteInstance(instanceId, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type RuntimeServiceDeleteInstanceMutationResult = NonNullable<
  Awaited<ReturnType<typeof runtimeServiceDeleteInstance>>
>;
export type RuntimeServiceDeleteInstanceMutationBody =
  RuntimeServiceDeleteInstanceBody;
export type RuntimeServiceDeleteInstanceMutationError = ErrorType<RpcStatus>;

/**
 * @summary DeleteInstance deletes an instance
 */
export const createRuntimeServiceDeleteInstance = <
  TError = ErrorType<RpcStatus>,
  TContext = unknown,
>(
  options?: {
    mutation?: CreateMutationOptions<
      Awaited<ReturnType<typeof runtimeServiceDeleteInstance>>,
      TError,
      { instanceId: string; data: RuntimeServiceDeleteInstanceBody },
      TContext
    >;
  },
  queryClient?: QueryClient,
): CreateMutationResult<
  Awaited<ReturnType<typeof runtimeServiceDeleteInstance>>,
  TError,
  { instanceId: string; data: RuntimeServiceDeleteInstanceBody },
  TContext
> => {
  const mutationOptions =
    getRuntimeServiceDeleteInstanceMutationOptions(options);

  return createMutation(mutationOptions, queryClient);
};
/**
 * @summary EditInstance edits an existing instance
 */
export const runtimeServiceEditInstance = (
  instanceId: string,
  runtimeServiceEditInstanceBody: RuntimeServiceEditInstanceBody,
) => {
  return httpClient<V1EditInstanceResponse>({
    url: `/v1/instances/${instanceId}`,
    method: "PATCH",
    headers: { "Content-Type": "application/json" },
    data: runtimeServiceEditInstanceBody,
  });
};

export const getRuntimeServiceEditInstanceMutationOptions = <
  TError = ErrorType<RpcStatus>,
  TContext = unknown,
>(options?: {
  mutation?: CreateMutationOptions<
    Awaited<ReturnType<typeof runtimeServiceEditInstance>>,
    TError,
    { instanceId: string; data: RuntimeServiceEditInstanceBody },
    TContext
  >;
}): CreateMutationOptions<
  Awaited<ReturnType<typeof runtimeServiceEditInstance>>,
  TError,
  { instanceId: string; data: RuntimeServiceEditInstanceBody },
  TContext
> => {
  const mutationKey = ["runtimeServiceEditInstance"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof runtimeServiceEditInstance>>,
    { instanceId: string; data: RuntimeServiceEditInstanceBody }
  > = (props) => {
    const { instanceId, data } = props ?? {};

    return runtimeServiceEditInstance(instanceId, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type RuntimeServiceEditInstanceMutationResult = NonNullable<
  Awaited<ReturnType<typeof runtimeServiceEditInstance>>
>;
export type RuntimeServiceEditInstanceMutationBody =
  RuntimeServiceEditInstanceBody;
export type RuntimeServiceEditInstanceMutationError = ErrorType<RpcStatus>;

/**
 * @summary EditInstance edits an existing instance
 */
export const createRuntimeServiceEditInstance = <
  TError = ErrorType<RpcStatus>,
  TContext = unknown,
>(
  options?: {
    mutation?: CreateMutationOptions<
      Awaited<ReturnType<typeof runtimeServiceEditInstance>>,
      TError,
      { instanceId: string; data: RuntimeServiceEditInstanceBody },
      TContext
    >;
  },
  queryClient?: QueryClient,
): CreateMutationResult<
  Awaited<ReturnType<typeof runtimeServiceEditInstance>>,
  TError,
  { instanceId: string; data: RuntimeServiceEditInstanceBody },
  TContext
> => {
  const mutationOptions = getRuntimeServiceEditInstanceMutationOptions(options);

  return createMutation(mutationOptions, queryClient);
};
/**
 * @summary AnalyzeConnectors scans all the project files and returns information about all referenced connectors.
 */
export const runtimeServiceAnalyzeConnectors = (
  instanceId: string,
  signal?: AbortSignal,
) => {
  return httpClient<V1AnalyzeConnectorsResponse>({
    url: `/v1/instances/${instanceId}/connectors/analyze`,
    method: "GET",
    signal,
  });
};

export const getRuntimeServiceAnalyzeConnectorsQueryKey = (
  instanceId: string,
) => {
  return [`/v1/instances/${instanceId}/connectors/analyze`] as const;
};

export const getRuntimeServiceAnalyzeConnectorsQueryOptions = <
  TData = Awaited<ReturnType<typeof runtimeServiceAnalyzeConnectors>>,
  TError = ErrorType<RpcStatus>,
>(
  instanceId: string,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof runtimeServiceAnalyzeConnectors>>,
        TError,
        TData
      >
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getRuntimeServiceAnalyzeConnectorsQueryKey(instanceId);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof runtimeServiceAnalyzeConnectors>>
  > = ({ signal }) => runtimeServiceAnalyzeConnectors(instanceId, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!instanceId,
    ...queryOptions,
  } as CreateQueryOptions<
    Awaited<ReturnType<typeof runtimeServiceAnalyzeConnectors>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type RuntimeServiceAnalyzeConnectorsQueryResult = NonNullable<
  Awaited<ReturnType<typeof runtimeServiceAnalyzeConnectors>>
>;
export type RuntimeServiceAnalyzeConnectorsQueryError = ErrorType<RpcStatus>;

/**
 * @summary AnalyzeConnectors scans all the project files and returns information about all referenced connectors.
 */

export function createRuntimeServiceAnalyzeConnectors<
  TData = Awaited<ReturnType<typeof runtimeServiceAnalyzeConnectors>>,
  TError = ErrorType<RpcStatus>,
>(
  instanceId: string,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof runtimeServiceAnalyzeConnectors>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): CreateQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getRuntimeServiceAnalyzeConnectorsQueryOptions(
    instanceId,
    options,
  );

  const query = createQuery(queryOptions, queryClient) as CreateQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary ListNotifierConnectors returns the names of all configured connectors that can be used as notifiers.
This API is much faster than AnalyzeConnectors and can be called without admin-level permissions.
 */
export const runtimeServiceListNotifierConnectors = (
  instanceId: string,
  signal?: AbortSignal,
) => {
  return httpClient<V1ListNotifierConnectorsResponse>({
    url: `/v1/instances/${instanceId}/connectors/notifiers`,
    method: "GET",
    signal,
  });
};

export const getRuntimeServiceListNotifierConnectorsQueryKey = (
  instanceId: string,
) => {
  return [`/v1/instances/${instanceId}/connectors/notifiers`] as const;
};

export const getRuntimeServiceListNotifierConnectorsQueryOptions = <
  TData = Awaited<ReturnType<typeof runtimeServiceListNotifierConnectors>>,
  TError = ErrorType<RpcStatus>,
>(
  instanceId: string,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof runtimeServiceListNotifierConnectors>>,
        TError,
        TData
      >
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getRuntimeServiceListNotifierConnectorsQueryKey(instanceId);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof runtimeServiceListNotifierConnectors>>
  > = ({ signal }) => runtimeServiceListNotifierConnectors(instanceId, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!instanceId,
    ...queryOptions,
  } as CreateQueryOptions<
    Awaited<ReturnType<typeof runtimeServiceListNotifierConnectors>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type RuntimeServiceListNotifierConnectorsQueryResult = NonNullable<
  Awaited<ReturnType<typeof runtimeServiceListNotifierConnectors>>
>;
export type RuntimeServiceListNotifierConnectorsQueryError =
  ErrorType<RpcStatus>;

/**
 * @summary ListNotifierConnectors returns the names of all configured connectors that can be used as notifiers.
This API is much faster than AnalyzeConnectors and can be called without admin-level permissions.
 */

export function createRuntimeServiceListNotifierConnectors<
  TData = Awaited<ReturnType<typeof runtimeServiceListNotifierConnectors>>,
  TError = ErrorType<RpcStatus>,
>(
  instanceId: string,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof runtimeServiceListNotifierConnectors>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): CreateQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getRuntimeServiceListNotifierConnectorsQueryOptions(
    instanceId,
    options,
  );

  const query = createQuery(queryOptions, queryClient) as CreateQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary ListFiles lists all the files matching a glob in a repo.
The files are sorted by their full path.
 */
export const runtimeServiceListFiles = (
  instanceId: string,
  params?: RuntimeServiceListFilesParams,
  signal?: AbortSignal,
) => {
  return httpClient<V1ListFilesResponse>({
    url: `/v1/instances/${instanceId}/files`,
    method: "GET",
    params,
    signal,
  });
};

export const getRuntimeServiceListFilesQueryKey = (
  instanceId: string,
  params?: RuntimeServiceListFilesParams,
) => {
  return [
    `/v1/instances/${instanceId}/files`,
    ...(params ? [params] : []),
  ] as const;
};

export const getRuntimeServiceListFilesQueryOptions = <
  TData = Awaited<ReturnType<typeof runtimeServiceListFiles>>,
  TError = ErrorType<RpcStatus>,
>(
  instanceId: string,
  params?: RuntimeServiceListFilesParams,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof runtimeServiceListFiles>>,
        TError,
        TData
      >
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getRuntimeServiceListFilesQueryKey(instanceId, params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof runtimeServiceListFiles>>
  > = ({ signal }) => runtimeServiceListFiles(instanceId, params, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!instanceId,
    ...queryOptions,
  } as CreateQueryOptions<
    Awaited<ReturnType<typeof runtimeServiceListFiles>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type RuntimeServiceListFilesQueryResult = NonNullable<
  Awaited<ReturnType<typeof runtimeServiceListFiles>>
>;
export type RuntimeServiceListFilesQueryError = ErrorType<RpcStatus>;

/**
 * @summary ListFiles lists all the files matching a glob in a repo.
The files are sorted by their full path.
 */

export function createRuntimeServiceListFiles<
  TData = Awaited<ReturnType<typeof runtimeServiceListFiles>>,
  TError = ErrorType<RpcStatus>,
>(
  instanceId: string,
  params?: RuntimeServiceListFilesParams,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof runtimeServiceListFiles>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): CreateQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getRuntimeServiceListFilesQueryOptions(
    instanceId,
    params,
    options,
  );

  const query = createQuery(queryOptions, queryClient) as CreateQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary CreateDirectory create a directory for the given path
 */
export const runtimeServiceCreateDirectory = (
  instanceId: string,
  runtimeServiceCreateDirectoryBody: RuntimeServiceCreateDirectoryBody,
  signal?: AbortSignal,
) => {
  return httpClient<V1CreateDirectoryResponse>({
    url: `/v1/instances/${instanceId}/files/dir`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: runtimeServiceCreateDirectoryBody,
    signal,
  });
};

export const getRuntimeServiceCreateDirectoryMutationOptions = <
  TError = ErrorType<RpcStatus>,
  TContext = unknown,
>(options?: {
  mutation?: CreateMutationOptions<
    Awaited<ReturnType<typeof runtimeServiceCreateDirectory>>,
    TError,
    { instanceId: string; data: RuntimeServiceCreateDirectoryBody },
    TContext
  >;
}): CreateMutationOptions<
  Awaited<ReturnType<typeof runtimeServiceCreateDirectory>>,
  TError,
  { instanceId: string; data: RuntimeServiceCreateDirectoryBody },
  TContext
> => {
  const mutationKey = ["runtimeServiceCreateDirectory"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof runtimeServiceCreateDirectory>>,
    { instanceId: string; data: RuntimeServiceCreateDirectoryBody }
  > = (props) => {
    const { instanceId, data } = props ?? {};

    return runtimeServiceCreateDirectory(instanceId, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type RuntimeServiceCreateDirectoryMutationResult = NonNullable<
  Awaited<ReturnType<typeof runtimeServiceCreateDirectory>>
>;
export type RuntimeServiceCreateDirectoryMutationBody =
  RuntimeServiceCreateDirectoryBody;
export type RuntimeServiceCreateDirectoryMutationError = ErrorType<RpcStatus>;

/**
 * @summary CreateDirectory create a directory for the given path
 */
export const createRuntimeServiceCreateDirectory = <
  TError = ErrorType<RpcStatus>,
  TContext = unknown,
>(
  options?: {
    mutation?: CreateMutationOptions<
      Awaited<ReturnType<typeof runtimeServiceCreateDirectory>>,
      TError,
      { instanceId: string; data: RuntimeServiceCreateDirectoryBody },
      TContext
    >;
  },
  queryClient?: QueryClient,
): CreateMutationResult<
  Awaited<ReturnType<typeof runtimeServiceCreateDirectory>>,
  TError,
  { instanceId: string; data: RuntimeServiceCreateDirectoryBody },
  TContext
> => {
  const mutationOptions =
    getRuntimeServiceCreateDirectoryMutationOptions(options);

  return createMutation(mutationOptions, queryClient);
};
/**
 * @summary GetFile returns the contents of a specific file in a repo.
 */
export const runtimeServiceGetFile = (
  instanceId: string,
  params?: RuntimeServiceGetFileParams,
  signal?: AbortSignal,
) => {
  return httpClient<V1GetFileResponse>({
    url: `/v1/instances/${instanceId}/files/entry`,
    method: "GET",
    params,
    signal,
  });
};

export const getRuntimeServiceGetFileQueryKey = (
  instanceId: string,
  params?: RuntimeServiceGetFileParams,
) => {
  return [
    `/v1/instances/${instanceId}/files/entry`,
    ...(params ? [params] : []),
  ] as const;
};

export const getRuntimeServiceGetFileQueryOptions = <
  TData = Awaited<ReturnType<typeof runtimeServiceGetFile>>,
  TError = ErrorType<RpcStatus>,
>(
  instanceId: string,
  params?: RuntimeServiceGetFileParams,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof runtimeServiceGetFile>>,
        TError,
        TData
      >
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getRuntimeServiceGetFileQueryKey(instanceId, params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof runtimeServiceGetFile>>
  > = ({ signal }) => runtimeServiceGetFile(instanceId, params, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!instanceId,
    ...queryOptions,
  } as CreateQueryOptions<
    Awaited<ReturnType<typeof runtimeServiceGetFile>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type RuntimeServiceGetFileQueryResult = NonNullable<
  Awaited<ReturnType<typeof runtimeServiceGetFile>>
>;
export type RuntimeServiceGetFileQueryError = ErrorType<RpcStatus>;

/**
 * @summary GetFile returns the contents of a specific file in a repo.
 */

export function createRuntimeServiceGetFile<
  TData = Awaited<ReturnType<typeof runtimeServiceGetFile>>,
  TError = ErrorType<RpcStatus>,
>(
  instanceId: string,
  params?: RuntimeServiceGetFileParams,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof runtimeServiceGetFile>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): CreateQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getRuntimeServiceGetFileQueryOptions(
    instanceId,
    params,
    options,
  );

  const query = createQuery(queryOptions, queryClient) as CreateQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary DeleteFile deletes a file from a repo
 */
export const runtimeServiceDeleteFile = (
  instanceId: string,
  params?: RuntimeServiceDeleteFileParams,
) => {
  return httpClient<V1DeleteFileResponse>({
    url: `/v1/instances/${instanceId}/files/entry`,
    method: "DELETE",
    params,
  });
};

export const getRuntimeServiceDeleteFileMutationOptions = <
  TError = ErrorType<RpcStatus>,
  TContext = unknown,
>(options?: {
  mutation?: CreateMutationOptions<
    Awaited<ReturnType<typeof runtimeServiceDeleteFile>>,
    TError,
    { instanceId: string; params?: RuntimeServiceDeleteFileParams },
    TContext
  >;
}): CreateMutationOptions<
  Awaited<ReturnType<typeof runtimeServiceDeleteFile>>,
  TError,
  { instanceId: string; params?: RuntimeServiceDeleteFileParams },
  TContext
> => {
  const mutationKey = ["runtimeServiceDeleteFile"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof runtimeServiceDeleteFile>>,
    { instanceId: string; params?: RuntimeServiceDeleteFileParams }
  > = (props) => {
    const { instanceId, params } = props ?? {};

    return runtimeServiceDeleteFile(instanceId, params);
  };

  return { mutationFn, ...mutationOptions };
};

export type RuntimeServiceDeleteFileMutationResult = NonNullable<
  Awaited<ReturnType<typeof runtimeServiceDeleteFile>>
>;

export type RuntimeServiceDeleteFileMutationError = ErrorType<RpcStatus>;

/**
 * @summary DeleteFile deletes a file from a repo
 */
export const createRuntimeServiceDeleteFile = <
  TError = ErrorType<RpcStatus>,
  TContext = unknown,
>(
  options?: {
    mutation?: CreateMutationOptions<
      Awaited<ReturnType<typeof runtimeServiceDeleteFile>>,
      TError,
      { instanceId: string; params?: RuntimeServiceDeleteFileParams },
      TContext
    >;
  },
  queryClient?: QueryClient,
): CreateMutationResult<
  Awaited<ReturnType<typeof runtimeServiceDeleteFile>>,
  TError,
  { instanceId: string; params?: RuntimeServiceDeleteFileParams },
  TContext
> => {
  const mutationOptions = getRuntimeServiceDeleteFileMutationOptions(options);

  return createMutation(mutationOptions, queryClient);
};
/**
 * @summary PutFile creates or updates a file in a repo
 */
export const runtimeServicePutFile = (
  instanceId: string,
  runtimeServicePutFileBody: RuntimeServicePutFileBody,
  signal?: AbortSignal,
) => {
  return httpClient<V1PutFileResponse>({
    url: `/v1/instances/${instanceId}/files/entry`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: runtimeServicePutFileBody,
    signal,
  });
};

export const getRuntimeServicePutFileMutationOptions = <
  TError = ErrorType<RpcStatus>,
  TContext = unknown,
>(options?: {
  mutation?: CreateMutationOptions<
    Awaited<ReturnType<typeof runtimeServicePutFile>>,
    TError,
    { instanceId: string; data: RuntimeServicePutFileBody },
    TContext
  >;
}): CreateMutationOptions<
  Awaited<ReturnType<typeof runtimeServicePutFile>>,
  TError,
  { instanceId: string; data: RuntimeServicePutFileBody },
  TContext
> => {
  const mutationKey = ["runtimeServicePutFile"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof runtimeServicePutFile>>,
    { instanceId: string; data: RuntimeServicePutFileBody }
  > = (props) => {
    const { instanceId, data } = props ?? {};

    return runtimeServicePutFile(instanceId, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type RuntimeServicePutFileMutationResult = NonNullable<
  Awaited<ReturnType<typeof runtimeServicePutFile>>
>;
export type RuntimeServicePutFileMutationBody = RuntimeServicePutFileBody;
export type RuntimeServicePutFileMutationError = ErrorType<RpcStatus>;

/**
 * @summary PutFile creates or updates a file in a repo
 */
export const createRuntimeServicePutFile = <
  TError = ErrorType<RpcStatus>,
  TContext = unknown,
>(
  options?: {
    mutation?: CreateMutationOptions<
      Awaited<ReturnType<typeof runtimeServicePutFile>>,
      TError,
      { instanceId: string; data: RuntimeServicePutFileBody },
      TContext
    >;
  },
  queryClient?: QueryClient,
): CreateMutationResult<
  Awaited<ReturnType<typeof runtimeServicePutFile>>,
  TError,
  { instanceId: string; data: RuntimeServicePutFileBody },
  TContext
> => {
  const mutationOptions = getRuntimeServicePutFileMutationOptions(options);

  return createMutation(mutationOptions, queryClient);
};
/**
 * @summary GenerateMetricsViewFile generates a metrics view YAML file from a table in an OLAP database
 */
export const runtimeServiceGenerateMetricsViewFile = (
  instanceId: string,
  runtimeServiceGenerateMetricsViewFileBody: RuntimeServiceGenerateMetricsViewFileBody,
  signal?: AbortSignal,
) => {
  return httpClient<V1GenerateMetricsViewFileResponse>({
    url: `/v1/instances/${instanceId}/files/generate-metrics-view`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: runtimeServiceGenerateMetricsViewFileBody,
    signal,
  });
};

export const getRuntimeServiceGenerateMetricsViewFileMutationOptions = <
  TError = ErrorType<RpcStatus>,
  TContext = unknown,
>(options?: {
  mutation?: CreateMutationOptions<
    Awaited<ReturnType<typeof runtimeServiceGenerateMetricsViewFile>>,
    TError,
    { instanceId: string; data: RuntimeServiceGenerateMetricsViewFileBody },
    TContext
  >;
}): CreateMutationOptions<
  Awaited<ReturnType<typeof runtimeServiceGenerateMetricsViewFile>>,
  TError,
  { instanceId: string; data: RuntimeServiceGenerateMetricsViewFileBody },
  TContext
> => {
  const mutationKey = ["runtimeServiceGenerateMetricsViewFile"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof runtimeServiceGenerateMetricsViewFile>>,
    { instanceId: string; data: RuntimeServiceGenerateMetricsViewFileBody }
  > = (props) => {
    const { instanceId, data } = props ?? {};

    return runtimeServiceGenerateMetricsViewFile(instanceId, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type RuntimeServiceGenerateMetricsViewFileMutationResult = NonNullable<
  Awaited<ReturnType<typeof runtimeServiceGenerateMetricsViewFile>>
>;
export type RuntimeServiceGenerateMetricsViewFileMutationBody =
  RuntimeServiceGenerateMetricsViewFileBody;
export type RuntimeServiceGenerateMetricsViewFileMutationError =
  ErrorType<RpcStatus>;

/**
 * @summary GenerateMetricsViewFile generates a metrics view YAML file from a table in an OLAP database
 */
export const createRuntimeServiceGenerateMetricsViewFile = <
  TError = ErrorType<RpcStatus>,
  TContext = unknown,
>(
  options?: {
    mutation?: CreateMutationOptions<
      Awaited<ReturnType<typeof runtimeServiceGenerateMetricsViewFile>>,
      TError,
      { instanceId: string; data: RuntimeServiceGenerateMetricsViewFileBody },
      TContext
    >;
  },
  queryClient?: QueryClient,
): CreateMutationResult<
  Awaited<ReturnType<typeof runtimeServiceGenerateMetricsViewFile>>,
  TError,
  { instanceId: string; data: RuntimeServiceGenerateMetricsViewFileBody },
  TContext
> => {
  const mutationOptions =
    getRuntimeServiceGenerateMetricsViewFileMutationOptions(options);

  return createMutation(mutationOptions, queryClient);
};
/**
 * @summary RenameFile renames a file in a repo
 */
export const runtimeServiceRenameFile = (
  instanceId: string,
  runtimeServiceRenameFileBody: RuntimeServiceRenameFileBody,
  signal?: AbortSignal,
) => {
  return httpClient<V1RenameFileResponse>({
    url: `/v1/instances/${instanceId}/files/rename`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: runtimeServiceRenameFileBody,
    signal,
  });
};

export const getRuntimeServiceRenameFileMutationOptions = <
  TError = ErrorType<RpcStatus>,
  TContext = unknown,
>(options?: {
  mutation?: CreateMutationOptions<
    Awaited<ReturnType<typeof runtimeServiceRenameFile>>,
    TError,
    { instanceId: string; data: RuntimeServiceRenameFileBody },
    TContext
  >;
}): CreateMutationOptions<
  Awaited<ReturnType<typeof runtimeServiceRenameFile>>,
  TError,
  { instanceId: string; data: RuntimeServiceRenameFileBody },
  TContext
> => {
  const mutationKey = ["runtimeServiceRenameFile"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof runtimeServiceRenameFile>>,
    { instanceId: string; data: RuntimeServiceRenameFileBody }
  > = (props) => {
    const { instanceId, data } = props ?? {};

    return runtimeServiceRenameFile(instanceId, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type RuntimeServiceRenameFileMutationResult = NonNullable<
  Awaited<ReturnType<typeof runtimeServiceRenameFile>>
>;
export type RuntimeServiceRenameFileMutationBody = RuntimeServiceRenameFileBody;
export type RuntimeServiceRenameFileMutationError = ErrorType<RpcStatus>;

/**
 * @summary RenameFile renames a file in a repo
 */
export const createRuntimeServiceRenameFile = <
  TError = ErrorType<RpcStatus>,
  TContext = unknown,
>(
  options?: {
    mutation?: CreateMutationOptions<
      Awaited<ReturnType<typeof runtimeServiceRenameFile>>,
      TError,
      { instanceId: string; data: RuntimeServiceRenameFileBody },
      TContext
    >;
  },
  queryClient?: QueryClient,
): CreateMutationResult<
  Awaited<ReturnType<typeof runtimeServiceRenameFile>>,
  TError,
  { instanceId: string; data: RuntimeServiceRenameFileBody },
  TContext
> => {
  const mutationOptions = getRuntimeServiceRenameFileMutationOptions(options);

  return createMutation(mutationOptions, queryClient);
};
/**
 * @summary UnpackEmpty unpacks an empty project
 */
export const runtimeServiceUnpackEmpty = (
  instanceId: string,
  runtimeServiceUnpackEmptyBody: RuntimeServiceUnpackEmptyBody,
  signal?: AbortSignal,
) => {
  return httpClient<V1UnpackEmptyResponse>({
    url: `/v1/instances/${instanceId}/files/unpack-empty`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: runtimeServiceUnpackEmptyBody,
    signal,
  });
};

export const getRuntimeServiceUnpackEmptyMutationOptions = <
  TError = ErrorType<RpcStatus>,
  TContext = unknown,
>(options?: {
  mutation?: CreateMutationOptions<
    Awaited<ReturnType<typeof runtimeServiceUnpackEmpty>>,
    TError,
    { instanceId: string; data: RuntimeServiceUnpackEmptyBody },
    TContext
  >;
}): CreateMutationOptions<
  Awaited<ReturnType<typeof runtimeServiceUnpackEmpty>>,
  TError,
  { instanceId: string; data: RuntimeServiceUnpackEmptyBody },
  TContext
> => {
  const mutationKey = ["runtimeServiceUnpackEmpty"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof runtimeServiceUnpackEmpty>>,
    { instanceId: string; data: RuntimeServiceUnpackEmptyBody }
  > = (props) => {
    const { instanceId, data } = props ?? {};

    return runtimeServiceUnpackEmpty(instanceId, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type RuntimeServiceUnpackEmptyMutationResult = NonNullable<
  Awaited<ReturnType<typeof runtimeServiceUnpackEmpty>>
>;
export type RuntimeServiceUnpackEmptyMutationBody =
  RuntimeServiceUnpackEmptyBody;
export type RuntimeServiceUnpackEmptyMutationError = ErrorType<RpcStatus>;

/**
 * @summary UnpackEmpty unpacks an empty project
 */
export const createRuntimeServiceUnpackEmpty = <
  TError = ErrorType<RpcStatus>,
  TContext = unknown,
>(
  options?: {
    mutation?: CreateMutationOptions<
      Awaited<ReturnType<typeof runtimeServiceUnpackEmpty>>,
      TError,
      { instanceId: string; data: RuntimeServiceUnpackEmptyBody },
      TContext
    >;
  },
  queryClient?: QueryClient,
): CreateMutationResult<
  Awaited<ReturnType<typeof runtimeServiceUnpackEmpty>>,
  TError,
  { instanceId: string; data: RuntimeServiceUnpackEmptyBody },
  TContext
> => {
  const mutationOptions = getRuntimeServiceUnpackEmptyMutationOptions(options);

  return createMutation(mutationOptions, queryClient);
};
/**
 * @summary UnpackExample unpacks an example project
 */
export const runtimeServiceUnpackExample = (
  instanceId: string,
  runtimeServiceUnpackExampleBody: RuntimeServiceUnpackExampleBody,
  signal?: AbortSignal,
) => {
  return httpClient<V1UnpackExampleResponse>({
    url: `/v1/instances/${instanceId}/files/unpack-example`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: runtimeServiceUnpackExampleBody,
    signal,
  });
};

export const getRuntimeServiceUnpackExampleMutationOptions = <
  TError = ErrorType<RpcStatus>,
  TContext = unknown,
>(options?: {
  mutation?: CreateMutationOptions<
    Awaited<ReturnType<typeof runtimeServiceUnpackExample>>,
    TError,
    { instanceId: string; data: RuntimeServiceUnpackExampleBody },
    TContext
  >;
}): CreateMutationOptions<
  Awaited<ReturnType<typeof runtimeServiceUnpackExample>>,
  TError,
  { instanceId: string; data: RuntimeServiceUnpackExampleBody },
  TContext
> => {
  const mutationKey = ["runtimeServiceUnpackExample"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof runtimeServiceUnpackExample>>,
    { instanceId: string; data: RuntimeServiceUnpackExampleBody }
  > = (props) => {
    const { instanceId, data } = props ?? {};

    return runtimeServiceUnpackExample(instanceId, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type RuntimeServiceUnpackExampleMutationResult = NonNullable<
  Awaited<ReturnType<typeof runtimeServiceUnpackExample>>
>;
export type RuntimeServiceUnpackExampleMutationBody =
  RuntimeServiceUnpackExampleBody;
export type RuntimeServiceUnpackExampleMutationError = ErrorType<RpcStatus>;

/**
 * @summary UnpackExample unpacks an example project
 */
export const createRuntimeServiceUnpackExample = <
  TError = ErrorType<RpcStatus>,
  TContext = unknown,
>(
  options?: {
    mutation?: CreateMutationOptions<
      Awaited<ReturnType<typeof runtimeServiceUnpackExample>>,
      TError,
      { instanceId: string; data: RuntimeServiceUnpackExampleBody },
      TContext
    >;
  },
  queryClient?: QueryClient,
): CreateMutationResult<
  Awaited<ReturnType<typeof runtimeServiceUnpackExample>>,
  TError,
  { instanceId: string; data: RuntimeServiceUnpackExampleBody },
  TContext
> => {
  const mutationOptions =
    getRuntimeServiceUnpackExampleMutationOptions(options);

  return createMutation(mutationOptions, queryClient);
};
/**
 * @summary WatchFiles streams repo file update events. It is not supported on all backends.
 */
export const runtimeServiceWatchFiles = (
  instanceId: string,
  params?: RuntimeServiceWatchFilesParams,
  signal?: AbortSignal,
) => {
  return httpClient<RuntimeServiceWatchFiles200>({
    url: `/v1/instances/${instanceId}/files/watch`,
    method: "GET",
    params,
    signal,
  });
};

export const getRuntimeServiceWatchFilesQueryKey = (
  instanceId: string,
  params?: RuntimeServiceWatchFilesParams,
) => {
  return [
    `/v1/instances/${instanceId}/files/watch`,
    ...(params ? [params] : []),
  ] as const;
};

export const getRuntimeServiceWatchFilesQueryOptions = <
  TData = Awaited<ReturnType<typeof runtimeServiceWatchFiles>>,
  TError = ErrorType<RpcStatus>,
>(
  instanceId: string,
  params?: RuntimeServiceWatchFilesParams,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof runtimeServiceWatchFiles>>,
        TError,
        TData
      >
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getRuntimeServiceWatchFilesQueryKey(instanceId, params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof runtimeServiceWatchFiles>>
  > = ({ signal }) => runtimeServiceWatchFiles(instanceId, params, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!instanceId,
    ...queryOptions,
  } as CreateQueryOptions<
    Awaited<ReturnType<typeof runtimeServiceWatchFiles>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type RuntimeServiceWatchFilesQueryResult = NonNullable<
  Awaited<ReturnType<typeof runtimeServiceWatchFiles>>
>;
export type RuntimeServiceWatchFilesQueryError = ErrorType<RpcStatus>;

/**
 * @summary WatchFiles streams repo file update events. It is not supported on all backends.
 */

export function createRuntimeServiceWatchFiles<
  TData = Awaited<ReturnType<typeof runtimeServiceWatchFiles>>,
  TError = ErrorType<RpcStatus>,
>(
  instanceId: string,
  params?: RuntimeServiceWatchFilesParams,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof runtimeServiceWatchFiles>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): CreateQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getRuntimeServiceWatchFilesQueryOptions(
    instanceId,
    params,
    options,
  );

  const query = createQuery(queryOptions, queryClient) as CreateQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary GenerateRenderer generates a component renderer and renderer properties from a resolver and resolver properties
 */
export const runtimeServiceGenerateRenderer = (
  instanceId: string,
  runtimeServiceGenerateRendererBody: RuntimeServiceGenerateRendererBody,
  signal?: AbortSignal,
) => {
  return httpClient<V1GenerateRendererResponse>({
    url: `/v1/instances/${instanceId}/generate/renderer`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: runtimeServiceGenerateRendererBody,
    signal,
  });
};

export const getRuntimeServiceGenerateRendererMutationOptions = <
  TError = ErrorType<RpcStatus>,
  TContext = unknown,
>(options?: {
  mutation?: CreateMutationOptions<
    Awaited<ReturnType<typeof runtimeServiceGenerateRenderer>>,
    TError,
    { instanceId: string; data: RuntimeServiceGenerateRendererBody },
    TContext
  >;
}): CreateMutationOptions<
  Awaited<ReturnType<typeof runtimeServiceGenerateRenderer>>,
  TError,
  { instanceId: string; data: RuntimeServiceGenerateRendererBody },
  TContext
> => {
  const mutationKey = ["runtimeServiceGenerateRenderer"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof runtimeServiceGenerateRenderer>>,
    { instanceId: string; data: RuntimeServiceGenerateRendererBody }
  > = (props) => {
    const { instanceId, data } = props ?? {};

    return runtimeServiceGenerateRenderer(instanceId, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type RuntimeServiceGenerateRendererMutationResult = NonNullable<
  Awaited<ReturnType<typeof runtimeServiceGenerateRenderer>>
>;
export type RuntimeServiceGenerateRendererMutationBody =
  RuntimeServiceGenerateRendererBody;
export type RuntimeServiceGenerateRendererMutationError = ErrorType<RpcStatus>;

/**
 * @summary GenerateRenderer generates a component renderer and renderer properties from a resolver and resolver properties
 */
export const createRuntimeServiceGenerateRenderer = <
  TError = ErrorType<RpcStatus>,
  TContext = unknown,
>(
  options?: {
    mutation?: CreateMutationOptions<
      Awaited<ReturnType<typeof runtimeServiceGenerateRenderer>>,
      TError,
      { instanceId: string; data: RuntimeServiceGenerateRendererBody },
      TContext
    >;
  },
  queryClient?: QueryClient,
): CreateMutationResult<
  Awaited<ReturnType<typeof runtimeServiceGenerateRenderer>>,
  TError,
  { instanceId: string; data: RuntimeServiceGenerateRendererBody },
  TContext
> => {
  const mutationOptions =
    getRuntimeServiceGenerateRendererMutationOptions(options);

  return createMutation(mutationOptions, queryClient);
};
/**
 * @summary GenerateResolver generates resolver and resolver properties from a table or a metrics view
 */
export const runtimeServiceGenerateResolver = (
  instanceId: string,
  runtimeServiceGenerateResolverBody: RuntimeServiceGenerateResolverBody,
  signal?: AbortSignal,
) => {
  return httpClient<V1GenerateResolverResponse>({
    url: `/v1/instances/${instanceId}/generate/resolver`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: runtimeServiceGenerateResolverBody,
    signal,
  });
};

export const getRuntimeServiceGenerateResolverMutationOptions = <
  TError = ErrorType<RpcStatus>,
  TContext = unknown,
>(options?: {
  mutation?: CreateMutationOptions<
    Awaited<ReturnType<typeof runtimeServiceGenerateResolver>>,
    TError,
    { instanceId: string; data: RuntimeServiceGenerateResolverBody },
    TContext
  >;
}): CreateMutationOptions<
  Awaited<ReturnType<typeof runtimeServiceGenerateResolver>>,
  TError,
  { instanceId: string; data: RuntimeServiceGenerateResolverBody },
  TContext
> => {
  const mutationKey = ["runtimeServiceGenerateResolver"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof runtimeServiceGenerateResolver>>,
    { instanceId: string; data: RuntimeServiceGenerateResolverBody }
  > = (props) => {
    const { instanceId, data } = props ?? {};

    return runtimeServiceGenerateResolver(instanceId, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type RuntimeServiceGenerateResolverMutationResult = NonNullable<
  Awaited<ReturnType<typeof runtimeServiceGenerateResolver>>
>;
export type RuntimeServiceGenerateResolverMutationBody =
  RuntimeServiceGenerateResolverBody;
export type RuntimeServiceGenerateResolverMutationError = ErrorType<RpcStatus>;

/**
 * @summary GenerateResolver generates resolver and resolver properties from a table or a metrics view
 */
export const createRuntimeServiceGenerateResolver = <
  TError = ErrorType<RpcStatus>,
  TContext = unknown,
>(
  options?: {
    mutation?: CreateMutationOptions<
      Awaited<ReturnType<typeof runtimeServiceGenerateResolver>>,
      TError,
      { instanceId: string; data: RuntimeServiceGenerateResolverBody },
      TContext
    >;
  },
  queryClient?: QueryClient,
): CreateMutationResult<
  Awaited<ReturnType<typeof runtimeServiceGenerateResolver>>,
  TError,
  { instanceId: string; data: RuntimeServiceGenerateResolverBody },
  TContext
> => {
  const mutationOptions =
    getRuntimeServiceGenerateResolverMutationOptions(options);

  return createMutation(mutationOptions, queryClient);
};
/**
 * @summary GetLogs returns recent logs from a controller
 */
export const runtimeServiceGetLogs = (
  instanceId: string,
  params?: RuntimeServiceGetLogsParams,
  signal?: AbortSignal,
) => {
  return httpClient<V1GetLogsResponse>({
    url: `/v1/instances/${instanceId}/logs`,
    method: "GET",
    params,
    signal,
  });
};

export const getRuntimeServiceGetLogsQueryKey = (
  instanceId: string,
  params?: RuntimeServiceGetLogsParams,
) => {
  return [
    `/v1/instances/${instanceId}/logs`,
    ...(params ? [params] : []),
  ] as const;
};

export const getRuntimeServiceGetLogsQueryOptions = <
  TData = Awaited<ReturnType<typeof runtimeServiceGetLogs>>,
  TError = ErrorType<RpcStatus>,
>(
  instanceId: string,
  params?: RuntimeServiceGetLogsParams,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof runtimeServiceGetLogs>>,
        TError,
        TData
      >
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getRuntimeServiceGetLogsQueryKey(instanceId, params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof runtimeServiceGetLogs>>
  > = ({ signal }) => runtimeServiceGetLogs(instanceId, params, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!instanceId,
    ...queryOptions,
  } as CreateQueryOptions<
    Awaited<ReturnType<typeof runtimeServiceGetLogs>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type RuntimeServiceGetLogsQueryResult = NonNullable<
  Awaited<ReturnType<typeof runtimeServiceGetLogs>>
>;
export type RuntimeServiceGetLogsQueryError = ErrorType<RpcStatus>;

/**
 * @summary GetLogs returns recent logs from a controller
 */

export function createRuntimeServiceGetLogs<
  TData = Awaited<ReturnType<typeof runtimeServiceGetLogs>>,
  TError = ErrorType<RpcStatus>,
>(
  instanceId: string,
  params?: RuntimeServiceGetLogsParams,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof runtimeServiceGetLogs>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): CreateQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getRuntimeServiceGetLogsQueryOptions(
    instanceId,
    params,
    options,
  );

  const query = createQuery(queryOptions, queryClient) as CreateQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary WatchLogs streams new logs emitted from a controller
 */
export const runtimeServiceWatchLogs = (
  instanceId: string,
  params?: RuntimeServiceWatchLogsParams,
  signal?: AbortSignal,
) => {
  return httpClient<RuntimeServiceWatchLogs200>({
    url: `/v1/instances/${instanceId}/logs/watch`,
    method: "GET",
    params,
    signal,
  });
};

export const getRuntimeServiceWatchLogsQueryKey = (
  instanceId: string,
  params?: RuntimeServiceWatchLogsParams,
) => {
  return [
    `/v1/instances/${instanceId}/logs/watch`,
    ...(params ? [params] : []),
  ] as const;
};

export const getRuntimeServiceWatchLogsQueryOptions = <
  TData = Awaited<ReturnType<typeof runtimeServiceWatchLogs>>,
  TError = ErrorType<RpcStatus>,
>(
  instanceId: string,
  params?: RuntimeServiceWatchLogsParams,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof runtimeServiceWatchLogs>>,
        TError,
        TData
      >
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getRuntimeServiceWatchLogsQueryKey(instanceId, params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof runtimeServiceWatchLogs>>
  > = ({ signal }) => runtimeServiceWatchLogs(instanceId, params, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!instanceId,
    ...queryOptions,
  } as CreateQueryOptions<
    Awaited<ReturnType<typeof runtimeServiceWatchLogs>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type RuntimeServiceWatchLogsQueryResult = NonNullable<
  Awaited<ReturnType<typeof runtimeServiceWatchLogs>>
>;
export type RuntimeServiceWatchLogsQueryError = ErrorType<RpcStatus>;

/**
 * @summary WatchLogs streams new logs emitted from a controller
 */

export function createRuntimeServiceWatchLogs<
  TData = Awaited<ReturnType<typeof runtimeServiceWatchLogs>>,
  TError = ErrorType<RpcStatus>,
>(
  instanceId: string,
  params?: RuntimeServiceWatchLogsParams,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof runtimeServiceWatchLogs>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): CreateQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getRuntimeServiceWatchLogsQueryOptions(
    instanceId,
    params,
    options,
  );

  const query = createQuery(queryOptions, queryClient) as CreateQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary GetModelPartitions returns the partitions of a model
 */
export const runtimeServiceGetModelPartitions = (
  instanceId: string,
  model: string,
  params?: RuntimeServiceGetModelPartitionsParams,
  signal?: AbortSignal,
) => {
  return httpClient<V1GetModelPartitionsResponse>({
    url: `/v1/instances/${instanceId}/models/${model}/partitions`,
    method: "GET",
    params,
    signal,
  });
};

export const getRuntimeServiceGetModelPartitionsQueryKey = (
  instanceId: string,
  model: string,
  params?: RuntimeServiceGetModelPartitionsParams,
) => {
  return [
    `/v1/instances/${instanceId}/models/${model}/partitions`,
    ...(params ? [params] : []),
  ] as const;
};

export const getRuntimeServiceGetModelPartitionsInfiniteQueryOptions = <
  TData = InfiniteData<
    Awaited<ReturnType<typeof runtimeServiceGetModelPartitions>>,
    RuntimeServiceGetModelPartitionsParams["pageToken"]
  >,
  TError = ErrorType<RpcStatus>,
>(
  instanceId: string,
  model: string,
  params?: RuntimeServiceGetModelPartitionsParams,
  options?: {
    query?: Partial<
      CreateInfiniteQueryOptions<
        Awaited<ReturnType<typeof runtimeServiceGetModelPartitions>>,
        TError,
        TData,
        Awaited<ReturnType<typeof runtimeServiceGetModelPartitions>>,
        QueryKey,
        RuntimeServiceGetModelPartitionsParams["pageToken"]
      >
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getRuntimeServiceGetModelPartitionsQueryKey(instanceId, model, params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof runtimeServiceGetModelPartitions>>,
    QueryKey,
    RuntimeServiceGetModelPartitionsParams["pageToken"]
  > = ({ signal, pageParam }) =>
    runtimeServiceGetModelPartitions(
      instanceId,
      model,
      { ...params, pageToken: pageParam || params?.["pageToken"] },
      signal,
    );

  return {
    queryKey,
    queryFn,
    enabled: !!(instanceId && model),
    ...queryOptions,
  } as CreateInfiniteQueryOptions<
    Awaited<ReturnType<typeof runtimeServiceGetModelPartitions>>,
    TError,
    TData,
    Awaited<ReturnType<typeof runtimeServiceGetModelPartitions>>,
    QueryKey,
    RuntimeServiceGetModelPartitionsParams["pageToken"]
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type RuntimeServiceGetModelPartitionsInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof runtimeServiceGetModelPartitions>>
>;
export type RuntimeServiceGetModelPartitionsInfiniteQueryError =
  ErrorType<RpcStatus>;

/**
 * @summary GetModelPartitions returns the partitions of a model
 */

export function createRuntimeServiceGetModelPartitionsInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof runtimeServiceGetModelPartitions>>,
    RuntimeServiceGetModelPartitionsParams["pageToken"]
  >,
  TError = ErrorType<RpcStatus>,
>(
  instanceId: string,
  model: string,
  params?: RuntimeServiceGetModelPartitionsParams,
  options?: {
    query?: Partial<
      CreateInfiniteQueryOptions<
        Awaited<ReturnType<typeof runtimeServiceGetModelPartitions>>,
        TError,
        TData,
        Awaited<ReturnType<typeof runtimeServiceGetModelPartitions>>,
        QueryKey,
        RuntimeServiceGetModelPartitionsParams["pageToken"]
      >
    >;
  },
  queryClient?: QueryClient,
): CreateInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getRuntimeServiceGetModelPartitionsInfiniteQueryOptions(
    instanceId,
    model,
    params,
    options,
  );

  const query = createInfiniteQuery(
    queryOptions,
    queryClient,
  ) as CreateInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getRuntimeServiceGetModelPartitionsQueryOptions = <
  TData = Awaited<ReturnType<typeof runtimeServiceGetModelPartitions>>,
  TError = ErrorType<RpcStatus>,
>(
  instanceId: string,
  model: string,
  params?: RuntimeServiceGetModelPartitionsParams,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof runtimeServiceGetModelPartitions>>,
        TError,
        TData
      >
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getRuntimeServiceGetModelPartitionsQueryKey(instanceId, model, params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof runtimeServiceGetModelPartitions>>
  > = ({ signal }) =>
    runtimeServiceGetModelPartitions(instanceId, model, params, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!(instanceId && model),
    ...queryOptions,
  } as CreateQueryOptions<
    Awaited<ReturnType<typeof runtimeServiceGetModelPartitions>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type RuntimeServiceGetModelPartitionsQueryResult = NonNullable<
  Awaited<ReturnType<typeof runtimeServiceGetModelPartitions>>
>;
export type RuntimeServiceGetModelPartitionsQueryError = ErrorType<RpcStatus>;

/**
 * @summary GetModelPartitions returns the partitions of a model
 */

export function createRuntimeServiceGetModelPartitions<
  TData = Awaited<ReturnType<typeof runtimeServiceGetModelPartitions>>,
  TError = ErrorType<RpcStatus>,
>(
  instanceId: string,
  model: string,
  params?: RuntimeServiceGetModelPartitionsParams,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof runtimeServiceGetModelPartitions>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): CreateQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getRuntimeServiceGetModelPartitionsQueryOptions(
    instanceId,
    model,
    params,
    options,
  );

  const query = createQuery(queryOptions, queryClient) as CreateQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary QueryResolver queries a resolver with the given properties and arguments
 */
export const runtimeServiceQueryResolver = (
  instanceId: string,
  runtimeServiceQueryResolverBody: RuntimeServiceQueryResolverBody,
  signal?: AbortSignal,
) => {
  return httpClient<V1QueryResolverResponse>({
    url: `/v1/instances/${instanceId}/query/resolver`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: runtimeServiceQueryResolverBody,
    signal,
  });
};

export const getRuntimeServiceQueryResolverMutationOptions = <
  TError = ErrorType<RpcStatus>,
  TContext = unknown,
>(options?: {
  mutation?: CreateMutationOptions<
    Awaited<ReturnType<typeof runtimeServiceQueryResolver>>,
    TError,
    { instanceId: string; data: RuntimeServiceQueryResolverBody },
    TContext
  >;
}): CreateMutationOptions<
  Awaited<ReturnType<typeof runtimeServiceQueryResolver>>,
  TError,
  { instanceId: string; data: RuntimeServiceQueryResolverBody },
  TContext
> => {
  const mutationKey = ["runtimeServiceQueryResolver"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof runtimeServiceQueryResolver>>,
    { instanceId: string; data: RuntimeServiceQueryResolverBody }
  > = (props) => {
    const { instanceId, data } = props ?? {};

    return runtimeServiceQueryResolver(instanceId, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type RuntimeServiceQueryResolverMutationResult = NonNullable<
  Awaited<ReturnType<typeof runtimeServiceQueryResolver>>
>;
export type RuntimeServiceQueryResolverMutationBody =
  RuntimeServiceQueryResolverBody;
export type RuntimeServiceQueryResolverMutationError = ErrorType<RpcStatus>;

/**
 * @summary QueryResolver queries a resolver with the given properties and arguments
 */
export const createRuntimeServiceQueryResolver = <
  TError = ErrorType<RpcStatus>,
  TContext = unknown,
>(
  options?: {
    mutation?: CreateMutationOptions<
      Awaited<ReturnType<typeof runtimeServiceQueryResolver>>,
      TError,
      { instanceId: string; data: RuntimeServiceQueryResolverBody },
      TContext
    >;
  },
  queryClient?: QueryClient,
): CreateMutationResult<
  Awaited<ReturnType<typeof runtimeServiceQueryResolver>>,
  TError,
  { instanceId: string; data: RuntimeServiceQueryResolverBody },
  TContext
> => {
  const mutationOptions =
    getRuntimeServiceQueryResolverMutationOptions(options);

  return createMutation(mutationOptions, queryClient);
};
/**
 * @summary GetResource looks up a specific catalog resource
 */
export const runtimeServiceGetResource = (
  instanceId: string,
  params?: RuntimeServiceGetResourceParams,
  signal?: AbortSignal,
) => {
  return httpClient<V1GetResourceResponse>({
    url: `/v1/instances/${instanceId}/resource`,
    method: "GET",
    params,
    signal,
  });
};

export const getRuntimeServiceGetResourceQueryKey = (
  instanceId: string,
  params?: RuntimeServiceGetResourceParams,
) => {
  return [
    `/v1/instances/${instanceId}/resource`,
    ...(params ? [params] : []),
  ] as const;
};

export const getRuntimeServiceGetResourceQueryOptions = <
  TData = Awaited<ReturnType<typeof runtimeServiceGetResource>>,
  TError = ErrorType<RpcStatus>,
>(
  instanceId: string,
  params?: RuntimeServiceGetResourceParams,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof runtimeServiceGetResource>>,
        TError,
        TData
      >
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getRuntimeServiceGetResourceQueryKey(instanceId, params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof runtimeServiceGetResource>>
  > = ({ signal }) => runtimeServiceGetResource(instanceId, params, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!instanceId,
    ...queryOptions,
  } as CreateQueryOptions<
    Awaited<ReturnType<typeof runtimeServiceGetResource>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type RuntimeServiceGetResourceQueryResult = NonNullable<
  Awaited<ReturnType<typeof runtimeServiceGetResource>>
>;
export type RuntimeServiceGetResourceQueryError = ErrorType<RpcStatus>;

/**
 * @summary GetResource looks up a specific catalog resource
 */

export function createRuntimeServiceGetResource<
  TData = Awaited<ReturnType<typeof runtimeServiceGetResource>>,
  TError = ErrorType<RpcStatus>,
>(
  instanceId: string,
  params?: RuntimeServiceGetResourceParams,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof runtimeServiceGetResource>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): CreateQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getRuntimeServiceGetResourceQueryOptions(
    instanceId,
    params,
    options,
  );

  const query = createQuery(queryOptions, queryClient) as CreateQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary ListResources lists the resources stored in the catalog
 */
export const runtimeServiceListResources = (
  instanceId: string,
  params?: RuntimeServiceListResourcesParams,
  signal?: AbortSignal,
) => {
  return httpClient<V1ListResourcesResponse>({
    url: `/v1/instances/${instanceId}/resources`,
    method: "GET",
    params,
    signal,
  });
};

export const getRuntimeServiceListResourcesQueryKey = (
  instanceId: string,
  params?: RuntimeServiceListResourcesParams,
) => {
  return [
    `/v1/instances/${instanceId}/resources`,
    ...(params ? [params] : []),
  ] as const;
};

export const getRuntimeServiceListResourcesQueryOptions = <
  TData = Awaited<ReturnType<typeof runtimeServiceListResources>>,
  TError = ErrorType<RpcStatus>,
>(
  instanceId: string,
  params?: RuntimeServiceListResourcesParams,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof runtimeServiceListResources>>,
        TError,
        TData
      >
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getRuntimeServiceListResourcesQueryKey(instanceId, params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof runtimeServiceListResources>>
  > = ({ signal }) => runtimeServiceListResources(instanceId, params, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!instanceId,
    ...queryOptions,
  } as CreateQueryOptions<
    Awaited<ReturnType<typeof runtimeServiceListResources>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type RuntimeServiceListResourcesQueryResult = NonNullable<
  Awaited<ReturnType<typeof runtimeServiceListResources>>
>;
export type RuntimeServiceListResourcesQueryError = ErrorType<RpcStatus>;

/**
 * @summary ListResources lists the resources stored in the catalog
 */

export function createRuntimeServiceListResources<
  TData = Awaited<ReturnType<typeof runtimeServiceListResources>>,
  TError = ErrorType<RpcStatus>,
>(
  instanceId: string,
  params?: RuntimeServiceListResourcesParams,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof runtimeServiceListResources>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): CreateQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getRuntimeServiceListResourcesQueryOptions(
    instanceId,
    params,
    options,
  );

  const query = createQuery(queryOptions, queryClient) as CreateQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary WatchResources streams updates to catalog resources (including creation and deletion events)
 */
export const runtimeServiceWatchResources = (
  instanceId: string,
  params?: RuntimeServiceWatchResourcesParams,
  signal?: AbortSignal,
) => {
  return httpClient<RuntimeServiceWatchResources200>({
    url: `/v1/instances/${instanceId}/resources/-/watch`,
    method: "GET",
    params,
    signal,
  });
};

export const getRuntimeServiceWatchResourcesQueryKey = (
  instanceId: string,
  params?: RuntimeServiceWatchResourcesParams,
) => {
  return [
    `/v1/instances/${instanceId}/resources/-/watch`,
    ...(params ? [params] : []),
  ] as const;
};

export const getRuntimeServiceWatchResourcesQueryOptions = <
  TData = Awaited<ReturnType<typeof runtimeServiceWatchResources>>,
  TError = ErrorType<RpcStatus>,
>(
  instanceId: string,
  params?: RuntimeServiceWatchResourcesParams,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof runtimeServiceWatchResources>>,
        TError,
        TData
      >
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getRuntimeServiceWatchResourcesQueryKey(instanceId, params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof runtimeServiceWatchResources>>
  > = ({ signal }) => runtimeServiceWatchResources(instanceId, params, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!instanceId,
    ...queryOptions,
  } as CreateQueryOptions<
    Awaited<ReturnType<typeof runtimeServiceWatchResources>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type RuntimeServiceWatchResourcesQueryResult = NonNullable<
  Awaited<ReturnType<typeof runtimeServiceWatchResources>>
>;
export type RuntimeServiceWatchResourcesQueryError = ErrorType<RpcStatus>;

/**
 * @summary WatchResources streams updates to catalog resources (including creation and deletion events)
 */

export function createRuntimeServiceWatchResources<
  TData = Awaited<ReturnType<typeof runtimeServiceWatchResources>>,
  TError = ErrorType<RpcStatus>,
>(
  instanceId: string,
  params?: RuntimeServiceWatchResourcesParams,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof runtimeServiceWatchResources>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): CreateQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getRuntimeServiceWatchResourcesQueryOptions(
    instanceId,
    params,
    options,
  );

  const query = createQuery(queryOptions, queryClient) as CreateQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary GetExplore is a convenience RPC that combines looking up an Explore resource and its underlying MetricsView into one network call.
 */
export const runtimeServiceGetExplore = (
  instanceId: string,
  params?: RuntimeServiceGetExploreParams,
  signal?: AbortSignal,
) => {
  return httpClient<V1GetExploreResponse>({
    url: `/v1/instances/${instanceId}/resources/explore`,
    method: "GET",
    params,
    signal,
  });
};

export const getRuntimeServiceGetExploreQueryKey = (
  instanceId: string,
  params?: RuntimeServiceGetExploreParams,
) => {
  return [
    `/v1/instances/${instanceId}/resources/explore`,
    ...(params ? [params] : []),
  ] as const;
};

export const getRuntimeServiceGetExploreQueryOptions = <
  TData = Awaited<ReturnType<typeof runtimeServiceGetExplore>>,
  TError = ErrorType<RpcStatus>,
>(
  instanceId: string,
  params?: RuntimeServiceGetExploreParams,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof runtimeServiceGetExplore>>,
        TError,
        TData
      >
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getRuntimeServiceGetExploreQueryKey(instanceId, params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof runtimeServiceGetExplore>>
  > = ({ signal }) => runtimeServiceGetExplore(instanceId, params, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!instanceId,
    ...queryOptions,
  } as CreateQueryOptions<
    Awaited<ReturnType<typeof runtimeServiceGetExplore>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type RuntimeServiceGetExploreQueryResult = NonNullable<
  Awaited<ReturnType<typeof runtimeServiceGetExplore>>
>;
export type RuntimeServiceGetExploreQueryError = ErrorType<RpcStatus>;

/**
 * @summary GetExplore is a convenience RPC that combines looking up an Explore resource and its underlying MetricsView into one network call.
 */

export function createRuntimeServiceGetExplore<
  TData = Awaited<ReturnType<typeof runtimeServiceGetExplore>>,
  TError = ErrorType<RpcStatus>,
>(
  instanceId: string,
  params?: RuntimeServiceGetExploreParams,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof runtimeServiceGetExplore>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): CreateQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getRuntimeServiceGetExploreQueryOptions(
    instanceId,
    params,
    options,
  );

  const query = createQuery(queryOptions, queryClient) as CreateQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary CreateTrigger submits a refresh trigger, which will asynchronously refresh the specified resources.
Triggers are ephemeral resources that will be cleaned up by the controller.
 */
export const runtimeServiceCreateTrigger = (
  instanceId: string,
  runtimeServiceCreateTriggerBody: RuntimeServiceCreateTriggerBody,
  signal?: AbortSignal,
) => {
  return httpClient<V1CreateTriggerResponse>({
    url: `/v1/instances/${instanceId}/trigger`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: runtimeServiceCreateTriggerBody,
    signal,
  });
};

export const getRuntimeServiceCreateTriggerMutationOptions = <
  TError = ErrorType<RpcStatus>,
  TContext = unknown,
>(options?: {
  mutation?: CreateMutationOptions<
    Awaited<ReturnType<typeof runtimeServiceCreateTrigger>>,
    TError,
    { instanceId: string; data: RuntimeServiceCreateTriggerBody },
    TContext
  >;
}): CreateMutationOptions<
  Awaited<ReturnType<typeof runtimeServiceCreateTrigger>>,
  TError,
  { instanceId: string; data: RuntimeServiceCreateTriggerBody },
  TContext
> => {
  const mutationKey = ["runtimeServiceCreateTrigger"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof runtimeServiceCreateTrigger>>,
    { instanceId: string; data: RuntimeServiceCreateTriggerBody }
  > = (props) => {
    const { instanceId, data } = props ?? {};

    return runtimeServiceCreateTrigger(instanceId, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type RuntimeServiceCreateTriggerMutationResult = NonNullable<
  Awaited<ReturnType<typeof runtimeServiceCreateTrigger>>
>;
export type RuntimeServiceCreateTriggerMutationBody =
  RuntimeServiceCreateTriggerBody;
export type RuntimeServiceCreateTriggerMutationError = ErrorType<RpcStatus>;

/**
 * @summary CreateTrigger submits a refresh trigger, which will asynchronously refresh the specified resources.
Triggers are ephemeral resources that will be cleaned up by the controller.
 */
export const createRuntimeServiceCreateTrigger = <
  TError = ErrorType<RpcStatus>,
  TContext = unknown,
>(
  options?: {
    mutation?: CreateMutationOptions<
      Awaited<ReturnType<typeof runtimeServiceCreateTrigger>>,
      TError,
      { instanceId: string; data: RuntimeServiceCreateTriggerBody },
      TContext
    >;
  },
  queryClient?: QueryClient,
): CreateMutationResult<
  Awaited<ReturnType<typeof runtimeServiceCreateTrigger>>,
  TError,
  { instanceId: string; data: RuntimeServiceCreateTriggerBody },
  TContext
> => {
  const mutationOptions =
    getRuntimeServiceCreateTriggerMutationOptions(options);

  return createMutation(mutationOptions, queryClient);
};
/**
 * @summary AnalyzeVariables scans `Source`, `Model` and `Connector` resources in the catalog for use of an environment variable
 */
export const runtimeServiceAnalyzeVariables = (
  instanceId: string,
  signal?: AbortSignal,
) => {
  return httpClient<V1AnalyzeVariablesResponse>({
    url: `/v1/instances/${instanceId}/variables/analyze`,
    method: "GET",
    signal,
  });
};

export const getRuntimeServiceAnalyzeVariablesQueryKey = (
  instanceId: string,
) => {
  return [`/v1/instances/${instanceId}/variables/analyze`] as const;
};

export const getRuntimeServiceAnalyzeVariablesQueryOptions = <
  TData = Awaited<ReturnType<typeof runtimeServiceAnalyzeVariables>>,
  TError = ErrorType<RpcStatus>,
>(
  instanceId: string,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof runtimeServiceAnalyzeVariables>>,
        TError,
        TData
      >
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getRuntimeServiceAnalyzeVariablesQueryKey(instanceId);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof runtimeServiceAnalyzeVariables>>
  > = ({ signal }) => runtimeServiceAnalyzeVariables(instanceId, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!instanceId,
    ...queryOptions,
  } as CreateQueryOptions<
    Awaited<ReturnType<typeof runtimeServiceAnalyzeVariables>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type RuntimeServiceAnalyzeVariablesQueryResult = NonNullable<
  Awaited<ReturnType<typeof runtimeServiceAnalyzeVariables>>
>;
export type RuntimeServiceAnalyzeVariablesQueryError = ErrorType<RpcStatus>;

/**
 * @summary AnalyzeVariables scans `Source`, `Model` and `Connector` resources in the catalog for use of an environment variable
 */

export function createRuntimeServiceAnalyzeVariables<
  TData = Awaited<ReturnType<typeof runtimeServiceAnalyzeVariables>>,
  TError = ErrorType<RpcStatus>,
>(
  instanceId: string,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof runtimeServiceAnalyzeVariables>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): CreateQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getRuntimeServiceAnalyzeVariablesQueryOptions(
    instanceId,
    options,
  );

  const query = createQuery(queryOptions, queryClient) as CreateQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Ping returns information about the runtime
 */
export const runtimeServicePing = (signal?: AbortSignal) => {
  return httpClient<V1PingResponse>({ url: `/v1/ping`, method: "GET", signal });
};

export const getRuntimeServicePingQueryKey = () => {
  return [`/v1/ping`] as const;
};

export const getRuntimeServicePingQueryOptions = <
  TData = Awaited<ReturnType<typeof runtimeServicePing>>,
  TError = ErrorType<RpcStatus>,
>(options?: {
  query?: Partial<
    CreateQueryOptions<
      Awaited<ReturnType<typeof runtimeServicePing>>,
      TError,
      TData
    >
  >;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getRuntimeServicePingQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof runtimeServicePing>>
  > = ({ signal }) => runtimeServicePing(signal);

  return { queryKey, queryFn, ...queryOptions } as CreateQueryOptions<
    Awaited<ReturnType<typeof runtimeServicePing>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type RuntimeServicePingQueryResult = NonNullable<
  Awaited<ReturnType<typeof runtimeServicePing>>
>;
export type RuntimeServicePingQueryError = ErrorType<RpcStatus>;

/**
 * @summary Ping returns information about the runtime
 */

export function createRuntimeServicePing<
  TData = Awaited<ReturnType<typeof runtimeServicePing>>,
  TError = ErrorType<RpcStatus>,
>(
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof runtimeServicePing>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): CreateQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getRuntimeServicePingQueryOptions(options);

  const query = createQuery(queryOptions, queryClient) as CreateQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

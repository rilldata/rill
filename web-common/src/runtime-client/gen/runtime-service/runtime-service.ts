/**
 * Generated by orval v6.10.1 ðŸº
 * Do not edit manually.
 * runtime.proto
 * OpenAPI spec version: version not set
 */
import { useQuery, useMutation } from "@sveltestack/svelte-query";
import type {
  UseQueryOptions,
  UseMutationOptions,
  QueryFunction,
  MutationFunction,
  UseQueryStoreResult,
  QueryKey,
} from "@sveltestack/svelte-query";
import type {
  V1ListConnectorsResponse,
  RpcStatus,
  V1ListInstancesResponse,
  RuntimeServiceListInstancesParams,
  V1CreateInstanceResponse,
  V1CreateInstanceRequest,
  V1GetInstanceResponse,
  V1DeleteInstanceResponse,
  V1ListCatalogObjectsResponse,
  RuntimeServiceListCatalogObjectsParams,
  V1GetCatalogObjectResponse,
  V1TriggerRefreshResponse,
  V1MetricsViewMetaResponse,
  V1MetricsViewTimeSeriesResponse,
  RuntimeServiceMetricsViewTimeSeriesBody,
  V1MetricsViewToplistResponse,
  RuntimeServiceMetricsViewToplistBody,
  V1MetricsViewTotalsResponse,
  RuntimeServiceMetricsViewTotalsBody,
  V1MigrateResponse,
  RuntimeServiceMigrateBody,
  V1MigrateSingleResponse,
  RuntimeServiceMigrateSingleBody,
  V1MigrateDeleteResponse,
  RuntimeServiceMigrateDeleteBody,
  V1QueryResponse,
  RuntimeServiceQueryBody,
  V1QueryDirectResponse,
  RuntimeServiceQueryDirectBody,
  V1TriggerSyncResponse,
  V1TopKResponse,
  RuntimeServiceGetTopKBody,
  V1PingResponse,
  V1ListReposResponse,
  RuntimeServiceListReposParams,
  V1CreateRepoResponse,
  V1CreateRepoRequest,
  V1GetRepoResponse,
  V1DeleteRepoResponse,
  V1ListRepoObjectsResponse,
  V1GetRepoObjectResponse,
  V1PutRepoObjectResponse,
  RuntimeServicePutRepoObjectBody,
} from "../index.schemas";
import { httpClient } from "../../http-client";

/**
 * @summary ListConnectors returns a description of all the connectors implemented in the runtime,
including their schema and validation rules
 */
export const runtimeServiceListConnectors = (signal?: AbortSignal) => {
  return httpClient<V1ListConnectorsResponse>({
    url: `/v1/connectors/meta`,
    method: "get",
    signal,
  });
};

export const getRuntimeServiceListConnectorsQueryKey = () => [
  `/v1/connectors/meta`,
];

export type RuntimeServiceListConnectorsQueryResult = NonNullable<
  Awaited<ReturnType<typeof runtimeServiceListConnectors>>
>;
export type RuntimeServiceListConnectorsQueryError = RpcStatus;

export const useRuntimeServiceListConnectors = <
  TData = Awaited<ReturnType<typeof runtimeServiceListConnectors>>,
  TError = RpcStatus
>(options?: {
  query?: UseQueryOptions<
    Awaited<ReturnType<typeof runtimeServiceListConnectors>>,
    TError,
    TData
  >;
}): UseQueryStoreResult<
  Awaited<ReturnType<typeof runtimeServiceListConnectors>>,
  TError,
  TData,
  QueryKey
> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getRuntimeServiceListConnectorsQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof runtimeServiceListConnectors>>
  > = ({ signal }) => runtimeServiceListConnectors(signal);

  const query = useQuery<
    Awaited<ReturnType<typeof runtimeServiceListConnectors>>,
    TError,
    TData
  >(queryKey, queryFn, queryOptions) as UseQueryStoreResult<
    Awaited<ReturnType<typeof runtimeServiceListConnectors>>,
    TError,
    TData,
    QueryKey
  > & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
};

/**
 * @summary ListInstances lists all the instances currently managed by the runtime
 */
export const runtimeServiceListInstances = (
  params?: RuntimeServiceListInstancesParams,
  signal?: AbortSignal
) => {
  return httpClient<V1ListInstancesResponse>({
    url: `/v1/instances`,
    method: "get",
    params,
    signal,
  });
};

export const getRuntimeServiceListInstancesQueryKey = (
  params?: RuntimeServiceListInstancesParams
) => [`/v1/instances`, ...(params ? [params] : [])];

export type RuntimeServiceListInstancesQueryResult = NonNullable<
  Awaited<ReturnType<typeof runtimeServiceListInstances>>
>;
export type RuntimeServiceListInstancesQueryError = RpcStatus;

export const useRuntimeServiceListInstances = <
  TData = Awaited<ReturnType<typeof runtimeServiceListInstances>>,
  TError = RpcStatus
>(
  params?: RuntimeServiceListInstancesParams,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof runtimeServiceListInstances>>,
      TError,
      TData
    >;
  }
): UseQueryStoreResult<
  Awaited<ReturnType<typeof runtimeServiceListInstances>>,
  TError,
  TData,
  QueryKey
> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getRuntimeServiceListInstancesQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof runtimeServiceListInstances>>
  > = ({ signal }) => runtimeServiceListInstances(params, signal);

  const query = useQuery<
    Awaited<ReturnType<typeof runtimeServiceListInstances>>,
    TError,
    TData
  >(queryKey, queryFn, queryOptions) as UseQueryStoreResult<
    Awaited<ReturnType<typeof runtimeServiceListInstances>>,
    TError,
    TData,
    QueryKey
  > & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
};

/**
 * @summary CreateInstance creates a new instance
 */
export const runtimeServiceCreateInstance = (
  v1CreateInstanceRequest: V1CreateInstanceRequest
) => {
  return httpClient<V1CreateInstanceResponse>({
    url: `/v1/instances`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: v1CreateInstanceRequest,
  });
};

export type RuntimeServiceCreateInstanceMutationResult = NonNullable<
  Awaited<ReturnType<typeof runtimeServiceCreateInstance>>
>;
export type RuntimeServiceCreateInstanceMutationBody = V1CreateInstanceRequest;
export type RuntimeServiceCreateInstanceMutationError = RpcStatus;

export const useRuntimeServiceCreateInstance = <
  TError = RpcStatus,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof runtimeServiceCreateInstance>>,
    TError,
    { data: V1CreateInstanceRequest },
    TContext
  >;
}) => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof runtimeServiceCreateInstance>>,
    { data: V1CreateInstanceRequest }
  > = (props) => {
    const { data } = props ?? {};

    return runtimeServiceCreateInstance(data);
  };

  return useMutation<
    Awaited<ReturnType<typeof runtimeServiceCreateInstance>>,
    TError,
    { data: V1CreateInstanceRequest },
    TContext
  >(mutationFn, mutationOptions);
};
/**
 * @summary GetInstance returns information about a specific instance
 */
export const runtimeServiceGetInstance = (
  instanceId: string,
  signal?: AbortSignal
) => {
  return httpClient<V1GetInstanceResponse>({
    url: `/v1/instances/${instanceId}`,
    method: "get",
    signal,
  });
};

export const getRuntimeServiceGetInstanceQueryKey = (instanceId: string) => [
  `/v1/instances/${instanceId}`,
];

export type RuntimeServiceGetInstanceQueryResult = NonNullable<
  Awaited<ReturnType<typeof runtimeServiceGetInstance>>
>;
export type RuntimeServiceGetInstanceQueryError = RpcStatus;

export const useRuntimeServiceGetInstance = <
  TData = Awaited<ReturnType<typeof runtimeServiceGetInstance>>,
  TError = RpcStatus
>(
  instanceId: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof runtimeServiceGetInstance>>,
      TError,
      TData
    >;
  }
): UseQueryStoreResult<
  Awaited<ReturnType<typeof runtimeServiceGetInstance>>,
  TError,
  TData,
  QueryKey
> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getRuntimeServiceGetInstanceQueryKey(instanceId);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof runtimeServiceGetInstance>>
  > = ({ signal }) => runtimeServiceGetInstance(instanceId, signal);

  const query = useQuery<
    Awaited<ReturnType<typeof runtimeServiceGetInstance>>,
    TError,
    TData
  >(queryKey, queryFn, {
    enabled: !!instanceId,
    ...queryOptions,
  }) as UseQueryStoreResult<
    Awaited<ReturnType<typeof runtimeServiceGetInstance>>,
    TError,
    TData,
    QueryKey
  > & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
};

/**
 * @summary DeleteInstance deletes an instance
 */
export const runtimeServiceDeleteInstance = (instanceId: string) => {
  return httpClient<V1DeleteInstanceResponse>({
    url: `/v1/instances/${instanceId}`,
    method: "delete",
  });
};

export type RuntimeServiceDeleteInstanceMutationResult = NonNullable<
  Awaited<ReturnType<typeof runtimeServiceDeleteInstance>>
>;

export type RuntimeServiceDeleteInstanceMutationError = RpcStatus;

export const useRuntimeServiceDeleteInstance = <
  TError = RpcStatus,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof runtimeServiceDeleteInstance>>,
    TError,
    { instanceId: string },
    TContext
  >;
}) => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof runtimeServiceDeleteInstance>>,
    { instanceId: string }
  > = (props) => {
    const { instanceId } = props ?? {};

    return runtimeServiceDeleteInstance(instanceId);
  };

  return useMutation<
    Awaited<ReturnType<typeof runtimeServiceDeleteInstance>>,
    TError,
    { instanceId: string },
    TContext
  >(mutationFn, mutationOptions);
};
/**
 * @summary ListCatalogObjects lists all the objects (like tables, sources or metrics views) registered in an instance's catalog
 */
export const runtimeServiceListCatalogObjects = (
  instanceId: string,
  params?: RuntimeServiceListCatalogObjectsParams,
  signal?: AbortSignal
) => {
  return httpClient<V1ListCatalogObjectsResponse>({
    url: `/v1/instances/${instanceId}/catalog`,
    method: "get",
    params,
    signal,
  });
};

export const getRuntimeServiceListCatalogObjectsQueryKey = (
  instanceId: string,
  params?: RuntimeServiceListCatalogObjectsParams
) => [`/v1/instances/${instanceId}/catalog`, ...(params ? [params] : [])];

export type RuntimeServiceListCatalogObjectsQueryResult = NonNullable<
  Awaited<ReturnType<typeof runtimeServiceListCatalogObjects>>
>;
export type RuntimeServiceListCatalogObjectsQueryError = RpcStatus;

export const useRuntimeServiceListCatalogObjects = <
  TData = Awaited<ReturnType<typeof runtimeServiceListCatalogObjects>>,
  TError = RpcStatus
>(
  instanceId: string,
  params?: RuntimeServiceListCatalogObjectsParams,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof runtimeServiceListCatalogObjects>>,
      TError,
      TData
    >;
  }
): UseQueryStoreResult<
  Awaited<ReturnType<typeof runtimeServiceListCatalogObjects>>,
  TError,
  TData,
  QueryKey
> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getRuntimeServiceListCatalogObjectsQueryKey(instanceId, params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof runtimeServiceListCatalogObjects>>
  > = ({ signal }) =>
    runtimeServiceListCatalogObjects(instanceId, params, signal);

  const query = useQuery<
    Awaited<ReturnType<typeof runtimeServiceListCatalogObjects>>,
    TError,
    TData
  >(queryKey, queryFn, {
    enabled: !!instanceId,
    ...queryOptions,
  }) as UseQueryStoreResult<
    Awaited<ReturnType<typeof runtimeServiceListCatalogObjects>>,
    TError,
    TData,
    QueryKey
  > & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
};

/**
 * @summary GetCatalogObject returns information about a specific object in the catalog
 */
export const runtimeServiceGetCatalogObject = (
  instanceId: string,
  name: string,
  signal?: AbortSignal
) => {
  return httpClient<V1GetCatalogObjectResponse>({
    url: `/v1/instances/${instanceId}/catalog/${name}`,
    method: "get",
    signal,
  });
};

export const getRuntimeServiceGetCatalogObjectQueryKey = (
  instanceId: string,
  name: string
) => [`/v1/instances/${instanceId}/catalog/${name}`];

export type RuntimeServiceGetCatalogObjectQueryResult = NonNullable<
  Awaited<ReturnType<typeof runtimeServiceGetCatalogObject>>
>;
export type RuntimeServiceGetCatalogObjectQueryError = RpcStatus;

export const useRuntimeServiceGetCatalogObject = <
  TData = Awaited<ReturnType<typeof runtimeServiceGetCatalogObject>>,
  TError = RpcStatus
>(
  instanceId: string,
  name: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof runtimeServiceGetCatalogObject>>,
      TError,
      TData
    >;
  }
): UseQueryStoreResult<
  Awaited<ReturnType<typeof runtimeServiceGetCatalogObject>>,
  TError,
  TData,
  QueryKey
> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getRuntimeServiceGetCatalogObjectQueryKey(instanceId, name);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof runtimeServiceGetCatalogObject>>
  > = ({ signal }) => runtimeServiceGetCatalogObject(instanceId, name, signal);

  const query = useQuery<
    Awaited<ReturnType<typeof runtimeServiceGetCatalogObject>>,
    TError,
    TData
  >(queryKey, queryFn, {
    enabled: !!(instanceId && name),
    ...queryOptions,
  }) as UseQueryStoreResult<
    Awaited<ReturnType<typeof runtimeServiceGetCatalogObject>>,
    TError,
    TData,
    QueryKey
  > & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
};

/**
 * @summary TriggerRefresh triggers a refresh of a refreshable catalog object.
It currently only supports sources (which will be re-ingested), but will also support materialized models in the future.
It does not respond until the refresh has completed (will move to async jobs when the task scheduler is in place).
 */
export const runtimeServiceTriggerRefresh = (
  instanceId: string,
  name: string
) => {
  return httpClient<V1TriggerRefreshResponse>({
    url: `/v1/instances/${instanceId}/catalog/${name}/refresh`,
    method: "post",
  });
};

export type RuntimeServiceTriggerRefreshMutationResult = NonNullable<
  Awaited<ReturnType<typeof runtimeServiceTriggerRefresh>>
>;

export type RuntimeServiceTriggerRefreshMutationError = RpcStatus;

export const useRuntimeServiceTriggerRefresh = <
  TError = RpcStatus,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof runtimeServiceTriggerRefresh>>,
    TError,
    { instanceId: string; name: string },
    TContext
  >;
}) => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof runtimeServiceTriggerRefresh>>,
    { instanceId: string; name: string }
  > = (props) => {
    const { instanceId, name } = props ?? {};

    return runtimeServiceTriggerRefresh(instanceId, name);
  };

  return useMutation<
    Awaited<ReturnType<typeof runtimeServiceTriggerRefresh>>,
    TError,
    { instanceId: string; name: string },
    TContext
  >(mutationFn, mutationOptions);
};
/**
 * @summary MetricsViewMeta returns metadata about a metrics view.
It's comparable to calling GetCatalogObject and will be deprecated in the future.
 */
export const runtimeServiceMetricsViewMeta = (
  instanceId: string,
  metricsViewName: string
) => {
  return httpClient<V1MetricsViewMetaResponse>({
    url: `/v1/instances/${instanceId}/metrics-views/${metricsViewName}/meta`,
    method: "post",
  });
};

export type RuntimeServiceMetricsViewMetaMutationResult = NonNullable<
  Awaited<ReturnType<typeof runtimeServiceMetricsViewMeta>>
>;

export type RuntimeServiceMetricsViewMetaMutationError = RpcStatus;

export const useRuntimeServiceMetricsViewMeta = <
  TError = RpcStatus,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof runtimeServiceMetricsViewMeta>>,
    TError,
    { instanceId: string; metricsViewName: string },
    TContext
  >;
}) => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof runtimeServiceMetricsViewMeta>>,
    { instanceId: string; metricsViewName: string }
  > = (props) => {
    const { instanceId, metricsViewName } = props ?? {};

    return runtimeServiceMetricsViewMeta(instanceId, metricsViewName);
  };

  return useMutation<
    Awaited<ReturnType<typeof runtimeServiceMetricsViewMeta>>,
    TError,
    { instanceId: string; metricsViewName: string },
    TContext
  >(mutationFn, mutationOptions);
};
/**
 * @summary MetricsViewTimeSeries returns time series for the measures in the metrics view.
It's a convenience API for querying a metrics view.
 */
export const runtimeServiceMetricsViewTimeSeries = (
  instanceId: string,
  metricsViewName: string,
  runtimeServiceMetricsViewTimeSeriesBody: RuntimeServiceMetricsViewTimeSeriesBody
) => {
  return httpClient<V1MetricsViewTimeSeriesResponse>({
    url: `/v1/instances/${instanceId}/metrics-views/${metricsViewName}/timeseries`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: runtimeServiceMetricsViewTimeSeriesBody,
  });
};

export type RuntimeServiceMetricsViewTimeSeriesMutationResult = NonNullable<
  Awaited<ReturnType<typeof runtimeServiceMetricsViewTimeSeries>>
>;
export type RuntimeServiceMetricsViewTimeSeriesMutationBody =
  RuntimeServiceMetricsViewTimeSeriesBody;
export type RuntimeServiceMetricsViewTimeSeriesMutationError = RpcStatus;

export const useRuntimeServiceMetricsViewTimeSeries = <
  TError = RpcStatus,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof runtimeServiceMetricsViewTimeSeries>>,
    TError,
    {
      instanceId: string;
      metricsViewName: string;
      data: RuntimeServiceMetricsViewTimeSeriesBody;
    },
    TContext
  >;
}) => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof runtimeServiceMetricsViewTimeSeries>>,
    {
      instanceId: string;
      metricsViewName: string;
      data: RuntimeServiceMetricsViewTimeSeriesBody;
    }
  > = (props) => {
    const { instanceId, metricsViewName, data } = props ?? {};

    return runtimeServiceMetricsViewTimeSeries(
      instanceId,
      metricsViewName,
      data
    );
  };

  return useMutation<
    Awaited<ReturnType<typeof runtimeServiceMetricsViewTimeSeries>>,
    TError,
    {
      instanceId: string;
      metricsViewName: string;
      data: RuntimeServiceMetricsViewTimeSeriesBody;
    },
    TContext
  >(mutationFn, mutationOptions);
};
/**
 * @summary MetricsViewToplist returns the top dimension values of a metrics view sorted by one or more measures.
It's a convenience API for querying a metrics view.
 */
export const runtimeServiceMetricsViewToplist = (
  instanceId: string,
  metricsViewName: string,
  dimensionName: string,
  runtimeServiceMetricsViewToplistBody: RuntimeServiceMetricsViewToplistBody
) => {
  return httpClient<V1MetricsViewToplistResponse>({
    url: `/v1/instances/${instanceId}/metrics-views/${metricsViewName}/toplist/${dimensionName}`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: runtimeServiceMetricsViewToplistBody,
  });
};

export type RuntimeServiceMetricsViewToplistMutationResult = NonNullable<
  Awaited<ReturnType<typeof runtimeServiceMetricsViewToplist>>
>;
export type RuntimeServiceMetricsViewToplistMutationBody =
  RuntimeServiceMetricsViewToplistBody;
export type RuntimeServiceMetricsViewToplistMutationError = RpcStatus;

export const useRuntimeServiceMetricsViewToplist = <
  TError = RpcStatus,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof runtimeServiceMetricsViewToplist>>,
    TError,
    {
      instanceId: string;
      metricsViewName: string;
      dimensionName: string;
      data: RuntimeServiceMetricsViewToplistBody;
    },
    TContext
  >;
}) => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof runtimeServiceMetricsViewToplist>>,
    {
      instanceId: string;
      metricsViewName: string;
      dimensionName: string;
      data: RuntimeServiceMetricsViewToplistBody;
    }
  > = (props) => {
    const { instanceId, metricsViewName, dimensionName, data } = props ?? {};

    return runtimeServiceMetricsViewToplist(
      instanceId,
      metricsViewName,
      dimensionName,
      data
    );
  };

  return useMutation<
    Awaited<ReturnType<typeof runtimeServiceMetricsViewToplist>>,
    TError,
    {
      instanceId: string;
      metricsViewName: string;
      dimensionName: string;
      data: RuntimeServiceMetricsViewToplistBody;
    },
    TContext
  >(mutationFn, mutationOptions);
};
/**
 * @summary MetricsViewTotals returns totals over a time period for the measures in a metrics view.
It's a convenience API for querying a metrics view.
 */
export const runtimeServiceMetricsViewTotals = (
  instanceId: string,
  metricsViewName: string,
  runtimeServiceMetricsViewTotalsBody: RuntimeServiceMetricsViewTotalsBody
) => {
  return httpClient<V1MetricsViewTotalsResponse>({
    url: `/v1/instances/${instanceId}/metrics-views/${metricsViewName}/totals`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: runtimeServiceMetricsViewTotalsBody,
  });
};

export type RuntimeServiceMetricsViewTotalsMutationResult = NonNullable<
  Awaited<ReturnType<typeof runtimeServiceMetricsViewTotals>>
>;
export type RuntimeServiceMetricsViewTotalsMutationBody =
  RuntimeServiceMetricsViewTotalsBody;
export type RuntimeServiceMetricsViewTotalsMutationError = RpcStatus;

export const useRuntimeServiceMetricsViewTotals = <
  TError = RpcStatus,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof runtimeServiceMetricsViewTotals>>,
    TError,
    {
      instanceId: string;
      metricsViewName: string;
      data: RuntimeServiceMetricsViewTotalsBody;
    },
    TContext
  >;
}) => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof runtimeServiceMetricsViewTotals>>,
    {
      instanceId: string;
      metricsViewName: string;
      data: RuntimeServiceMetricsViewTotalsBody;
    }
  > = (props) => {
    const { instanceId, metricsViewName, data } = props ?? {};

    return runtimeServiceMetricsViewTotals(instanceId, metricsViewName, data);
  };

  return useMutation<
    Awaited<ReturnType<typeof runtimeServiceMetricsViewTotals>>,
    TError,
    {
      instanceId: string;
      metricsViewName: string;
      data: RuntimeServiceMetricsViewTotalsBody;
    },
    TContext
  >(mutationFn, mutationOptions);
};
/**
 * @summary Migrate applies a full set of SQL artifacts (files containing CREATE statements) to the catalog/infra.
It attempts to infer a minimal number of migrations to apply to reconcile the current state with
the desired state expressed in the artifacts. Any existing objects not described in the submitted
artifacts will be deleted.
 */
export const runtimeServiceMigrate = (
  instanceId: string,
  runtimeServiceMigrateBody: RuntimeServiceMigrateBody
) => {
  return httpClient<V1MigrateResponse>({
    url: `/v1/instances/${instanceId}/migrate`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: runtimeServiceMigrateBody,
  });
};

export type RuntimeServiceMigrateMutationResult = NonNullable<
  Awaited<ReturnType<typeof runtimeServiceMigrate>>
>;
export type RuntimeServiceMigrateMutationBody = RuntimeServiceMigrateBody;
export type RuntimeServiceMigrateMutationError = RpcStatus;

export const useRuntimeServiceMigrate = <
  TError = RpcStatus,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof runtimeServiceMigrate>>,
    TError,
    { instanceId: string; data: RuntimeServiceMigrateBody },
    TContext
  >;
}) => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof runtimeServiceMigrate>>,
    { instanceId: string; data: RuntimeServiceMigrateBody }
  > = (props) => {
    const { instanceId, data } = props ?? {};

    return runtimeServiceMigrate(instanceId, data);
  };

  return useMutation<
    Awaited<ReturnType<typeof runtimeServiceMigrate>>,
    TError,
    { instanceId: string; data: RuntimeServiceMigrateBody },
    TContext
  >(mutationFn, mutationOptions);
};
/**
 * @summary MigrateSingle applies a single `CREATE` statement.
It bypasses the reconciling migrations described in Migrate.
We aim to deprecate this function once reconciling migrations are mature and adopted in the modeller.
 */
export const runtimeServiceMigrateSingle = (
  instanceId: string,
  runtimeServiceMigrateSingleBody: RuntimeServiceMigrateSingleBody
) => {
  return httpClient<V1MigrateSingleResponse>({
    url: `/v1/instances/${instanceId}/migrate/single`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: runtimeServiceMigrateSingleBody,
  });
};

export type RuntimeServiceMigrateSingleMutationResult = NonNullable<
  Awaited<ReturnType<typeof runtimeServiceMigrateSingle>>
>;
export type RuntimeServiceMigrateSingleMutationBody =
  RuntimeServiceMigrateSingleBody;
export type RuntimeServiceMigrateSingleMutationError = RpcStatus;

export const useRuntimeServiceMigrateSingle = <
  TError = RpcStatus,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof runtimeServiceMigrateSingle>>,
    TError,
    { instanceId: string; data: RuntimeServiceMigrateSingleBody },
    TContext
  >;
}) => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof runtimeServiceMigrateSingle>>,
    { instanceId: string; data: RuntimeServiceMigrateSingleBody }
  > = (props) => {
    const { instanceId, data } = props ?? {};

    return runtimeServiceMigrateSingle(instanceId, data);
  };

  return useMutation<
    Awaited<ReturnType<typeof runtimeServiceMigrateSingle>>,
    TError,
    { instanceId: string; data: RuntimeServiceMigrateSingleBody },
    TContext
  >(mutationFn, mutationOptions);
};
/**
 * @summary MigrateDelete deletes a single object.
It bypasses the reconciling migrations described in Migrate.
We aim to deprecate this function once reconciling migrations are mature and adopted in the modeller.
 */
export const runtimeServiceMigrateDelete = (
  instanceId: string,
  runtimeServiceMigrateDeleteBody: RuntimeServiceMigrateDeleteBody
) => {
  return httpClient<V1MigrateDeleteResponse>({
    url: `/v1/instances/${instanceId}/migrate/single/delete`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: runtimeServiceMigrateDeleteBody,
  });
};

export type RuntimeServiceMigrateDeleteMutationResult = NonNullable<
  Awaited<ReturnType<typeof runtimeServiceMigrateDelete>>
>;
export type RuntimeServiceMigrateDeleteMutationBody =
  RuntimeServiceMigrateDeleteBody;
export type RuntimeServiceMigrateDeleteMutationError = RpcStatus;

export const useRuntimeServiceMigrateDelete = <
  TError = RpcStatus,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof runtimeServiceMigrateDelete>>,
    TError,
    { instanceId: string; data: RuntimeServiceMigrateDeleteBody },
    TContext
  >;
}) => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof runtimeServiceMigrateDelete>>,
    { instanceId: string; data: RuntimeServiceMigrateDeleteBody }
  > = (props) => {
    const { instanceId, data } = props ?? {};

    return runtimeServiceMigrateDelete(instanceId, data);
  };

  return useMutation<
    Awaited<ReturnType<typeof runtimeServiceMigrateDelete>>,
    TError,
    { instanceId: string; data: RuntimeServiceMigrateDeleteBody },
    TContext
  >(mutationFn, mutationOptions);
};
/**
 * @summary Query runs a Rill SQL query by transpiling it and proxying it to the instance's OLAP datastore.
 */
export const runtimeServiceQuery = (
  instanceId: string,
  runtimeServiceQueryBody: RuntimeServiceQueryBody
) => {
  return httpClient<V1QueryResponse>({
    url: `/v1/instances/${instanceId}/query`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: runtimeServiceQueryBody,
  });
};

export type RuntimeServiceQueryMutationResult = NonNullable<
  Awaited<ReturnType<typeof runtimeServiceQuery>>
>;
export type RuntimeServiceQueryMutationBody = RuntimeServiceQueryBody;
export type RuntimeServiceQueryMutationError = RpcStatus;

export const useRuntimeServiceQuery = <
  TError = RpcStatus,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof runtimeServiceQuery>>,
    TError,
    { instanceId: string; data: RuntimeServiceQueryBody },
    TContext
  >;
}) => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof runtimeServiceQuery>>,
    { instanceId: string; data: RuntimeServiceQueryBody }
  > = (props) => {
    const { instanceId, data } = props ?? {};

    return runtimeServiceQuery(instanceId, data);
  };

  return useMutation<
    Awaited<ReturnType<typeof runtimeServiceQuery>>,
    TError,
    { instanceId: string; data: RuntimeServiceQueryBody },
    TContext
  >(mutationFn, mutationOptions);
};
/**
 * @summary QueryDirect runs a SQL query by directly executing it against the instance's OLAP datastore.
It bypasses Rill SQL and expects the query to use the underlying dialect.
 */
export const runtimeServiceQueryDirect = (
  instanceId: string,
  runtimeServiceQueryDirectBody: RuntimeServiceQueryDirectBody
) => {
  return httpClient<V1QueryDirectResponse>({
    url: `/v1/instances/${instanceId}/query/direct`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: runtimeServiceQueryDirectBody,
  });
};

export type RuntimeServiceQueryDirectMutationResult = NonNullable<
  Awaited<ReturnType<typeof runtimeServiceQueryDirect>>
>;
export type RuntimeServiceQueryDirectMutationBody =
  RuntimeServiceQueryDirectBody;
export type RuntimeServiceQueryDirectMutationError = RpcStatus;

export const useRuntimeServiceQueryDirect = <
  TError = RpcStatus,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof runtimeServiceQueryDirect>>,
    TError,
    { instanceId: string; data: RuntimeServiceQueryDirectBody },
    TContext
  >;
}) => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof runtimeServiceQueryDirect>>,
    { instanceId: string; data: RuntimeServiceQueryDirectBody }
  > = (props) => {
    const { instanceId, data } = props ?? {};

    return runtimeServiceQueryDirect(instanceId, data);
  };

  return useMutation<
    Awaited<ReturnType<typeof runtimeServiceQueryDirect>>,
    TError,
    { instanceId: string; data: RuntimeServiceQueryDirectBody },
    TContext
  >(mutationFn, mutationOptions);
};
/**
 * @summary TriggerSync syncronizes the instance's catalog with the underlying OLAP's information schema.
If the instance has exposed=true, tables found in the information schema will be added to the catalog.
 */
export const runtimeServiceTriggerSync = (instanceId: string) => {
  return httpClient<V1TriggerSyncResponse>({
    url: `/v1/instances/${instanceId}/sync`,
    method: "post",
  });
};

export type RuntimeServiceTriggerSyncMutationResult = NonNullable<
  Awaited<ReturnType<typeof runtimeServiceTriggerSync>>
>;

export type RuntimeServiceTriggerSyncMutationError = RpcStatus;

export const useRuntimeServiceTriggerSync = <
  TError = RpcStatus,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof runtimeServiceTriggerSync>>,
    TError,
    { instanceId: string },
    TContext
  >;
}) => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof runtimeServiceTriggerSync>>,
    { instanceId: string }
  > = (props) => {
    const { instanceId } = props ?? {};

    return runtimeServiceTriggerSync(instanceId);
  };

  return useMutation<
    Awaited<ReturnType<typeof runtimeServiceTriggerSync>>,
    TError,
    { instanceId: string },
    TContext
  >(mutationFn, mutationOptions);
};
/**
 * @summary Get TopK elements from a table for a column given an agg function
agg function and k are optional, defaults are count(*) and 50 respectively
 */
export const runtimeServiceGetTopK = (
  instanceId: string,
  tableName: string,
  columnName: string,
  runtimeServiceGetTopKBody: RuntimeServiceGetTopKBody
) => {
  return httpClient<V1TopKResponse>({
    url: `/v1/instances/${instanceId}/topk/${tableName}/${columnName}`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: runtimeServiceGetTopKBody,
  });
};

export type RuntimeServiceGetTopKMutationResult = NonNullable<
  Awaited<ReturnType<typeof runtimeServiceGetTopK>>
>;
export type RuntimeServiceGetTopKMutationBody = RuntimeServiceGetTopKBody;
export type RuntimeServiceGetTopKMutationError = RpcStatus;

export const useRuntimeServiceGetTopK = <
  TError = RpcStatus,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof runtimeServiceGetTopK>>,
    TError,
    {
      instanceId: string;
      tableName: string;
      columnName: string;
      data: RuntimeServiceGetTopKBody;
    },
    TContext
  >;
}) => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof runtimeServiceGetTopK>>,
    {
      instanceId: string;
      tableName: string;
      columnName: string;
      data: RuntimeServiceGetTopKBody;
    }
  > = (props) => {
    const { instanceId, tableName, columnName, data } = props ?? {};

    return runtimeServiceGetTopK(instanceId, tableName, columnName, data);
  };

  return useMutation<
    Awaited<ReturnType<typeof runtimeServiceGetTopK>>,
    TError,
    {
      instanceId: string;
      tableName: string;
      columnName: string;
      data: RuntimeServiceGetTopKBody;
    },
    TContext
  >(mutationFn, mutationOptions);
};
/**
 * @summary Ping returns information about the runtime
 */
export const runtimeServicePing = (signal?: AbortSignal) => {
  return httpClient<V1PingResponse>({ url: `/v1/ping`, method: "get", signal });
};

export const getRuntimeServicePingQueryKey = () => [`/v1/ping`];

export type RuntimeServicePingQueryResult = NonNullable<
  Awaited<ReturnType<typeof runtimeServicePing>>
>;
export type RuntimeServicePingQueryError = RpcStatus;

export const useRuntimeServicePing = <
  TData = Awaited<ReturnType<typeof runtimeServicePing>>,
  TError = RpcStatus
>(options?: {
  query?: UseQueryOptions<
    Awaited<ReturnType<typeof runtimeServicePing>>,
    TError,
    TData
  >;
}): UseQueryStoreResult<
  Awaited<ReturnType<typeof runtimeServicePing>>,
  TError,
  TData,
  QueryKey
> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getRuntimeServicePingQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof runtimeServicePing>>
  > = ({ signal }) => runtimeServicePing(signal);

  const query = useQuery<
    Awaited<ReturnType<typeof runtimeServicePing>>,
    TError,
    TData
  >(queryKey, queryFn, queryOptions) as UseQueryStoreResult<
    Awaited<ReturnType<typeof runtimeServicePing>>,
    TError,
    TData,
    QueryKey
  > & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
};

/**
 * @summary ListRepos lists all the repos currently managed by the runtime
 */
export const runtimeServiceListRepos = (
  params?: RuntimeServiceListReposParams,
  signal?: AbortSignal
) => {
  return httpClient<V1ListReposResponse>({
    url: `/v1/repos`,
    method: "get",
    params,
    signal,
  });
};

export const getRuntimeServiceListReposQueryKey = (
  params?: RuntimeServiceListReposParams
) => [`/v1/repos`, ...(params ? [params] : [])];

export type RuntimeServiceListReposQueryResult = NonNullable<
  Awaited<ReturnType<typeof runtimeServiceListRepos>>
>;
export type RuntimeServiceListReposQueryError = RpcStatus;

export const useRuntimeServiceListRepos = <
  TData = Awaited<ReturnType<typeof runtimeServiceListRepos>>,
  TError = RpcStatus
>(
  params?: RuntimeServiceListReposParams,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof runtimeServiceListRepos>>,
      TError,
      TData
    >;
  }
): UseQueryStoreResult<
  Awaited<ReturnType<typeof runtimeServiceListRepos>>,
  TError,
  TData,
  QueryKey
> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getRuntimeServiceListReposQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof runtimeServiceListRepos>>
  > = ({ signal }) => runtimeServiceListRepos(params, signal);

  const query = useQuery<
    Awaited<ReturnType<typeof runtimeServiceListRepos>>,
    TError,
    TData
  >(queryKey, queryFn, queryOptions) as UseQueryStoreResult<
    Awaited<ReturnType<typeof runtimeServiceListRepos>>,
    TError,
    TData,
    QueryKey
  > & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
};

/**
 * @summary CreateRepo creates a new repo. See the Repo message for an explanation of repos.
 */
export const runtimeServiceCreateRepo = (
  v1CreateRepoRequest: V1CreateRepoRequest
) => {
  return httpClient<V1CreateRepoResponse>({
    url: `/v1/repos`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: v1CreateRepoRequest,
  });
};

export type RuntimeServiceCreateRepoMutationResult = NonNullable<
  Awaited<ReturnType<typeof runtimeServiceCreateRepo>>
>;
export type RuntimeServiceCreateRepoMutationBody = V1CreateRepoRequest;
export type RuntimeServiceCreateRepoMutationError = RpcStatus;

export const useRuntimeServiceCreateRepo = <
  TError = RpcStatus,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof runtimeServiceCreateRepo>>,
    TError,
    { data: V1CreateRepoRequest },
    TContext
  >;
}) => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof runtimeServiceCreateRepo>>,
    { data: V1CreateRepoRequest }
  > = (props) => {
    const { data } = props ?? {};

    return runtimeServiceCreateRepo(data);
  };

  return useMutation<
    Awaited<ReturnType<typeof runtimeServiceCreateRepo>>,
    TError,
    { data: V1CreateRepoRequest },
    TContext
  >(mutationFn, mutationOptions);
};
/**
 * @summary GetRepo returns info about a specific repo
 */
export const runtimeServiceGetRepo = (repoId: string, signal?: AbortSignal) => {
  return httpClient<V1GetRepoResponse>({
    url: `/v1/repos/${repoId}`,
    method: "get",
    signal,
  });
};

export const getRuntimeServiceGetRepoQueryKey = (repoId: string) => [
  `/v1/repos/${repoId}`,
];

export type RuntimeServiceGetRepoQueryResult = NonNullable<
  Awaited<ReturnType<typeof runtimeServiceGetRepo>>
>;
export type RuntimeServiceGetRepoQueryError = RpcStatus;

export const useRuntimeServiceGetRepo = <
  TData = Awaited<ReturnType<typeof runtimeServiceGetRepo>>,
  TError = RpcStatus
>(
  repoId: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof runtimeServiceGetRepo>>,
      TError,
      TData
    >;
  }
): UseQueryStoreResult<
  Awaited<ReturnType<typeof runtimeServiceGetRepo>>,
  TError,
  TData,
  QueryKey
> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getRuntimeServiceGetRepoQueryKey(repoId);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof runtimeServiceGetRepo>>
  > = ({ signal }) => runtimeServiceGetRepo(repoId, signal);

  const query = useQuery<
    Awaited<ReturnType<typeof runtimeServiceGetRepo>>,
    TError,
    TData
  >(queryKey, queryFn, {
    enabled: !!repoId,
    ...queryOptions,
  }) as UseQueryStoreResult<
    Awaited<ReturnType<typeof runtimeServiceGetRepo>>,
    TError,
    TData,
    QueryKey
  > & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
};

/**
 * @summary DeleteRepo deletes a repo
 */
export const runtimeServiceDeleteRepo = (repoId: string) => {
  return httpClient<V1DeleteRepoResponse>({
    url: `/v1/repos/${repoId}`,
    method: "delete",
  });
};

export type RuntimeServiceDeleteRepoMutationResult = NonNullable<
  Awaited<ReturnType<typeof runtimeServiceDeleteRepo>>
>;

export type RuntimeServiceDeleteRepoMutationError = RpcStatus;

export const useRuntimeServiceDeleteRepo = <
  TError = RpcStatus,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof runtimeServiceDeleteRepo>>,
    TError,
    { repoId: string },
    TContext
  >;
}) => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof runtimeServiceDeleteRepo>>,
    { repoId: string }
  > = (props) => {
    const { repoId } = props ?? {};

    return runtimeServiceDeleteRepo(repoId);
  };

  return useMutation<
    Awaited<ReturnType<typeof runtimeServiceDeleteRepo>>,
    TError,
    { repoId: string },
    TContext
  >(mutationFn, mutationOptions);
};
/**
 * @summary ListRepoObjects lists all the objects (files) in a repo sorted by full path. 
It includes objects in nested "directories".
 */
export const runtimeServiceListRepoObjects = (
  repoId: string,
  signal?: AbortSignal
) => {
  return httpClient<V1ListRepoObjectsResponse>({
    url: `/v1/repos/${repoId}/objects`,
    method: "get",
    signal,
  });
};

export const getRuntimeServiceListRepoObjectsQueryKey = (repoId: string) => [
  `/v1/repos/${repoId}/objects`,
];

export type RuntimeServiceListRepoObjectsQueryResult = NonNullable<
  Awaited<ReturnType<typeof runtimeServiceListRepoObjects>>
>;
export type RuntimeServiceListRepoObjectsQueryError = RpcStatus;

export const useRuntimeServiceListRepoObjects = <
  TData = Awaited<ReturnType<typeof runtimeServiceListRepoObjects>>,
  TError = RpcStatus
>(
  repoId: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof runtimeServiceListRepoObjects>>,
      TError,
      TData
    >;
  }
): UseQueryStoreResult<
  Awaited<ReturnType<typeof runtimeServiceListRepoObjects>>,
  TError,
  TData,
  QueryKey
> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getRuntimeServiceListRepoObjectsQueryKey(repoId);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof runtimeServiceListRepoObjects>>
  > = ({ signal }) => runtimeServiceListRepoObjects(repoId, signal);

  const query = useQuery<
    Awaited<ReturnType<typeof runtimeServiceListRepoObjects>>,
    TError,
    TData
  >(queryKey, queryFn, {
    enabled: !!repoId,
    ...queryOptions,
  }) as UseQueryStoreResult<
    Awaited<ReturnType<typeof runtimeServiceListRepoObjects>>,
    TError,
    TData,
    QueryKey
  > & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
};

/**
 * @summary GetRepoObject returns the contents of a specific object (file) in a repo.
 */
export const runtimeServiceGetRepoObject = (
  repoId: string,
  path: string,
  signal?: AbortSignal
) => {
  return httpClient<V1GetRepoObjectResponse>({
    url: `/v1/repos/${repoId}/objects/-/${path}`,
    method: "get",
    signal,
  });
};

export const getRuntimeServiceGetRepoObjectQueryKey = (
  repoId: string,
  path: string
) => [`/v1/repos/${repoId}/objects/-/${path}`];

export type RuntimeServiceGetRepoObjectQueryResult = NonNullable<
  Awaited<ReturnType<typeof runtimeServiceGetRepoObject>>
>;
export type RuntimeServiceGetRepoObjectQueryError = RpcStatus;

export const useRuntimeServiceGetRepoObject = <
  TData = Awaited<ReturnType<typeof runtimeServiceGetRepoObject>>,
  TError = RpcStatus
>(
  repoId: string,
  path: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof runtimeServiceGetRepoObject>>,
      TError,
      TData
    >;
  }
): UseQueryStoreResult<
  Awaited<ReturnType<typeof runtimeServiceGetRepoObject>>,
  TError,
  TData,
  QueryKey
> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getRuntimeServiceGetRepoObjectQueryKey(repoId, path);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof runtimeServiceGetRepoObject>>
  > = ({ signal }) => runtimeServiceGetRepoObject(repoId, path, signal);

  const query = useQuery<
    Awaited<ReturnType<typeof runtimeServiceGetRepoObject>>,
    TError,
    TData
  >(queryKey, queryFn, {
    enabled: !!(repoId && path),
    ...queryOptions,
  }) as UseQueryStoreResult<
    Awaited<ReturnType<typeof runtimeServiceGetRepoObject>>,
    TError,
    TData,
    QueryKey
  > & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
};

/**
 * @summary PutRepoObject can be used to create, update, or delete an object (file) in a repo
 */
export const runtimeServicePutRepoObject = (
  repoId: string,
  path: string,
  runtimeServicePutRepoObjectBody: RuntimeServicePutRepoObjectBody
) => {
  return httpClient<V1PutRepoObjectResponse>({
    url: `/v1/repos/${repoId}/objects/-/${path}`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: runtimeServicePutRepoObjectBody,
  });
};

export type RuntimeServicePutRepoObjectMutationResult = NonNullable<
  Awaited<ReturnType<typeof runtimeServicePutRepoObject>>
>;
export type RuntimeServicePutRepoObjectMutationBody =
  RuntimeServicePutRepoObjectBody;
export type RuntimeServicePutRepoObjectMutationError = RpcStatus;

export const useRuntimeServicePutRepoObject = <
  TError = RpcStatus,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof runtimeServicePutRepoObject>>,
    TError,
    { repoId: string; path: string; data: RuntimeServicePutRepoObjectBody },
    TContext
  >;
}) => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof runtimeServicePutRepoObject>>,
    { repoId: string; path: string; data: RuntimeServicePutRepoObjectBody }
  > = (props) => {
    const { repoId, path, data } = props ?? {};

    return runtimeServicePutRepoObject(repoId, path, data);
  };

  return useMutation<
    Awaited<ReturnType<typeof runtimeServicePutRepoObject>>,
    TError,
    { repoId: string; path: string; data: RuntimeServicePutRepoObjectBody },
    TContext
  >(mutationFn, mutationOptions);
};

/**
 * Generated by orval v7.9.0 üç∫
 * Do not edit manually.
 * rill/runtime/v1/schema.proto
 * OpenAPI spec version: version not set
 */
import {
  createInfiniteQuery,
  createMutation,
  createQuery,
} from "@tanstack/svelte-query";
import type {
  CreateInfiniteQueryOptions,
  CreateInfiniteQueryResult,
  CreateMutationOptions,
  CreateMutationResult,
  CreateQueryOptions,
  CreateQueryResult,
  DataTag,
  InfiniteData,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
} from "@tanstack/svelte-query";

import type {
  ConnectorServiceGetTableParams,
  ConnectorServiceListBucketsParams,
  ConnectorServiceListDatabaseSchemasParams,
  ConnectorServiceListObjectsParams,
  ConnectorServiceListTablesParams,
  ConnectorServiceOLAPGetTableParams,
  ConnectorServiceOLAPListTablesParams,
  QueryServiceColumnCardinalityParams,
  QueryServiceColumnDescriptiveStatisticsParams,
  QueryServiceColumnNullCountParams,
  QueryServiceColumnNumericHistogramParams,
  QueryServiceColumnRollupIntervalBody,
  QueryServiceColumnRugHistogramParams,
  QueryServiceColumnTimeGrainParams,
  QueryServiceColumnTimeRangeParams,
  QueryServiceColumnTimeSeriesBody,
  QueryServiceColumnTopKBody,
  QueryServiceExportBody,
  QueryServiceExportReportBody,
  QueryServiceMetricsViewAggregationBody,
  QueryServiceMetricsViewAnnotationsBody,
  QueryServiceMetricsViewComparisonBody,
  QueryServiceMetricsViewRowsBody,
  QueryServiceMetricsViewSchemaParams,
  QueryServiceMetricsViewSearchBody,
  QueryServiceMetricsViewTimeRangeBody,
  QueryServiceMetricsViewTimeRangesBody,
  QueryServiceMetricsViewTimeSeriesBody,
  QueryServiceMetricsViewToplistBody,
  QueryServiceMetricsViewTotalsBody,
  QueryServiceQueryBatch200,
  QueryServiceQueryBatchBody,
  QueryServiceQueryBody,
  QueryServiceResolveCanvasBody,
  QueryServiceResolveComponentBody,
  QueryServiceResolveTemplatedStringBody,
  QueryServiceTableCardinalityParams,
  QueryServiceTableColumnsParams,
  QueryServiceTableRowsParams,
  RpcStatus,
  RuntimeServiceCompleteBody,
  RuntimeServiceCompleteStreaming200,
  RuntimeServiceCompleteStreamingBody,
  RuntimeServiceCreateDirectoryBody,
  RuntimeServiceCreateTriggerBody,
  RuntimeServiceDeleteFileParams,
  RuntimeServiceDeleteInstanceBody,
  RuntimeServiceEditInstanceBody,
  RuntimeServiceGenerateCanvasFileBody,
  RuntimeServiceGenerateMetricsViewFileBody,
  RuntimeServiceGenerateRendererBody,
  RuntimeServiceGenerateResolverBody,
  RuntimeServiceGetExploreParams,
  RuntimeServiceGetFileParams,
  RuntimeServiceGetInstanceParams,
  RuntimeServiceGetLogsParams,
  RuntimeServiceGetModelPartitionsParams,
  RuntimeServiceGetResourceParams,
  RuntimeServiceListConversationsParams,
  RuntimeServiceListFilesParams,
  RuntimeServiceListInstancesParams,
  RuntimeServiceListResourcesParams,
  RuntimeServicePutFileBody,
  RuntimeServiceQueryResolverBody,
  RuntimeServiceRenameFileBody,
  RuntimeServiceUnpackEmptyBody,
  RuntimeServiceUnpackExampleBody,
  RuntimeServiceWatchFiles200,
  RuntimeServiceWatchFilesParams,
  RuntimeServiceWatchLogs200,
  RuntimeServiceWatchLogsParams,
  RuntimeServiceWatchResources200,
  RuntimeServiceWatchResourcesParams,
  V1AnalyzeConnectorsResponse,
  V1AnalyzeVariablesResponse,
  V1ColumnCardinalityResponse,
  V1ColumnDescriptiveStatisticsResponse,
  V1ColumnNullCountResponse,
  V1ColumnNumericHistogramResponse,
  V1ColumnRollupIntervalResponse,
  V1ColumnRugHistogramResponse,
  V1ColumnTimeGrainResponse,
  V1ColumnTimeRangeResponse,
  V1ColumnTimeSeriesResponse,
  V1ColumnTopKResponse,
  V1CompleteResponse,
  V1CreateDirectoryResponse,
  V1CreateInstanceRequest,
  V1CreateInstanceResponse,
  V1CreateTriggerResponse,
  V1DeleteFileResponse,
  V1DeleteInstanceResponse,
  V1EditInstanceResponse,
  V1ExportReportResponse,
  V1ExportResponse,
  V1GenerateCanvasFileResponse,
  V1GenerateMetricsViewFileResponse,
  V1GenerateRendererResponse,
  V1GenerateResolverResponse,
  V1GetConversationResponse,
  V1GetExploreResponse,
  V1GetFileResponse,
  V1GetInstanceResponse,
  V1GetLogsResponse,
  V1GetModelPartitionsResponse,
  V1GetResourceResponse,
  V1GetTableResponse,
  V1HealthResponse,
  V1InstanceHealthResponse,
  V1IssueDevJWTRequest,
  V1IssueDevJWTResponse,
  V1ListBucketsResponse,
  V1ListConnectorDriversResponse,
  V1ListConversationsResponse,
  V1ListDatabaseSchemasResponse,
  V1ListExamplesResponse,
  V1ListFilesResponse,
  V1ListInstancesResponse,
  V1ListNotifierConnectorsResponse,
  V1ListObjectsResponse,
  V1ListResourcesResponse,
  V1ListTablesResponse,
  V1ListToolsResponse,
  V1MetricsViewAggregationResponse,
  V1MetricsViewAnnotationsResponse,
  V1MetricsViewComparisonResponse,
  V1MetricsViewRowsResponse,
  V1MetricsViewSchemaResponse,
  V1MetricsViewSearchResponse,
  V1MetricsViewTimeRangeResponse,
  V1MetricsViewTimeRangesResponse,
  V1MetricsViewTimeSeriesResponse,
  V1MetricsViewToplistResponse,
  V1MetricsViewTotalsResponse,
  V1OLAPGetTableResponse,
  V1OLAPListTablesResponse,
  V1PingResponse,
  V1PutFileResponse,
  V1QueryResolverResponse,
  V1QueryResponse,
  V1RenameFileResponse,
  V1ResolveCanvasResponse,
  V1ResolveComponentResponse,
  V1ResolveTemplatedStringResponse,
  V1TableCardinalityResponse,
  V1TableColumnsResponse,
  V1TableRowsResponse,
  V1UnpackEmptyResponse,
  V1UnpackExampleResponse,
} from "../index.schemas";

import { httpClient } from "../../http-client";
import type { ErrorType } from "../../http-client";

type AwaitedInput<T> = PromiseLike<T> | T;

type Awaited<O> = O extends AwaitedInput<infer T> ? T : never;

/**
 * @summary ListDatabaseSchemas list all schemas across databases
 */
export const connectorServiceListDatabaseSchemas = (
  params?: ConnectorServiceListDatabaseSchemasParams,
  signal?: AbortSignal,
) => {
  return httpClient<V1ListDatabaseSchemasResponse>({
    url: `/v1/connectors/database_schemas`,
    method: "GET",
    params,
    signal,
  });
};

export const getConnectorServiceListDatabaseSchemasQueryKey = (
  params?: ConnectorServiceListDatabaseSchemasParams,
) => {
  return [
    `/v1/connectors/database_schemas`,
    ...(params ? [params] : []),
  ] as const;
};

export const getConnectorServiceListDatabaseSchemasQueryOptions = <
  TData = Awaited<ReturnType<typeof connectorServiceListDatabaseSchemas>>,
  TError = ErrorType<RpcStatus>,
>(
  params?: ConnectorServiceListDatabaseSchemasParams,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof connectorServiceListDatabaseSchemas>>,
        TError,
        TData
      >
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getConnectorServiceListDatabaseSchemasQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof connectorServiceListDatabaseSchemas>>
  > = ({ signal }) => connectorServiceListDatabaseSchemas(params, signal);

  return { queryKey, queryFn, ...queryOptions } as CreateQueryOptions<
    Awaited<ReturnType<typeof connectorServiceListDatabaseSchemas>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type ConnectorServiceListDatabaseSchemasQueryResult = NonNullable<
  Awaited<ReturnType<typeof connectorServiceListDatabaseSchemas>>
>;
export type ConnectorServiceListDatabaseSchemasQueryError =
  ErrorType<RpcStatus>;

/**
 * @summary ListDatabaseSchemas list all schemas across databases
 */

export function createConnectorServiceListDatabaseSchemas<
  TData = Awaited<ReturnType<typeof connectorServiceListDatabaseSchemas>>,
  TError = ErrorType<RpcStatus>,
>(
  params?: ConnectorServiceListDatabaseSchemasParams,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof connectorServiceListDatabaseSchemas>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): CreateQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getConnectorServiceListDatabaseSchemasQueryOptions(
    params,
    options,
  );

  const query = createQuery(queryOptions, queryClient) as CreateQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary ListConnectorDrivers returns a description of all the connector drivers registed in the runtime,
including their configuration specs and the capabilities they support.
 */
export const runtimeServiceListConnectorDrivers = (signal?: AbortSignal) => {
  return httpClient<V1ListConnectorDriversResponse>({
    url: `/v1/connectors/meta`,
    method: "GET",
    signal,
  });
};

export const getRuntimeServiceListConnectorDriversQueryKey = () => {
  return [`/v1/connectors/meta`] as const;
};

export const getRuntimeServiceListConnectorDriversQueryOptions = <
  TData = Awaited<ReturnType<typeof runtimeServiceListConnectorDrivers>>,
  TError = ErrorType<RpcStatus>,
>(options?: {
  query?: Partial<
    CreateQueryOptions<
      Awaited<ReturnType<typeof runtimeServiceListConnectorDrivers>>,
      TError,
      TData
    >
  >;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getRuntimeServiceListConnectorDriversQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof runtimeServiceListConnectorDrivers>>
  > = ({ signal }) => runtimeServiceListConnectorDrivers(signal);

  return { queryKey, queryFn, ...queryOptions } as CreateQueryOptions<
    Awaited<ReturnType<typeof runtimeServiceListConnectorDrivers>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type RuntimeServiceListConnectorDriversQueryResult = NonNullable<
  Awaited<ReturnType<typeof runtimeServiceListConnectorDrivers>>
>;
export type RuntimeServiceListConnectorDriversQueryError = ErrorType<RpcStatus>;

/**
 * @summary ListConnectorDrivers returns a description of all the connector drivers registed in the runtime,
including their configuration specs and the capabilities they support.
 */

export function createRuntimeServiceListConnectorDrivers<
  TData = Awaited<ReturnType<typeof runtimeServiceListConnectorDrivers>>,
  TError = ErrorType<RpcStatus>,
>(
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof runtimeServiceListConnectorDrivers>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): CreateQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions =
    getRuntimeServiceListConnectorDriversQueryOptions(options);

  const query = createQuery(queryOptions, queryClient) as CreateQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary OLAPGetTable returns metadata about a table or view in an OLAP
 */
export const connectorServiceOLAPGetTable = (
  params?: ConnectorServiceOLAPGetTableParams,
  signal?: AbortSignal,
) => {
  return httpClient<V1OLAPGetTableResponse>({
    url: `/v1/connectors/olap/table`,
    method: "GET",
    params,
    signal,
  });
};

export const getConnectorServiceOLAPGetTableQueryKey = (
  params?: ConnectorServiceOLAPGetTableParams,
) => {
  return [`/v1/connectors/olap/table`, ...(params ? [params] : [])] as const;
};

export const getConnectorServiceOLAPGetTableQueryOptions = <
  TData = Awaited<ReturnType<typeof connectorServiceOLAPGetTable>>,
  TError = ErrorType<RpcStatus>,
>(
  params?: ConnectorServiceOLAPGetTableParams,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof connectorServiceOLAPGetTable>>,
        TError,
        TData
      >
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getConnectorServiceOLAPGetTableQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof connectorServiceOLAPGetTable>>
  > = ({ signal }) => connectorServiceOLAPGetTable(params, signal);

  return { queryKey, queryFn, ...queryOptions } as CreateQueryOptions<
    Awaited<ReturnType<typeof connectorServiceOLAPGetTable>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type ConnectorServiceOLAPGetTableQueryResult = NonNullable<
  Awaited<ReturnType<typeof connectorServiceOLAPGetTable>>
>;
export type ConnectorServiceOLAPGetTableQueryError = ErrorType<RpcStatus>;

/**
 * @summary OLAPGetTable returns metadata about a table or view in an OLAP
 */

export function createConnectorServiceOLAPGetTable<
  TData = Awaited<ReturnType<typeof connectorServiceOLAPGetTable>>,
  TError = ErrorType<RpcStatus>,
>(
  params?: ConnectorServiceOLAPGetTableParams,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof connectorServiceOLAPGetTable>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): CreateQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getConnectorServiceOLAPGetTableQueryOptions(
    params,
    options,
  );

  const query = createQuery(queryOptions, queryClient) as CreateQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary GetTable returns metadata about a table or view
 */
export const connectorServiceGetTable = (
  params?: ConnectorServiceGetTableParams,
  signal?: AbortSignal,
) => {
  return httpClient<V1GetTableResponse>({
    url: `/v1/connectors/table_metadata`,
    method: "GET",
    params,
    signal,
  });
};

export const getConnectorServiceGetTableQueryKey = (
  params?: ConnectorServiceGetTableParams,
) => {
  return [
    `/v1/connectors/table_metadata`,
    ...(params ? [params] : []),
  ] as const;
};

export const getConnectorServiceGetTableQueryOptions = <
  TData = Awaited<ReturnType<typeof connectorServiceGetTable>>,
  TError = ErrorType<RpcStatus>,
>(
  params?: ConnectorServiceGetTableParams,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof connectorServiceGetTable>>,
        TError,
        TData
      >
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getConnectorServiceGetTableQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof connectorServiceGetTable>>
  > = ({ signal }) => connectorServiceGetTable(params, signal);

  return { queryKey, queryFn, ...queryOptions } as CreateQueryOptions<
    Awaited<ReturnType<typeof connectorServiceGetTable>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type ConnectorServiceGetTableQueryResult = NonNullable<
  Awaited<ReturnType<typeof connectorServiceGetTable>>
>;
export type ConnectorServiceGetTableQueryError = ErrorType<RpcStatus>;

/**
 * @summary GetTable returns metadata about a table or view
 */

export function createConnectorServiceGetTable<
  TData = Awaited<ReturnType<typeof connectorServiceGetTable>>,
  TError = ErrorType<RpcStatus>,
>(
  params?: ConnectorServiceGetTableParams,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof connectorServiceGetTable>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): CreateQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getConnectorServiceGetTableQueryOptions(params, options);

  const query = createQuery(queryOptions, queryClient) as CreateQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary ListTables list all tables for database and database_schema provided
 */
export const connectorServiceListTables = (
  params?: ConnectorServiceListTablesParams,
  signal?: AbortSignal,
) => {
  return httpClient<V1ListTablesResponse>({
    url: `/v1/connectors/tables`,
    method: "GET",
    params,
    signal,
  });
};

export const getConnectorServiceListTablesQueryKey = (
  params?: ConnectorServiceListTablesParams,
) => {
  return [`/v1/connectors/tables`, ...(params ? [params] : [])] as const;
};

export const getConnectorServiceListTablesQueryOptions = <
  TData = Awaited<ReturnType<typeof connectorServiceListTables>>,
  TError = ErrorType<RpcStatus>,
>(
  params?: ConnectorServiceListTablesParams,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof connectorServiceListTables>>,
        TError,
        TData
      >
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getConnectorServiceListTablesQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof connectorServiceListTables>>
  > = ({ signal }) => connectorServiceListTables(params, signal);

  return { queryKey, queryFn, ...queryOptions } as CreateQueryOptions<
    Awaited<ReturnType<typeof connectorServiceListTables>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type ConnectorServiceListTablesQueryResult = NonNullable<
  Awaited<ReturnType<typeof connectorServiceListTables>>
>;
export type ConnectorServiceListTablesQueryError = ErrorType<RpcStatus>;

/**
 * @summary ListTables list all tables for database and database_schema provided
 */

export function createConnectorServiceListTables<
  TData = Awaited<ReturnType<typeof connectorServiceListTables>>,
  TError = ErrorType<RpcStatus>,
>(
  params?: ConnectorServiceListTablesParams,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof connectorServiceListTables>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): CreateQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getConnectorServiceListTablesQueryOptions(
    params,
    options,
  );

  const query = createQuery(queryOptions, queryClient) as CreateQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary IssueDevJWT issues a JWT for mimicking a user in local development.
 */
export const runtimeServiceIssueDevJWT = (
  v1IssueDevJWTRequest: V1IssueDevJWTRequest,
  signal?: AbortSignal,
) => {
  return httpClient<V1IssueDevJWTResponse>({
    url: `/v1/dev-jwt`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: v1IssueDevJWTRequest,
    signal,
  });
};

export const getRuntimeServiceIssueDevJWTQueryKey = (
  v1IssueDevJWTRequest: V1IssueDevJWTRequest,
) => {
  return [`/v1/dev-jwt`, v1IssueDevJWTRequest] as const;
};

export const getRuntimeServiceIssueDevJWTQueryOptions = <
  TData = Awaited<ReturnType<typeof runtimeServiceIssueDevJWT>>,
  TError = ErrorType<RpcStatus>,
>(
  v1IssueDevJWTRequest: V1IssueDevJWTRequest,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof runtimeServiceIssueDevJWT>>,
        TError,
        TData
      >
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getRuntimeServiceIssueDevJWTQueryKey(v1IssueDevJWTRequest);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof runtimeServiceIssueDevJWT>>
  > = ({ signal }) => runtimeServiceIssueDevJWT(v1IssueDevJWTRequest, signal);

  return { queryKey, queryFn, ...queryOptions } as CreateQueryOptions<
    Awaited<ReturnType<typeof runtimeServiceIssueDevJWT>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type RuntimeServiceIssueDevJWTQueryResult = NonNullable<
  Awaited<ReturnType<typeof runtimeServiceIssueDevJWT>>
>;
export type RuntimeServiceIssueDevJWTQueryError = ErrorType<RpcStatus>;

/**
 * @summary IssueDevJWT issues a JWT for mimicking a user in local development.
 */

export function createRuntimeServiceIssueDevJWT<
  TData = Awaited<ReturnType<typeof runtimeServiceIssueDevJWT>>,
  TError = ErrorType<RpcStatus>,
>(
  v1IssueDevJWTRequest: V1IssueDevJWTRequest,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof runtimeServiceIssueDevJWT>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): CreateQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getRuntimeServiceIssueDevJWTQueryOptions(
    v1IssueDevJWTRequest,
    options,
  );

  const query = createQuery(queryOptions, queryClient) as CreateQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary ListExamples lists all the examples embedded into binary
 */
export const runtimeServiceListExamples = (signal?: AbortSignal) => {
  return httpClient<V1ListExamplesResponse>({
    url: `/v1/examples`,
    method: "GET",
    signal,
  });
};

export const getRuntimeServiceListExamplesQueryKey = () => {
  return [`/v1/examples`] as const;
};

export const getRuntimeServiceListExamplesQueryOptions = <
  TData = Awaited<ReturnType<typeof runtimeServiceListExamples>>,
  TError = ErrorType<RpcStatus>,
>(options?: {
  query?: Partial<
    CreateQueryOptions<
      Awaited<ReturnType<typeof runtimeServiceListExamples>>,
      TError,
      TData
    >
  >;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getRuntimeServiceListExamplesQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof runtimeServiceListExamples>>
  > = ({ signal }) => runtimeServiceListExamples(signal);

  return { queryKey, queryFn, ...queryOptions } as CreateQueryOptions<
    Awaited<ReturnType<typeof runtimeServiceListExamples>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type RuntimeServiceListExamplesQueryResult = NonNullable<
  Awaited<ReturnType<typeof runtimeServiceListExamples>>
>;
export type RuntimeServiceListExamplesQueryError = ErrorType<RpcStatus>;

/**
 * @summary ListExamples lists all the examples embedded into binary
 */

export function createRuntimeServiceListExamples<
  TData = Awaited<ReturnType<typeof runtimeServiceListExamples>>,
  TError = ErrorType<RpcStatus>,
>(
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof runtimeServiceListExamples>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): CreateQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getRuntimeServiceListExamplesQueryOptions(options);

  const query = createQuery(queryOptions, queryClient) as CreateQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Health runs a health check on the runtime.
 */
export const runtimeServiceHealth = (signal?: AbortSignal) => {
  return httpClient<V1HealthResponse>({
    url: `/v1/health`,
    method: "GET",
    signal,
  });
};

export const getRuntimeServiceHealthQueryKey = () => {
  return [`/v1/health`] as const;
};

export const getRuntimeServiceHealthQueryOptions = <
  TData = Awaited<ReturnType<typeof runtimeServiceHealth>>,
  TError = ErrorType<RpcStatus>,
>(options?: {
  query?: Partial<
    CreateQueryOptions<
      Awaited<ReturnType<typeof runtimeServiceHealth>>,
      TError,
      TData
    >
  >;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getRuntimeServiceHealthQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof runtimeServiceHealth>>
  > = ({ signal }) => runtimeServiceHealth(signal);

  return { queryKey, queryFn, ...queryOptions } as CreateQueryOptions<
    Awaited<ReturnType<typeof runtimeServiceHealth>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type RuntimeServiceHealthQueryResult = NonNullable<
  Awaited<ReturnType<typeof runtimeServiceHealth>>
>;
export type RuntimeServiceHealthQueryError = ErrorType<RpcStatus>;

/**
 * @summary Health runs a health check on the runtime.
 */

export function createRuntimeServiceHealth<
  TData = Awaited<ReturnType<typeof runtimeServiceHealth>>,
  TError = ErrorType<RpcStatus>,
>(
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof runtimeServiceHealth>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): CreateQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getRuntimeServiceHealthQueryOptions(options);

  const query = createQuery(queryOptions, queryClient) as CreateQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary InstanceHealth runs a health check on a specific instance.
 */
export const runtimeServiceInstanceHealth = (
  instanceId: string,
  signal?: AbortSignal,
) => {
  return httpClient<V1InstanceHealthResponse>({
    url: `/v1/health/instances/${instanceId}`,
    method: "GET",
    signal,
  });
};

export const getRuntimeServiceInstanceHealthQueryKey = (instanceId: string) => {
  return [`/v1/health/instances/${instanceId}`] as const;
};

export const getRuntimeServiceInstanceHealthQueryOptions = <
  TData = Awaited<ReturnType<typeof runtimeServiceInstanceHealth>>,
  TError = ErrorType<RpcStatus>,
>(
  instanceId: string,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof runtimeServiceInstanceHealth>>,
        TError,
        TData
      >
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getRuntimeServiceInstanceHealthQueryKey(instanceId);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof runtimeServiceInstanceHealth>>
  > = ({ signal }) => runtimeServiceInstanceHealth(instanceId, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!instanceId,
    ...queryOptions,
  } as CreateQueryOptions<
    Awaited<ReturnType<typeof runtimeServiceInstanceHealth>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type RuntimeServiceInstanceHealthQueryResult = NonNullable<
  Awaited<ReturnType<typeof runtimeServiceInstanceHealth>>
>;
export type RuntimeServiceInstanceHealthQueryError = ErrorType<RpcStatus>;

/**
 * @summary InstanceHealth runs a health check on a specific instance.
 */

export function createRuntimeServiceInstanceHealth<
  TData = Awaited<ReturnType<typeof runtimeServiceInstanceHealth>>,
  TError = ErrorType<RpcStatus>,
>(
  instanceId: string,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof runtimeServiceInstanceHealth>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): CreateQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getRuntimeServiceInstanceHealthQueryOptions(
    instanceId,
    options,
  );

  const query = createQuery(queryOptions, queryClient) as CreateQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary ListInstances lists all the instances currently managed by the runtime
 */
export const runtimeServiceListInstances = (
  params?: RuntimeServiceListInstancesParams,
  signal?: AbortSignal,
) => {
  return httpClient<V1ListInstancesResponse>({
    url: `/v1/instances`,
    method: "GET",
    params,
    signal,
  });
};

export const getRuntimeServiceListInstancesQueryKey = (
  params?: RuntimeServiceListInstancesParams,
) => {
  return [`/v1/instances`, ...(params ? [params] : [])] as const;
};

export const getRuntimeServiceListInstancesQueryOptions = <
  TData = Awaited<ReturnType<typeof runtimeServiceListInstances>>,
  TError = ErrorType<RpcStatus>,
>(
  params?: RuntimeServiceListInstancesParams,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof runtimeServiceListInstances>>,
        TError,
        TData
      >
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getRuntimeServiceListInstancesQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof runtimeServiceListInstances>>
  > = ({ signal }) => runtimeServiceListInstances(params, signal);

  return { queryKey, queryFn, ...queryOptions } as CreateQueryOptions<
    Awaited<ReturnType<typeof runtimeServiceListInstances>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type RuntimeServiceListInstancesQueryResult = NonNullable<
  Awaited<ReturnType<typeof runtimeServiceListInstances>>
>;
export type RuntimeServiceListInstancesQueryError = ErrorType<RpcStatus>;

/**
 * @summary ListInstances lists all the instances currently managed by the runtime
 */

export function createRuntimeServiceListInstances<
  TData = Awaited<ReturnType<typeof runtimeServiceListInstances>>,
  TError = ErrorType<RpcStatus>,
>(
  params?: RuntimeServiceListInstancesParams,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof runtimeServiceListInstances>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): CreateQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getRuntimeServiceListInstancesQueryOptions(
    params,
    options,
  );

  const query = createQuery(queryOptions, queryClient) as CreateQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary CreateInstance creates a new instance
 */
export const runtimeServiceCreateInstance = (
  v1CreateInstanceRequest: V1CreateInstanceRequest,
  signal?: AbortSignal,
) => {
  return httpClient<V1CreateInstanceResponse>({
    url: `/v1/instances`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: v1CreateInstanceRequest,
    signal,
  });
};

export const getRuntimeServiceCreateInstanceMutationOptions = <
  TError = ErrorType<RpcStatus>,
  TContext = unknown,
>(options?: {
  mutation?: CreateMutationOptions<
    Awaited<ReturnType<typeof runtimeServiceCreateInstance>>,
    TError,
    { data: V1CreateInstanceRequest },
    TContext
  >;
}): CreateMutationOptions<
  Awaited<ReturnType<typeof runtimeServiceCreateInstance>>,
  TError,
  { data: V1CreateInstanceRequest },
  TContext
> => {
  const mutationKey = ["runtimeServiceCreateInstance"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof runtimeServiceCreateInstance>>,
    { data: V1CreateInstanceRequest }
  > = (props) => {
    const { data } = props ?? {};

    return runtimeServiceCreateInstance(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type RuntimeServiceCreateInstanceMutationResult = NonNullable<
  Awaited<ReturnType<typeof runtimeServiceCreateInstance>>
>;
export type RuntimeServiceCreateInstanceMutationBody = V1CreateInstanceRequest;
export type RuntimeServiceCreateInstanceMutationError = ErrorType<RpcStatus>;

/**
 * @summary CreateInstance creates a new instance
 */
export const createRuntimeServiceCreateInstance = <
  TError = ErrorType<RpcStatus>,
  TContext = unknown,
>(
  options?: {
    mutation?: CreateMutationOptions<
      Awaited<ReturnType<typeof runtimeServiceCreateInstance>>,
      TError,
      { data: V1CreateInstanceRequest },
      TContext
    >;
  },
  queryClient?: QueryClient,
): CreateMutationResult<
  Awaited<ReturnType<typeof runtimeServiceCreateInstance>>,
  TError,
  { data: V1CreateInstanceRequest },
  TContext
> => {
  const mutationOptions =
    getRuntimeServiceCreateInstanceMutationOptions(options);

  return createMutation(mutationOptions, queryClient);
};
/**
 * @summary GetInstance returns information about a specific instance
 */
export const runtimeServiceGetInstance = (
  instanceId: string,
  params?: RuntimeServiceGetInstanceParams,
  signal?: AbortSignal,
) => {
  return httpClient<V1GetInstanceResponse>({
    url: `/v1/instances/${instanceId}`,
    method: "GET",
    params,
    signal,
  });
};

export const getRuntimeServiceGetInstanceQueryKey = (
  instanceId: string,
  params?: RuntimeServiceGetInstanceParams,
) => {
  return [`/v1/instances/${instanceId}`, ...(params ? [params] : [])] as const;
};

export const getRuntimeServiceGetInstanceQueryOptions = <
  TData = Awaited<ReturnType<typeof runtimeServiceGetInstance>>,
  TError = ErrorType<RpcStatus>,
>(
  instanceId: string,
  params?: RuntimeServiceGetInstanceParams,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof runtimeServiceGetInstance>>,
        TError,
        TData
      >
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getRuntimeServiceGetInstanceQueryKey(instanceId, params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof runtimeServiceGetInstance>>
  > = ({ signal }) => runtimeServiceGetInstance(instanceId, params, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!instanceId,
    ...queryOptions,
  } as CreateQueryOptions<
    Awaited<ReturnType<typeof runtimeServiceGetInstance>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type RuntimeServiceGetInstanceQueryResult = NonNullable<
  Awaited<ReturnType<typeof runtimeServiceGetInstance>>
>;
export type RuntimeServiceGetInstanceQueryError = ErrorType<RpcStatus>;

/**
 * @summary GetInstance returns information about a specific instance
 */

export function createRuntimeServiceGetInstance<
  TData = Awaited<ReturnType<typeof runtimeServiceGetInstance>>,
  TError = ErrorType<RpcStatus>,
>(
  instanceId: string,
  params?: RuntimeServiceGetInstanceParams,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof runtimeServiceGetInstance>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): CreateQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getRuntimeServiceGetInstanceQueryOptions(
    instanceId,
    params,
    options,
  );

  const query = createQuery(queryOptions, queryClient) as CreateQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary DeleteInstance deletes an instance
 */
export const runtimeServiceDeleteInstance = (
  instanceId: string,
  runtimeServiceDeleteInstanceBody: RuntimeServiceDeleteInstanceBody,
  signal?: AbortSignal,
) => {
  return httpClient<V1DeleteInstanceResponse>({
    url: `/v1/instances/${instanceId}`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: runtimeServiceDeleteInstanceBody,
    signal,
  });
};

export const getRuntimeServiceDeleteInstanceMutationOptions = <
  TError = ErrorType<RpcStatus>,
  TContext = unknown,
>(options?: {
  mutation?: CreateMutationOptions<
    Awaited<ReturnType<typeof runtimeServiceDeleteInstance>>,
    TError,
    { instanceId: string; data: RuntimeServiceDeleteInstanceBody },
    TContext
  >;
}): CreateMutationOptions<
  Awaited<ReturnType<typeof runtimeServiceDeleteInstance>>,
  TError,
  { instanceId: string; data: RuntimeServiceDeleteInstanceBody },
  TContext
> => {
  const mutationKey = ["runtimeServiceDeleteInstance"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof runtimeServiceDeleteInstance>>,
    { instanceId: string; data: RuntimeServiceDeleteInstanceBody }
  > = (props) => {
    const { instanceId, data } = props ?? {};

    return runtimeServiceDeleteInstance(instanceId, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type RuntimeServiceDeleteInstanceMutationResult = NonNullable<
  Awaited<ReturnType<typeof runtimeServiceDeleteInstance>>
>;
export type RuntimeServiceDeleteInstanceMutationBody =
  RuntimeServiceDeleteInstanceBody;
export type RuntimeServiceDeleteInstanceMutationError = ErrorType<RpcStatus>;

/**
 * @summary DeleteInstance deletes an instance
 */
export const createRuntimeServiceDeleteInstance = <
  TError = ErrorType<RpcStatus>,
  TContext = unknown,
>(
  options?: {
    mutation?: CreateMutationOptions<
      Awaited<ReturnType<typeof runtimeServiceDeleteInstance>>,
      TError,
      { instanceId: string; data: RuntimeServiceDeleteInstanceBody },
      TContext
    >;
  },
  queryClient?: QueryClient,
): CreateMutationResult<
  Awaited<ReturnType<typeof runtimeServiceDeleteInstance>>,
  TError,
  { instanceId: string; data: RuntimeServiceDeleteInstanceBody },
  TContext
> => {
  const mutationOptions =
    getRuntimeServiceDeleteInstanceMutationOptions(options);

  return createMutation(mutationOptions, queryClient);
};
/**
 * @summary EditInstance edits an existing instance
 */
export const runtimeServiceEditInstance = (
  instanceId: string,
  runtimeServiceEditInstanceBody: RuntimeServiceEditInstanceBody,
) => {
  return httpClient<V1EditInstanceResponse>({
    url: `/v1/instances/${instanceId}`,
    method: "PATCH",
    headers: { "Content-Type": "application/json" },
    data: runtimeServiceEditInstanceBody,
  });
};

export const getRuntimeServiceEditInstanceMutationOptions = <
  TError = ErrorType<RpcStatus>,
  TContext = unknown,
>(options?: {
  mutation?: CreateMutationOptions<
    Awaited<ReturnType<typeof runtimeServiceEditInstance>>,
    TError,
    { instanceId: string; data: RuntimeServiceEditInstanceBody },
    TContext
  >;
}): CreateMutationOptions<
  Awaited<ReturnType<typeof runtimeServiceEditInstance>>,
  TError,
  { instanceId: string; data: RuntimeServiceEditInstanceBody },
  TContext
> => {
  const mutationKey = ["runtimeServiceEditInstance"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof runtimeServiceEditInstance>>,
    { instanceId: string; data: RuntimeServiceEditInstanceBody }
  > = (props) => {
    const { instanceId, data } = props ?? {};

    return runtimeServiceEditInstance(instanceId, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type RuntimeServiceEditInstanceMutationResult = NonNullable<
  Awaited<ReturnType<typeof runtimeServiceEditInstance>>
>;
export type RuntimeServiceEditInstanceMutationBody =
  RuntimeServiceEditInstanceBody;
export type RuntimeServiceEditInstanceMutationError = ErrorType<RpcStatus>;

/**
 * @summary EditInstance edits an existing instance
 */
export const createRuntimeServiceEditInstance = <
  TError = ErrorType<RpcStatus>,
  TContext = unknown,
>(
  options?: {
    mutation?: CreateMutationOptions<
      Awaited<ReturnType<typeof runtimeServiceEditInstance>>,
      TError,
      { instanceId: string; data: RuntimeServiceEditInstanceBody },
      TContext
    >;
  },
  queryClient?: QueryClient,
): CreateMutationResult<
  Awaited<ReturnType<typeof runtimeServiceEditInstance>>,
  TError,
  { instanceId: string; data: RuntimeServiceEditInstanceBody },
  TContext
> => {
  const mutationOptions = getRuntimeServiceEditInstanceMutationOptions(options);

  return createMutation(mutationOptions, queryClient);
};
/**
 * @summary Complete runs a language model completion (LLM chat) using the configured AI connector.
 */
export const runtimeServiceComplete = (
  instanceId: string,
  runtimeServiceCompleteBody: RuntimeServiceCompleteBody,
  signal?: AbortSignal,
) => {
  return httpClient<V1CompleteResponse>({
    url: `/v1/instances/${instanceId}/ai/complete`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: runtimeServiceCompleteBody,
    signal,
  });
};

export const getRuntimeServiceCompleteMutationOptions = <
  TError = ErrorType<RpcStatus>,
  TContext = unknown,
>(options?: {
  mutation?: CreateMutationOptions<
    Awaited<ReturnType<typeof runtimeServiceComplete>>,
    TError,
    { instanceId: string; data: RuntimeServiceCompleteBody },
    TContext
  >;
}): CreateMutationOptions<
  Awaited<ReturnType<typeof runtimeServiceComplete>>,
  TError,
  { instanceId: string; data: RuntimeServiceCompleteBody },
  TContext
> => {
  const mutationKey = ["runtimeServiceComplete"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof runtimeServiceComplete>>,
    { instanceId: string; data: RuntimeServiceCompleteBody }
  > = (props) => {
    const { instanceId, data } = props ?? {};

    return runtimeServiceComplete(instanceId, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type RuntimeServiceCompleteMutationResult = NonNullable<
  Awaited<ReturnType<typeof runtimeServiceComplete>>
>;
export type RuntimeServiceCompleteMutationBody = RuntimeServiceCompleteBody;
export type RuntimeServiceCompleteMutationError = ErrorType<RpcStatus>;

/**
 * @summary Complete runs a language model completion (LLM chat) using the configured AI connector.
 */
export const createRuntimeServiceComplete = <
  TError = ErrorType<RpcStatus>,
  TContext = unknown,
>(
  options?: {
    mutation?: CreateMutationOptions<
      Awaited<ReturnType<typeof runtimeServiceComplete>>,
      TError,
      { instanceId: string; data: RuntimeServiceCompleteBody },
      TContext
    >;
  },
  queryClient?: QueryClient,
): CreateMutationResult<
  Awaited<ReturnType<typeof runtimeServiceComplete>>,
  TError,
  { instanceId: string; data: RuntimeServiceCompleteBody },
  TContext
> => {
  const mutationOptions = getRuntimeServiceCompleteMutationOptions(options);

  return createMutation(mutationOptions, queryClient);
};
/**
 * @summary CompleteStreaming runs an AI-powered chat completion, optionally invoking agents or tool calls available in Rill.
 */
export const runtimeServiceCompleteStreaming = (
  instanceId: string,
  runtimeServiceCompleteStreamingBody: RuntimeServiceCompleteStreamingBody,
  signal?: AbortSignal,
) => {
  return httpClient<RuntimeServiceCompleteStreaming200>({
    url: `/v1/instances/${instanceId}/ai/complete/stream`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: runtimeServiceCompleteStreamingBody,
    signal,
  });
};

export const getRuntimeServiceCompleteStreamingMutationOptions = <
  TError = ErrorType<RpcStatus>,
  TContext = unknown,
>(options?: {
  mutation?: CreateMutationOptions<
    Awaited<ReturnType<typeof runtimeServiceCompleteStreaming>>,
    TError,
    { instanceId: string; data: RuntimeServiceCompleteStreamingBody },
    TContext
  >;
}): CreateMutationOptions<
  Awaited<ReturnType<typeof runtimeServiceCompleteStreaming>>,
  TError,
  { instanceId: string; data: RuntimeServiceCompleteStreamingBody },
  TContext
> => {
  const mutationKey = ["runtimeServiceCompleteStreaming"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof runtimeServiceCompleteStreaming>>,
    { instanceId: string; data: RuntimeServiceCompleteStreamingBody }
  > = (props) => {
    const { instanceId, data } = props ?? {};

    return runtimeServiceCompleteStreaming(instanceId, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type RuntimeServiceCompleteStreamingMutationResult = NonNullable<
  Awaited<ReturnType<typeof runtimeServiceCompleteStreaming>>
>;
export type RuntimeServiceCompleteStreamingMutationBody =
  RuntimeServiceCompleteStreamingBody;
export type RuntimeServiceCompleteStreamingMutationError = ErrorType<RpcStatus>;

/**
 * @summary CompleteStreaming runs an AI-powered chat completion, optionally invoking agents or tool calls available in Rill.
 */
export const createRuntimeServiceCompleteStreaming = <
  TError = ErrorType<RpcStatus>,
  TContext = unknown,
>(
  options?: {
    mutation?: CreateMutationOptions<
      Awaited<ReturnType<typeof runtimeServiceCompleteStreaming>>,
      TError,
      { instanceId: string; data: RuntimeServiceCompleteStreamingBody },
      TContext
    >;
  },
  queryClient?: QueryClient,
): CreateMutationResult<
  Awaited<ReturnType<typeof runtimeServiceCompleteStreaming>>,
  TError,
  { instanceId: string; data: RuntimeServiceCompleteStreamingBody },
  TContext
> => {
  const mutationOptions =
    getRuntimeServiceCompleteStreamingMutationOptions(options);

  return createMutation(mutationOptions, queryClient);
};
/**
 * @summary ListConversations lists all AI chat conversations for an instance.
 */
export const runtimeServiceListConversations = (
  instanceId: string,
  params?: RuntimeServiceListConversationsParams,
  signal?: AbortSignal,
) => {
  return httpClient<V1ListConversationsResponse>({
    url: `/v1/instances/${instanceId}/ai/conversations`,
    method: "GET",
    params,
    signal,
  });
};

export const getRuntimeServiceListConversationsQueryKey = (
  instanceId: string,
  params?: RuntimeServiceListConversationsParams,
) => {
  return [
    `/v1/instances/${instanceId}/ai/conversations`,
    ...(params ? [params] : []),
  ] as const;
};

export const getRuntimeServiceListConversationsQueryOptions = <
  TData = Awaited<ReturnType<typeof runtimeServiceListConversations>>,
  TError = ErrorType<RpcStatus>,
>(
  instanceId: string,
  params?: RuntimeServiceListConversationsParams,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof runtimeServiceListConversations>>,
        TError,
        TData
      >
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getRuntimeServiceListConversationsQueryKey(instanceId, params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof runtimeServiceListConversations>>
  > = ({ signal }) =>
    runtimeServiceListConversations(instanceId, params, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!instanceId,
    ...queryOptions,
  } as CreateQueryOptions<
    Awaited<ReturnType<typeof runtimeServiceListConversations>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type RuntimeServiceListConversationsQueryResult = NonNullable<
  Awaited<ReturnType<typeof runtimeServiceListConversations>>
>;
export type RuntimeServiceListConversationsQueryError = ErrorType<RpcStatus>;

/**
 * @summary ListConversations lists all AI chat conversations for an instance.
 */

export function createRuntimeServiceListConversations<
  TData = Awaited<ReturnType<typeof runtimeServiceListConversations>>,
  TError = ErrorType<RpcStatus>,
>(
  instanceId: string,
  params?: RuntimeServiceListConversationsParams,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof runtimeServiceListConversations>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): CreateQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getRuntimeServiceListConversationsQueryOptions(
    instanceId,
    params,
    options,
  );

  const query = createQuery(queryOptions, queryClient) as CreateQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary GetConversation returns a specific AI chat conversation.
 */
export const runtimeServiceGetConversation = (
  instanceId: string,
  conversationId: string,
  signal?: AbortSignal,
) => {
  return httpClient<V1GetConversationResponse>({
    url: `/v1/instances/${instanceId}/ai/conversations/${conversationId}`,
    method: "GET",
    signal,
  });
};

export const getRuntimeServiceGetConversationQueryKey = (
  instanceId: string,
  conversationId: string,
) => {
  return [
    `/v1/instances/${instanceId}/ai/conversations/${conversationId}`,
  ] as const;
};

export const getRuntimeServiceGetConversationQueryOptions = <
  TData = Awaited<ReturnType<typeof runtimeServiceGetConversation>>,
  TError = ErrorType<RpcStatus>,
>(
  instanceId: string,
  conversationId: string,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof runtimeServiceGetConversation>>,
        TError,
        TData
      >
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getRuntimeServiceGetConversationQueryKey(instanceId, conversationId);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof runtimeServiceGetConversation>>
  > = ({ signal }) =>
    runtimeServiceGetConversation(instanceId, conversationId, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!(instanceId && conversationId),
    ...queryOptions,
  } as CreateQueryOptions<
    Awaited<ReturnType<typeof runtimeServiceGetConversation>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type RuntimeServiceGetConversationQueryResult = NonNullable<
  Awaited<ReturnType<typeof runtimeServiceGetConversation>>
>;
export type RuntimeServiceGetConversationQueryError = ErrorType<RpcStatus>;

/**
 * @summary GetConversation returns a specific AI chat conversation.
 */

export function createRuntimeServiceGetConversation<
  TData = Awaited<ReturnType<typeof runtimeServiceGetConversation>>,
  TError = ErrorType<RpcStatus>,
>(
  instanceId: string,
  conversationId: string,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof runtimeServiceGetConversation>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): CreateQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getRuntimeServiceGetConversationQueryOptions(
    instanceId,
    conversationId,
    options,
  );

  const query = createQuery(queryOptions, queryClient) as CreateQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary ListTools lists metadata about all AI tools that calls to Complete(Streaming) may invoke.
Note that it covers all registered tools, but the current user may not have access to all of them.
 */
export const runtimeServiceListTools = (
  instanceId: string,
  signal?: AbortSignal,
) => {
  return httpClient<V1ListToolsResponse>({
    url: `/v1/instances/${instanceId}/ai/tools`,
    method: "GET",
    signal,
  });
};

export const getRuntimeServiceListToolsQueryKey = (instanceId: string) => {
  return [`/v1/instances/${instanceId}/ai/tools`] as const;
};

export const getRuntimeServiceListToolsQueryOptions = <
  TData = Awaited<ReturnType<typeof runtimeServiceListTools>>,
  TError = ErrorType<RpcStatus>,
>(
  instanceId: string,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof runtimeServiceListTools>>,
        TError,
        TData
      >
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getRuntimeServiceListToolsQueryKey(instanceId);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof runtimeServiceListTools>>
  > = ({ signal }) => runtimeServiceListTools(instanceId, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!instanceId,
    ...queryOptions,
  } as CreateQueryOptions<
    Awaited<ReturnType<typeof runtimeServiceListTools>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type RuntimeServiceListToolsQueryResult = NonNullable<
  Awaited<ReturnType<typeof runtimeServiceListTools>>
>;
export type RuntimeServiceListToolsQueryError = ErrorType<RpcStatus>;

/**
 * @summary ListTools lists metadata about all AI tools that calls to Complete(Streaming) may invoke.
Note that it covers all registered tools, but the current user may not have access to all of them.
 */

export function createRuntimeServiceListTools<
  TData = Awaited<ReturnType<typeof runtimeServiceListTools>>,
  TError = ErrorType<RpcStatus>,
>(
  instanceId: string,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof runtimeServiceListTools>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): CreateQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getRuntimeServiceListToolsQueryOptions(
    instanceId,
    options,
  );

  const query = createQuery(queryOptions, queryClient) as CreateQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary ListBuckets lists buckets accessible with the configured credentials.
 */
export const connectorServiceListBuckets = (
  instanceId: string,
  connector: string,
  params?: ConnectorServiceListBucketsParams,
  signal?: AbortSignal,
) => {
  return httpClient<V1ListBucketsResponse>({
    url: `/v1/instances/${instanceId}/connectors/${connector}/buckets`,
    method: "GET",
    params,
    signal,
  });
};

export const getConnectorServiceListBucketsQueryKey = (
  instanceId: string,
  connector: string,
  params?: ConnectorServiceListBucketsParams,
) => {
  return [
    `/v1/instances/${instanceId}/connectors/${connector}/buckets`,
    ...(params ? [params] : []),
  ] as const;
};

export const getConnectorServiceListBucketsQueryOptions = <
  TData = Awaited<ReturnType<typeof connectorServiceListBuckets>>,
  TError = ErrorType<RpcStatus>,
>(
  instanceId: string,
  connector: string,
  params?: ConnectorServiceListBucketsParams,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof connectorServiceListBuckets>>,
        TError,
        TData
      >
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getConnectorServiceListBucketsQueryKey(instanceId, connector, params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof connectorServiceListBuckets>>
  > = ({ signal }) =>
    connectorServiceListBuckets(instanceId, connector, params, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!(instanceId && connector),
    ...queryOptions,
  } as CreateQueryOptions<
    Awaited<ReturnType<typeof connectorServiceListBuckets>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type ConnectorServiceListBucketsQueryResult = NonNullable<
  Awaited<ReturnType<typeof connectorServiceListBuckets>>
>;
export type ConnectorServiceListBucketsQueryError = ErrorType<RpcStatus>;

/**
 * @summary ListBuckets lists buckets accessible with the configured credentials.
 */

export function createConnectorServiceListBuckets<
  TData = Awaited<ReturnType<typeof connectorServiceListBuckets>>,
  TError = ErrorType<RpcStatus>,
>(
  instanceId: string,
  connector: string,
  params?: ConnectorServiceListBucketsParams,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof connectorServiceListBuckets>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): CreateQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getConnectorServiceListBucketsQueryOptions(
    instanceId,
    connector,
    params,
    options,
  );

  const query = createQuery(queryOptions, queryClient) as CreateQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary ListObjects lists objects for the given bucket.
 */
export const connectorServiceListObjects = (
  instanceId: string,
  connector: string,
  bucket: string,
  params?: ConnectorServiceListObjectsParams,
  signal?: AbortSignal,
) => {
  return httpClient<V1ListObjectsResponse>({
    url: `/v1/instances/${instanceId}/connectors/${connector}/buckets/${bucket}/objects`,
    method: "GET",
    params,
    signal,
  });
};

export const getConnectorServiceListObjectsQueryKey = (
  instanceId: string,
  connector: string,
  bucket: string,
  params?: ConnectorServiceListObjectsParams,
) => {
  return [
    `/v1/instances/${instanceId}/connectors/${connector}/buckets/${bucket}/objects`,
    ...(params ? [params] : []),
  ] as const;
};

export const getConnectorServiceListObjectsQueryOptions = <
  TData = Awaited<ReturnType<typeof connectorServiceListObjects>>,
  TError = ErrorType<RpcStatus>,
>(
  instanceId: string,
  connector: string,
  bucket: string,
  params?: ConnectorServiceListObjectsParams,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof connectorServiceListObjects>>,
        TError,
        TData
      >
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getConnectorServiceListObjectsQueryKey(
      instanceId,
      connector,
      bucket,
      params,
    );

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof connectorServiceListObjects>>
  > = ({ signal }) =>
    connectorServiceListObjects(instanceId, connector, bucket, params, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!(instanceId && connector && bucket),
    ...queryOptions,
  } as CreateQueryOptions<
    Awaited<ReturnType<typeof connectorServiceListObjects>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type ConnectorServiceListObjectsQueryResult = NonNullable<
  Awaited<ReturnType<typeof connectorServiceListObjects>>
>;
export type ConnectorServiceListObjectsQueryError = ErrorType<RpcStatus>;

/**
 * @summary ListObjects lists objects for the given bucket.
 */

export function createConnectorServiceListObjects<
  TData = Awaited<ReturnType<typeof connectorServiceListObjects>>,
  TError = ErrorType<RpcStatus>,
>(
  instanceId: string,
  connector: string,
  bucket: string,
  params?: ConnectorServiceListObjectsParams,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof connectorServiceListObjects>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): CreateQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getConnectorServiceListObjectsQueryOptions(
    instanceId,
    connector,
    bucket,
    params,
    options,
  );

  const query = createQuery(queryOptions, queryClient) as CreateQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary AnalyzeConnectors scans all the project files and returns information about all referenced connectors.
 */
export const runtimeServiceAnalyzeConnectors = (
  instanceId: string,
  signal?: AbortSignal,
) => {
  return httpClient<V1AnalyzeConnectorsResponse>({
    url: `/v1/instances/${instanceId}/connectors/analyze`,
    method: "GET",
    signal,
  });
};

export const getRuntimeServiceAnalyzeConnectorsQueryKey = (
  instanceId: string,
) => {
  return [`/v1/instances/${instanceId}/connectors/analyze`] as const;
};

export const getRuntimeServiceAnalyzeConnectorsQueryOptions = <
  TData = Awaited<ReturnType<typeof runtimeServiceAnalyzeConnectors>>,
  TError = ErrorType<RpcStatus>,
>(
  instanceId: string,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof runtimeServiceAnalyzeConnectors>>,
        TError,
        TData
      >
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getRuntimeServiceAnalyzeConnectorsQueryKey(instanceId);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof runtimeServiceAnalyzeConnectors>>
  > = ({ signal }) => runtimeServiceAnalyzeConnectors(instanceId, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!instanceId,
    ...queryOptions,
  } as CreateQueryOptions<
    Awaited<ReturnType<typeof runtimeServiceAnalyzeConnectors>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type RuntimeServiceAnalyzeConnectorsQueryResult = NonNullable<
  Awaited<ReturnType<typeof runtimeServiceAnalyzeConnectors>>
>;
export type RuntimeServiceAnalyzeConnectorsQueryError = ErrorType<RpcStatus>;

/**
 * @summary AnalyzeConnectors scans all the project files and returns information about all referenced connectors.
 */

export function createRuntimeServiceAnalyzeConnectors<
  TData = Awaited<ReturnType<typeof runtimeServiceAnalyzeConnectors>>,
  TError = ErrorType<RpcStatus>,
>(
  instanceId: string,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof runtimeServiceAnalyzeConnectors>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): CreateQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getRuntimeServiceAnalyzeConnectorsQueryOptions(
    instanceId,
    options,
  );

  const query = createQuery(queryOptions, queryClient) as CreateQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary ListNotifierConnectors returns the names of all configured connectors that can be used as notifiers.
This API is much faster than AnalyzeConnectors and can be called without admin-level permissions.
 */
export const runtimeServiceListNotifierConnectors = (
  instanceId: string,
  signal?: AbortSignal,
) => {
  return httpClient<V1ListNotifierConnectorsResponse>({
    url: `/v1/instances/${instanceId}/connectors/notifiers`,
    method: "GET",
    signal,
  });
};

export const getRuntimeServiceListNotifierConnectorsQueryKey = (
  instanceId: string,
) => {
  return [`/v1/instances/${instanceId}/connectors/notifiers`] as const;
};

export const getRuntimeServiceListNotifierConnectorsQueryOptions = <
  TData = Awaited<ReturnType<typeof runtimeServiceListNotifierConnectors>>,
  TError = ErrorType<RpcStatus>,
>(
  instanceId: string,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof runtimeServiceListNotifierConnectors>>,
        TError,
        TData
      >
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getRuntimeServiceListNotifierConnectorsQueryKey(instanceId);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof runtimeServiceListNotifierConnectors>>
  > = ({ signal }) => runtimeServiceListNotifierConnectors(instanceId, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!instanceId,
    ...queryOptions,
  } as CreateQueryOptions<
    Awaited<ReturnType<typeof runtimeServiceListNotifierConnectors>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type RuntimeServiceListNotifierConnectorsQueryResult = NonNullable<
  Awaited<ReturnType<typeof runtimeServiceListNotifierConnectors>>
>;
export type RuntimeServiceListNotifierConnectorsQueryError =
  ErrorType<RpcStatus>;

/**
 * @summary ListNotifierConnectors returns the names of all configured connectors that can be used as notifiers.
This API is much faster than AnalyzeConnectors and can be called without admin-level permissions.
 */

export function createRuntimeServiceListNotifierConnectors<
  TData = Awaited<ReturnType<typeof runtimeServiceListNotifierConnectors>>,
  TError = ErrorType<RpcStatus>,
>(
  instanceId: string,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof runtimeServiceListNotifierConnectors>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): CreateQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getRuntimeServiceListNotifierConnectorsQueryOptions(
    instanceId,
    options,
  );

  const query = createQuery(queryOptions, queryClient) as CreateQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary ListFiles lists all the files matching a glob in a repo.
The files are sorted by their full path.
 */
export const runtimeServiceListFiles = (
  instanceId: string,
  params?: RuntimeServiceListFilesParams,
  signal?: AbortSignal,
) => {
  return httpClient<V1ListFilesResponse>({
    url: `/v1/instances/${instanceId}/files`,
    method: "GET",
    params,
    signal,
  });
};

export const getRuntimeServiceListFilesQueryKey = (
  instanceId: string,
  params?: RuntimeServiceListFilesParams,
) => {
  return [
    `/v1/instances/${instanceId}/files`,
    ...(params ? [params] : []),
  ] as const;
};

export const getRuntimeServiceListFilesQueryOptions = <
  TData = Awaited<ReturnType<typeof runtimeServiceListFiles>>,
  TError = ErrorType<RpcStatus>,
>(
  instanceId: string,
  params?: RuntimeServiceListFilesParams,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof runtimeServiceListFiles>>,
        TError,
        TData
      >
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getRuntimeServiceListFilesQueryKey(instanceId, params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof runtimeServiceListFiles>>
  > = ({ signal }) => runtimeServiceListFiles(instanceId, params, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!instanceId,
    ...queryOptions,
  } as CreateQueryOptions<
    Awaited<ReturnType<typeof runtimeServiceListFiles>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type RuntimeServiceListFilesQueryResult = NonNullable<
  Awaited<ReturnType<typeof runtimeServiceListFiles>>
>;
export type RuntimeServiceListFilesQueryError = ErrorType<RpcStatus>;

/**
 * @summary ListFiles lists all the files matching a glob in a repo.
The files are sorted by their full path.
 */

export function createRuntimeServiceListFiles<
  TData = Awaited<ReturnType<typeof runtimeServiceListFiles>>,
  TError = ErrorType<RpcStatus>,
>(
  instanceId: string,
  params?: RuntimeServiceListFilesParams,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof runtimeServiceListFiles>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): CreateQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getRuntimeServiceListFilesQueryOptions(
    instanceId,
    params,
    options,
  );

  const query = createQuery(queryOptions, queryClient) as CreateQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary CreateDirectory create a directory for the given path
 */
export const runtimeServiceCreateDirectory = (
  instanceId: string,
  runtimeServiceCreateDirectoryBody: RuntimeServiceCreateDirectoryBody,
  signal?: AbortSignal,
) => {
  return httpClient<V1CreateDirectoryResponse>({
    url: `/v1/instances/${instanceId}/files/dir`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: runtimeServiceCreateDirectoryBody,
    signal,
  });
};

export const getRuntimeServiceCreateDirectoryMutationOptions = <
  TError = ErrorType<RpcStatus>,
  TContext = unknown,
>(options?: {
  mutation?: CreateMutationOptions<
    Awaited<ReturnType<typeof runtimeServiceCreateDirectory>>,
    TError,
    { instanceId: string; data: RuntimeServiceCreateDirectoryBody },
    TContext
  >;
}): CreateMutationOptions<
  Awaited<ReturnType<typeof runtimeServiceCreateDirectory>>,
  TError,
  { instanceId: string; data: RuntimeServiceCreateDirectoryBody },
  TContext
> => {
  const mutationKey = ["runtimeServiceCreateDirectory"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof runtimeServiceCreateDirectory>>,
    { instanceId: string; data: RuntimeServiceCreateDirectoryBody }
  > = (props) => {
    const { instanceId, data } = props ?? {};

    return runtimeServiceCreateDirectory(instanceId, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type RuntimeServiceCreateDirectoryMutationResult = NonNullable<
  Awaited<ReturnType<typeof runtimeServiceCreateDirectory>>
>;
export type RuntimeServiceCreateDirectoryMutationBody =
  RuntimeServiceCreateDirectoryBody;
export type RuntimeServiceCreateDirectoryMutationError = ErrorType<RpcStatus>;

/**
 * @summary CreateDirectory create a directory for the given path
 */
export const createRuntimeServiceCreateDirectory = <
  TError = ErrorType<RpcStatus>,
  TContext = unknown,
>(
  options?: {
    mutation?: CreateMutationOptions<
      Awaited<ReturnType<typeof runtimeServiceCreateDirectory>>,
      TError,
      { instanceId: string; data: RuntimeServiceCreateDirectoryBody },
      TContext
    >;
  },
  queryClient?: QueryClient,
): CreateMutationResult<
  Awaited<ReturnType<typeof runtimeServiceCreateDirectory>>,
  TError,
  { instanceId: string; data: RuntimeServiceCreateDirectoryBody },
  TContext
> => {
  const mutationOptions =
    getRuntimeServiceCreateDirectoryMutationOptions(options);

  return createMutation(mutationOptions, queryClient);
};
/**
 * @summary GetFile returns the contents of a specific file in a repo.
 */
export const runtimeServiceGetFile = (
  instanceId: string,
  params?: RuntimeServiceGetFileParams,
  signal?: AbortSignal,
) => {
  return httpClient<V1GetFileResponse>({
    url: `/v1/instances/${instanceId}/files/entry`,
    method: "GET",
    params,
    signal,
  });
};

export const getRuntimeServiceGetFileQueryKey = (
  instanceId: string,
  params?: RuntimeServiceGetFileParams,
) => {
  return [
    `/v1/instances/${instanceId}/files/entry`,
    ...(params ? [params] : []),
  ] as const;
};

export const getRuntimeServiceGetFileQueryOptions = <
  TData = Awaited<ReturnType<typeof runtimeServiceGetFile>>,
  TError = ErrorType<RpcStatus>,
>(
  instanceId: string,
  params?: RuntimeServiceGetFileParams,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof runtimeServiceGetFile>>,
        TError,
        TData
      >
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getRuntimeServiceGetFileQueryKey(instanceId, params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof runtimeServiceGetFile>>
  > = ({ signal }) => runtimeServiceGetFile(instanceId, params, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!instanceId,
    ...queryOptions,
  } as CreateQueryOptions<
    Awaited<ReturnType<typeof runtimeServiceGetFile>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type RuntimeServiceGetFileQueryResult = NonNullable<
  Awaited<ReturnType<typeof runtimeServiceGetFile>>
>;
export type RuntimeServiceGetFileQueryError = ErrorType<RpcStatus>;

/**
 * @summary GetFile returns the contents of a specific file in a repo.
 */

export function createRuntimeServiceGetFile<
  TData = Awaited<ReturnType<typeof runtimeServiceGetFile>>,
  TError = ErrorType<RpcStatus>,
>(
  instanceId: string,
  params?: RuntimeServiceGetFileParams,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof runtimeServiceGetFile>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): CreateQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getRuntimeServiceGetFileQueryOptions(
    instanceId,
    params,
    options,
  );

  const query = createQuery(queryOptions, queryClient) as CreateQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary DeleteFile deletes a file from a repo
 */
export const runtimeServiceDeleteFile = (
  instanceId: string,
  params?: RuntimeServiceDeleteFileParams,
) => {
  return httpClient<V1DeleteFileResponse>({
    url: `/v1/instances/${instanceId}/files/entry`,
    method: "DELETE",
    params,
  });
};

export const getRuntimeServiceDeleteFileMutationOptions = <
  TError = ErrorType<RpcStatus>,
  TContext = unknown,
>(options?: {
  mutation?: CreateMutationOptions<
    Awaited<ReturnType<typeof runtimeServiceDeleteFile>>,
    TError,
    { instanceId: string; params?: RuntimeServiceDeleteFileParams },
    TContext
  >;
}): CreateMutationOptions<
  Awaited<ReturnType<typeof runtimeServiceDeleteFile>>,
  TError,
  { instanceId: string; params?: RuntimeServiceDeleteFileParams },
  TContext
> => {
  const mutationKey = ["runtimeServiceDeleteFile"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof runtimeServiceDeleteFile>>,
    { instanceId: string; params?: RuntimeServiceDeleteFileParams }
  > = (props) => {
    const { instanceId, params } = props ?? {};

    return runtimeServiceDeleteFile(instanceId, params);
  };

  return { mutationFn, ...mutationOptions };
};

export type RuntimeServiceDeleteFileMutationResult = NonNullable<
  Awaited<ReturnType<typeof runtimeServiceDeleteFile>>
>;

export type RuntimeServiceDeleteFileMutationError = ErrorType<RpcStatus>;

/**
 * @summary DeleteFile deletes a file from a repo
 */
export const createRuntimeServiceDeleteFile = <
  TError = ErrorType<RpcStatus>,
  TContext = unknown,
>(
  options?: {
    mutation?: CreateMutationOptions<
      Awaited<ReturnType<typeof runtimeServiceDeleteFile>>,
      TError,
      { instanceId: string; params?: RuntimeServiceDeleteFileParams },
      TContext
    >;
  },
  queryClient?: QueryClient,
): CreateMutationResult<
  Awaited<ReturnType<typeof runtimeServiceDeleteFile>>,
  TError,
  { instanceId: string; params?: RuntimeServiceDeleteFileParams },
  TContext
> => {
  const mutationOptions = getRuntimeServiceDeleteFileMutationOptions(options);

  return createMutation(mutationOptions, queryClient);
};
/**
 * @summary PutFile creates or updates a file in a repo
 */
export const runtimeServicePutFile = (
  instanceId: string,
  runtimeServicePutFileBody: RuntimeServicePutFileBody,
  signal?: AbortSignal,
) => {
  return httpClient<V1PutFileResponse>({
    url: `/v1/instances/${instanceId}/files/entry`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: runtimeServicePutFileBody,
    signal,
  });
};

export const getRuntimeServicePutFileMutationOptions = <
  TError = ErrorType<RpcStatus>,
  TContext = unknown,
>(options?: {
  mutation?: CreateMutationOptions<
    Awaited<ReturnType<typeof runtimeServicePutFile>>,
    TError,
    { instanceId: string; data: RuntimeServicePutFileBody },
    TContext
  >;
}): CreateMutationOptions<
  Awaited<ReturnType<typeof runtimeServicePutFile>>,
  TError,
  { instanceId: string; data: RuntimeServicePutFileBody },
  TContext
> => {
  const mutationKey = ["runtimeServicePutFile"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof runtimeServicePutFile>>,
    { instanceId: string; data: RuntimeServicePutFileBody }
  > = (props) => {
    const { instanceId, data } = props ?? {};

    return runtimeServicePutFile(instanceId, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type RuntimeServicePutFileMutationResult = NonNullable<
  Awaited<ReturnType<typeof runtimeServicePutFile>>
>;
export type RuntimeServicePutFileMutationBody = RuntimeServicePutFileBody;
export type RuntimeServicePutFileMutationError = ErrorType<RpcStatus>;

/**
 * @summary PutFile creates or updates a file in a repo
 */
export const createRuntimeServicePutFile = <
  TError = ErrorType<RpcStatus>,
  TContext = unknown,
>(
  options?: {
    mutation?: CreateMutationOptions<
      Awaited<ReturnType<typeof runtimeServicePutFile>>,
      TError,
      { instanceId: string; data: RuntimeServicePutFileBody },
      TContext
    >;
  },
  queryClient?: QueryClient,
): CreateMutationResult<
  Awaited<ReturnType<typeof runtimeServicePutFile>>,
  TError,
  { instanceId: string; data: RuntimeServicePutFileBody },
  TContext
> => {
  const mutationOptions = getRuntimeServicePutFileMutationOptions(options);

  return createMutation(mutationOptions, queryClient);
};
/**
 * @summary GenerateCanvasFile generates a canvas YAML file from a metrics view
 */
export const runtimeServiceGenerateCanvasFile = (
  instanceId: string,
  runtimeServiceGenerateCanvasFileBody: RuntimeServiceGenerateCanvasFileBody,
  signal?: AbortSignal,
) => {
  return httpClient<V1GenerateCanvasFileResponse>({
    url: `/v1/instances/${instanceId}/files/generate-canvas`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: runtimeServiceGenerateCanvasFileBody,
    signal,
  });
};

export const getRuntimeServiceGenerateCanvasFileMutationOptions = <
  TError = ErrorType<RpcStatus>,
  TContext = unknown,
>(options?: {
  mutation?: CreateMutationOptions<
    Awaited<ReturnType<typeof runtimeServiceGenerateCanvasFile>>,
    TError,
    { instanceId: string; data: RuntimeServiceGenerateCanvasFileBody },
    TContext
  >;
}): CreateMutationOptions<
  Awaited<ReturnType<typeof runtimeServiceGenerateCanvasFile>>,
  TError,
  { instanceId: string; data: RuntimeServiceGenerateCanvasFileBody },
  TContext
> => {
  const mutationKey = ["runtimeServiceGenerateCanvasFile"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof runtimeServiceGenerateCanvasFile>>,
    { instanceId: string; data: RuntimeServiceGenerateCanvasFileBody }
  > = (props) => {
    const { instanceId, data } = props ?? {};

    return runtimeServiceGenerateCanvasFile(instanceId, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type RuntimeServiceGenerateCanvasFileMutationResult = NonNullable<
  Awaited<ReturnType<typeof runtimeServiceGenerateCanvasFile>>
>;
export type RuntimeServiceGenerateCanvasFileMutationBody =
  RuntimeServiceGenerateCanvasFileBody;
export type RuntimeServiceGenerateCanvasFileMutationError =
  ErrorType<RpcStatus>;

/**
 * @summary GenerateCanvasFile generates a canvas YAML file from a metrics view
 */
export const createRuntimeServiceGenerateCanvasFile = <
  TError = ErrorType<RpcStatus>,
  TContext = unknown,
>(
  options?: {
    mutation?: CreateMutationOptions<
      Awaited<ReturnType<typeof runtimeServiceGenerateCanvasFile>>,
      TError,
      { instanceId: string; data: RuntimeServiceGenerateCanvasFileBody },
      TContext
    >;
  },
  queryClient?: QueryClient,
): CreateMutationResult<
  Awaited<ReturnType<typeof runtimeServiceGenerateCanvasFile>>,
  TError,
  { instanceId: string; data: RuntimeServiceGenerateCanvasFileBody },
  TContext
> => {
  const mutationOptions =
    getRuntimeServiceGenerateCanvasFileMutationOptions(options);

  return createMutation(mutationOptions, queryClient);
};
/**
 * @summary GenerateMetricsViewFile generates a metrics view YAML file from a table in an OLAP database
 */
export const runtimeServiceGenerateMetricsViewFile = (
  instanceId: string,
  runtimeServiceGenerateMetricsViewFileBody: RuntimeServiceGenerateMetricsViewFileBody,
  signal?: AbortSignal,
) => {
  return httpClient<V1GenerateMetricsViewFileResponse>({
    url: `/v1/instances/${instanceId}/files/generate-metrics-view`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: runtimeServiceGenerateMetricsViewFileBody,
    signal,
  });
};

export const getRuntimeServiceGenerateMetricsViewFileMutationOptions = <
  TError = ErrorType<RpcStatus>,
  TContext = unknown,
>(options?: {
  mutation?: CreateMutationOptions<
    Awaited<ReturnType<typeof runtimeServiceGenerateMetricsViewFile>>,
    TError,
    { instanceId: string; data: RuntimeServiceGenerateMetricsViewFileBody },
    TContext
  >;
}): CreateMutationOptions<
  Awaited<ReturnType<typeof runtimeServiceGenerateMetricsViewFile>>,
  TError,
  { instanceId: string; data: RuntimeServiceGenerateMetricsViewFileBody },
  TContext
> => {
  const mutationKey = ["runtimeServiceGenerateMetricsViewFile"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof runtimeServiceGenerateMetricsViewFile>>,
    { instanceId: string; data: RuntimeServiceGenerateMetricsViewFileBody }
  > = (props) => {
    const { instanceId, data } = props ?? {};

    return runtimeServiceGenerateMetricsViewFile(instanceId, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type RuntimeServiceGenerateMetricsViewFileMutationResult = NonNullable<
  Awaited<ReturnType<typeof runtimeServiceGenerateMetricsViewFile>>
>;
export type RuntimeServiceGenerateMetricsViewFileMutationBody =
  RuntimeServiceGenerateMetricsViewFileBody;
export type RuntimeServiceGenerateMetricsViewFileMutationError =
  ErrorType<RpcStatus>;

/**
 * @summary GenerateMetricsViewFile generates a metrics view YAML file from a table in an OLAP database
 */
export const createRuntimeServiceGenerateMetricsViewFile = <
  TError = ErrorType<RpcStatus>,
  TContext = unknown,
>(
  options?: {
    mutation?: CreateMutationOptions<
      Awaited<ReturnType<typeof runtimeServiceGenerateMetricsViewFile>>,
      TError,
      { instanceId: string; data: RuntimeServiceGenerateMetricsViewFileBody },
      TContext
    >;
  },
  queryClient?: QueryClient,
): CreateMutationResult<
  Awaited<ReturnType<typeof runtimeServiceGenerateMetricsViewFile>>,
  TError,
  { instanceId: string; data: RuntimeServiceGenerateMetricsViewFileBody },
  TContext
> => {
  const mutationOptions =
    getRuntimeServiceGenerateMetricsViewFileMutationOptions(options);

  return createMutation(mutationOptions, queryClient);
};
/**
 * @summary RenameFile renames a file in a repo
 */
export const runtimeServiceRenameFile = (
  instanceId: string,
  runtimeServiceRenameFileBody: RuntimeServiceRenameFileBody,
  signal?: AbortSignal,
) => {
  return httpClient<V1RenameFileResponse>({
    url: `/v1/instances/${instanceId}/files/rename`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: runtimeServiceRenameFileBody,
    signal,
  });
};

export const getRuntimeServiceRenameFileMutationOptions = <
  TError = ErrorType<RpcStatus>,
  TContext = unknown,
>(options?: {
  mutation?: CreateMutationOptions<
    Awaited<ReturnType<typeof runtimeServiceRenameFile>>,
    TError,
    { instanceId: string; data: RuntimeServiceRenameFileBody },
    TContext
  >;
}): CreateMutationOptions<
  Awaited<ReturnType<typeof runtimeServiceRenameFile>>,
  TError,
  { instanceId: string; data: RuntimeServiceRenameFileBody },
  TContext
> => {
  const mutationKey = ["runtimeServiceRenameFile"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof runtimeServiceRenameFile>>,
    { instanceId: string; data: RuntimeServiceRenameFileBody }
  > = (props) => {
    const { instanceId, data } = props ?? {};

    return runtimeServiceRenameFile(instanceId, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type RuntimeServiceRenameFileMutationResult = NonNullable<
  Awaited<ReturnType<typeof runtimeServiceRenameFile>>
>;
export type RuntimeServiceRenameFileMutationBody = RuntimeServiceRenameFileBody;
export type RuntimeServiceRenameFileMutationError = ErrorType<RpcStatus>;

/**
 * @summary RenameFile renames a file in a repo
 */
export const createRuntimeServiceRenameFile = <
  TError = ErrorType<RpcStatus>,
  TContext = unknown,
>(
  options?: {
    mutation?: CreateMutationOptions<
      Awaited<ReturnType<typeof runtimeServiceRenameFile>>,
      TError,
      { instanceId: string; data: RuntimeServiceRenameFileBody },
      TContext
    >;
  },
  queryClient?: QueryClient,
): CreateMutationResult<
  Awaited<ReturnType<typeof runtimeServiceRenameFile>>,
  TError,
  { instanceId: string; data: RuntimeServiceRenameFileBody },
  TContext
> => {
  const mutationOptions = getRuntimeServiceRenameFileMutationOptions(options);

  return createMutation(mutationOptions, queryClient);
};
/**
 * @summary UnpackEmpty unpacks an empty project
 */
export const runtimeServiceUnpackEmpty = (
  instanceId: string,
  runtimeServiceUnpackEmptyBody: RuntimeServiceUnpackEmptyBody,
  signal?: AbortSignal,
) => {
  return httpClient<V1UnpackEmptyResponse>({
    url: `/v1/instances/${instanceId}/files/unpack-empty`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: runtimeServiceUnpackEmptyBody,
    signal,
  });
};

export const getRuntimeServiceUnpackEmptyMutationOptions = <
  TError = ErrorType<RpcStatus>,
  TContext = unknown,
>(options?: {
  mutation?: CreateMutationOptions<
    Awaited<ReturnType<typeof runtimeServiceUnpackEmpty>>,
    TError,
    { instanceId: string; data: RuntimeServiceUnpackEmptyBody },
    TContext
  >;
}): CreateMutationOptions<
  Awaited<ReturnType<typeof runtimeServiceUnpackEmpty>>,
  TError,
  { instanceId: string; data: RuntimeServiceUnpackEmptyBody },
  TContext
> => {
  const mutationKey = ["runtimeServiceUnpackEmpty"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof runtimeServiceUnpackEmpty>>,
    { instanceId: string; data: RuntimeServiceUnpackEmptyBody }
  > = (props) => {
    const { instanceId, data } = props ?? {};

    return runtimeServiceUnpackEmpty(instanceId, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type RuntimeServiceUnpackEmptyMutationResult = NonNullable<
  Awaited<ReturnType<typeof runtimeServiceUnpackEmpty>>
>;
export type RuntimeServiceUnpackEmptyMutationBody =
  RuntimeServiceUnpackEmptyBody;
export type RuntimeServiceUnpackEmptyMutationError = ErrorType<RpcStatus>;

/**
 * @summary UnpackEmpty unpacks an empty project
 */
export const createRuntimeServiceUnpackEmpty = <
  TError = ErrorType<RpcStatus>,
  TContext = unknown,
>(
  options?: {
    mutation?: CreateMutationOptions<
      Awaited<ReturnType<typeof runtimeServiceUnpackEmpty>>,
      TError,
      { instanceId: string; data: RuntimeServiceUnpackEmptyBody },
      TContext
    >;
  },
  queryClient?: QueryClient,
): CreateMutationResult<
  Awaited<ReturnType<typeof runtimeServiceUnpackEmpty>>,
  TError,
  { instanceId: string; data: RuntimeServiceUnpackEmptyBody },
  TContext
> => {
  const mutationOptions = getRuntimeServiceUnpackEmptyMutationOptions(options);

  return createMutation(mutationOptions, queryClient);
};
/**
 * @summary UnpackExample unpacks an example project
 */
export const runtimeServiceUnpackExample = (
  instanceId: string,
  runtimeServiceUnpackExampleBody: RuntimeServiceUnpackExampleBody,
  signal?: AbortSignal,
) => {
  return httpClient<V1UnpackExampleResponse>({
    url: `/v1/instances/${instanceId}/files/unpack-example`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: runtimeServiceUnpackExampleBody,
    signal,
  });
};

export const getRuntimeServiceUnpackExampleMutationOptions = <
  TError = ErrorType<RpcStatus>,
  TContext = unknown,
>(options?: {
  mutation?: CreateMutationOptions<
    Awaited<ReturnType<typeof runtimeServiceUnpackExample>>,
    TError,
    { instanceId: string; data: RuntimeServiceUnpackExampleBody },
    TContext
  >;
}): CreateMutationOptions<
  Awaited<ReturnType<typeof runtimeServiceUnpackExample>>,
  TError,
  { instanceId: string; data: RuntimeServiceUnpackExampleBody },
  TContext
> => {
  const mutationKey = ["runtimeServiceUnpackExample"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof runtimeServiceUnpackExample>>,
    { instanceId: string; data: RuntimeServiceUnpackExampleBody }
  > = (props) => {
    const { instanceId, data } = props ?? {};

    return runtimeServiceUnpackExample(instanceId, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type RuntimeServiceUnpackExampleMutationResult = NonNullable<
  Awaited<ReturnType<typeof runtimeServiceUnpackExample>>
>;
export type RuntimeServiceUnpackExampleMutationBody =
  RuntimeServiceUnpackExampleBody;
export type RuntimeServiceUnpackExampleMutationError = ErrorType<RpcStatus>;

/**
 * @summary UnpackExample unpacks an example project
 */
export const createRuntimeServiceUnpackExample = <
  TError = ErrorType<RpcStatus>,
  TContext = unknown,
>(
  options?: {
    mutation?: CreateMutationOptions<
      Awaited<ReturnType<typeof runtimeServiceUnpackExample>>,
      TError,
      { instanceId: string; data: RuntimeServiceUnpackExampleBody },
      TContext
    >;
  },
  queryClient?: QueryClient,
): CreateMutationResult<
  Awaited<ReturnType<typeof runtimeServiceUnpackExample>>,
  TError,
  { instanceId: string; data: RuntimeServiceUnpackExampleBody },
  TContext
> => {
  const mutationOptions =
    getRuntimeServiceUnpackExampleMutationOptions(options);

  return createMutation(mutationOptions, queryClient);
};
/**
 * @summary WatchFiles streams repo file update events. It is not supported on all backends.
 */
export const runtimeServiceWatchFiles = (
  instanceId: string,
  params?: RuntimeServiceWatchFilesParams,
  signal?: AbortSignal,
) => {
  return httpClient<RuntimeServiceWatchFiles200>({
    url: `/v1/instances/${instanceId}/files/watch`,
    method: "GET",
    params,
    signal,
  });
};

export const getRuntimeServiceWatchFilesQueryKey = (
  instanceId: string,
  params?: RuntimeServiceWatchFilesParams,
) => {
  return [
    `/v1/instances/${instanceId}/files/watch`,
    ...(params ? [params] : []),
  ] as const;
};

export const getRuntimeServiceWatchFilesQueryOptions = <
  TData = Awaited<ReturnType<typeof runtimeServiceWatchFiles>>,
  TError = ErrorType<RpcStatus>,
>(
  instanceId: string,
  params?: RuntimeServiceWatchFilesParams,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof runtimeServiceWatchFiles>>,
        TError,
        TData
      >
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getRuntimeServiceWatchFilesQueryKey(instanceId, params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof runtimeServiceWatchFiles>>
  > = ({ signal }) => runtimeServiceWatchFiles(instanceId, params, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!instanceId,
    ...queryOptions,
  } as CreateQueryOptions<
    Awaited<ReturnType<typeof runtimeServiceWatchFiles>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type RuntimeServiceWatchFilesQueryResult = NonNullable<
  Awaited<ReturnType<typeof runtimeServiceWatchFiles>>
>;
export type RuntimeServiceWatchFilesQueryError = ErrorType<RpcStatus>;

/**
 * @summary WatchFiles streams repo file update events. It is not supported on all backends.
 */

export function createRuntimeServiceWatchFiles<
  TData = Awaited<ReturnType<typeof runtimeServiceWatchFiles>>,
  TError = ErrorType<RpcStatus>,
>(
  instanceId: string,
  params?: RuntimeServiceWatchFilesParams,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof runtimeServiceWatchFiles>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): CreateQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getRuntimeServiceWatchFilesQueryOptions(
    instanceId,
    params,
    options,
  );

  const query = createQuery(queryOptions, queryClient) as CreateQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary GenerateRenderer generates a component renderer and renderer properties from a resolver and resolver properties
 */
export const runtimeServiceGenerateRenderer = (
  instanceId: string,
  runtimeServiceGenerateRendererBody: RuntimeServiceGenerateRendererBody,
  signal?: AbortSignal,
) => {
  return httpClient<V1GenerateRendererResponse>({
    url: `/v1/instances/${instanceId}/generate/renderer`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: runtimeServiceGenerateRendererBody,
    signal,
  });
};

export const getRuntimeServiceGenerateRendererMutationOptions = <
  TError = ErrorType<RpcStatus>,
  TContext = unknown,
>(options?: {
  mutation?: CreateMutationOptions<
    Awaited<ReturnType<typeof runtimeServiceGenerateRenderer>>,
    TError,
    { instanceId: string; data: RuntimeServiceGenerateRendererBody },
    TContext
  >;
}): CreateMutationOptions<
  Awaited<ReturnType<typeof runtimeServiceGenerateRenderer>>,
  TError,
  { instanceId: string; data: RuntimeServiceGenerateRendererBody },
  TContext
> => {
  const mutationKey = ["runtimeServiceGenerateRenderer"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof runtimeServiceGenerateRenderer>>,
    { instanceId: string; data: RuntimeServiceGenerateRendererBody }
  > = (props) => {
    const { instanceId, data } = props ?? {};

    return runtimeServiceGenerateRenderer(instanceId, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type RuntimeServiceGenerateRendererMutationResult = NonNullable<
  Awaited<ReturnType<typeof runtimeServiceGenerateRenderer>>
>;
export type RuntimeServiceGenerateRendererMutationBody =
  RuntimeServiceGenerateRendererBody;
export type RuntimeServiceGenerateRendererMutationError = ErrorType<RpcStatus>;

/**
 * @summary GenerateRenderer generates a component renderer and renderer properties from a resolver and resolver properties
 */
export const createRuntimeServiceGenerateRenderer = <
  TError = ErrorType<RpcStatus>,
  TContext = unknown,
>(
  options?: {
    mutation?: CreateMutationOptions<
      Awaited<ReturnType<typeof runtimeServiceGenerateRenderer>>,
      TError,
      { instanceId: string; data: RuntimeServiceGenerateRendererBody },
      TContext
    >;
  },
  queryClient?: QueryClient,
): CreateMutationResult<
  Awaited<ReturnType<typeof runtimeServiceGenerateRenderer>>,
  TError,
  { instanceId: string; data: RuntimeServiceGenerateRendererBody },
  TContext
> => {
  const mutationOptions =
    getRuntimeServiceGenerateRendererMutationOptions(options);

  return createMutation(mutationOptions, queryClient);
};
/**
 * @summary GenerateResolver generates resolver and resolver properties from a table or a metrics view
 */
export const runtimeServiceGenerateResolver = (
  instanceId: string,
  runtimeServiceGenerateResolverBody: RuntimeServiceGenerateResolverBody,
  signal?: AbortSignal,
) => {
  return httpClient<V1GenerateResolverResponse>({
    url: `/v1/instances/${instanceId}/generate/resolver`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: runtimeServiceGenerateResolverBody,
    signal,
  });
};

export const getRuntimeServiceGenerateResolverMutationOptions = <
  TError = ErrorType<RpcStatus>,
  TContext = unknown,
>(options?: {
  mutation?: CreateMutationOptions<
    Awaited<ReturnType<typeof runtimeServiceGenerateResolver>>,
    TError,
    { instanceId: string; data: RuntimeServiceGenerateResolverBody },
    TContext
  >;
}): CreateMutationOptions<
  Awaited<ReturnType<typeof runtimeServiceGenerateResolver>>,
  TError,
  { instanceId: string; data: RuntimeServiceGenerateResolverBody },
  TContext
> => {
  const mutationKey = ["runtimeServiceGenerateResolver"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof runtimeServiceGenerateResolver>>,
    { instanceId: string; data: RuntimeServiceGenerateResolverBody }
  > = (props) => {
    const { instanceId, data } = props ?? {};

    return runtimeServiceGenerateResolver(instanceId, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type RuntimeServiceGenerateResolverMutationResult = NonNullable<
  Awaited<ReturnType<typeof runtimeServiceGenerateResolver>>
>;
export type RuntimeServiceGenerateResolverMutationBody =
  RuntimeServiceGenerateResolverBody;
export type RuntimeServiceGenerateResolverMutationError = ErrorType<RpcStatus>;

/**
 * @summary GenerateResolver generates resolver and resolver properties from a table or a metrics view
 */
export const createRuntimeServiceGenerateResolver = <
  TError = ErrorType<RpcStatus>,
  TContext = unknown,
>(
  options?: {
    mutation?: CreateMutationOptions<
      Awaited<ReturnType<typeof runtimeServiceGenerateResolver>>,
      TError,
      { instanceId: string; data: RuntimeServiceGenerateResolverBody },
      TContext
    >;
  },
  queryClient?: QueryClient,
): CreateMutationResult<
  Awaited<ReturnType<typeof runtimeServiceGenerateResolver>>,
  TError,
  { instanceId: string; data: RuntimeServiceGenerateResolverBody },
  TContext
> => {
  const mutationOptions =
    getRuntimeServiceGenerateResolverMutationOptions(options);

  return createMutation(mutationOptions, queryClient);
};
/**
 * @summary GetLogs returns recent logs from a controller
 */
export const runtimeServiceGetLogs = (
  instanceId: string,
  params?: RuntimeServiceGetLogsParams,
  signal?: AbortSignal,
) => {
  return httpClient<V1GetLogsResponse>({
    url: `/v1/instances/${instanceId}/logs`,
    method: "GET",
    params,
    signal,
  });
};

export const getRuntimeServiceGetLogsQueryKey = (
  instanceId: string,
  params?: RuntimeServiceGetLogsParams,
) => {
  return [
    `/v1/instances/${instanceId}/logs`,
    ...(params ? [params] : []),
  ] as const;
};

export const getRuntimeServiceGetLogsQueryOptions = <
  TData = Awaited<ReturnType<typeof runtimeServiceGetLogs>>,
  TError = ErrorType<RpcStatus>,
>(
  instanceId: string,
  params?: RuntimeServiceGetLogsParams,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof runtimeServiceGetLogs>>,
        TError,
        TData
      >
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getRuntimeServiceGetLogsQueryKey(instanceId, params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof runtimeServiceGetLogs>>
  > = ({ signal }) => runtimeServiceGetLogs(instanceId, params, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!instanceId,
    ...queryOptions,
  } as CreateQueryOptions<
    Awaited<ReturnType<typeof runtimeServiceGetLogs>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type RuntimeServiceGetLogsQueryResult = NonNullable<
  Awaited<ReturnType<typeof runtimeServiceGetLogs>>
>;
export type RuntimeServiceGetLogsQueryError = ErrorType<RpcStatus>;

/**
 * @summary GetLogs returns recent logs from a controller
 */

export function createRuntimeServiceGetLogs<
  TData = Awaited<ReturnType<typeof runtimeServiceGetLogs>>,
  TError = ErrorType<RpcStatus>,
>(
  instanceId: string,
  params?: RuntimeServiceGetLogsParams,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof runtimeServiceGetLogs>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): CreateQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getRuntimeServiceGetLogsQueryOptions(
    instanceId,
    params,
    options,
  );

  const query = createQuery(queryOptions, queryClient) as CreateQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary WatchLogs streams new logs emitted from a controller
 */
export const runtimeServiceWatchLogs = (
  instanceId: string,
  params?: RuntimeServiceWatchLogsParams,
  signal?: AbortSignal,
) => {
  return httpClient<RuntimeServiceWatchLogs200>({
    url: `/v1/instances/${instanceId}/logs/watch`,
    method: "GET",
    params,
    signal,
  });
};

export const getRuntimeServiceWatchLogsQueryKey = (
  instanceId: string,
  params?: RuntimeServiceWatchLogsParams,
) => {
  return [
    `/v1/instances/${instanceId}/logs/watch`,
    ...(params ? [params] : []),
  ] as const;
};

export const getRuntimeServiceWatchLogsQueryOptions = <
  TData = Awaited<ReturnType<typeof runtimeServiceWatchLogs>>,
  TError = ErrorType<RpcStatus>,
>(
  instanceId: string,
  params?: RuntimeServiceWatchLogsParams,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof runtimeServiceWatchLogs>>,
        TError,
        TData
      >
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getRuntimeServiceWatchLogsQueryKey(instanceId, params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof runtimeServiceWatchLogs>>
  > = ({ signal }) => runtimeServiceWatchLogs(instanceId, params, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!instanceId,
    ...queryOptions,
  } as CreateQueryOptions<
    Awaited<ReturnType<typeof runtimeServiceWatchLogs>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type RuntimeServiceWatchLogsQueryResult = NonNullable<
  Awaited<ReturnType<typeof runtimeServiceWatchLogs>>
>;
export type RuntimeServiceWatchLogsQueryError = ErrorType<RpcStatus>;

/**
 * @summary WatchLogs streams new logs emitted from a controller
 */

export function createRuntimeServiceWatchLogs<
  TData = Awaited<ReturnType<typeof runtimeServiceWatchLogs>>,
  TError = ErrorType<RpcStatus>,
>(
  instanceId: string,
  params?: RuntimeServiceWatchLogsParams,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof runtimeServiceWatchLogs>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): CreateQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getRuntimeServiceWatchLogsQueryOptions(
    instanceId,
    params,
    options,
  );

  const query = createQuery(queryOptions, queryClient) as CreateQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary GetModelPartitions returns the partitions of a model
 */
export const runtimeServiceGetModelPartitions = (
  instanceId: string,
  model: string,
  params?: RuntimeServiceGetModelPartitionsParams,
  signal?: AbortSignal,
) => {
  return httpClient<V1GetModelPartitionsResponse>({
    url: `/v1/instances/${instanceId}/models/${model}/partitions`,
    method: "GET",
    params,
    signal,
  });
};

export const getRuntimeServiceGetModelPartitionsQueryKey = (
  instanceId: string,
  model: string,
  params?: RuntimeServiceGetModelPartitionsParams,
) => {
  return [
    `/v1/instances/${instanceId}/models/${model}/partitions`,
    ...(params ? [params] : []),
  ] as const;
};

export const getRuntimeServiceGetModelPartitionsInfiniteQueryOptions = <
  TData = InfiniteData<
    Awaited<ReturnType<typeof runtimeServiceGetModelPartitions>>,
    RuntimeServiceGetModelPartitionsParams["pageToken"]
  >,
  TError = ErrorType<RpcStatus>,
>(
  instanceId: string,
  model: string,
  params?: RuntimeServiceGetModelPartitionsParams,
  options?: {
    query?: Partial<
      CreateInfiniteQueryOptions<
        Awaited<ReturnType<typeof runtimeServiceGetModelPartitions>>,
        TError,
        TData,
        Awaited<ReturnType<typeof runtimeServiceGetModelPartitions>>,
        QueryKey,
        RuntimeServiceGetModelPartitionsParams["pageToken"]
      >
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getRuntimeServiceGetModelPartitionsQueryKey(instanceId, model, params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof runtimeServiceGetModelPartitions>>,
    QueryKey,
    RuntimeServiceGetModelPartitionsParams["pageToken"]
  > = ({ signal, pageParam }) =>
    runtimeServiceGetModelPartitions(
      instanceId,
      model,
      { ...params, pageToken: pageParam || params?.["pageToken"] },
      signal,
    );

  return {
    queryKey,
    queryFn,
    enabled: !!(instanceId && model),
    ...queryOptions,
  } as CreateInfiniteQueryOptions<
    Awaited<ReturnType<typeof runtimeServiceGetModelPartitions>>,
    TError,
    TData,
    Awaited<ReturnType<typeof runtimeServiceGetModelPartitions>>,
    QueryKey,
    RuntimeServiceGetModelPartitionsParams["pageToken"]
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type RuntimeServiceGetModelPartitionsInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof runtimeServiceGetModelPartitions>>
>;
export type RuntimeServiceGetModelPartitionsInfiniteQueryError =
  ErrorType<RpcStatus>;

/**
 * @summary GetModelPartitions returns the partitions of a model
 */

export function createRuntimeServiceGetModelPartitionsInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof runtimeServiceGetModelPartitions>>,
    RuntimeServiceGetModelPartitionsParams["pageToken"]
  >,
  TError = ErrorType<RpcStatus>,
>(
  instanceId: string,
  model: string,
  params?: RuntimeServiceGetModelPartitionsParams,
  options?: {
    query?: Partial<
      CreateInfiniteQueryOptions<
        Awaited<ReturnType<typeof runtimeServiceGetModelPartitions>>,
        TError,
        TData,
        Awaited<ReturnType<typeof runtimeServiceGetModelPartitions>>,
        QueryKey,
        RuntimeServiceGetModelPartitionsParams["pageToken"]
      >
    >;
  },
  queryClient?: QueryClient,
): CreateInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getRuntimeServiceGetModelPartitionsInfiniteQueryOptions(
    instanceId,
    model,
    params,
    options,
  );

  const query = createInfiniteQuery(
    queryOptions,
    queryClient,
  ) as CreateInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getRuntimeServiceGetModelPartitionsQueryOptions = <
  TData = Awaited<ReturnType<typeof runtimeServiceGetModelPartitions>>,
  TError = ErrorType<RpcStatus>,
>(
  instanceId: string,
  model: string,
  params?: RuntimeServiceGetModelPartitionsParams,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof runtimeServiceGetModelPartitions>>,
        TError,
        TData
      >
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getRuntimeServiceGetModelPartitionsQueryKey(instanceId, model, params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof runtimeServiceGetModelPartitions>>
  > = ({ signal }) =>
    runtimeServiceGetModelPartitions(instanceId, model, params, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!(instanceId && model),
    ...queryOptions,
  } as CreateQueryOptions<
    Awaited<ReturnType<typeof runtimeServiceGetModelPartitions>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type RuntimeServiceGetModelPartitionsQueryResult = NonNullable<
  Awaited<ReturnType<typeof runtimeServiceGetModelPartitions>>
>;
export type RuntimeServiceGetModelPartitionsQueryError = ErrorType<RpcStatus>;

/**
 * @summary GetModelPartitions returns the partitions of a model
 */

export function createRuntimeServiceGetModelPartitions<
  TData = Awaited<ReturnType<typeof runtimeServiceGetModelPartitions>>,
  TError = ErrorType<RpcStatus>,
>(
  instanceId: string,
  model: string,
  params?: RuntimeServiceGetModelPartitionsParams,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof runtimeServiceGetModelPartitions>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): CreateQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getRuntimeServiceGetModelPartitionsQueryOptions(
    instanceId,
    model,
    params,
    options,
  );

  const query = createQuery(queryOptions, queryClient) as CreateQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary ResolveCanvas is a convenience API that returns a canvas and all its referenced components and metrics views.
 */
export const queryServiceResolveCanvas = (
  instanceId: string,
  canvas: string,
  queryServiceResolveCanvasBody: QueryServiceResolveCanvasBody,
  signal?: AbortSignal,
) => {
  return httpClient<V1ResolveCanvasResponse>({
    url: `/v1/instances/${instanceId}/queries/canvases/${canvas}/resolve`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: queryServiceResolveCanvasBody,
    signal,
  });
};

export const getQueryServiceResolveCanvasQueryKey = (
  instanceId: string,
  canvas: string,
  queryServiceResolveCanvasBody: QueryServiceResolveCanvasBody,
) => {
  return [
    `/v1/instances/${instanceId}/queries/canvases/${canvas}/resolve`,
    queryServiceResolveCanvasBody,
  ] as const;
};

export const getQueryServiceResolveCanvasQueryOptions = <
  TData = Awaited<ReturnType<typeof queryServiceResolveCanvas>>,
  TError = ErrorType<RpcStatus>,
>(
  instanceId: string,
  canvas: string,
  queryServiceResolveCanvasBody: QueryServiceResolveCanvasBody,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof queryServiceResolveCanvas>>,
        TError,
        TData
      >
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getQueryServiceResolveCanvasQueryKey(
      instanceId,
      canvas,
      queryServiceResolveCanvasBody,
    );

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof queryServiceResolveCanvas>>
  > = ({ signal }) =>
    queryServiceResolveCanvas(
      instanceId,
      canvas,
      queryServiceResolveCanvasBody,
      signal,
    );

  return {
    queryKey,
    queryFn,
    enabled: !!(instanceId && canvas),
    ...queryOptions,
  } as CreateQueryOptions<
    Awaited<ReturnType<typeof queryServiceResolveCanvas>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type QueryServiceResolveCanvasQueryResult = NonNullable<
  Awaited<ReturnType<typeof queryServiceResolveCanvas>>
>;
export type QueryServiceResolveCanvasQueryError = ErrorType<RpcStatus>;

/**
 * @summary ResolveCanvas is a convenience API that returns a canvas and all its referenced components and metrics views.
 */

export function createQueryServiceResolveCanvas<
  TData = Awaited<ReturnType<typeof queryServiceResolveCanvas>>,
  TError = ErrorType<RpcStatus>,
>(
  instanceId: string,
  canvas: string,
  queryServiceResolveCanvasBody: QueryServiceResolveCanvasBody,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof queryServiceResolveCanvas>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): CreateQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getQueryServiceResolveCanvasQueryOptions(
    instanceId,
    canvas,
    queryServiceResolveCanvasBody,
    options,
  );

  const query = createQuery(queryOptions, queryClient) as CreateQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Get cardinality for a column
 */
export const queryServiceColumnCardinality = (
  instanceId: string,
  tableName: string,
  params?: QueryServiceColumnCardinalityParams,
  signal?: AbortSignal,
) => {
  return httpClient<V1ColumnCardinalityResponse>({
    url: `/v1/instances/${instanceId}/queries/column-cardinality/tables/${tableName}`,
    method: "GET",
    params,
    signal,
  });
};

export const getQueryServiceColumnCardinalityQueryKey = (
  instanceId: string,
  tableName: string,
  params?: QueryServiceColumnCardinalityParams,
) => {
  return [
    `/v1/instances/${instanceId}/queries/column-cardinality/tables/${tableName}`,
    ...(params ? [params] : []),
  ] as const;
};

export const getQueryServiceColumnCardinalityQueryOptions = <
  TData = Awaited<ReturnType<typeof queryServiceColumnCardinality>>,
  TError = ErrorType<RpcStatus>,
>(
  instanceId: string,
  tableName: string,
  params?: QueryServiceColumnCardinalityParams,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof queryServiceColumnCardinality>>,
        TError,
        TData
      >
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getQueryServiceColumnCardinalityQueryKey(instanceId, tableName, params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof queryServiceColumnCardinality>>
  > = ({ signal }) =>
    queryServiceColumnCardinality(instanceId, tableName, params, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!(instanceId && tableName),
    ...queryOptions,
  } as CreateQueryOptions<
    Awaited<ReturnType<typeof queryServiceColumnCardinality>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type QueryServiceColumnCardinalityQueryResult = NonNullable<
  Awaited<ReturnType<typeof queryServiceColumnCardinality>>
>;
export type QueryServiceColumnCardinalityQueryError = ErrorType<RpcStatus>;

/**
 * @summary Get cardinality for a column
 */

export function createQueryServiceColumnCardinality<
  TData = Awaited<ReturnType<typeof queryServiceColumnCardinality>>,
  TError = ErrorType<RpcStatus>,
>(
  instanceId: string,
  tableName: string,
  params?: QueryServiceColumnCardinalityParams,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof queryServiceColumnCardinality>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): CreateQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getQueryServiceColumnCardinalityQueryOptions(
    instanceId,
    tableName,
    params,
    options,
  );

  const query = createQuery(queryOptions, queryClient) as CreateQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary TableColumns returns column profiles
 */
export const queryServiceTableColumns = (
  instanceId: string,
  tableName: string,
  params?: QueryServiceTableColumnsParams,
  signal?: AbortSignal,
) => {
  return httpClient<V1TableColumnsResponse>({
    url: `/v1/instances/${instanceId}/queries/columns-profile/tables/${tableName}`,
    method: "POST",
    params,
    signal,
  });
};

export const getQueryServiceTableColumnsQueryKey = (
  instanceId: string,
  tableName: string,
  params?: QueryServiceTableColumnsParams,
) => {
  return [
    `/v1/instances/${instanceId}/queries/columns-profile/tables/${tableName}`,
    ...(params ? [params] : []),
  ] as const;
};

export const getQueryServiceTableColumnsQueryOptions = <
  TData = Awaited<ReturnType<typeof queryServiceTableColumns>>,
  TError = ErrorType<RpcStatus>,
>(
  instanceId: string,
  tableName: string,
  params?: QueryServiceTableColumnsParams,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof queryServiceTableColumns>>,
        TError,
        TData
      >
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getQueryServiceTableColumnsQueryKey(instanceId, tableName, params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof queryServiceTableColumns>>
  > = ({ signal }) =>
    queryServiceTableColumns(instanceId, tableName, params, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!(instanceId && tableName),
    ...queryOptions,
  } as CreateQueryOptions<
    Awaited<ReturnType<typeof queryServiceTableColumns>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type QueryServiceTableColumnsQueryResult = NonNullable<
  Awaited<ReturnType<typeof queryServiceTableColumns>>
>;
export type QueryServiceTableColumnsQueryError = ErrorType<RpcStatus>;

/**
 * @summary TableColumns returns column profiles
 */

export function createQueryServiceTableColumns<
  TData = Awaited<ReturnType<typeof queryServiceTableColumns>>,
  TError = ErrorType<RpcStatus>,
>(
  instanceId: string,
  tableName: string,
  params?: QueryServiceTableColumnsParams,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof queryServiceTableColumns>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): CreateQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getQueryServiceTableColumnsQueryOptions(
    instanceId,
    tableName,
    params,
    options,
  );

  const query = createQuery(queryOptions, queryClient) as CreateQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary ResolveComponent resolves renderer for a Component resource.
 */
export const queryServiceResolveComponent = (
  instanceId: string,
  component: string,
  queryServiceResolveComponentBody: QueryServiceResolveComponentBody,
  signal?: AbortSignal,
) => {
  return httpClient<V1ResolveComponentResponse>({
    url: `/v1/instances/${instanceId}/queries/components/${component}/resolve`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: queryServiceResolveComponentBody,
    signal,
  });
};

export const getQueryServiceResolveComponentQueryKey = (
  instanceId: string,
  component: string,
  queryServiceResolveComponentBody: QueryServiceResolveComponentBody,
) => {
  return [
    `/v1/instances/${instanceId}/queries/components/${component}/resolve`,
    queryServiceResolveComponentBody,
  ] as const;
};

export const getQueryServiceResolveComponentQueryOptions = <
  TData = Awaited<ReturnType<typeof queryServiceResolveComponent>>,
  TError = ErrorType<RpcStatus>,
>(
  instanceId: string,
  component: string,
  queryServiceResolveComponentBody: QueryServiceResolveComponentBody,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof queryServiceResolveComponent>>,
        TError,
        TData
      >
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getQueryServiceResolveComponentQueryKey(
      instanceId,
      component,
      queryServiceResolveComponentBody,
    );

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof queryServiceResolveComponent>>
  > = ({ signal }) =>
    queryServiceResolveComponent(
      instanceId,
      component,
      queryServiceResolveComponentBody,
      signal,
    );

  return {
    queryKey,
    queryFn,
    enabled: !!(instanceId && component),
    ...queryOptions,
  } as CreateQueryOptions<
    Awaited<ReturnType<typeof queryServiceResolveComponent>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type QueryServiceResolveComponentQueryResult = NonNullable<
  Awaited<ReturnType<typeof queryServiceResolveComponent>>
>;
export type QueryServiceResolveComponentQueryError = ErrorType<RpcStatus>;

/**
 * @summary ResolveComponent resolves renderer for a Component resource.
 */

export function createQueryServiceResolveComponent<
  TData = Awaited<ReturnType<typeof queryServiceResolveComponent>>,
  TError = ErrorType<RpcStatus>,
>(
  instanceId: string,
  component: string,
  queryServiceResolveComponentBody: QueryServiceResolveComponentBody,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof queryServiceResolveComponent>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): CreateQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getQueryServiceResolveComponentQueryOptions(
    instanceId,
    component,
    queryServiceResolveComponentBody,
    options,
  );

  const query = createQuery(queryOptions, queryClient) as CreateQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Get basic stats for a numeric column like min, max, mean, stddev, etc
 */
export const queryServiceColumnDescriptiveStatistics = (
  instanceId: string,
  tableName: string,
  params?: QueryServiceColumnDescriptiveStatisticsParams,
  signal?: AbortSignal,
) => {
  return httpClient<V1ColumnDescriptiveStatisticsResponse>({
    url: `/v1/instances/${instanceId}/queries/descriptive-statistics/tables/${tableName}`,
    method: "GET",
    params,
    signal,
  });
};

export const getQueryServiceColumnDescriptiveStatisticsQueryKey = (
  instanceId: string,
  tableName: string,
  params?: QueryServiceColumnDescriptiveStatisticsParams,
) => {
  return [
    `/v1/instances/${instanceId}/queries/descriptive-statistics/tables/${tableName}`,
    ...(params ? [params] : []),
  ] as const;
};

export const getQueryServiceColumnDescriptiveStatisticsQueryOptions = <
  TData = Awaited<ReturnType<typeof queryServiceColumnDescriptiveStatistics>>,
  TError = ErrorType<RpcStatus>,
>(
  instanceId: string,
  tableName: string,
  params?: QueryServiceColumnDescriptiveStatisticsParams,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof queryServiceColumnDescriptiveStatistics>>,
        TError,
        TData
      >
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getQueryServiceColumnDescriptiveStatisticsQueryKey(
      instanceId,
      tableName,
      params,
    );

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof queryServiceColumnDescriptiveStatistics>>
  > = ({ signal }) =>
    queryServiceColumnDescriptiveStatistics(
      instanceId,
      tableName,
      params,
      signal,
    );

  return {
    queryKey,
    queryFn,
    enabled: !!(instanceId && tableName),
    ...queryOptions,
  } as CreateQueryOptions<
    Awaited<ReturnType<typeof queryServiceColumnDescriptiveStatistics>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type QueryServiceColumnDescriptiveStatisticsQueryResult = NonNullable<
  Awaited<ReturnType<typeof queryServiceColumnDescriptiveStatistics>>
>;
export type QueryServiceColumnDescriptiveStatisticsQueryError =
  ErrorType<RpcStatus>;

/**
 * @summary Get basic stats for a numeric column like min, max, mean, stddev, etc
 */

export function createQueryServiceColumnDescriptiveStatistics<
  TData = Awaited<ReturnType<typeof queryServiceColumnDescriptiveStatistics>>,
  TError = ErrorType<RpcStatus>,
>(
  instanceId: string,
  tableName: string,
  params?: QueryServiceColumnDescriptiveStatisticsParams,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof queryServiceColumnDescriptiveStatistics>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): CreateQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getQueryServiceColumnDescriptiveStatisticsQueryOptions(
    instanceId,
    tableName,
    params,
    options,
  );

  const query = createQuery(queryOptions, queryClient) as CreateQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Export builds a URL to download the results of a query as a file.
 */
export const queryServiceExport = (
  instanceId: string,
  queryServiceExportBody: QueryServiceExportBody,
  signal?: AbortSignal,
) => {
  return httpClient<V1ExportResponse>({
    url: `/v1/instances/${instanceId}/queries/export`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: queryServiceExportBody,
    signal,
  });
};

export const getQueryServiceExportMutationOptions = <
  TError = ErrorType<RpcStatus>,
  TContext = unknown,
>(options?: {
  mutation?: CreateMutationOptions<
    Awaited<ReturnType<typeof queryServiceExport>>,
    TError,
    { instanceId: string; data: QueryServiceExportBody },
    TContext
  >;
}): CreateMutationOptions<
  Awaited<ReturnType<typeof queryServiceExport>>,
  TError,
  { instanceId: string; data: QueryServiceExportBody },
  TContext
> => {
  const mutationKey = ["queryServiceExport"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof queryServiceExport>>,
    { instanceId: string; data: QueryServiceExportBody }
  > = (props) => {
    const { instanceId, data } = props ?? {};

    return queryServiceExport(instanceId, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type QueryServiceExportMutationResult = NonNullable<
  Awaited<ReturnType<typeof queryServiceExport>>
>;
export type QueryServiceExportMutationBody = QueryServiceExportBody;
export type QueryServiceExportMutationError = ErrorType<RpcStatus>;

/**
 * @summary Export builds a URL to download the results of a query as a file.
 */
export const createQueryServiceExport = <
  TError = ErrorType<RpcStatus>,
  TContext = unknown,
>(
  options?: {
    mutation?: CreateMutationOptions<
      Awaited<ReturnType<typeof queryServiceExport>>,
      TError,
      { instanceId: string; data: QueryServiceExportBody },
      TContext
    >;
  },
  queryClient?: QueryClient,
): CreateMutationResult<
  Awaited<ReturnType<typeof queryServiceExport>>,
  TError,
  { instanceId: string; data: QueryServiceExportBody },
  TContext
> => {
  const mutationOptions = getQueryServiceExportMutationOptions(options);

  return createMutation(mutationOptions, queryClient);
};
/**
 * @summary MetricsViewAggregation is a generic API for running group-by/pivot queries against a metrics view.
 */
export const queryServiceMetricsViewAggregation = (
  instanceId: string,
  metricsView: string,
  queryServiceMetricsViewAggregationBody: QueryServiceMetricsViewAggregationBody,
  signal?: AbortSignal,
) => {
  return httpClient<V1MetricsViewAggregationResponse>({
    url: `/v1/instances/${instanceId}/queries/metrics-views/${metricsView}/aggregation`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: queryServiceMetricsViewAggregationBody,
    signal,
  });
};

export const getQueryServiceMetricsViewAggregationQueryKey = (
  instanceId: string,
  metricsView: string,
  queryServiceMetricsViewAggregationBody: QueryServiceMetricsViewAggregationBody,
) => {
  return [
    `/v1/instances/${instanceId}/queries/metrics-views/${metricsView}/aggregation`,
    queryServiceMetricsViewAggregationBody,
  ] as const;
};

export const getQueryServiceMetricsViewAggregationQueryOptions = <
  TData = Awaited<ReturnType<typeof queryServiceMetricsViewAggregation>>,
  TError = ErrorType<RpcStatus>,
>(
  instanceId: string,
  metricsView: string,
  queryServiceMetricsViewAggregationBody: QueryServiceMetricsViewAggregationBody,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof queryServiceMetricsViewAggregation>>,
        TError,
        TData
      >
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getQueryServiceMetricsViewAggregationQueryKey(
      instanceId,
      metricsView,
      queryServiceMetricsViewAggregationBody,
    );

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof queryServiceMetricsViewAggregation>>
  > = ({ signal }) =>
    queryServiceMetricsViewAggregation(
      instanceId,
      metricsView,
      queryServiceMetricsViewAggregationBody,
      signal,
    );

  return {
    queryKey,
    queryFn,
    enabled: !!(instanceId && metricsView),
    ...queryOptions,
  } as CreateQueryOptions<
    Awaited<ReturnType<typeof queryServiceMetricsViewAggregation>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type QueryServiceMetricsViewAggregationQueryResult = NonNullable<
  Awaited<ReturnType<typeof queryServiceMetricsViewAggregation>>
>;
export type QueryServiceMetricsViewAggregationQueryError = ErrorType<RpcStatus>;

/**
 * @summary MetricsViewAggregation is a generic API for running group-by/pivot queries against a metrics view.
 */

export function createQueryServiceMetricsViewAggregation<
  TData = Awaited<ReturnType<typeof queryServiceMetricsViewAggregation>>,
  TError = ErrorType<RpcStatus>,
>(
  instanceId: string,
  metricsView: string,
  queryServiceMetricsViewAggregationBody: QueryServiceMetricsViewAggregationBody,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof queryServiceMetricsViewAggregation>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): CreateQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getQueryServiceMetricsViewAggregationQueryOptions(
    instanceId,
    metricsView,
    queryServiceMetricsViewAggregationBody,
    options,
  );

  const query = createQuery(queryOptions, queryClient) as CreateQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const queryServiceMetricsViewAnnotations = (
  instanceId: string,
  metricsViewName: string,
  queryServiceMetricsViewAnnotationsBody: QueryServiceMetricsViewAnnotationsBody,
  signal?: AbortSignal,
) => {
  return httpClient<V1MetricsViewAnnotationsResponse>({
    url: `/v1/instances/${instanceId}/queries/metrics-views/${metricsViewName}/annotations`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: queryServiceMetricsViewAnnotationsBody,
    signal,
  });
};

export const getQueryServiceMetricsViewAnnotationsQueryKey = (
  instanceId: string,
  metricsViewName: string,
  queryServiceMetricsViewAnnotationsBody: QueryServiceMetricsViewAnnotationsBody,
) => {
  return [
    `/v1/instances/${instanceId}/queries/metrics-views/${metricsViewName}/annotations`,
    queryServiceMetricsViewAnnotationsBody,
  ] as const;
};

export const getQueryServiceMetricsViewAnnotationsQueryOptions = <
  TData = Awaited<ReturnType<typeof queryServiceMetricsViewAnnotations>>,
  TError = ErrorType<RpcStatus>,
>(
  instanceId: string,
  metricsViewName: string,
  queryServiceMetricsViewAnnotationsBody: QueryServiceMetricsViewAnnotationsBody,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof queryServiceMetricsViewAnnotations>>,
        TError,
        TData
      >
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getQueryServiceMetricsViewAnnotationsQueryKey(
      instanceId,
      metricsViewName,
      queryServiceMetricsViewAnnotationsBody,
    );

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof queryServiceMetricsViewAnnotations>>
  > = ({ signal }) =>
    queryServiceMetricsViewAnnotations(
      instanceId,
      metricsViewName,
      queryServiceMetricsViewAnnotationsBody,
      signal,
    );

  return {
    queryKey,
    queryFn,
    enabled: !!(instanceId && metricsViewName),
    ...queryOptions,
  } as CreateQueryOptions<
    Awaited<ReturnType<typeof queryServiceMetricsViewAnnotations>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type QueryServiceMetricsViewAnnotationsQueryResult = NonNullable<
  Awaited<ReturnType<typeof queryServiceMetricsViewAnnotations>>
>;
export type QueryServiceMetricsViewAnnotationsQueryError = ErrorType<RpcStatus>;

export function createQueryServiceMetricsViewAnnotations<
  TData = Awaited<ReturnType<typeof queryServiceMetricsViewAnnotations>>,
  TError = ErrorType<RpcStatus>,
>(
  instanceId: string,
  metricsViewName: string,
  queryServiceMetricsViewAnnotationsBody: QueryServiceMetricsViewAnnotationsBody,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof queryServiceMetricsViewAnnotations>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): CreateQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getQueryServiceMetricsViewAnnotationsQueryOptions(
    instanceId,
    metricsViewName,
    queryServiceMetricsViewAnnotationsBody,
    options,
  );

  const query = createQuery(queryOptions, queryClient) as CreateQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * ie. comparsion toplist:
| measure1_base | measure1_previous   | measure1__delta_abs | measure1__delta_rel | dimension |
|---------------|---------------------|---------------------|--------------------|-----------|
| 2             | 2                   | 0                   | 0                  | Safari    |
| 1             | 0                   | 1                   | N/A                | Chrome    |
| 0             | 4                   | -4                  | -1.0               | Firefox   |

ie. toplist:
| measure1 | measure2 | dimension |
|----------|----------|-----------|
| 2        | 45       | Safari    |
| 1        | 350      | Chrome    |
| 0        | 25       | Firefox   |
 * @summary MetricsViewComparison returns a toplist containing comparison data of another toplist (same dimension/measure but a different time range).
Returns a toplist without comparison data if comparison time range is omitted.
 */
export const queryServiceMetricsViewComparison = (
  instanceId: string,
  metricsViewName: string,
  queryServiceMetricsViewComparisonBody: QueryServiceMetricsViewComparisonBody,
  signal?: AbortSignal,
) => {
  return httpClient<V1MetricsViewComparisonResponse>({
    url: `/v1/instances/${instanceId}/queries/metrics-views/${metricsViewName}/compare-toplist`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: queryServiceMetricsViewComparisonBody,
    signal,
  });
};

export const getQueryServiceMetricsViewComparisonQueryKey = (
  instanceId: string,
  metricsViewName: string,
  queryServiceMetricsViewComparisonBody: QueryServiceMetricsViewComparisonBody,
) => {
  return [
    `/v1/instances/${instanceId}/queries/metrics-views/${metricsViewName}/compare-toplist`,
    queryServiceMetricsViewComparisonBody,
  ] as const;
};

export const getQueryServiceMetricsViewComparisonQueryOptions = <
  TData = Awaited<ReturnType<typeof queryServiceMetricsViewComparison>>,
  TError = ErrorType<RpcStatus>,
>(
  instanceId: string,
  metricsViewName: string,
  queryServiceMetricsViewComparisonBody: QueryServiceMetricsViewComparisonBody,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof queryServiceMetricsViewComparison>>,
        TError,
        TData
      >
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getQueryServiceMetricsViewComparisonQueryKey(
      instanceId,
      metricsViewName,
      queryServiceMetricsViewComparisonBody,
    );

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof queryServiceMetricsViewComparison>>
  > = ({ signal }) =>
    queryServiceMetricsViewComparison(
      instanceId,
      metricsViewName,
      queryServiceMetricsViewComparisonBody,
      signal,
    );

  return {
    queryKey,
    queryFn,
    enabled: !!(instanceId && metricsViewName),
    ...queryOptions,
  } as CreateQueryOptions<
    Awaited<ReturnType<typeof queryServiceMetricsViewComparison>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type QueryServiceMetricsViewComparisonQueryResult = NonNullable<
  Awaited<ReturnType<typeof queryServiceMetricsViewComparison>>
>;
export type QueryServiceMetricsViewComparisonQueryError = ErrorType<RpcStatus>;

/**
 * @summary MetricsViewComparison returns a toplist containing comparison data of another toplist (same dimension/measure but a different time range).
Returns a toplist without comparison data if comparison time range is omitted.
 */

export function createQueryServiceMetricsViewComparison<
  TData = Awaited<ReturnType<typeof queryServiceMetricsViewComparison>>,
  TError = ErrorType<RpcStatus>,
>(
  instanceId: string,
  metricsViewName: string,
  queryServiceMetricsViewComparisonBody: QueryServiceMetricsViewComparisonBody,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof queryServiceMetricsViewComparison>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): CreateQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getQueryServiceMetricsViewComparisonQueryOptions(
    instanceId,
    metricsViewName,
    queryServiceMetricsViewComparisonBody,
    options,
  );

  const query = createQuery(queryOptions, queryClient) as CreateQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * ie. without granularity
| column1 | column2 | dimension |
|---------|---------|-----------|
| 2       | 2       | Safari    |
| 1       | 0       | Chrome    |
| 0       | 4       | Firefox   |

ie. with granularity
| timestamp__day0      | column1 | column2 | dimension |
|----------------------|---------|---------|-----------|
| 2022-01-01T00:00:00Z | 2       | 2       | Safari    |
| 2022-01-01T00:00:00Z | 1       | 0       | Chrome    |
| 2022-01-01T00:00:00Z | 0       | 4       | Firefox   |
 * @summary MetricsViewRows returns the underlying model rows matching a metrics view time range and filter(s).
 */
export const queryServiceMetricsViewRows = (
  instanceId: string,
  metricsViewName: string,
  queryServiceMetricsViewRowsBody: QueryServiceMetricsViewRowsBody,
  signal?: AbortSignal,
) => {
  return httpClient<V1MetricsViewRowsResponse>({
    url: `/v1/instances/${instanceId}/queries/metrics-views/${metricsViewName}/rows`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: queryServiceMetricsViewRowsBody,
    signal,
  });
};

export const getQueryServiceMetricsViewRowsQueryKey = (
  instanceId: string,
  metricsViewName: string,
  queryServiceMetricsViewRowsBody: QueryServiceMetricsViewRowsBody,
) => {
  return [
    `/v1/instances/${instanceId}/queries/metrics-views/${metricsViewName}/rows`,
    queryServiceMetricsViewRowsBody,
  ] as const;
};

export const getQueryServiceMetricsViewRowsQueryOptions = <
  TData = Awaited<ReturnType<typeof queryServiceMetricsViewRows>>,
  TError = ErrorType<RpcStatus>,
>(
  instanceId: string,
  metricsViewName: string,
  queryServiceMetricsViewRowsBody: QueryServiceMetricsViewRowsBody,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof queryServiceMetricsViewRows>>,
        TError,
        TData
      >
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getQueryServiceMetricsViewRowsQueryKey(
      instanceId,
      metricsViewName,
      queryServiceMetricsViewRowsBody,
    );

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof queryServiceMetricsViewRows>>
  > = ({ signal }) =>
    queryServiceMetricsViewRows(
      instanceId,
      metricsViewName,
      queryServiceMetricsViewRowsBody,
      signal,
    );

  return {
    queryKey,
    queryFn,
    enabled: !!(instanceId && metricsViewName),
    ...queryOptions,
  } as CreateQueryOptions<
    Awaited<ReturnType<typeof queryServiceMetricsViewRows>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type QueryServiceMetricsViewRowsQueryResult = NonNullable<
  Awaited<ReturnType<typeof queryServiceMetricsViewRows>>
>;
export type QueryServiceMetricsViewRowsQueryError = ErrorType<RpcStatus>;

/**
 * @summary MetricsViewRows returns the underlying model rows matching a metrics view time range and filter(s).
 */

export function createQueryServiceMetricsViewRows<
  TData = Awaited<ReturnType<typeof queryServiceMetricsViewRows>>,
  TError = ErrorType<RpcStatus>,
>(
  instanceId: string,
  metricsViewName: string,
  queryServiceMetricsViewRowsBody: QueryServiceMetricsViewRowsBody,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof queryServiceMetricsViewRows>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): CreateQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getQueryServiceMetricsViewRowsQueryOptions(
    instanceId,
    metricsViewName,
    queryServiceMetricsViewRowsBody,
    options,
  );

  const query = createQuery(queryOptions, queryClient) as CreateQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary MetricsViewSchema Get the data types of measures and dimensions
 */
export const queryServiceMetricsViewSchema = (
  instanceId: string,
  metricsViewName: string,
  params?: QueryServiceMetricsViewSchemaParams,
  signal?: AbortSignal,
) => {
  return httpClient<V1MetricsViewSchemaResponse>({
    url: `/v1/instances/${instanceId}/queries/metrics-views/${metricsViewName}/schema`,
    method: "GET",
    params,
    signal,
  });
};

export const getQueryServiceMetricsViewSchemaQueryKey = (
  instanceId: string,
  metricsViewName: string,
  params?: QueryServiceMetricsViewSchemaParams,
) => {
  return [
    `/v1/instances/${instanceId}/queries/metrics-views/${metricsViewName}/schema`,
    ...(params ? [params] : []),
  ] as const;
};

export const getQueryServiceMetricsViewSchemaQueryOptions = <
  TData = Awaited<ReturnType<typeof queryServiceMetricsViewSchema>>,
  TError = ErrorType<RpcStatus>,
>(
  instanceId: string,
  metricsViewName: string,
  params?: QueryServiceMetricsViewSchemaParams,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof queryServiceMetricsViewSchema>>,
        TError,
        TData
      >
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getQueryServiceMetricsViewSchemaQueryKey(
      instanceId,
      metricsViewName,
      params,
    );

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof queryServiceMetricsViewSchema>>
  > = ({ signal }) =>
    queryServiceMetricsViewSchema(instanceId, metricsViewName, params, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!(instanceId && metricsViewName),
    ...queryOptions,
  } as CreateQueryOptions<
    Awaited<ReturnType<typeof queryServiceMetricsViewSchema>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type QueryServiceMetricsViewSchemaQueryResult = NonNullable<
  Awaited<ReturnType<typeof queryServiceMetricsViewSchema>>
>;
export type QueryServiceMetricsViewSchemaQueryError = ErrorType<RpcStatus>;

/**
 * @summary MetricsViewSchema Get the data types of measures and dimensions
 */

export function createQueryServiceMetricsViewSchema<
  TData = Awaited<ReturnType<typeof queryServiceMetricsViewSchema>>,
  TError = ErrorType<RpcStatus>,
>(
  instanceId: string,
  metricsViewName: string,
  params?: QueryServiceMetricsViewSchemaParams,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof queryServiceMetricsViewSchema>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): CreateQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getQueryServiceMetricsViewSchemaQueryOptions(
    instanceId,
    metricsViewName,
    params,
    options,
  );

  const query = createQuery(queryOptions, queryClient) as CreateQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary MetricsViewSearch Get the data types of measures and dimensions
 */
export const queryServiceMetricsViewSearch = (
  instanceId: string,
  metricsViewName: string,
  queryServiceMetricsViewSearchBody: QueryServiceMetricsViewSearchBody,
  signal?: AbortSignal,
) => {
  return httpClient<V1MetricsViewSearchResponse>({
    url: `/v1/instances/${instanceId}/queries/metrics-views/${metricsViewName}/search`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: queryServiceMetricsViewSearchBody,
    signal,
  });
};

export const getQueryServiceMetricsViewSearchQueryKey = (
  instanceId: string,
  metricsViewName: string,
  queryServiceMetricsViewSearchBody: QueryServiceMetricsViewSearchBody,
) => {
  return [
    `/v1/instances/${instanceId}/queries/metrics-views/${metricsViewName}/search`,
    queryServiceMetricsViewSearchBody,
  ] as const;
};

export const getQueryServiceMetricsViewSearchQueryOptions = <
  TData = Awaited<ReturnType<typeof queryServiceMetricsViewSearch>>,
  TError = ErrorType<RpcStatus>,
>(
  instanceId: string,
  metricsViewName: string,
  queryServiceMetricsViewSearchBody: QueryServiceMetricsViewSearchBody,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof queryServiceMetricsViewSearch>>,
        TError,
        TData
      >
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getQueryServiceMetricsViewSearchQueryKey(
      instanceId,
      metricsViewName,
      queryServiceMetricsViewSearchBody,
    );

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof queryServiceMetricsViewSearch>>
  > = ({ signal }) =>
    queryServiceMetricsViewSearch(
      instanceId,
      metricsViewName,
      queryServiceMetricsViewSearchBody,
      signal,
    );

  return {
    queryKey,
    queryFn,
    enabled: !!(instanceId && metricsViewName),
    ...queryOptions,
  } as CreateQueryOptions<
    Awaited<ReturnType<typeof queryServiceMetricsViewSearch>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type QueryServiceMetricsViewSearchQueryResult = NonNullable<
  Awaited<ReturnType<typeof queryServiceMetricsViewSearch>>
>;
export type QueryServiceMetricsViewSearchQueryError = ErrorType<RpcStatus>;

/**
 * @summary MetricsViewSearch Get the data types of measures and dimensions
 */

export function createQueryServiceMetricsViewSearch<
  TData = Awaited<ReturnType<typeof queryServiceMetricsViewSearch>>,
  TError = ErrorType<RpcStatus>,
>(
  instanceId: string,
  metricsViewName: string,
  queryServiceMetricsViewSearchBody: QueryServiceMetricsViewSearchBody,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof queryServiceMetricsViewSearch>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): CreateQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getQueryServiceMetricsViewSearchQueryOptions(
    instanceId,
    metricsViewName,
    queryServiceMetricsViewSearchBody,
    options,
  );

  const query = createQuery(queryOptions, queryClient) as CreateQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary MetricsViewTimeRange Get the time range summaries (min, max) for time column in a metrics view.
Deprecated: use MetricsViewTimeRanges instead.
 */
export const queryServiceMetricsViewTimeRange = (
  instanceId: string,
  metricsViewName: string,
  queryServiceMetricsViewTimeRangeBody: QueryServiceMetricsViewTimeRangeBody,
  signal?: AbortSignal,
) => {
  return httpClient<V1MetricsViewTimeRangeResponse>({
    url: `/v1/instances/${instanceId}/queries/metrics-views/${metricsViewName}/time-range-summary`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: queryServiceMetricsViewTimeRangeBody,
    signal,
  });
};

export const getQueryServiceMetricsViewTimeRangeQueryKey = (
  instanceId: string,
  metricsViewName: string,
  queryServiceMetricsViewTimeRangeBody: QueryServiceMetricsViewTimeRangeBody,
) => {
  return [
    `/v1/instances/${instanceId}/queries/metrics-views/${metricsViewName}/time-range-summary`,
    queryServiceMetricsViewTimeRangeBody,
  ] as const;
};

export const getQueryServiceMetricsViewTimeRangeQueryOptions = <
  TData = Awaited<ReturnType<typeof queryServiceMetricsViewTimeRange>>,
  TError = ErrorType<RpcStatus>,
>(
  instanceId: string,
  metricsViewName: string,
  queryServiceMetricsViewTimeRangeBody: QueryServiceMetricsViewTimeRangeBody,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof queryServiceMetricsViewTimeRange>>,
        TError,
        TData
      >
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getQueryServiceMetricsViewTimeRangeQueryKey(
      instanceId,
      metricsViewName,
      queryServiceMetricsViewTimeRangeBody,
    );

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof queryServiceMetricsViewTimeRange>>
  > = ({ signal }) =>
    queryServiceMetricsViewTimeRange(
      instanceId,
      metricsViewName,
      queryServiceMetricsViewTimeRangeBody,
      signal,
    );

  return {
    queryKey,
    queryFn,
    enabled: !!(instanceId && metricsViewName),
    ...queryOptions,
  } as CreateQueryOptions<
    Awaited<ReturnType<typeof queryServiceMetricsViewTimeRange>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type QueryServiceMetricsViewTimeRangeQueryResult = NonNullable<
  Awaited<ReturnType<typeof queryServiceMetricsViewTimeRange>>
>;
export type QueryServiceMetricsViewTimeRangeQueryError = ErrorType<RpcStatus>;

/**
 * @summary MetricsViewTimeRange Get the time range summaries (min, max) for time column in a metrics view.
Deprecated: use MetricsViewTimeRanges instead.
 */

export function createQueryServiceMetricsViewTimeRange<
  TData = Awaited<ReturnType<typeof queryServiceMetricsViewTimeRange>>,
  TError = ErrorType<RpcStatus>,
>(
  instanceId: string,
  metricsViewName: string,
  queryServiceMetricsViewTimeRangeBody: QueryServiceMetricsViewTimeRangeBody,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof queryServiceMetricsViewTimeRange>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): CreateQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getQueryServiceMetricsViewTimeRangeQueryOptions(
    instanceId,
    metricsViewName,
    queryServiceMetricsViewTimeRangeBody,
    options,
  );

  const query = createQuery(queryOptions, queryClient) as CreateQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary MetricsViewTimeRanges resolves time ranges for a metrics view.
 */
export const queryServiceMetricsViewTimeRanges = (
  instanceId: string,
  metricsViewName: string,
  queryServiceMetricsViewTimeRangesBody: QueryServiceMetricsViewTimeRangesBody,
  signal?: AbortSignal,
) => {
  return httpClient<V1MetricsViewTimeRangesResponse>({
    url: `/v1/instances/${instanceId}/queries/metrics-views/${metricsViewName}/time-ranges`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: queryServiceMetricsViewTimeRangesBody,
    signal,
  });
};

export const getQueryServiceMetricsViewTimeRangesQueryKey = (
  instanceId: string,
  metricsViewName: string,
  queryServiceMetricsViewTimeRangesBody: QueryServiceMetricsViewTimeRangesBody,
) => {
  return [
    `/v1/instances/${instanceId}/queries/metrics-views/${metricsViewName}/time-ranges`,
    queryServiceMetricsViewTimeRangesBody,
  ] as const;
};

export const getQueryServiceMetricsViewTimeRangesQueryOptions = <
  TData = Awaited<ReturnType<typeof queryServiceMetricsViewTimeRanges>>,
  TError = ErrorType<RpcStatus>,
>(
  instanceId: string,
  metricsViewName: string,
  queryServiceMetricsViewTimeRangesBody: QueryServiceMetricsViewTimeRangesBody,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof queryServiceMetricsViewTimeRanges>>,
        TError,
        TData
      >
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getQueryServiceMetricsViewTimeRangesQueryKey(
      instanceId,
      metricsViewName,
      queryServiceMetricsViewTimeRangesBody,
    );

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof queryServiceMetricsViewTimeRanges>>
  > = ({ signal }) =>
    queryServiceMetricsViewTimeRanges(
      instanceId,
      metricsViewName,
      queryServiceMetricsViewTimeRangesBody,
      signal,
    );

  return {
    queryKey,
    queryFn,
    enabled: !!(instanceId && metricsViewName),
    ...queryOptions,
  } as CreateQueryOptions<
    Awaited<ReturnType<typeof queryServiceMetricsViewTimeRanges>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type QueryServiceMetricsViewTimeRangesQueryResult = NonNullable<
  Awaited<ReturnType<typeof queryServiceMetricsViewTimeRanges>>
>;
export type QueryServiceMetricsViewTimeRangesQueryError = ErrorType<RpcStatus>;

/**
 * @summary MetricsViewTimeRanges resolves time ranges for a metrics view.
 */

export function createQueryServiceMetricsViewTimeRanges<
  TData = Awaited<ReturnType<typeof queryServiceMetricsViewTimeRanges>>,
  TError = ErrorType<RpcStatus>,
>(
  instanceId: string,
  metricsViewName: string,
  queryServiceMetricsViewTimeRangesBody: QueryServiceMetricsViewTimeRangesBody,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof queryServiceMetricsViewTimeRanges>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): CreateQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getQueryServiceMetricsViewTimeRangesQueryOptions(
    instanceId,
    metricsViewName,
    queryServiceMetricsViewTimeRangesBody,
    options,
  );

  const query = createQuery(queryOptions, queryClient) as CreateQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary MetricsViewTimeSeries returns time series for the measures in the metrics view.
It's a convenience API for querying a metrics view.
 */
export const queryServiceMetricsViewTimeSeries = (
  instanceId: string,
  metricsViewName: string,
  queryServiceMetricsViewTimeSeriesBody: QueryServiceMetricsViewTimeSeriesBody,
  signal?: AbortSignal,
) => {
  return httpClient<V1MetricsViewTimeSeriesResponse>({
    url: `/v1/instances/${instanceId}/queries/metrics-views/${metricsViewName}/timeseries`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: queryServiceMetricsViewTimeSeriesBody,
    signal,
  });
};

export const getQueryServiceMetricsViewTimeSeriesQueryKey = (
  instanceId: string,
  metricsViewName: string,
  queryServiceMetricsViewTimeSeriesBody: QueryServiceMetricsViewTimeSeriesBody,
) => {
  return [
    `/v1/instances/${instanceId}/queries/metrics-views/${metricsViewName}/timeseries`,
    queryServiceMetricsViewTimeSeriesBody,
  ] as const;
};

export const getQueryServiceMetricsViewTimeSeriesQueryOptions = <
  TData = Awaited<ReturnType<typeof queryServiceMetricsViewTimeSeries>>,
  TError = ErrorType<RpcStatus>,
>(
  instanceId: string,
  metricsViewName: string,
  queryServiceMetricsViewTimeSeriesBody: QueryServiceMetricsViewTimeSeriesBody,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof queryServiceMetricsViewTimeSeries>>,
        TError,
        TData
      >
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getQueryServiceMetricsViewTimeSeriesQueryKey(
      instanceId,
      metricsViewName,
      queryServiceMetricsViewTimeSeriesBody,
    );

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof queryServiceMetricsViewTimeSeries>>
  > = ({ signal }) =>
    queryServiceMetricsViewTimeSeries(
      instanceId,
      metricsViewName,
      queryServiceMetricsViewTimeSeriesBody,
      signal,
    );

  return {
    queryKey,
    queryFn,
    enabled: !!(instanceId && metricsViewName),
    ...queryOptions,
  } as CreateQueryOptions<
    Awaited<ReturnType<typeof queryServiceMetricsViewTimeSeries>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type QueryServiceMetricsViewTimeSeriesQueryResult = NonNullable<
  Awaited<ReturnType<typeof queryServiceMetricsViewTimeSeries>>
>;
export type QueryServiceMetricsViewTimeSeriesQueryError = ErrorType<RpcStatus>;

/**
 * @summary MetricsViewTimeSeries returns time series for the measures in the metrics view.
It's a convenience API for querying a metrics view.
 */

export function createQueryServiceMetricsViewTimeSeries<
  TData = Awaited<ReturnType<typeof queryServiceMetricsViewTimeSeries>>,
  TError = ErrorType<RpcStatus>,
>(
  instanceId: string,
  metricsViewName: string,
  queryServiceMetricsViewTimeSeriesBody: QueryServiceMetricsViewTimeSeriesBody,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof queryServiceMetricsViewTimeSeries>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): CreateQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getQueryServiceMetricsViewTimeSeriesQueryOptions(
    instanceId,
    metricsViewName,
    queryServiceMetricsViewTimeSeriesBody,
    options,
  );

  const query = createQuery(queryOptions, queryClient) as CreateQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Deprecated - use MetricsViewComparison instead.
MetricsViewToplist returns the top dimension values of a metrics view sorted by one or more measures.
It's a convenience API for querying a metrics view.
 */
export const queryServiceMetricsViewToplist = (
  instanceId: string,
  metricsViewName: string,
  queryServiceMetricsViewToplistBody: QueryServiceMetricsViewToplistBody,
  signal?: AbortSignal,
) => {
  return httpClient<V1MetricsViewToplistResponse>({
    url: `/v1/instances/${instanceId}/queries/metrics-views/${metricsViewName}/toplist`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: queryServiceMetricsViewToplistBody,
    signal,
  });
};

export const getQueryServiceMetricsViewToplistQueryKey = (
  instanceId: string,
  metricsViewName: string,
  queryServiceMetricsViewToplistBody: QueryServiceMetricsViewToplistBody,
) => {
  return [
    `/v1/instances/${instanceId}/queries/metrics-views/${metricsViewName}/toplist`,
    queryServiceMetricsViewToplistBody,
  ] as const;
};

export const getQueryServiceMetricsViewToplistQueryOptions = <
  TData = Awaited<ReturnType<typeof queryServiceMetricsViewToplist>>,
  TError = ErrorType<RpcStatus>,
>(
  instanceId: string,
  metricsViewName: string,
  queryServiceMetricsViewToplistBody: QueryServiceMetricsViewToplistBody,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof queryServiceMetricsViewToplist>>,
        TError,
        TData
      >
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getQueryServiceMetricsViewToplistQueryKey(
      instanceId,
      metricsViewName,
      queryServiceMetricsViewToplistBody,
    );

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof queryServiceMetricsViewToplist>>
  > = ({ signal }) =>
    queryServiceMetricsViewToplist(
      instanceId,
      metricsViewName,
      queryServiceMetricsViewToplistBody,
      signal,
    );

  return {
    queryKey,
    queryFn,
    enabled: !!(instanceId && metricsViewName),
    ...queryOptions,
  } as CreateQueryOptions<
    Awaited<ReturnType<typeof queryServiceMetricsViewToplist>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type QueryServiceMetricsViewToplistQueryResult = NonNullable<
  Awaited<ReturnType<typeof queryServiceMetricsViewToplist>>
>;
export type QueryServiceMetricsViewToplistQueryError = ErrorType<RpcStatus>;

/**
 * @summary Deprecated - use MetricsViewComparison instead.
MetricsViewToplist returns the top dimension values of a metrics view sorted by one or more measures.
It's a convenience API for querying a metrics view.
 */

export function createQueryServiceMetricsViewToplist<
  TData = Awaited<ReturnType<typeof queryServiceMetricsViewToplist>>,
  TError = ErrorType<RpcStatus>,
>(
  instanceId: string,
  metricsViewName: string,
  queryServiceMetricsViewToplistBody: QueryServiceMetricsViewToplistBody,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof queryServiceMetricsViewToplist>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): CreateQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getQueryServiceMetricsViewToplistQueryOptions(
    instanceId,
    metricsViewName,
    queryServiceMetricsViewToplistBody,
    options,
  );

  const query = createQuery(queryOptions, queryClient) as CreateQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary MetricsViewTotals returns totals over a time period for the measures in a metrics view.
It's a convenience API for querying a metrics view.
 */
export const queryServiceMetricsViewTotals = (
  instanceId: string,
  metricsViewName: string,
  queryServiceMetricsViewTotalsBody: QueryServiceMetricsViewTotalsBody,
  signal?: AbortSignal,
) => {
  return httpClient<V1MetricsViewTotalsResponse>({
    url: `/v1/instances/${instanceId}/queries/metrics-views/${metricsViewName}/totals`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: queryServiceMetricsViewTotalsBody,
    signal,
  });
};

export const getQueryServiceMetricsViewTotalsQueryKey = (
  instanceId: string,
  metricsViewName: string,
  queryServiceMetricsViewTotalsBody: QueryServiceMetricsViewTotalsBody,
) => {
  return [
    `/v1/instances/${instanceId}/queries/metrics-views/${metricsViewName}/totals`,
    queryServiceMetricsViewTotalsBody,
  ] as const;
};

export const getQueryServiceMetricsViewTotalsQueryOptions = <
  TData = Awaited<ReturnType<typeof queryServiceMetricsViewTotals>>,
  TError = ErrorType<RpcStatus>,
>(
  instanceId: string,
  metricsViewName: string,
  queryServiceMetricsViewTotalsBody: QueryServiceMetricsViewTotalsBody,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof queryServiceMetricsViewTotals>>,
        TError,
        TData
      >
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getQueryServiceMetricsViewTotalsQueryKey(
      instanceId,
      metricsViewName,
      queryServiceMetricsViewTotalsBody,
    );

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof queryServiceMetricsViewTotals>>
  > = ({ signal }) =>
    queryServiceMetricsViewTotals(
      instanceId,
      metricsViewName,
      queryServiceMetricsViewTotalsBody,
      signal,
    );

  return {
    queryKey,
    queryFn,
    enabled: !!(instanceId && metricsViewName),
    ...queryOptions,
  } as CreateQueryOptions<
    Awaited<ReturnType<typeof queryServiceMetricsViewTotals>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type QueryServiceMetricsViewTotalsQueryResult = NonNullable<
  Awaited<ReturnType<typeof queryServiceMetricsViewTotals>>
>;
export type QueryServiceMetricsViewTotalsQueryError = ErrorType<RpcStatus>;

/**
 * @summary MetricsViewTotals returns totals over a time period for the measures in a metrics view.
It's a convenience API for querying a metrics view.
 */

export function createQueryServiceMetricsViewTotals<
  TData = Awaited<ReturnType<typeof queryServiceMetricsViewTotals>>,
  TError = ErrorType<RpcStatus>,
>(
  instanceId: string,
  metricsViewName: string,
  queryServiceMetricsViewTotalsBody: QueryServiceMetricsViewTotalsBody,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof queryServiceMetricsViewTotals>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): CreateQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getQueryServiceMetricsViewTotalsQueryOptions(
    instanceId,
    metricsViewName,
    queryServiceMetricsViewTotalsBody,
    options,
  );

  const query = createQuery(queryOptions, queryClient) as CreateQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Get the number of nulls in a column
 */
export const queryServiceColumnNullCount = (
  instanceId: string,
  tableName: string,
  params?: QueryServiceColumnNullCountParams,
  signal?: AbortSignal,
) => {
  return httpClient<V1ColumnNullCountResponse>({
    url: `/v1/instances/${instanceId}/queries/null-count/tables/${tableName}`,
    method: "GET",
    params,
    signal,
  });
};

export const getQueryServiceColumnNullCountQueryKey = (
  instanceId: string,
  tableName: string,
  params?: QueryServiceColumnNullCountParams,
) => {
  return [
    `/v1/instances/${instanceId}/queries/null-count/tables/${tableName}`,
    ...(params ? [params] : []),
  ] as const;
};

export const getQueryServiceColumnNullCountQueryOptions = <
  TData = Awaited<ReturnType<typeof queryServiceColumnNullCount>>,
  TError = ErrorType<RpcStatus>,
>(
  instanceId: string,
  tableName: string,
  params?: QueryServiceColumnNullCountParams,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof queryServiceColumnNullCount>>,
        TError,
        TData
      >
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getQueryServiceColumnNullCountQueryKey(instanceId, tableName, params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof queryServiceColumnNullCount>>
  > = ({ signal }) =>
    queryServiceColumnNullCount(instanceId, tableName, params, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!(instanceId && tableName),
    ...queryOptions,
  } as CreateQueryOptions<
    Awaited<ReturnType<typeof queryServiceColumnNullCount>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type QueryServiceColumnNullCountQueryResult = NonNullable<
  Awaited<ReturnType<typeof queryServiceColumnNullCount>>
>;
export type QueryServiceColumnNullCountQueryError = ErrorType<RpcStatus>;

/**
 * @summary Get the number of nulls in a column
 */

export function createQueryServiceColumnNullCount<
  TData = Awaited<ReturnType<typeof queryServiceColumnNullCount>>,
  TError = ErrorType<RpcStatus>,
>(
  instanceId: string,
  tableName: string,
  params?: QueryServiceColumnNullCountParams,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof queryServiceColumnNullCount>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): CreateQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getQueryServiceColumnNullCountQueryOptions(
    instanceId,
    tableName,
    params,
    options,
  );

  const query = createQuery(queryOptions, queryClient) as CreateQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Get the histogram for values in a column
 */
export const queryServiceColumnNumericHistogram = (
  instanceId: string,
  tableName: string,
  params?: QueryServiceColumnNumericHistogramParams,
  signal?: AbortSignal,
) => {
  return httpClient<V1ColumnNumericHistogramResponse>({
    url: `/v1/instances/${instanceId}/queries/numeric-histogram/tables/${tableName}`,
    method: "GET",
    params,
    signal,
  });
};

export const getQueryServiceColumnNumericHistogramQueryKey = (
  instanceId: string,
  tableName: string,
  params?: QueryServiceColumnNumericHistogramParams,
) => {
  return [
    `/v1/instances/${instanceId}/queries/numeric-histogram/tables/${tableName}`,
    ...(params ? [params] : []),
  ] as const;
};

export const getQueryServiceColumnNumericHistogramQueryOptions = <
  TData = Awaited<ReturnType<typeof queryServiceColumnNumericHistogram>>,
  TError = ErrorType<RpcStatus>,
>(
  instanceId: string,
  tableName: string,
  params?: QueryServiceColumnNumericHistogramParams,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof queryServiceColumnNumericHistogram>>,
        TError,
        TData
      >
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getQueryServiceColumnNumericHistogramQueryKey(
      instanceId,
      tableName,
      params,
    );

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof queryServiceColumnNumericHistogram>>
  > = ({ signal }) =>
    queryServiceColumnNumericHistogram(instanceId, tableName, params, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!(instanceId && tableName),
    ...queryOptions,
  } as CreateQueryOptions<
    Awaited<ReturnType<typeof queryServiceColumnNumericHistogram>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type QueryServiceColumnNumericHistogramQueryResult = NonNullable<
  Awaited<ReturnType<typeof queryServiceColumnNumericHistogram>>
>;
export type QueryServiceColumnNumericHistogramQueryError = ErrorType<RpcStatus>;

/**
 * @summary Get the histogram for values in a column
 */

export function createQueryServiceColumnNumericHistogram<
  TData = Awaited<ReturnType<typeof queryServiceColumnNumericHistogram>>,
  TError = ErrorType<RpcStatus>,
>(
  instanceId: string,
  tableName: string,
  params?: QueryServiceColumnNumericHistogramParams,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof queryServiceColumnNumericHistogram>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): CreateQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getQueryServiceColumnNumericHistogramQueryOptions(
    instanceId,
    tableName,
    params,
    options,
  );

  const query = createQuery(queryOptions, queryClient) as CreateQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary ResolveTemplatedString resolves a templated strings.
 */
export const queryServiceResolveTemplatedString = (
  instanceId: string,
  queryServiceResolveTemplatedStringBody: QueryServiceResolveTemplatedStringBody,
  signal?: AbortSignal,
) => {
  return httpClient<V1ResolveTemplatedStringResponse>({
    url: `/v1/instances/${instanceId}/queries/resolve-templated-string`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: queryServiceResolveTemplatedStringBody,
    signal,
  });
};

export const getQueryServiceResolveTemplatedStringMutationOptions = <
  TError = ErrorType<RpcStatus>,
  TContext = unknown,
>(options?: {
  mutation?: CreateMutationOptions<
    Awaited<ReturnType<typeof queryServiceResolveTemplatedString>>,
    TError,
    { instanceId: string; data: QueryServiceResolveTemplatedStringBody },
    TContext
  >;
}): CreateMutationOptions<
  Awaited<ReturnType<typeof queryServiceResolveTemplatedString>>,
  TError,
  { instanceId: string; data: QueryServiceResolveTemplatedStringBody },
  TContext
> => {
  const mutationKey = ["queryServiceResolveTemplatedString"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof queryServiceResolveTemplatedString>>,
    { instanceId: string; data: QueryServiceResolveTemplatedStringBody }
  > = (props) => {
    const { instanceId, data } = props ?? {};

    return queryServiceResolveTemplatedString(instanceId, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type QueryServiceResolveTemplatedStringMutationResult = NonNullable<
  Awaited<ReturnType<typeof queryServiceResolveTemplatedString>>
>;
export type QueryServiceResolveTemplatedStringMutationBody =
  QueryServiceResolveTemplatedStringBody;
export type QueryServiceResolveTemplatedStringMutationError =
  ErrorType<RpcStatus>;

/**
 * @summary ResolveTemplatedString resolves a templated strings.
 */
export const createQueryServiceResolveTemplatedString = <
  TError = ErrorType<RpcStatus>,
  TContext = unknown,
>(
  options?: {
    mutation?: CreateMutationOptions<
      Awaited<ReturnType<typeof queryServiceResolveTemplatedString>>,
      TError,
      { instanceId: string; data: QueryServiceResolveTemplatedStringBody },
      TContext
    >;
  },
  queryClient?: QueryClient,
): CreateMutationResult<
  Awaited<ReturnType<typeof queryServiceResolveTemplatedString>>,
  TError,
  { instanceId: string; data: QueryServiceResolveTemplatedStringBody },
  TContext
> => {
  const mutationOptions =
    getQueryServiceResolveTemplatedStringMutationOptions(options);

  return createMutation(mutationOptions, queryClient);
};
/**
 * @summary ColumnRollupInterval returns the minimum time granularity (as well as the time range) for a specified timestamp column
 */
export const queryServiceColumnRollupInterval = (
  instanceId: string,
  tableName: string,
  queryServiceColumnRollupIntervalBody: QueryServiceColumnRollupIntervalBody,
  signal?: AbortSignal,
) => {
  return httpClient<V1ColumnRollupIntervalResponse>({
    url: `/v1/instances/${instanceId}/queries/rollup-interval/tables/${tableName}`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: queryServiceColumnRollupIntervalBody,
    signal,
  });
};

export const getQueryServiceColumnRollupIntervalQueryKey = (
  instanceId: string,
  tableName: string,
  queryServiceColumnRollupIntervalBody: QueryServiceColumnRollupIntervalBody,
) => {
  return [
    `/v1/instances/${instanceId}/queries/rollup-interval/tables/${tableName}`,
    queryServiceColumnRollupIntervalBody,
  ] as const;
};

export const getQueryServiceColumnRollupIntervalQueryOptions = <
  TData = Awaited<ReturnType<typeof queryServiceColumnRollupInterval>>,
  TError = ErrorType<RpcStatus>,
>(
  instanceId: string,
  tableName: string,
  queryServiceColumnRollupIntervalBody: QueryServiceColumnRollupIntervalBody,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof queryServiceColumnRollupInterval>>,
        TError,
        TData
      >
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getQueryServiceColumnRollupIntervalQueryKey(
      instanceId,
      tableName,
      queryServiceColumnRollupIntervalBody,
    );

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof queryServiceColumnRollupInterval>>
  > = ({ signal }) =>
    queryServiceColumnRollupInterval(
      instanceId,
      tableName,
      queryServiceColumnRollupIntervalBody,
      signal,
    );

  return {
    queryKey,
    queryFn,
    enabled: !!(instanceId && tableName),
    ...queryOptions,
  } as CreateQueryOptions<
    Awaited<ReturnType<typeof queryServiceColumnRollupInterval>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type QueryServiceColumnRollupIntervalQueryResult = NonNullable<
  Awaited<ReturnType<typeof queryServiceColumnRollupInterval>>
>;
export type QueryServiceColumnRollupIntervalQueryError = ErrorType<RpcStatus>;

/**
 * @summary ColumnRollupInterval returns the minimum time granularity (as well as the time range) for a specified timestamp column
 */

export function createQueryServiceColumnRollupInterval<
  TData = Awaited<ReturnType<typeof queryServiceColumnRollupInterval>>,
  TError = ErrorType<RpcStatus>,
>(
  instanceId: string,
  tableName: string,
  queryServiceColumnRollupIntervalBody: QueryServiceColumnRollupIntervalBody,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof queryServiceColumnRollupInterval>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): CreateQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getQueryServiceColumnRollupIntervalQueryOptions(
    instanceId,
    tableName,
    queryServiceColumnRollupIntervalBody,
    options,
  );

  const query = createQuery(queryOptions, queryClient) as CreateQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary TableRows returns table rows
 */
export const queryServiceTableRows = (
  instanceId: string,
  tableName: string,
  params?: QueryServiceTableRowsParams,
  signal?: AbortSignal,
) => {
  return httpClient<V1TableRowsResponse>({
    url: `/v1/instances/${instanceId}/queries/rows/tables/${tableName}`,
    method: "GET",
    params,
    signal,
  });
};

export const getQueryServiceTableRowsQueryKey = (
  instanceId: string,
  tableName: string,
  params?: QueryServiceTableRowsParams,
) => {
  return [
    `/v1/instances/${instanceId}/queries/rows/tables/${tableName}`,
    ...(params ? [params] : []),
  ] as const;
};

export const getQueryServiceTableRowsQueryOptions = <
  TData = Awaited<ReturnType<typeof queryServiceTableRows>>,
  TError = ErrorType<RpcStatus>,
>(
  instanceId: string,
  tableName: string,
  params?: QueryServiceTableRowsParams,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof queryServiceTableRows>>,
        TError,
        TData
      >
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getQueryServiceTableRowsQueryKey(instanceId, tableName, params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof queryServiceTableRows>>
  > = ({ signal }) =>
    queryServiceTableRows(instanceId, tableName, params, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!(instanceId && tableName),
    ...queryOptions,
  } as CreateQueryOptions<
    Awaited<ReturnType<typeof queryServiceTableRows>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type QueryServiceTableRowsQueryResult = NonNullable<
  Awaited<ReturnType<typeof queryServiceTableRows>>
>;
export type QueryServiceTableRowsQueryError = ErrorType<RpcStatus>;

/**
 * @summary TableRows returns table rows
 */

export function createQueryServiceTableRows<
  TData = Awaited<ReturnType<typeof queryServiceTableRows>>,
  TError = ErrorType<RpcStatus>,
>(
  instanceId: string,
  tableName: string,
  params?: QueryServiceTableRowsParams,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof queryServiceTableRows>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): CreateQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getQueryServiceTableRowsQueryOptions(
    instanceId,
    tableName,
    params,
    options,
  );

  const query = createQuery(queryOptions, queryClient) as CreateQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Get outliers for a numeric column
 */
export const queryServiceColumnRugHistogram = (
  instanceId: string,
  tableName: string,
  params?: QueryServiceColumnRugHistogramParams,
  signal?: AbortSignal,
) => {
  return httpClient<V1ColumnRugHistogramResponse>({
    url: `/v1/instances/${instanceId}/queries/rug-histogram/tables/${tableName}`,
    method: "GET",
    params,
    signal,
  });
};

export const getQueryServiceColumnRugHistogramQueryKey = (
  instanceId: string,
  tableName: string,
  params?: QueryServiceColumnRugHistogramParams,
) => {
  return [
    `/v1/instances/${instanceId}/queries/rug-histogram/tables/${tableName}`,
    ...(params ? [params] : []),
  ] as const;
};

export const getQueryServiceColumnRugHistogramQueryOptions = <
  TData = Awaited<ReturnType<typeof queryServiceColumnRugHistogram>>,
  TError = ErrorType<RpcStatus>,
>(
  instanceId: string,
  tableName: string,
  params?: QueryServiceColumnRugHistogramParams,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof queryServiceColumnRugHistogram>>,
        TError,
        TData
      >
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getQueryServiceColumnRugHistogramQueryKey(instanceId, tableName, params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof queryServiceColumnRugHistogram>>
  > = ({ signal }) =>
    queryServiceColumnRugHistogram(instanceId, tableName, params, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!(instanceId && tableName),
    ...queryOptions,
  } as CreateQueryOptions<
    Awaited<ReturnType<typeof queryServiceColumnRugHistogram>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type QueryServiceColumnRugHistogramQueryResult = NonNullable<
  Awaited<ReturnType<typeof queryServiceColumnRugHistogram>>
>;
export type QueryServiceColumnRugHistogramQueryError = ErrorType<RpcStatus>;

/**
 * @summary Get outliers for a numeric column
 */

export function createQueryServiceColumnRugHistogram<
  TData = Awaited<ReturnType<typeof queryServiceColumnRugHistogram>>,
  TError = ErrorType<RpcStatus>,
>(
  instanceId: string,
  tableName: string,
  params?: QueryServiceColumnRugHistogramParams,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof queryServiceColumnRugHistogram>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): CreateQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getQueryServiceColumnRugHistogramQueryOptions(
    instanceId,
    tableName,
    params,
    options,
  );

  const query = createQuery(queryOptions, queryClient) as CreateQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Estimates the smallest time grain present in the column
 */
export const queryServiceColumnTimeGrain = (
  instanceId: string,
  tableName: string,
  params?: QueryServiceColumnTimeGrainParams,
  signal?: AbortSignal,
) => {
  return httpClient<V1ColumnTimeGrainResponse>({
    url: `/v1/instances/${instanceId}/queries/smallest-time-grain/tables/${tableName}`,
    method: "GET",
    params,
    signal,
  });
};

export const getQueryServiceColumnTimeGrainQueryKey = (
  instanceId: string,
  tableName: string,
  params?: QueryServiceColumnTimeGrainParams,
) => {
  return [
    `/v1/instances/${instanceId}/queries/smallest-time-grain/tables/${tableName}`,
    ...(params ? [params] : []),
  ] as const;
};

export const getQueryServiceColumnTimeGrainQueryOptions = <
  TData = Awaited<ReturnType<typeof queryServiceColumnTimeGrain>>,
  TError = ErrorType<RpcStatus>,
>(
  instanceId: string,
  tableName: string,
  params?: QueryServiceColumnTimeGrainParams,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof queryServiceColumnTimeGrain>>,
        TError,
        TData
      >
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getQueryServiceColumnTimeGrainQueryKey(instanceId, tableName, params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof queryServiceColumnTimeGrain>>
  > = ({ signal }) =>
    queryServiceColumnTimeGrain(instanceId, tableName, params, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!(instanceId && tableName),
    ...queryOptions,
  } as CreateQueryOptions<
    Awaited<ReturnType<typeof queryServiceColumnTimeGrain>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type QueryServiceColumnTimeGrainQueryResult = NonNullable<
  Awaited<ReturnType<typeof queryServiceColumnTimeGrain>>
>;
export type QueryServiceColumnTimeGrainQueryError = ErrorType<RpcStatus>;

/**
 * @summary Estimates the smallest time grain present in the column
 */

export function createQueryServiceColumnTimeGrain<
  TData = Awaited<ReturnType<typeof queryServiceColumnTimeGrain>>,
  TError = ErrorType<RpcStatus>,
>(
  instanceId: string,
  tableName: string,
  params?: QueryServiceColumnTimeGrainParams,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof queryServiceColumnTimeGrain>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): CreateQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getQueryServiceColumnTimeGrainQueryOptions(
    instanceId,
    tableName,
    params,
    options,
  );

  const query = createQuery(queryOptions, queryClient) as CreateQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary TableCardinality returns row count
 */
export const queryServiceTableCardinality = (
  instanceId: string,
  tableName: string,
  params?: QueryServiceTableCardinalityParams,
  signal?: AbortSignal,
) => {
  return httpClient<V1TableCardinalityResponse>({
    url: `/v1/instances/${instanceId}/queries/table-cardinality/tables/${tableName}`,
    method: "GET",
    params,
    signal,
  });
};

export const getQueryServiceTableCardinalityQueryKey = (
  instanceId: string,
  tableName: string,
  params?: QueryServiceTableCardinalityParams,
) => {
  return [
    `/v1/instances/${instanceId}/queries/table-cardinality/tables/${tableName}`,
    ...(params ? [params] : []),
  ] as const;
};

export const getQueryServiceTableCardinalityQueryOptions = <
  TData = Awaited<ReturnType<typeof queryServiceTableCardinality>>,
  TError = ErrorType<RpcStatus>,
>(
  instanceId: string,
  tableName: string,
  params?: QueryServiceTableCardinalityParams,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof queryServiceTableCardinality>>,
        TError,
        TData
      >
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getQueryServiceTableCardinalityQueryKey(instanceId, tableName, params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof queryServiceTableCardinality>>
  > = ({ signal }) =>
    queryServiceTableCardinality(instanceId, tableName, params, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!(instanceId && tableName),
    ...queryOptions,
  } as CreateQueryOptions<
    Awaited<ReturnType<typeof queryServiceTableCardinality>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type QueryServiceTableCardinalityQueryResult = NonNullable<
  Awaited<ReturnType<typeof queryServiceTableCardinality>>
>;
export type QueryServiceTableCardinalityQueryError = ErrorType<RpcStatus>;

/**
 * @summary TableCardinality returns row count
 */

export function createQueryServiceTableCardinality<
  TData = Awaited<ReturnType<typeof queryServiceTableCardinality>>,
  TError = ErrorType<RpcStatus>,
>(
  instanceId: string,
  tableName: string,
  params?: QueryServiceTableCardinalityParams,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof queryServiceTableCardinality>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): CreateQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getQueryServiceTableCardinalityQueryOptions(
    instanceId,
    tableName,
    params,
    options,
  );

  const query = createQuery(queryOptions, queryClient) as CreateQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Get the time range summaries (min, max) for a column
 */
export const queryServiceColumnTimeRange = (
  instanceId: string,
  tableName: string,
  params?: QueryServiceColumnTimeRangeParams,
  signal?: AbortSignal,
) => {
  return httpClient<V1ColumnTimeRangeResponse>({
    url: `/v1/instances/${instanceId}/queries/time-range-summary/tables/${tableName}`,
    method: "GET",
    params,
    signal,
  });
};

export const getQueryServiceColumnTimeRangeQueryKey = (
  instanceId: string,
  tableName: string,
  params?: QueryServiceColumnTimeRangeParams,
) => {
  return [
    `/v1/instances/${instanceId}/queries/time-range-summary/tables/${tableName}`,
    ...(params ? [params] : []),
  ] as const;
};

export const getQueryServiceColumnTimeRangeQueryOptions = <
  TData = Awaited<ReturnType<typeof queryServiceColumnTimeRange>>,
  TError = ErrorType<RpcStatus>,
>(
  instanceId: string,
  tableName: string,
  params?: QueryServiceColumnTimeRangeParams,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof queryServiceColumnTimeRange>>,
        TError,
        TData
      >
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getQueryServiceColumnTimeRangeQueryKey(instanceId, tableName, params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof queryServiceColumnTimeRange>>
  > = ({ signal }) =>
    queryServiceColumnTimeRange(instanceId, tableName, params, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!(instanceId && tableName),
    ...queryOptions,
  } as CreateQueryOptions<
    Awaited<ReturnType<typeof queryServiceColumnTimeRange>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type QueryServiceColumnTimeRangeQueryResult = NonNullable<
  Awaited<ReturnType<typeof queryServiceColumnTimeRange>>
>;
export type QueryServiceColumnTimeRangeQueryError = ErrorType<RpcStatus>;

/**
 * @summary Get the time range summaries (min, max) for a column
 */

export function createQueryServiceColumnTimeRange<
  TData = Awaited<ReturnType<typeof queryServiceColumnTimeRange>>,
  TError = ErrorType<RpcStatus>,
>(
  instanceId: string,
  tableName: string,
  params?: QueryServiceColumnTimeRangeParams,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof queryServiceColumnTimeRange>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): CreateQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getQueryServiceColumnTimeRangeQueryOptions(
    instanceId,
    tableName,
    params,
    options,
  );

  const query = createQuery(queryOptions, queryClient) as CreateQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Generate time series for the given measures (aggregation expressions) along with the sparkline timeseries
 */
export const queryServiceColumnTimeSeries = (
  instanceId: string,
  tableName: string,
  queryServiceColumnTimeSeriesBody: QueryServiceColumnTimeSeriesBody,
  signal?: AbortSignal,
) => {
  return httpClient<V1ColumnTimeSeriesResponse>({
    url: `/v1/instances/${instanceId}/queries/timeseries/tables/${tableName}`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: queryServiceColumnTimeSeriesBody,
    signal,
  });
};

export const getQueryServiceColumnTimeSeriesQueryKey = (
  instanceId: string,
  tableName: string,
  queryServiceColumnTimeSeriesBody: QueryServiceColumnTimeSeriesBody,
) => {
  return [
    `/v1/instances/${instanceId}/queries/timeseries/tables/${tableName}`,
    queryServiceColumnTimeSeriesBody,
  ] as const;
};

export const getQueryServiceColumnTimeSeriesQueryOptions = <
  TData = Awaited<ReturnType<typeof queryServiceColumnTimeSeries>>,
  TError = ErrorType<RpcStatus>,
>(
  instanceId: string,
  tableName: string,
  queryServiceColumnTimeSeriesBody: QueryServiceColumnTimeSeriesBody,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof queryServiceColumnTimeSeries>>,
        TError,
        TData
      >
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getQueryServiceColumnTimeSeriesQueryKey(
      instanceId,
      tableName,
      queryServiceColumnTimeSeriesBody,
    );

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof queryServiceColumnTimeSeries>>
  > = ({ signal }) =>
    queryServiceColumnTimeSeries(
      instanceId,
      tableName,
      queryServiceColumnTimeSeriesBody,
      signal,
    );

  return {
    queryKey,
    queryFn,
    enabled: !!(instanceId && tableName),
    ...queryOptions,
  } as CreateQueryOptions<
    Awaited<ReturnType<typeof queryServiceColumnTimeSeries>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type QueryServiceColumnTimeSeriesQueryResult = NonNullable<
  Awaited<ReturnType<typeof queryServiceColumnTimeSeries>>
>;
export type QueryServiceColumnTimeSeriesQueryError = ErrorType<RpcStatus>;

/**
 * @summary Generate time series for the given measures (aggregation expressions) along with the sparkline timeseries
 */

export function createQueryServiceColumnTimeSeries<
  TData = Awaited<ReturnType<typeof queryServiceColumnTimeSeries>>,
  TError = ErrorType<RpcStatus>,
>(
  instanceId: string,
  tableName: string,
  queryServiceColumnTimeSeriesBody: QueryServiceColumnTimeSeriesBody,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof queryServiceColumnTimeSeries>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): CreateQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getQueryServiceColumnTimeSeriesQueryOptions(
    instanceId,
    tableName,
    queryServiceColumnTimeSeriesBody,
    options,
  );

  const query = createQuery(queryOptions, queryClient) as CreateQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Get TopK elements from a table for a column given an agg function
agg function and k are optional, defaults are count(*) and 50 respectively
 */
export const queryServiceColumnTopK = (
  instanceId: string,
  tableName: string,
  queryServiceColumnTopKBody: QueryServiceColumnTopKBody,
  signal?: AbortSignal,
) => {
  return httpClient<V1ColumnTopKResponse>({
    url: `/v1/instances/${instanceId}/queries/topk/tables/${tableName}`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: queryServiceColumnTopKBody,
    signal,
  });
};

export const getQueryServiceColumnTopKQueryKey = (
  instanceId: string,
  tableName: string,
  queryServiceColumnTopKBody: QueryServiceColumnTopKBody,
) => {
  return [
    `/v1/instances/${instanceId}/queries/topk/tables/${tableName}`,
    queryServiceColumnTopKBody,
  ] as const;
};

export const getQueryServiceColumnTopKQueryOptions = <
  TData = Awaited<ReturnType<typeof queryServiceColumnTopK>>,
  TError = ErrorType<RpcStatus>,
>(
  instanceId: string,
  tableName: string,
  queryServiceColumnTopKBody: QueryServiceColumnTopKBody,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof queryServiceColumnTopK>>,
        TError,
        TData
      >
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getQueryServiceColumnTopKQueryKey(
      instanceId,
      tableName,
      queryServiceColumnTopKBody,
    );

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof queryServiceColumnTopK>>
  > = ({ signal }) =>
    queryServiceColumnTopK(
      instanceId,
      tableName,
      queryServiceColumnTopKBody,
      signal,
    );

  return {
    queryKey,
    queryFn,
    enabled: !!(instanceId && tableName),
    ...queryOptions,
  } as CreateQueryOptions<
    Awaited<ReturnType<typeof queryServiceColumnTopK>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type QueryServiceColumnTopKQueryResult = NonNullable<
  Awaited<ReturnType<typeof queryServiceColumnTopK>>
>;
export type QueryServiceColumnTopKQueryError = ErrorType<RpcStatus>;

/**
 * @summary Get TopK elements from a table for a column given an agg function
agg function and k are optional, defaults are count(*) and 50 respectively
 */

export function createQueryServiceColumnTopK<
  TData = Awaited<ReturnType<typeof queryServiceColumnTopK>>,
  TError = ErrorType<RpcStatus>,
>(
  instanceId: string,
  tableName: string,
  queryServiceColumnTopKBody: QueryServiceColumnTopKBody,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof queryServiceColumnTopK>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): CreateQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getQueryServiceColumnTopKQueryOptions(
    instanceId,
    tableName,
    queryServiceColumnTopKBody,
    options,
  );

  const query = createQuery(queryOptions, queryClient) as CreateQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Query runs a SQL query against the instance's OLAP datastore.
 */
export const queryServiceQuery = (
  instanceId: string,
  queryServiceQueryBody: QueryServiceQueryBody,
  signal?: AbortSignal,
) => {
  return httpClient<V1QueryResponse>({
    url: `/v1/instances/${instanceId}/query`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: queryServiceQueryBody,
    signal,
  });
};

export const getQueryServiceQueryMutationOptions = <
  TError = ErrorType<RpcStatus>,
  TContext = unknown,
>(options?: {
  mutation?: CreateMutationOptions<
    Awaited<ReturnType<typeof queryServiceQuery>>,
    TError,
    { instanceId: string; data: QueryServiceQueryBody },
    TContext
  >;
}): CreateMutationOptions<
  Awaited<ReturnType<typeof queryServiceQuery>>,
  TError,
  { instanceId: string; data: QueryServiceQueryBody },
  TContext
> => {
  const mutationKey = ["queryServiceQuery"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof queryServiceQuery>>,
    { instanceId: string; data: QueryServiceQueryBody }
  > = (props) => {
    const { instanceId, data } = props ?? {};

    return queryServiceQuery(instanceId, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type QueryServiceQueryMutationResult = NonNullable<
  Awaited<ReturnType<typeof queryServiceQuery>>
>;
export type QueryServiceQueryMutationBody = QueryServiceQueryBody;
export type QueryServiceQueryMutationError = ErrorType<RpcStatus>;

/**
 * @summary Query runs a SQL query against the instance's OLAP datastore.
 */
export const createQueryServiceQuery = <
  TError = ErrorType<RpcStatus>,
  TContext = unknown,
>(
  options?: {
    mutation?: CreateMutationOptions<
      Awaited<ReturnType<typeof queryServiceQuery>>,
      TError,
      { instanceId: string; data: QueryServiceQueryBody },
      TContext
    >;
  },
  queryClient?: QueryClient,
): CreateMutationResult<
  Awaited<ReturnType<typeof queryServiceQuery>>,
  TError,
  { instanceId: string; data: QueryServiceQueryBody },
  TContext
> => {
  const mutationOptions = getQueryServiceQueryMutationOptions(options);

  return createMutation(mutationOptions, queryClient);
};
/**
 * @summary Batch request with different queries
 */
export const queryServiceQueryBatch = (
  instanceId: string,
  queryServiceQueryBatchBody: QueryServiceQueryBatchBody,
  signal?: AbortSignal,
) => {
  return httpClient<QueryServiceQueryBatch200>({
    url: `/v1/instances/${instanceId}/query/batch`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: queryServiceQueryBatchBody,
    signal,
  });
};

export const getQueryServiceQueryBatchMutationOptions = <
  TError = ErrorType<RpcStatus>,
  TContext = unknown,
>(options?: {
  mutation?: CreateMutationOptions<
    Awaited<ReturnType<typeof queryServiceQueryBatch>>,
    TError,
    { instanceId: string; data: QueryServiceQueryBatchBody },
    TContext
  >;
}): CreateMutationOptions<
  Awaited<ReturnType<typeof queryServiceQueryBatch>>,
  TError,
  { instanceId: string; data: QueryServiceQueryBatchBody },
  TContext
> => {
  const mutationKey = ["queryServiceQueryBatch"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof queryServiceQueryBatch>>,
    { instanceId: string; data: QueryServiceQueryBatchBody }
  > = (props) => {
    const { instanceId, data } = props ?? {};

    return queryServiceQueryBatch(instanceId, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type QueryServiceQueryBatchMutationResult = NonNullable<
  Awaited<ReturnType<typeof queryServiceQueryBatch>>
>;
export type QueryServiceQueryBatchMutationBody = QueryServiceQueryBatchBody;
export type QueryServiceQueryBatchMutationError = ErrorType<RpcStatus>;

/**
 * @summary Batch request with different queries
 */
export const createQueryServiceQueryBatch = <
  TError = ErrorType<RpcStatus>,
  TContext = unknown,
>(
  options?: {
    mutation?: CreateMutationOptions<
      Awaited<ReturnType<typeof queryServiceQueryBatch>>,
      TError,
      { instanceId: string; data: QueryServiceQueryBatchBody },
      TContext
    >;
  },
  queryClient?: QueryClient,
): CreateMutationResult<
  Awaited<ReturnType<typeof queryServiceQueryBatch>>,
  TError,
  { instanceId: string; data: QueryServiceQueryBatchBody },
  TContext
> => {
  const mutationOptions = getQueryServiceQueryBatchMutationOptions(options);

  return createMutation(mutationOptions, queryClient);
};
/**
 * @summary QueryResolver queries a resolver with the given properties and arguments
 */
export const runtimeServiceQueryResolver = (
  instanceId: string,
  runtimeServiceQueryResolverBody: RuntimeServiceQueryResolverBody,
  signal?: AbortSignal,
) => {
  return httpClient<V1QueryResolverResponse>({
    url: `/v1/instances/${instanceId}/query/resolver`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: runtimeServiceQueryResolverBody,
    signal,
  });
};

export const getRuntimeServiceQueryResolverMutationOptions = <
  TError = ErrorType<RpcStatus>,
  TContext = unknown,
>(options?: {
  mutation?: CreateMutationOptions<
    Awaited<ReturnType<typeof runtimeServiceQueryResolver>>,
    TError,
    { instanceId: string; data: RuntimeServiceQueryResolverBody },
    TContext
  >;
}): CreateMutationOptions<
  Awaited<ReturnType<typeof runtimeServiceQueryResolver>>,
  TError,
  { instanceId: string; data: RuntimeServiceQueryResolverBody },
  TContext
> => {
  const mutationKey = ["runtimeServiceQueryResolver"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof runtimeServiceQueryResolver>>,
    { instanceId: string; data: RuntimeServiceQueryResolverBody }
  > = (props) => {
    const { instanceId, data } = props ?? {};

    return runtimeServiceQueryResolver(instanceId, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type RuntimeServiceQueryResolverMutationResult = NonNullable<
  Awaited<ReturnType<typeof runtimeServiceQueryResolver>>
>;
export type RuntimeServiceQueryResolverMutationBody =
  RuntimeServiceQueryResolverBody;
export type RuntimeServiceQueryResolverMutationError = ErrorType<RpcStatus>;

/**
 * @summary QueryResolver queries a resolver with the given properties and arguments
 */
export const createRuntimeServiceQueryResolver = <
  TError = ErrorType<RpcStatus>,
  TContext = unknown,
>(
  options?: {
    mutation?: CreateMutationOptions<
      Awaited<ReturnType<typeof runtimeServiceQueryResolver>>,
      TError,
      { instanceId: string; data: RuntimeServiceQueryResolverBody },
      TContext
    >;
  },
  queryClient?: QueryClient,
): CreateMutationResult<
  Awaited<ReturnType<typeof runtimeServiceQueryResolver>>,
  TError,
  { instanceId: string; data: RuntimeServiceQueryResolverBody },
  TContext
> => {
  const mutationOptions =
    getRuntimeServiceQueryResolverMutationOptions(options);

  return createMutation(mutationOptions, queryClient);
};
/**
 * @summary ExportReport builds a URL to download the results of a query as a file.
 */
export const queryServiceExportReport = (
  instanceId: string,
  report: string,
  queryServiceExportReportBody: QueryServiceExportReportBody,
  signal?: AbortSignal,
) => {
  return httpClient<V1ExportReportResponse>({
    url: `/v1/instances/${instanceId}/reports/${report}/export`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: queryServiceExportReportBody,
    signal,
  });
};

export const getQueryServiceExportReportMutationOptions = <
  TError = ErrorType<RpcStatus>,
  TContext = unknown,
>(options?: {
  mutation?: CreateMutationOptions<
    Awaited<ReturnType<typeof queryServiceExportReport>>,
    TError,
    { instanceId: string; report: string; data: QueryServiceExportReportBody },
    TContext
  >;
}): CreateMutationOptions<
  Awaited<ReturnType<typeof queryServiceExportReport>>,
  TError,
  { instanceId: string; report: string; data: QueryServiceExportReportBody },
  TContext
> => {
  const mutationKey = ["queryServiceExportReport"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof queryServiceExportReport>>,
    { instanceId: string; report: string; data: QueryServiceExportReportBody }
  > = (props) => {
    const { instanceId, report, data } = props ?? {};

    return queryServiceExportReport(instanceId, report, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type QueryServiceExportReportMutationResult = NonNullable<
  Awaited<ReturnType<typeof queryServiceExportReport>>
>;
export type QueryServiceExportReportMutationBody = QueryServiceExportReportBody;
export type QueryServiceExportReportMutationError = ErrorType<RpcStatus>;

/**
 * @summary ExportReport builds a URL to download the results of a query as a file.
 */
export const createQueryServiceExportReport = <
  TError = ErrorType<RpcStatus>,
  TContext = unknown,
>(
  options?: {
    mutation?: CreateMutationOptions<
      Awaited<ReturnType<typeof queryServiceExportReport>>,
      TError,
      {
        instanceId: string;
        report: string;
        data: QueryServiceExportReportBody;
      },
      TContext
    >;
  },
  queryClient?: QueryClient,
): CreateMutationResult<
  Awaited<ReturnType<typeof queryServiceExportReport>>,
  TError,
  { instanceId: string; report: string; data: QueryServiceExportReportBody },
  TContext
> => {
  const mutationOptions = getQueryServiceExportReportMutationOptions(options);

  return createMutation(mutationOptions, queryClient);
};
/**
 * @summary GetResource looks up a specific catalog resource
 */
export const runtimeServiceGetResource = (
  instanceId: string,
  params?: RuntimeServiceGetResourceParams,
  signal?: AbortSignal,
) => {
  return httpClient<V1GetResourceResponse>({
    url: `/v1/instances/${instanceId}/resource`,
    method: "GET",
    params,
    signal,
  });
};

export const getRuntimeServiceGetResourceQueryKey = (
  instanceId: string,
  params?: RuntimeServiceGetResourceParams,
) => {
  return [
    `/v1/instances/${instanceId}/resource`,
    ...(params ? [params] : []),
  ] as const;
};

export const getRuntimeServiceGetResourceQueryOptions = <
  TData = Awaited<ReturnType<typeof runtimeServiceGetResource>>,
  TError = ErrorType<RpcStatus>,
>(
  instanceId: string,
  params?: RuntimeServiceGetResourceParams,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof runtimeServiceGetResource>>,
        TError,
        TData
      >
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getRuntimeServiceGetResourceQueryKey(instanceId, params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof runtimeServiceGetResource>>
  > = ({ signal }) => runtimeServiceGetResource(instanceId, params, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!instanceId,
    ...queryOptions,
  } as CreateQueryOptions<
    Awaited<ReturnType<typeof runtimeServiceGetResource>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type RuntimeServiceGetResourceQueryResult = NonNullable<
  Awaited<ReturnType<typeof runtimeServiceGetResource>>
>;
export type RuntimeServiceGetResourceQueryError = ErrorType<RpcStatus>;

/**
 * @summary GetResource looks up a specific catalog resource
 */

export function createRuntimeServiceGetResource<
  TData = Awaited<ReturnType<typeof runtimeServiceGetResource>>,
  TError = ErrorType<RpcStatus>,
>(
  instanceId: string,
  params?: RuntimeServiceGetResourceParams,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof runtimeServiceGetResource>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): CreateQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getRuntimeServiceGetResourceQueryOptions(
    instanceId,
    params,
    options,
  );

  const query = createQuery(queryOptions, queryClient) as CreateQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary ListResources lists the resources stored in the catalog
 */
export const runtimeServiceListResources = (
  instanceId: string,
  params?: RuntimeServiceListResourcesParams,
  signal?: AbortSignal,
) => {
  return httpClient<V1ListResourcesResponse>({
    url: `/v1/instances/${instanceId}/resources`,
    method: "GET",
    params,
    signal,
  });
};

export const getRuntimeServiceListResourcesQueryKey = (
  instanceId: string,
  params?: RuntimeServiceListResourcesParams,
) => {
  return [
    `/v1/instances/${instanceId}/resources`,
    ...(params ? [params] : []),
  ] as const;
};

export const getRuntimeServiceListResourcesQueryOptions = <
  TData = Awaited<ReturnType<typeof runtimeServiceListResources>>,
  TError = ErrorType<RpcStatus>,
>(
  instanceId: string,
  params?: RuntimeServiceListResourcesParams,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof runtimeServiceListResources>>,
        TError,
        TData
      >
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getRuntimeServiceListResourcesQueryKey(instanceId, params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof runtimeServiceListResources>>
  > = ({ signal }) => runtimeServiceListResources(instanceId, params, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!instanceId,
    ...queryOptions,
  } as CreateQueryOptions<
    Awaited<ReturnType<typeof runtimeServiceListResources>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type RuntimeServiceListResourcesQueryResult = NonNullable<
  Awaited<ReturnType<typeof runtimeServiceListResources>>
>;
export type RuntimeServiceListResourcesQueryError = ErrorType<RpcStatus>;

/**
 * @summary ListResources lists the resources stored in the catalog
 */

export function createRuntimeServiceListResources<
  TData = Awaited<ReturnType<typeof runtimeServiceListResources>>,
  TError = ErrorType<RpcStatus>,
>(
  instanceId: string,
  params?: RuntimeServiceListResourcesParams,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof runtimeServiceListResources>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): CreateQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getRuntimeServiceListResourcesQueryOptions(
    instanceId,
    params,
    options,
  );

  const query = createQuery(queryOptions, queryClient) as CreateQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary WatchResources streams updates to catalog resources (including creation and deletion events)
 */
export const runtimeServiceWatchResources = (
  instanceId: string,
  params?: RuntimeServiceWatchResourcesParams,
  signal?: AbortSignal,
) => {
  return httpClient<RuntimeServiceWatchResources200>({
    url: `/v1/instances/${instanceId}/resources/-/watch`,
    method: "GET",
    params,
    signal,
  });
};

export const getRuntimeServiceWatchResourcesQueryKey = (
  instanceId: string,
  params?: RuntimeServiceWatchResourcesParams,
) => {
  return [
    `/v1/instances/${instanceId}/resources/-/watch`,
    ...(params ? [params] : []),
  ] as const;
};

export const getRuntimeServiceWatchResourcesQueryOptions = <
  TData = Awaited<ReturnType<typeof runtimeServiceWatchResources>>,
  TError = ErrorType<RpcStatus>,
>(
  instanceId: string,
  params?: RuntimeServiceWatchResourcesParams,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof runtimeServiceWatchResources>>,
        TError,
        TData
      >
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getRuntimeServiceWatchResourcesQueryKey(instanceId, params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof runtimeServiceWatchResources>>
  > = ({ signal }) => runtimeServiceWatchResources(instanceId, params, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!instanceId,
    ...queryOptions,
  } as CreateQueryOptions<
    Awaited<ReturnType<typeof runtimeServiceWatchResources>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type RuntimeServiceWatchResourcesQueryResult = NonNullable<
  Awaited<ReturnType<typeof runtimeServiceWatchResources>>
>;
export type RuntimeServiceWatchResourcesQueryError = ErrorType<RpcStatus>;

/**
 * @summary WatchResources streams updates to catalog resources (including creation and deletion events)
 */

export function createRuntimeServiceWatchResources<
  TData = Awaited<ReturnType<typeof runtimeServiceWatchResources>>,
  TError = ErrorType<RpcStatus>,
>(
  instanceId: string,
  params?: RuntimeServiceWatchResourcesParams,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof runtimeServiceWatchResources>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): CreateQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getRuntimeServiceWatchResourcesQueryOptions(
    instanceId,
    params,
    options,
  );

  const query = createQuery(queryOptions, queryClient) as CreateQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary GetExplore is a convenience RPC that combines looking up an Explore resource and its underlying MetricsView into one network call.
 */
export const runtimeServiceGetExplore = (
  instanceId: string,
  params?: RuntimeServiceGetExploreParams,
  signal?: AbortSignal,
) => {
  return httpClient<V1GetExploreResponse>({
    url: `/v1/instances/${instanceId}/resources/explore`,
    method: "GET",
    params,
    signal,
  });
};

export const getRuntimeServiceGetExploreQueryKey = (
  instanceId: string,
  params?: RuntimeServiceGetExploreParams,
) => {
  return [
    `/v1/instances/${instanceId}/resources/explore`,
    ...(params ? [params] : []),
  ] as const;
};

export const getRuntimeServiceGetExploreQueryOptions = <
  TData = Awaited<ReturnType<typeof runtimeServiceGetExplore>>,
  TError = ErrorType<RpcStatus>,
>(
  instanceId: string,
  params?: RuntimeServiceGetExploreParams,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof runtimeServiceGetExplore>>,
        TError,
        TData
      >
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getRuntimeServiceGetExploreQueryKey(instanceId, params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof runtimeServiceGetExplore>>
  > = ({ signal }) => runtimeServiceGetExplore(instanceId, params, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!instanceId,
    ...queryOptions,
  } as CreateQueryOptions<
    Awaited<ReturnType<typeof runtimeServiceGetExplore>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type RuntimeServiceGetExploreQueryResult = NonNullable<
  Awaited<ReturnType<typeof runtimeServiceGetExplore>>
>;
export type RuntimeServiceGetExploreQueryError = ErrorType<RpcStatus>;

/**
 * @summary GetExplore is a convenience RPC that combines looking up an Explore resource and its underlying MetricsView into one network call.
 */

export function createRuntimeServiceGetExplore<
  TData = Awaited<ReturnType<typeof runtimeServiceGetExplore>>,
  TError = ErrorType<RpcStatus>,
>(
  instanceId: string,
  params?: RuntimeServiceGetExploreParams,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof runtimeServiceGetExplore>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): CreateQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getRuntimeServiceGetExploreQueryOptions(
    instanceId,
    params,
    options,
  );

  const query = createQuery(queryOptions, queryClient) as CreateQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary CreateTrigger submits a refresh trigger, which will asynchronously refresh the specified resources.
Triggers are ephemeral resources that will be cleaned up by the controller.
 */
export const runtimeServiceCreateTrigger = (
  instanceId: string,
  runtimeServiceCreateTriggerBody: RuntimeServiceCreateTriggerBody,
  signal?: AbortSignal,
) => {
  return httpClient<V1CreateTriggerResponse>({
    url: `/v1/instances/${instanceId}/trigger`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: runtimeServiceCreateTriggerBody,
    signal,
  });
};

export const getRuntimeServiceCreateTriggerMutationOptions = <
  TError = ErrorType<RpcStatus>,
  TContext = unknown,
>(options?: {
  mutation?: CreateMutationOptions<
    Awaited<ReturnType<typeof runtimeServiceCreateTrigger>>,
    TError,
    { instanceId: string; data: RuntimeServiceCreateTriggerBody },
    TContext
  >;
}): CreateMutationOptions<
  Awaited<ReturnType<typeof runtimeServiceCreateTrigger>>,
  TError,
  { instanceId: string; data: RuntimeServiceCreateTriggerBody },
  TContext
> => {
  const mutationKey = ["runtimeServiceCreateTrigger"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof runtimeServiceCreateTrigger>>,
    { instanceId: string; data: RuntimeServiceCreateTriggerBody }
  > = (props) => {
    const { instanceId, data } = props ?? {};

    return runtimeServiceCreateTrigger(instanceId, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type RuntimeServiceCreateTriggerMutationResult = NonNullable<
  Awaited<ReturnType<typeof runtimeServiceCreateTrigger>>
>;
export type RuntimeServiceCreateTriggerMutationBody =
  RuntimeServiceCreateTriggerBody;
export type RuntimeServiceCreateTriggerMutationError = ErrorType<RpcStatus>;

/**
 * @summary CreateTrigger submits a refresh trigger, which will asynchronously refresh the specified resources.
Triggers are ephemeral resources that will be cleaned up by the controller.
 */
export const createRuntimeServiceCreateTrigger = <
  TError = ErrorType<RpcStatus>,
  TContext = unknown,
>(
  options?: {
    mutation?: CreateMutationOptions<
      Awaited<ReturnType<typeof runtimeServiceCreateTrigger>>,
      TError,
      { instanceId: string; data: RuntimeServiceCreateTriggerBody },
      TContext
    >;
  },
  queryClient?: QueryClient,
): CreateMutationResult<
  Awaited<ReturnType<typeof runtimeServiceCreateTrigger>>,
  TError,
  { instanceId: string; data: RuntimeServiceCreateTriggerBody },
  TContext
> => {
  const mutationOptions =
    getRuntimeServiceCreateTriggerMutationOptions(options);

  return createMutation(mutationOptions, queryClient);
};
/**
 * @summary AnalyzeVariables scans `Source`, `Model` and `Connector` resources in the catalog for use of an environment variable
 */
export const runtimeServiceAnalyzeVariables = (
  instanceId: string,
  signal?: AbortSignal,
) => {
  return httpClient<V1AnalyzeVariablesResponse>({
    url: `/v1/instances/${instanceId}/variables/analyze`,
    method: "GET",
    signal,
  });
};

export const getRuntimeServiceAnalyzeVariablesQueryKey = (
  instanceId: string,
) => {
  return [`/v1/instances/${instanceId}/variables/analyze`] as const;
};

export const getRuntimeServiceAnalyzeVariablesQueryOptions = <
  TData = Awaited<ReturnType<typeof runtimeServiceAnalyzeVariables>>,
  TError = ErrorType<RpcStatus>,
>(
  instanceId: string,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof runtimeServiceAnalyzeVariables>>,
        TError,
        TData
      >
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getRuntimeServiceAnalyzeVariablesQueryKey(instanceId);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof runtimeServiceAnalyzeVariables>>
  > = ({ signal }) => runtimeServiceAnalyzeVariables(instanceId, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!instanceId,
    ...queryOptions,
  } as CreateQueryOptions<
    Awaited<ReturnType<typeof runtimeServiceAnalyzeVariables>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type RuntimeServiceAnalyzeVariablesQueryResult = NonNullable<
  Awaited<ReturnType<typeof runtimeServiceAnalyzeVariables>>
>;
export type RuntimeServiceAnalyzeVariablesQueryError = ErrorType<RpcStatus>;

/**
 * @summary AnalyzeVariables scans `Source`, `Model` and `Connector` resources in the catalog for use of an environment variable
 */

export function createRuntimeServiceAnalyzeVariables<
  TData = Awaited<ReturnType<typeof runtimeServiceAnalyzeVariables>>,
  TError = ErrorType<RpcStatus>,
>(
  instanceId: string,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof runtimeServiceAnalyzeVariables>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): CreateQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getRuntimeServiceAnalyzeVariablesQueryOptions(
    instanceId,
    options,
  );

  const query = createQuery(queryOptions, queryClient) as CreateQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary OLAPListTables list all tables across all databases in an OLAP
 */
export const connectorServiceOLAPListTables = (
  params?: ConnectorServiceOLAPListTablesParams,
  signal?: AbortSignal,
) => {
  return httpClient<V1OLAPListTablesResponse>({
    url: `/v1/olap/tables`,
    method: "GET",
    params,
    signal,
  });
};

export const getConnectorServiceOLAPListTablesQueryKey = (
  params?: ConnectorServiceOLAPListTablesParams,
) => {
  return [`/v1/olap/tables`, ...(params ? [params] : [])] as const;
};

export const getConnectorServiceOLAPListTablesQueryOptions = <
  TData = Awaited<ReturnType<typeof connectorServiceOLAPListTables>>,
  TError = ErrorType<RpcStatus>,
>(
  params?: ConnectorServiceOLAPListTablesParams,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof connectorServiceOLAPListTables>>,
        TError,
        TData
      >
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getConnectorServiceOLAPListTablesQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof connectorServiceOLAPListTables>>
  > = ({ signal }) => connectorServiceOLAPListTables(params, signal);

  return { queryKey, queryFn, ...queryOptions } as CreateQueryOptions<
    Awaited<ReturnType<typeof connectorServiceOLAPListTables>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type ConnectorServiceOLAPListTablesQueryResult = NonNullable<
  Awaited<ReturnType<typeof connectorServiceOLAPListTables>>
>;
export type ConnectorServiceOLAPListTablesQueryError = ErrorType<RpcStatus>;

/**
 * @summary OLAPListTables list all tables across all databases in an OLAP
 */

export function createConnectorServiceOLAPListTables<
  TData = Awaited<ReturnType<typeof connectorServiceOLAPListTables>>,
  TError = ErrorType<RpcStatus>,
>(
  params?: ConnectorServiceOLAPListTablesParams,
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof connectorServiceOLAPListTables>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): CreateQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getConnectorServiceOLAPListTablesQueryOptions(
    params,
    options,
  );

  const query = createQuery(queryOptions, queryClient) as CreateQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Ping returns information about the runtime
 */
export const runtimeServicePing = (signal?: AbortSignal) => {
  return httpClient<V1PingResponse>({ url: `/v1/ping`, method: "GET", signal });
};

export const getRuntimeServicePingQueryKey = () => {
  return [`/v1/ping`] as const;
};

export const getRuntimeServicePingQueryOptions = <
  TData = Awaited<ReturnType<typeof runtimeServicePing>>,
  TError = ErrorType<RpcStatus>,
>(options?: {
  query?: Partial<
    CreateQueryOptions<
      Awaited<ReturnType<typeof runtimeServicePing>>,
      TError,
      TData
    >
  >;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getRuntimeServicePingQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof runtimeServicePing>>
  > = ({ signal }) => runtimeServicePing(signal);

  return { queryKey, queryFn, ...queryOptions } as CreateQueryOptions<
    Awaited<ReturnType<typeof runtimeServicePing>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type RuntimeServicePingQueryResult = NonNullable<
  Awaited<ReturnType<typeof runtimeServicePing>>
>;
export type RuntimeServicePingQueryError = ErrorType<RpcStatus>;

/**
 * @summary Ping returns information about the runtime
 */

export function createRuntimeServicePing<
  TData = Awaited<ReturnType<typeof runtimeServicePing>>,
  TError = ErrorType<RpcStatus>,
>(
  options?: {
    query?: Partial<
      CreateQueryOptions<
        Awaited<ReturnType<typeof runtimeServicePing>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): CreateQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getRuntimeServicePingQueryOptions(options);

  const query = createQuery(queryOptions, queryClient) as CreateQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

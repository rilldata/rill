// Generated by generate-query-hooks.ts — DO NOT EDIT

import type { RuntimeClient } from "../runtime-client";
import type { ConnectError } from "@connectrpc/connect";
import type { PartialMessage, JsonValue } from "@bufbuild/protobuf";
import {
  createQuery,
  createMutation,
  type CreateQueryOptions,
  type CreateQueryResult,
  type QueryClient,
  type QueryFunction,
  type QueryKey,
  type CreateMutationOptions,
  type CreateMutationResult,
} from "@tanstack/svelte-query";
import type {
  V1GetTableResponse,
  V1ListBucketsResponse,
  V1ListDatabaseSchemasResponse,
  V1ListObjectsResponse,
  V1ListTablesResponse,
  V1OLAPGetTableResponse,
  V1OLAPListTablesResponse,
} from "../../gen/index.schemas";
import {
  GetTableRequest,
  ListBucketsRequest,
  ListDatabaseSchemasRequest,
  ListObjectsRequest,
  ListTablesRequest,
  OLAPGetTableRequest,
  OLAPListTablesRequest,
} from "../../../proto/gen/rill/runtime/v1/connectors_pb";

/** Deep-strip undefined values — proto fromJson rejects them */
// eslint-disable-next-line @typescript-eslint/no-explicit-any
function stripUndefined(obj: Record<string, any>): Record<string, unknown> {
  const result: Record<string, unknown> = {};
  for (const [key, value] of Object.entries(obj)) {
    if (value === undefined) continue;
    if (Array.isArray(value)) {
      result[key] = value.map((item) =>
        item && typeof item === "object" && !Array.isArray(item)
          ? stripUndefined(item)
          : item,
      );
    } else if (value && typeof value === "object" && !(value instanceof Date)) {
      result[key] = stripUndefined(value);
    } else {
      result[key] = value;
    }
  }
  return result;
}

/**
 * Raw RPC call: ConnectorService.ListBuckets
 */
export async function connectorServiceListBuckets(
  client: RuntimeClient,
  request: Omit<PartialMessage<ListBucketsRequest>, "instanceId">,
  options?: { signal?: AbortSignal },
): Promise<V1ListBucketsResponse> {
  const r = await client.connectorService.listBuckets(
    ListBucketsRequest.fromJson(
      stripUndefined({
        instanceId: client.instanceId,
        ...request,
      }) as unknown as JsonValue,
    ),
    { signal: options?.signal },
  );
  return r.toJson({
    emitDefaultValues: true,
  }) as unknown as V1ListBucketsResponse;
}

export function getConnectorServiceListBucketsQueryKey(
  instanceId: string,
  request?: Omit<PartialMessage<ListBucketsRequest>, "instanceId">,
): QueryKey {
  return [
    "ConnectorService",
    "listBuckets",
    instanceId,
    request ?? {},
  ] as const;
}

export function getConnectorServiceListBucketsQueryOptions<
  TData = V1ListBucketsResponse,
>(
  client: RuntimeClient,
  request: Omit<PartialMessage<ListBucketsRequest>, "instanceId">,
  options?: {
    query?: Partial<
      CreateQueryOptions<V1ListBucketsResponse, ConnectError, TData>
    >;
  },
): CreateQueryOptions<V1ListBucketsResponse, ConnectError, TData> & {
  queryKey: QueryKey;
} {
  const queryKey = getConnectorServiceListBucketsQueryKey(
    client.instanceId,
    request,
  );
  const queryFn: QueryFunction<V1ListBucketsResponse> = ({ signal }) =>
    connectorServiceListBuckets(client, request, { signal });
  return {
    queryKey,
    queryFn,
    enabled: !!client.instanceId,
    ...options?.query,
  } as CreateQueryOptions<V1ListBucketsResponse, ConnectError, TData> & {
    queryKey: QueryKey;
  };
}

export function createConnectorServiceListBuckets<
  TData = V1ListBucketsResponse,
>(
  client: RuntimeClient,
  request: Omit<PartialMessage<ListBucketsRequest>, "instanceId">,
  options?: {
    query?: Partial<
      CreateQueryOptions<V1ListBucketsResponse, ConnectError, TData>
    >;
  },
  queryClient?: QueryClient,
): CreateQueryResult<TData, ConnectError> {
  const queryOptions = getConnectorServiceListBucketsQueryOptions(
    client,
    request,
    options,
  );
  return createQuery(queryOptions, queryClient);
}

/**
 * Raw RPC call: ConnectorService.ListObjects
 */
export async function connectorServiceListObjects(
  client: RuntimeClient,
  request: Omit<PartialMessage<ListObjectsRequest>, "instanceId">,
  options?: { signal?: AbortSignal },
): Promise<V1ListObjectsResponse> {
  const r = await client.connectorService.listObjects(
    ListObjectsRequest.fromJson(
      stripUndefined({
        instanceId: client.instanceId,
        ...request,
      }) as unknown as JsonValue,
    ),
    { signal: options?.signal },
  );
  return r.toJson({
    emitDefaultValues: true,
  }) as unknown as V1ListObjectsResponse;
}

export function getConnectorServiceListObjectsQueryKey(
  instanceId: string,
  request?: Omit<PartialMessage<ListObjectsRequest>, "instanceId">,
): QueryKey {
  return [
    "ConnectorService",
    "listObjects",
    instanceId,
    request ?? {},
  ] as const;
}

export function getConnectorServiceListObjectsQueryOptions<
  TData = V1ListObjectsResponse,
>(
  client: RuntimeClient,
  request: Omit<PartialMessage<ListObjectsRequest>, "instanceId">,
  options?: {
    query?: Partial<
      CreateQueryOptions<V1ListObjectsResponse, ConnectError, TData>
    >;
  },
): CreateQueryOptions<V1ListObjectsResponse, ConnectError, TData> & {
  queryKey: QueryKey;
} {
  const queryKey = getConnectorServiceListObjectsQueryKey(
    client.instanceId,
    request,
  );
  const queryFn: QueryFunction<V1ListObjectsResponse> = ({ signal }) =>
    connectorServiceListObjects(client, request, { signal });
  return {
    queryKey,
    queryFn,
    enabled: !!client.instanceId,
    ...options?.query,
  } as CreateQueryOptions<V1ListObjectsResponse, ConnectError, TData> & {
    queryKey: QueryKey;
  };
}

export function createConnectorServiceListObjects<
  TData = V1ListObjectsResponse,
>(
  client: RuntimeClient,
  request: Omit<PartialMessage<ListObjectsRequest>, "instanceId">,
  options?: {
    query?: Partial<
      CreateQueryOptions<V1ListObjectsResponse, ConnectError, TData>
    >;
  },
  queryClient?: QueryClient,
): CreateQueryResult<TData, ConnectError> {
  const queryOptions = getConnectorServiceListObjectsQueryOptions(
    client,
    request,
    options,
  );
  return createQuery(queryOptions, queryClient);
}

/**
 * Raw RPC call: ConnectorService.OLAPListTables
 */
export async function connectorServiceOLAPListTables(
  client: RuntimeClient,
  request: Omit<PartialMessage<OLAPListTablesRequest>, "instanceId">,
  options?: { signal?: AbortSignal },
): Promise<V1OLAPListTablesResponse> {
  const r = await client.connectorService.oLAPListTables(
    OLAPListTablesRequest.fromJson(
      stripUndefined({
        instanceId: client.instanceId,
        ...request,
      }) as unknown as JsonValue,
    ),
    { signal: options?.signal },
  );
  return r.toJson({
    emitDefaultValues: true,
  }) as unknown as V1OLAPListTablesResponse;
}

export function getConnectorServiceOLAPListTablesQueryKey(
  instanceId: string,
  request?: Omit<PartialMessage<OLAPListTablesRequest>, "instanceId">,
): QueryKey {
  return [
    "ConnectorService",
    "oLAPListTables",
    instanceId,
    request ?? {},
  ] as const;
}

export function getConnectorServiceOLAPListTablesQueryOptions<
  TData = V1OLAPListTablesResponse,
>(
  client: RuntimeClient,
  request: Omit<PartialMessage<OLAPListTablesRequest>, "instanceId">,
  options?: {
    query?: Partial<
      CreateQueryOptions<V1OLAPListTablesResponse, ConnectError, TData>
    >;
  },
): CreateQueryOptions<V1OLAPListTablesResponse, ConnectError, TData> & {
  queryKey: QueryKey;
} {
  const queryKey = getConnectorServiceOLAPListTablesQueryKey(
    client.instanceId,
    request,
  );
  const queryFn: QueryFunction<V1OLAPListTablesResponse> = ({ signal }) =>
    connectorServiceOLAPListTables(client, request, { signal });
  return {
    queryKey,
    queryFn,
    enabled: !!client.instanceId,
    ...options?.query,
  } as CreateQueryOptions<V1OLAPListTablesResponse, ConnectError, TData> & {
    queryKey: QueryKey;
  };
}

export function createConnectorServiceOLAPListTables<
  TData = V1OLAPListTablesResponse,
>(
  client: RuntimeClient,
  request: Omit<PartialMessage<OLAPListTablesRequest>, "instanceId">,
  options?: {
    query?: Partial<
      CreateQueryOptions<V1OLAPListTablesResponse, ConnectError, TData>
    >;
  },
  queryClient?: QueryClient,
): CreateQueryResult<TData, ConnectError> {
  const queryOptions = getConnectorServiceOLAPListTablesQueryOptions(
    client,
    request,
    options,
  );
  return createQuery(queryOptions, queryClient);
}

/**
 * Raw RPC call: ConnectorService.OLAPGetTable
 */
export async function connectorServiceOLAPGetTable(
  client: RuntimeClient,
  request: Omit<PartialMessage<OLAPGetTableRequest>, "instanceId">,
  options?: { signal?: AbortSignal },
): Promise<V1OLAPGetTableResponse> {
  const r = await client.connectorService.oLAPGetTable(
    OLAPGetTableRequest.fromJson(
      stripUndefined({
        instanceId: client.instanceId,
        ...request,
      }) as unknown as JsonValue,
    ),
    { signal: options?.signal },
  );
  return r.toJson({
    emitDefaultValues: true,
  }) as unknown as V1OLAPGetTableResponse;
}

export function getConnectorServiceOLAPGetTableQueryKey(
  instanceId: string,
  request?: Omit<PartialMessage<OLAPGetTableRequest>, "instanceId">,
): QueryKey {
  return [
    "ConnectorService",
    "oLAPGetTable",
    instanceId,
    request ?? {},
  ] as const;
}

export function getConnectorServiceOLAPGetTableQueryOptions<
  TData = V1OLAPGetTableResponse,
>(
  client: RuntimeClient,
  request: Omit<PartialMessage<OLAPGetTableRequest>, "instanceId">,
  options?: {
    query?: Partial<
      CreateQueryOptions<V1OLAPGetTableResponse, ConnectError, TData>
    >;
  },
): CreateQueryOptions<V1OLAPGetTableResponse, ConnectError, TData> & {
  queryKey: QueryKey;
} {
  const queryKey = getConnectorServiceOLAPGetTableQueryKey(
    client.instanceId,
    request,
  );
  const queryFn: QueryFunction<V1OLAPGetTableResponse> = ({ signal }) =>
    connectorServiceOLAPGetTable(client, request, { signal });
  return {
    queryKey,
    queryFn,
    enabled: !!client.instanceId,
    ...options?.query,
  } as CreateQueryOptions<V1OLAPGetTableResponse, ConnectError, TData> & {
    queryKey: QueryKey;
  };
}

export function createConnectorServiceOLAPGetTable<
  TData = V1OLAPGetTableResponse,
>(
  client: RuntimeClient,
  request: Omit<PartialMessage<OLAPGetTableRequest>, "instanceId">,
  options?: {
    query?: Partial<
      CreateQueryOptions<V1OLAPGetTableResponse, ConnectError, TData>
    >;
  },
  queryClient?: QueryClient,
): CreateQueryResult<TData, ConnectError> {
  const queryOptions = getConnectorServiceOLAPGetTableQueryOptions(
    client,
    request,
    options,
  );
  return createQuery(queryOptions, queryClient);
}

/**
 * Raw RPC call: ConnectorService.ListDatabaseSchemas
 */
export async function connectorServiceListDatabaseSchemas(
  client: RuntimeClient,
  request: Omit<PartialMessage<ListDatabaseSchemasRequest>, "instanceId">,
  options?: { signal?: AbortSignal },
): Promise<V1ListDatabaseSchemasResponse> {
  const r = await client.connectorService.listDatabaseSchemas(
    ListDatabaseSchemasRequest.fromJson(
      stripUndefined({
        instanceId: client.instanceId,
        ...request,
      }) as unknown as JsonValue,
    ),
    { signal: options?.signal },
  );
  return r.toJson({
    emitDefaultValues: true,
  }) as unknown as V1ListDatabaseSchemasResponse;
}

export function getConnectorServiceListDatabaseSchemasQueryKey(
  instanceId: string,
  request?: Omit<PartialMessage<ListDatabaseSchemasRequest>, "instanceId">,
): QueryKey {
  return [
    "ConnectorService",
    "listDatabaseSchemas",
    instanceId,
    request ?? {},
  ] as const;
}

export function getConnectorServiceListDatabaseSchemasQueryOptions<
  TData = V1ListDatabaseSchemasResponse,
>(
  client: RuntimeClient,
  request: Omit<PartialMessage<ListDatabaseSchemasRequest>, "instanceId">,
  options?: {
    query?: Partial<
      CreateQueryOptions<V1ListDatabaseSchemasResponse, ConnectError, TData>
    >;
  },
): CreateQueryOptions<V1ListDatabaseSchemasResponse, ConnectError, TData> & {
  queryKey: QueryKey;
} {
  const queryKey = getConnectorServiceListDatabaseSchemasQueryKey(
    client.instanceId,
    request,
  );
  const queryFn: QueryFunction<V1ListDatabaseSchemasResponse> = ({ signal }) =>
    connectorServiceListDatabaseSchemas(client, request, { signal });
  return {
    queryKey,
    queryFn,
    enabled: !!client.instanceId,
    ...options?.query,
  } as CreateQueryOptions<
    V1ListDatabaseSchemasResponse,
    ConnectError,
    TData
  > & { queryKey: QueryKey };
}

export function createConnectorServiceListDatabaseSchemas<
  TData = V1ListDatabaseSchemasResponse,
>(
  client: RuntimeClient,
  request: Omit<PartialMessage<ListDatabaseSchemasRequest>, "instanceId">,
  options?: {
    query?: Partial<
      CreateQueryOptions<V1ListDatabaseSchemasResponse, ConnectError, TData>
    >;
  },
  queryClient?: QueryClient,
): CreateQueryResult<TData, ConnectError> {
  const queryOptions = getConnectorServiceListDatabaseSchemasQueryOptions(
    client,
    request,
    options,
  );
  return createQuery(queryOptions, queryClient);
}

/**
 * Raw RPC call: ConnectorService.ListTables
 */
export async function connectorServiceListTables(
  client: RuntimeClient,
  request: Omit<PartialMessage<ListTablesRequest>, "instanceId">,
  options?: { signal?: AbortSignal },
): Promise<V1ListTablesResponse> {
  const r = await client.connectorService.listTables(
    ListTablesRequest.fromJson(
      stripUndefined({
        instanceId: client.instanceId,
        ...request,
      }) as unknown as JsonValue,
    ),
    { signal: options?.signal },
  );
  return r.toJson({
    emitDefaultValues: true,
  }) as unknown as V1ListTablesResponse;
}

export function getConnectorServiceListTablesQueryKey(
  instanceId: string,
  request?: Omit<PartialMessage<ListTablesRequest>, "instanceId">,
): QueryKey {
  return ["ConnectorService", "listTables", instanceId, request ?? {}] as const;
}

export function getConnectorServiceListTablesQueryOptions<
  TData = V1ListTablesResponse,
>(
  client: RuntimeClient,
  request: Omit<PartialMessage<ListTablesRequest>, "instanceId">,
  options?: {
    query?: Partial<
      CreateQueryOptions<V1ListTablesResponse, ConnectError, TData>
    >;
  },
): CreateQueryOptions<V1ListTablesResponse, ConnectError, TData> & {
  queryKey: QueryKey;
} {
  const queryKey = getConnectorServiceListTablesQueryKey(
    client.instanceId,
    request,
  );
  const queryFn: QueryFunction<V1ListTablesResponse> = ({ signal }) =>
    connectorServiceListTables(client, request, { signal });
  return {
    queryKey,
    queryFn,
    enabled: !!client.instanceId,
    ...options?.query,
  } as CreateQueryOptions<V1ListTablesResponse, ConnectError, TData> & {
    queryKey: QueryKey;
  };
}

export function createConnectorServiceListTables<TData = V1ListTablesResponse>(
  client: RuntimeClient,
  request: Omit<PartialMessage<ListTablesRequest>, "instanceId">,
  options?: {
    query?: Partial<
      CreateQueryOptions<V1ListTablesResponse, ConnectError, TData>
    >;
  },
  queryClient?: QueryClient,
): CreateQueryResult<TData, ConnectError> {
  const queryOptions = getConnectorServiceListTablesQueryOptions(
    client,
    request,
    options,
  );
  return createQuery(queryOptions, queryClient);
}

/**
 * Raw RPC call: ConnectorService.GetTable
 */
export async function connectorServiceGetTable(
  client: RuntimeClient,
  request: Omit<PartialMessage<GetTableRequest>, "instanceId">,
  options?: { signal?: AbortSignal },
): Promise<V1GetTableResponse> {
  const r = await client.connectorService.getTable(
    GetTableRequest.fromJson(
      stripUndefined({
        instanceId: client.instanceId,
        ...request,
      }) as unknown as JsonValue,
    ),
    { signal: options?.signal },
  );
  return r.toJson({ emitDefaultValues: true }) as unknown as V1GetTableResponse;
}

export function getConnectorServiceGetTableQueryKey(
  instanceId: string,
  request?: Omit<PartialMessage<GetTableRequest>, "instanceId">,
): QueryKey {
  return ["ConnectorService", "getTable", instanceId, request ?? {}] as const;
}

export function getConnectorServiceGetTableQueryOptions<
  TData = V1GetTableResponse,
>(
  client: RuntimeClient,
  request: Omit<PartialMessage<GetTableRequest>, "instanceId">,
  options?: {
    query?: Partial<
      CreateQueryOptions<V1GetTableResponse, ConnectError, TData>
    >;
  },
): CreateQueryOptions<V1GetTableResponse, ConnectError, TData> & {
  queryKey: QueryKey;
} {
  const queryKey = getConnectorServiceGetTableQueryKey(
    client.instanceId,
    request,
  );
  const queryFn: QueryFunction<V1GetTableResponse> = ({ signal }) =>
    connectorServiceGetTable(client, request, { signal });
  return {
    queryKey,
    queryFn,
    enabled: !!client.instanceId,
    ...options?.query,
  } as CreateQueryOptions<V1GetTableResponse, ConnectError, TData> & {
    queryKey: QueryKey;
  };
}

export function createConnectorServiceGetTable<TData = V1GetTableResponse>(
  client: RuntimeClient,
  request: Omit<PartialMessage<GetTableRequest>, "instanceId">,
  options?: {
    query?: Partial<
      CreateQueryOptions<V1GetTableResponse, ConnectError, TData>
    >;
  },
  queryClient?: QueryClient,
): CreateQueryResult<TData, ConnectError> {
  const queryOptions = getConnectorServiceGetTableQueryOptions(
    client,
    request,
    options,
  );
  return createQuery(queryOptions, queryClient);
}

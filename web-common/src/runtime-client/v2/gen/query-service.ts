// Generated by generate-query-hooks.ts — DO NOT EDIT

import type { RuntimeClient } from "../runtime-client";
import type { PartialMessage, JsonValue } from "@bufbuild/protobuf";
import {
  createQuery,
  createMutation,
  type CreateQueryOptions,
  type CreateQueryResult,
  type QueryClient,
  type QueryFunction,
  type QueryKey,
  type CreateMutationOptions,
  type CreateMutationResult,
} from "@tanstack/svelte-query";
import type {
  V1ColumnCardinalityRequest,
  V1ColumnCardinalityResponse,
  V1ColumnDescriptiveStatisticsRequest,
  V1ColumnDescriptiveStatisticsResponse,
  V1ColumnNullCountRequest,
  V1ColumnNullCountResponse,
  V1ColumnNumericHistogramRequest,
  V1ColumnNumericHistogramResponse,
  V1ColumnRollupIntervalRequest,
  V1ColumnRollupIntervalResponse,
  V1ColumnRugHistogramRequest,
  V1ColumnRugHistogramResponse,
  V1ColumnTimeGrainRequest,
  V1ColumnTimeGrainResponse,
  V1ColumnTimeRangeRequest,
  V1ColumnTimeRangeResponse,
  V1ColumnTimeSeriesRequest,
  V1ColumnTimeSeriesResponse,
  V1ColumnTopKRequest,
  V1ColumnTopKResponse,
  V1ConvertExpressionToMetricsSQLResponse,
  V1ExportReportResponse,
  V1ExportResponse,
  V1MetricsViewAggregationRequest,
  V1MetricsViewAggregationResponse,
  V1MetricsViewAnnotationsResponse,
  V1MetricsViewComparisonRequest,
  V1MetricsViewComparisonResponse,
  V1MetricsViewRowsRequest,
  V1MetricsViewRowsResponse,
  V1MetricsViewSchemaResponse,
  V1MetricsViewSearchResponse,
  V1MetricsViewTimeRangeResponse,
  V1MetricsViewTimeRangesResponse,
  V1MetricsViewTimeSeriesRequest,
  V1MetricsViewTimeSeriesResponse,
  V1MetricsViewToplistRequest,
  V1MetricsViewToplistResponse,
  V1MetricsViewTotalsRequest,
  V1MetricsViewTotalsResponse,
  V1QueryResponse,
  V1ResolveCanvasResponse,
  V1ResolveComponentResponse,
  V1ResolveTemplatedStringResponse,
  V1TableCardinalityRequest,
  V1TableCardinalityResponse,
  V1TableColumnsRequest,
  V1TableColumnsResponse,
  V1TableRowsRequest,
  V1TableRowsResponse,
} from "../../gen/index.schemas";
import {
  ColumnCardinalityRequest,
  ColumnDescriptiveStatisticsRequest,
  ColumnNullCountRequest,
  ColumnNumericHistogramRequest,
  ColumnRollupIntervalRequest,
  ColumnRugHistogramRequest,
  ColumnTimeGrainRequest,
  ColumnTimeRangeRequest,
  ColumnTimeSeriesRequest,
  ColumnTopKRequest,
  ConvertExpressionToMetricsSQLRequest,
  ExportReportRequest,
  ExportRequest,
  MetricsViewAggregationRequest,
  MetricsViewAnnotationsRequest,
  MetricsViewComparisonRequest,
  MetricsViewRowsRequest,
  MetricsViewSchemaRequest,
  MetricsViewSearchRequest,
  MetricsViewTimeRangeRequest,
  MetricsViewTimeRangesRequest,
  MetricsViewTimeSeriesRequest,
  MetricsViewToplistRequest,
  MetricsViewTotalsRequest,
  QueryRequest,
  ResolveCanvasRequest,
  ResolveComponentRequest,
  ResolveTemplatedStringRequest,
  TableCardinalityRequest,
  TableColumnsRequest,
  TableRowsRequest,
} from "../../../proto/gen/rill/runtime/v1/queries_pb";

/** Deep-strip undefined values — proto fromJson rejects them */
// eslint-disable-next-line @typescript-eslint/no-explicit-any
function stripUndefined(obj: Record<string, any>): Record<string, unknown> {
  const result: Record<string, unknown> = {};
  for (const [key, value] of Object.entries(obj)) {
    if (value === undefined) continue;
    if (Array.isArray(value)) {
      result[key] = value.map((item) =>
        item && typeof item === "object" && !Array.isArray(item)
          ? stripUndefined(item)
          : item,
      );
    } else if (value && typeof value === "object" && !(value instanceof Date)) {
      result[key] = stripUndefined(value);
    } else {
      result[key] = value;
    }
  }
  return result;
}

/**
 * Raw RPC call: QueryService.MetricsViewAggregation
 */
export async function queryServiceMetricsViewAggregation(
  client: RuntimeClient,
  request: Omit<V1MetricsViewAggregationRequest, "instanceId">,
  options?: { signal?: AbortSignal },
): Promise<V1MetricsViewAggregationResponse> {
  const r = await client.queryService.metricsViewAggregation(
    MetricsViewAggregationRequest.fromJson(
      stripUndefined({
        instanceId: client.instanceId,
        ...request,
      }) as unknown as JsonValue,
    ),
    { signal: options?.signal },
  );
  return r.toJson({
    emitDefaultValues: true,
  }) as unknown as V1MetricsViewAggregationResponse;
}

export function getQueryServiceMetricsViewAggregationQueryKey(
  instanceId: string,
  request?: Omit<V1MetricsViewAggregationRequest, "instanceId">,
): QueryKey {
  return [
    "QueryService",
    "metricsViewAggregation",
    instanceId,
    request ?? {},
  ] as const;
}

export function getQueryServiceMetricsViewAggregationQueryOptions<
  TData = V1MetricsViewAggregationResponse,
>(
  client: RuntimeClient,
  request: Omit<V1MetricsViewAggregationRequest, "instanceId">,
  options?: {
    query?: Partial<
      CreateQueryOptions<V1MetricsViewAggregationResponse, Error, TData>
    >;
  },
): CreateQueryOptions<V1MetricsViewAggregationResponse, Error, TData> & {
  queryKey: QueryKey;
} {
  const queryKey = getQueryServiceMetricsViewAggregationQueryKey(
    client.instanceId,
    request,
  );
  const queryFn: QueryFunction<V1MetricsViewAggregationResponse> = ({
    signal,
  }) => queryServiceMetricsViewAggregation(client, request, { signal });
  return {
    queryKey,
    queryFn,
    enabled: !!client.instanceId,
    ...options?.query,
  } as CreateQueryOptions<V1MetricsViewAggregationResponse, Error, TData> & {
    queryKey: QueryKey;
  };
}

export function createQueryServiceMetricsViewAggregation<
  TData = V1MetricsViewAggregationResponse,
>(
  client: RuntimeClient,
  request: Omit<V1MetricsViewAggregationRequest, "instanceId">,
  options?: {
    query?: Partial<
      CreateQueryOptions<V1MetricsViewAggregationResponse, Error, TData>
    >;
  },
  queryClient?: QueryClient,
): CreateQueryResult<TData, Error> {
  const queryOptions = getQueryServiceMetricsViewAggregationQueryOptions(
    client,
    request,
    options,
  );
  return createQuery(queryOptions, queryClient);
}

/**
 * Raw RPC call: QueryService.MetricsViewToplist
 */
export async function queryServiceMetricsViewToplist(
  client: RuntimeClient,
  request: Omit<V1MetricsViewToplistRequest, "instanceId">,
  options?: { signal?: AbortSignal },
): Promise<V1MetricsViewToplistResponse> {
  const r = await client.queryService.metricsViewToplist(
    MetricsViewToplistRequest.fromJson(
      stripUndefined({
        instanceId: client.instanceId,
        ...request,
      }) as unknown as JsonValue,
    ),
    { signal: options?.signal },
  );
  return r.toJson({
    emitDefaultValues: true,
  }) as unknown as V1MetricsViewToplistResponse;
}

export function getQueryServiceMetricsViewToplistQueryKey(
  instanceId: string,
  request?: Omit<V1MetricsViewToplistRequest, "instanceId">,
): QueryKey {
  return [
    "QueryService",
    "metricsViewToplist",
    instanceId,
    request ?? {},
  ] as const;
}

export function getQueryServiceMetricsViewToplistQueryOptions<
  TData = V1MetricsViewToplistResponse,
>(
  client: RuntimeClient,
  request: Omit<V1MetricsViewToplistRequest, "instanceId">,
  options?: {
    query?: Partial<
      CreateQueryOptions<V1MetricsViewToplistResponse, Error, TData>
    >;
  },
): CreateQueryOptions<V1MetricsViewToplistResponse, Error, TData> & {
  queryKey: QueryKey;
} {
  const queryKey = getQueryServiceMetricsViewToplistQueryKey(
    client.instanceId,
    request,
  );
  const queryFn: QueryFunction<V1MetricsViewToplistResponse> = ({ signal }) =>
    queryServiceMetricsViewToplist(client, request, { signal });
  return {
    queryKey,
    queryFn,
    enabled: !!client.instanceId,
    ...options?.query,
  } as CreateQueryOptions<V1MetricsViewToplistResponse, Error, TData> & {
    queryKey: QueryKey;
  };
}

export function createQueryServiceMetricsViewToplist<
  TData = V1MetricsViewToplistResponse,
>(
  client: RuntimeClient,
  request: Omit<V1MetricsViewToplistRequest, "instanceId">,
  options?: {
    query?: Partial<
      CreateQueryOptions<V1MetricsViewToplistResponse, Error, TData>
    >;
  },
  queryClient?: QueryClient,
): CreateQueryResult<TData, Error> {
  const queryOptions = getQueryServiceMetricsViewToplistQueryOptions(
    client,
    request,
    options,
  );
  return createQuery(queryOptions, queryClient);
}

/**
 * Raw RPC call: QueryService.MetricsViewComparison
 */
export async function queryServiceMetricsViewComparison(
  client: RuntimeClient,
  request: Omit<V1MetricsViewComparisonRequest, "instanceId">,
  options?: { signal?: AbortSignal },
): Promise<V1MetricsViewComparisonResponse> {
  const r = await client.queryService.metricsViewComparison(
    MetricsViewComparisonRequest.fromJson(
      stripUndefined({
        instanceId: client.instanceId,
        ...request,
      }) as unknown as JsonValue,
    ),
    { signal: options?.signal },
  );
  return r.toJson({
    emitDefaultValues: true,
  }) as unknown as V1MetricsViewComparisonResponse;
}

export function getQueryServiceMetricsViewComparisonQueryKey(
  instanceId: string,
  request?: Omit<V1MetricsViewComparisonRequest, "instanceId">,
): QueryKey {
  return [
    "QueryService",
    "metricsViewComparison",
    instanceId,
    request ?? {},
  ] as const;
}

export function getQueryServiceMetricsViewComparisonQueryOptions<
  TData = V1MetricsViewComparisonResponse,
>(
  client: RuntimeClient,
  request: Omit<V1MetricsViewComparisonRequest, "instanceId">,
  options?: {
    query?: Partial<
      CreateQueryOptions<V1MetricsViewComparisonResponse, Error, TData>
    >;
  },
): CreateQueryOptions<V1MetricsViewComparisonResponse, Error, TData> & {
  queryKey: QueryKey;
} {
  const queryKey = getQueryServiceMetricsViewComparisonQueryKey(
    client.instanceId,
    request,
  );
  const queryFn: QueryFunction<V1MetricsViewComparisonResponse> = ({
    signal,
  }) => queryServiceMetricsViewComparison(client, request, { signal });
  return {
    queryKey,
    queryFn,
    enabled: !!client.instanceId,
    ...options?.query,
  } as CreateQueryOptions<V1MetricsViewComparisonResponse, Error, TData> & {
    queryKey: QueryKey;
  };
}

export function createQueryServiceMetricsViewComparison<
  TData = V1MetricsViewComparisonResponse,
>(
  client: RuntimeClient,
  request: Omit<V1MetricsViewComparisonRequest, "instanceId">,
  options?: {
    query?: Partial<
      CreateQueryOptions<V1MetricsViewComparisonResponse, Error, TData>
    >;
  },
  queryClient?: QueryClient,
): CreateQueryResult<TData, Error> {
  const queryOptions = getQueryServiceMetricsViewComparisonQueryOptions(
    client,
    request,
    options,
  );
  return createQuery(queryOptions, queryClient);
}

/**
 * Raw RPC call: QueryService.MetricsViewTimeSeries
 */
export async function queryServiceMetricsViewTimeSeries(
  client: RuntimeClient,
  request: Omit<V1MetricsViewTimeSeriesRequest, "instanceId">,
  options?: { signal?: AbortSignal },
): Promise<V1MetricsViewTimeSeriesResponse> {
  const r = await client.queryService.metricsViewTimeSeries(
    MetricsViewTimeSeriesRequest.fromJson(
      stripUndefined({
        instanceId: client.instanceId,
        ...request,
      }) as unknown as JsonValue,
    ),
    { signal: options?.signal },
  );
  return r.toJson({
    emitDefaultValues: true,
  }) as unknown as V1MetricsViewTimeSeriesResponse;
}

export function getQueryServiceMetricsViewTimeSeriesQueryKey(
  instanceId: string,
  request?: Omit<V1MetricsViewTimeSeriesRequest, "instanceId">,
): QueryKey {
  return [
    "QueryService",
    "metricsViewTimeSeries",
    instanceId,
    request ?? {},
  ] as const;
}

export function getQueryServiceMetricsViewTimeSeriesQueryOptions<
  TData = V1MetricsViewTimeSeriesResponse,
>(
  client: RuntimeClient,
  request: Omit<V1MetricsViewTimeSeriesRequest, "instanceId">,
  options?: {
    query?: Partial<
      CreateQueryOptions<V1MetricsViewTimeSeriesResponse, Error, TData>
    >;
  },
): CreateQueryOptions<V1MetricsViewTimeSeriesResponse, Error, TData> & {
  queryKey: QueryKey;
} {
  const queryKey = getQueryServiceMetricsViewTimeSeriesQueryKey(
    client.instanceId,
    request,
  );
  const queryFn: QueryFunction<V1MetricsViewTimeSeriesResponse> = ({
    signal,
  }) => queryServiceMetricsViewTimeSeries(client, request, { signal });
  return {
    queryKey,
    queryFn,
    enabled: !!client.instanceId,
    ...options?.query,
  } as CreateQueryOptions<V1MetricsViewTimeSeriesResponse, Error, TData> & {
    queryKey: QueryKey;
  };
}

export function createQueryServiceMetricsViewTimeSeries<
  TData = V1MetricsViewTimeSeriesResponse,
>(
  client: RuntimeClient,
  request: Omit<V1MetricsViewTimeSeriesRequest, "instanceId">,
  options?: {
    query?: Partial<
      CreateQueryOptions<V1MetricsViewTimeSeriesResponse, Error, TData>
    >;
  },
  queryClient?: QueryClient,
): CreateQueryResult<TData, Error> {
  const queryOptions = getQueryServiceMetricsViewTimeSeriesQueryOptions(
    client,
    request,
    options,
  );
  return createQuery(queryOptions, queryClient);
}

/**
 * Raw RPC call: QueryService.MetricsViewTotals
 */
export async function queryServiceMetricsViewTotals(
  client: RuntimeClient,
  request: Omit<V1MetricsViewTotalsRequest, "instanceId">,
  options?: { signal?: AbortSignal },
): Promise<V1MetricsViewTotalsResponse> {
  const r = await client.queryService.metricsViewTotals(
    MetricsViewTotalsRequest.fromJson(
      stripUndefined({
        instanceId: client.instanceId,
        ...request,
      }) as unknown as JsonValue,
    ),
    { signal: options?.signal },
  );
  return r.toJson({
    emitDefaultValues: true,
  }) as unknown as V1MetricsViewTotalsResponse;
}

export function getQueryServiceMetricsViewTotalsQueryKey(
  instanceId: string,
  request?: Omit<V1MetricsViewTotalsRequest, "instanceId">,
): QueryKey {
  return [
    "QueryService",
    "metricsViewTotals",
    instanceId,
    request ?? {},
  ] as const;
}

export function getQueryServiceMetricsViewTotalsQueryOptions<
  TData = V1MetricsViewTotalsResponse,
>(
  client: RuntimeClient,
  request: Omit<V1MetricsViewTotalsRequest, "instanceId">,
  options?: {
    query?: Partial<
      CreateQueryOptions<V1MetricsViewTotalsResponse, Error, TData>
    >;
  },
): CreateQueryOptions<V1MetricsViewTotalsResponse, Error, TData> & {
  queryKey: QueryKey;
} {
  const queryKey = getQueryServiceMetricsViewTotalsQueryKey(
    client.instanceId,
    request,
  );
  const queryFn: QueryFunction<V1MetricsViewTotalsResponse> = ({ signal }) =>
    queryServiceMetricsViewTotals(client, request, { signal });
  return {
    queryKey,
    queryFn,
    enabled: !!client.instanceId,
    ...options?.query,
  } as CreateQueryOptions<V1MetricsViewTotalsResponse, Error, TData> & {
    queryKey: QueryKey;
  };
}

export function createQueryServiceMetricsViewTotals<
  TData = V1MetricsViewTotalsResponse,
>(
  client: RuntimeClient,
  request: Omit<V1MetricsViewTotalsRequest, "instanceId">,
  options?: {
    query?: Partial<
      CreateQueryOptions<V1MetricsViewTotalsResponse, Error, TData>
    >;
  },
  queryClient?: QueryClient,
): CreateQueryResult<TData, Error> {
  const queryOptions = getQueryServiceMetricsViewTotalsQueryOptions(
    client,
    request,
    options,
  );
  return createQuery(queryOptions, queryClient);
}

/**
 * Raw RPC call: QueryService.MetricsViewRows
 */
export async function queryServiceMetricsViewRows(
  client: RuntimeClient,
  request: Omit<V1MetricsViewRowsRequest, "instanceId">,
  options?: { signal?: AbortSignal },
): Promise<V1MetricsViewRowsResponse> {
  const r = await client.queryService.metricsViewRows(
    MetricsViewRowsRequest.fromJson(
      stripUndefined({
        instanceId: client.instanceId,
        ...request,
      }) as unknown as JsonValue,
    ),
    { signal: options?.signal },
  );
  return r.toJson({
    emitDefaultValues: true,
  }) as unknown as V1MetricsViewRowsResponse;
}

export function getQueryServiceMetricsViewRowsQueryKey(
  instanceId: string,
  request?: Omit<V1MetricsViewRowsRequest, "instanceId">,
): QueryKey {
  return [
    "QueryService",
    "metricsViewRows",
    instanceId,
    request ?? {},
  ] as const;
}

export function getQueryServiceMetricsViewRowsQueryOptions<
  TData = V1MetricsViewRowsResponse,
>(
  client: RuntimeClient,
  request: Omit<V1MetricsViewRowsRequest, "instanceId">,
  options?: {
    query?: Partial<
      CreateQueryOptions<V1MetricsViewRowsResponse, Error, TData>
    >;
  },
): CreateQueryOptions<V1MetricsViewRowsResponse, Error, TData> & {
  queryKey: QueryKey;
} {
  const queryKey = getQueryServiceMetricsViewRowsQueryKey(
    client.instanceId,
    request,
  );
  const queryFn: QueryFunction<V1MetricsViewRowsResponse> = ({ signal }) =>
    queryServiceMetricsViewRows(client, request, { signal });
  return {
    queryKey,
    queryFn,
    enabled: !!client.instanceId,
    ...options?.query,
  } as CreateQueryOptions<V1MetricsViewRowsResponse, Error, TData> & {
    queryKey: QueryKey;
  };
}

export function createQueryServiceMetricsViewRows<
  TData = V1MetricsViewRowsResponse,
>(
  client: RuntimeClient,
  request: Omit<V1MetricsViewRowsRequest, "instanceId">,
  options?: {
    query?: Partial<
      CreateQueryOptions<V1MetricsViewRowsResponse, Error, TData>
    >;
  },
  queryClient?: QueryClient,
): CreateQueryResult<TData, Error> {
  const queryOptions = getQueryServiceMetricsViewRowsQueryOptions(
    client,
    request,
    options,
  );
  return createQuery(queryOptions, queryClient);
}

/**
 * Raw RPC call: QueryService.MetricsViewTimeRange
 */
export async function queryServiceMetricsViewTimeRange(
  client: RuntimeClient,
  request: Omit<PartialMessage<MetricsViewTimeRangeRequest>, "instanceId">,
  options?: { signal?: AbortSignal },
): Promise<V1MetricsViewTimeRangeResponse> {
  const r = await client.queryService.metricsViewTimeRange(
    MetricsViewTimeRangeRequest.fromJson(
      stripUndefined({
        instanceId: client.instanceId,
        ...request,
      }) as unknown as JsonValue,
    ),
    { signal: options?.signal },
  );
  return r.toJson({
    emitDefaultValues: true,
  }) as unknown as V1MetricsViewTimeRangeResponse;
}

export function getQueryServiceMetricsViewTimeRangeQueryKey(
  instanceId: string,
  request?: Omit<PartialMessage<MetricsViewTimeRangeRequest>, "instanceId">,
): QueryKey {
  return [
    "QueryService",
    "metricsViewTimeRange",
    instanceId,
    request ?? {},
  ] as const;
}

export function getQueryServiceMetricsViewTimeRangeQueryOptions<
  TData = V1MetricsViewTimeRangeResponse,
>(
  client: RuntimeClient,
  request: Omit<PartialMessage<MetricsViewTimeRangeRequest>, "instanceId">,
  options?: {
    query?: Partial<
      CreateQueryOptions<V1MetricsViewTimeRangeResponse, Error, TData>
    >;
  },
): CreateQueryOptions<V1MetricsViewTimeRangeResponse, Error, TData> & {
  queryKey: QueryKey;
} {
  const queryKey = getQueryServiceMetricsViewTimeRangeQueryKey(
    client.instanceId,
    request,
  );
  const queryFn: QueryFunction<V1MetricsViewTimeRangeResponse> = ({ signal }) =>
    queryServiceMetricsViewTimeRange(client, request, { signal });
  return {
    queryKey,
    queryFn,
    enabled: !!client.instanceId,
    ...options?.query,
  } as CreateQueryOptions<V1MetricsViewTimeRangeResponse, Error, TData> & {
    queryKey: QueryKey;
  };
}

export function createQueryServiceMetricsViewTimeRange<
  TData = V1MetricsViewTimeRangeResponse,
>(
  client: RuntimeClient,
  request: Omit<PartialMessage<MetricsViewTimeRangeRequest>, "instanceId">,
  options?: {
    query?: Partial<
      CreateQueryOptions<V1MetricsViewTimeRangeResponse, Error, TData>
    >;
  },
  queryClient?: QueryClient,
): CreateQueryResult<TData, Error> {
  const queryOptions = getQueryServiceMetricsViewTimeRangeQueryOptions(
    client,
    request,
    options,
  );
  return createQuery(queryOptions, queryClient);
}

/**
 * Raw RPC call: QueryService.MetricsViewSchema
 */
export async function queryServiceMetricsViewSchema(
  client: RuntimeClient,
  request: Omit<PartialMessage<MetricsViewSchemaRequest>, "instanceId">,
  options?: { signal?: AbortSignal },
): Promise<V1MetricsViewSchemaResponse> {
  const r = await client.queryService.metricsViewSchema(
    MetricsViewSchemaRequest.fromJson(
      stripUndefined({
        instanceId: client.instanceId,
        ...request,
      }) as unknown as JsonValue,
    ),
    { signal: options?.signal },
  );
  return r.toJson({
    emitDefaultValues: true,
  }) as unknown as V1MetricsViewSchemaResponse;
}

export function getQueryServiceMetricsViewSchemaQueryKey(
  instanceId: string,
  request?: Omit<PartialMessage<MetricsViewSchemaRequest>, "instanceId">,
): QueryKey {
  return [
    "QueryService",
    "metricsViewSchema",
    instanceId,
    request ?? {},
  ] as const;
}

export function getQueryServiceMetricsViewSchemaQueryOptions<
  TData = V1MetricsViewSchemaResponse,
>(
  client: RuntimeClient,
  request: Omit<PartialMessage<MetricsViewSchemaRequest>, "instanceId">,
  options?: {
    query?: Partial<
      CreateQueryOptions<V1MetricsViewSchemaResponse, Error, TData>
    >;
  },
): CreateQueryOptions<V1MetricsViewSchemaResponse, Error, TData> & {
  queryKey: QueryKey;
} {
  const queryKey = getQueryServiceMetricsViewSchemaQueryKey(
    client.instanceId,
    request,
  );
  const queryFn: QueryFunction<V1MetricsViewSchemaResponse> = ({ signal }) =>
    queryServiceMetricsViewSchema(client, request, { signal });
  return {
    queryKey,
    queryFn,
    enabled: !!client.instanceId,
    ...options?.query,
  } as CreateQueryOptions<V1MetricsViewSchemaResponse, Error, TData> & {
    queryKey: QueryKey;
  };
}

export function createQueryServiceMetricsViewSchema<
  TData = V1MetricsViewSchemaResponse,
>(
  client: RuntimeClient,
  request: Omit<PartialMessage<MetricsViewSchemaRequest>, "instanceId">,
  options?: {
    query?: Partial<
      CreateQueryOptions<V1MetricsViewSchemaResponse, Error, TData>
    >;
  },
  queryClient?: QueryClient,
): CreateQueryResult<TData, Error> {
  const queryOptions = getQueryServiceMetricsViewSchemaQueryOptions(
    client,
    request,
    options,
  );
  return createQuery(queryOptions, queryClient);
}

/**
 * Raw RPC call: QueryService.MetricsViewSearch
 */
export async function queryServiceMetricsViewSearch(
  client: RuntimeClient,
  request: Omit<PartialMessage<MetricsViewSearchRequest>, "instanceId">,
  options?: { signal?: AbortSignal },
): Promise<V1MetricsViewSearchResponse> {
  const r = await client.queryService.metricsViewSearch(
    MetricsViewSearchRequest.fromJson(
      stripUndefined({
        instanceId: client.instanceId,
        ...request,
      }) as unknown as JsonValue,
    ),
    { signal: options?.signal },
  );
  return r.toJson({
    emitDefaultValues: true,
  }) as unknown as V1MetricsViewSearchResponse;
}

export function getQueryServiceMetricsViewSearchQueryKey(
  instanceId: string,
  request?: Omit<PartialMessage<MetricsViewSearchRequest>, "instanceId">,
): QueryKey {
  return [
    "QueryService",
    "metricsViewSearch",
    instanceId,
    request ?? {},
  ] as const;
}

export function getQueryServiceMetricsViewSearchQueryOptions<
  TData = V1MetricsViewSearchResponse,
>(
  client: RuntimeClient,
  request: Omit<PartialMessage<MetricsViewSearchRequest>, "instanceId">,
  options?: {
    query?: Partial<
      CreateQueryOptions<V1MetricsViewSearchResponse, Error, TData>
    >;
  },
): CreateQueryOptions<V1MetricsViewSearchResponse, Error, TData> & {
  queryKey: QueryKey;
} {
  const queryKey = getQueryServiceMetricsViewSearchQueryKey(
    client.instanceId,
    request,
  );
  const queryFn: QueryFunction<V1MetricsViewSearchResponse> = ({ signal }) =>
    queryServiceMetricsViewSearch(client, request, { signal });
  return {
    queryKey,
    queryFn,
    enabled: !!client.instanceId,
    ...options?.query,
  } as CreateQueryOptions<V1MetricsViewSearchResponse, Error, TData> & {
    queryKey: QueryKey;
  };
}

export function createQueryServiceMetricsViewSearch<
  TData = V1MetricsViewSearchResponse,
>(
  client: RuntimeClient,
  request: Omit<PartialMessage<MetricsViewSearchRequest>, "instanceId">,
  options?: {
    query?: Partial<
      CreateQueryOptions<V1MetricsViewSearchResponse, Error, TData>
    >;
  },
  queryClient?: QueryClient,
): CreateQueryResult<TData, Error> {
  const queryOptions = getQueryServiceMetricsViewSearchQueryOptions(
    client,
    request,
    options,
  );
  return createQuery(queryOptions, queryClient);
}

/**
 * Raw RPC call: QueryService.MetricsViewTimeRanges
 */
export async function queryServiceMetricsViewTimeRanges(
  client: RuntimeClient,
  request: Omit<PartialMessage<MetricsViewTimeRangesRequest>, "instanceId">,
  options?: { signal?: AbortSignal },
): Promise<V1MetricsViewTimeRangesResponse> {
  const r = await client.queryService.metricsViewTimeRanges(
    MetricsViewTimeRangesRequest.fromJson(
      stripUndefined({
        instanceId: client.instanceId,
        ...request,
      }) as unknown as JsonValue,
    ),
    { signal: options?.signal },
  );
  return r.toJson({
    emitDefaultValues: true,
  }) as unknown as V1MetricsViewTimeRangesResponse;
}

export function getQueryServiceMetricsViewTimeRangesQueryKey(
  instanceId: string,
  request?: Omit<PartialMessage<MetricsViewTimeRangesRequest>, "instanceId">,
): QueryKey {
  return [
    "QueryService",
    "metricsViewTimeRanges",
    instanceId,
    request ?? {},
  ] as const;
}

export function getQueryServiceMetricsViewTimeRangesQueryOptions<
  TData = V1MetricsViewTimeRangesResponse,
>(
  client: RuntimeClient,
  request: Omit<PartialMessage<MetricsViewTimeRangesRequest>, "instanceId">,
  options?: {
    query?: Partial<
      CreateQueryOptions<V1MetricsViewTimeRangesResponse, Error, TData>
    >;
  },
): CreateQueryOptions<V1MetricsViewTimeRangesResponse, Error, TData> & {
  queryKey: QueryKey;
} {
  const queryKey = getQueryServiceMetricsViewTimeRangesQueryKey(
    client.instanceId,
    request,
  );
  const queryFn: QueryFunction<V1MetricsViewTimeRangesResponse> = ({
    signal,
  }) => queryServiceMetricsViewTimeRanges(client, request, { signal });
  return {
    queryKey,
    queryFn,
    enabled: !!client.instanceId,
    ...options?.query,
  } as CreateQueryOptions<V1MetricsViewTimeRangesResponse, Error, TData> & {
    queryKey: QueryKey;
  };
}

export function createQueryServiceMetricsViewTimeRanges<
  TData = V1MetricsViewTimeRangesResponse,
>(
  client: RuntimeClient,
  request: Omit<PartialMessage<MetricsViewTimeRangesRequest>, "instanceId">,
  options?: {
    query?: Partial<
      CreateQueryOptions<V1MetricsViewTimeRangesResponse, Error, TData>
    >;
  },
  queryClient?: QueryClient,
): CreateQueryResult<TData, Error> {
  const queryOptions = getQueryServiceMetricsViewTimeRangesQueryOptions(
    client,
    request,
    options,
  );
  return createQuery(queryOptions, queryClient);
}

/**
 * Raw RPC call: QueryService.MetricsViewAnnotations
 */
export async function queryServiceMetricsViewAnnotations(
  client: RuntimeClient,
  request: Omit<PartialMessage<MetricsViewAnnotationsRequest>, "instanceId">,
  options?: { signal?: AbortSignal },
): Promise<V1MetricsViewAnnotationsResponse> {
  const r = await client.queryService.metricsViewAnnotations(
    MetricsViewAnnotationsRequest.fromJson(
      stripUndefined({
        instanceId: client.instanceId,
        ...request,
      }) as unknown as JsonValue,
    ),
    { signal: options?.signal },
  );
  return r.toJson({
    emitDefaultValues: true,
  }) as unknown as V1MetricsViewAnnotationsResponse;
}

export function getQueryServiceMetricsViewAnnotationsQueryKey(
  instanceId: string,
  request?: Omit<PartialMessage<MetricsViewAnnotationsRequest>, "instanceId">,
): QueryKey {
  return [
    "QueryService",
    "metricsViewAnnotations",
    instanceId,
    request ?? {},
  ] as const;
}

export function getQueryServiceMetricsViewAnnotationsQueryOptions<
  TData = V1MetricsViewAnnotationsResponse,
>(
  client: RuntimeClient,
  request: Omit<PartialMessage<MetricsViewAnnotationsRequest>, "instanceId">,
  options?: {
    query?: Partial<
      CreateQueryOptions<V1MetricsViewAnnotationsResponse, Error, TData>
    >;
  },
): CreateQueryOptions<V1MetricsViewAnnotationsResponse, Error, TData> & {
  queryKey: QueryKey;
} {
  const queryKey = getQueryServiceMetricsViewAnnotationsQueryKey(
    client.instanceId,
    request,
  );
  const queryFn: QueryFunction<V1MetricsViewAnnotationsResponse> = ({
    signal,
  }) => queryServiceMetricsViewAnnotations(client, request, { signal });
  return {
    queryKey,
    queryFn,
    enabled: !!client.instanceId,
    ...options?.query,
  } as CreateQueryOptions<V1MetricsViewAnnotationsResponse, Error, TData> & {
    queryKey: QueryKey;
  };
}

export function createQueryServiceMetricsViewAnnotations<
  TData = V1MetricsViewAnnotationsResponse,
>(
  client: RuntimeClient,
  request: Omit<PartialMessage<MetricsViewAnnotationsRequest>, "instanceId">,
  options?: {
    query?: Partial<
      CreateQueryOptions<V1MetricsViewAnnotationsResponse, Error, TData>
    >;
  },
  queryClient?: QueryClient,
): CreateQueryResult<TData, Error> {
  const queryOptions = getQueryServiceMetricsViewAnnotationsQueryOptions(
    client,
    request,
    options,
  );
  return createQuery(queryOptions, queryClient);
}

/**
 * Raw RPC call: QueryService.ConvertExpressionToMetricsSQL
 */
export async function queryServiceConvertExpressionToMetricsSQL(
  client: RuntimeClient,
  request: Omit<
    PartialMessage<ConvertExpressionToMetricsSQLRequest>,
    "instanceId"
  >,
  options?: { signal?: AbortSignal },
): Promise<V1ConvertExpressionToMetricsSQLResponse> {
  const r = await client.queryService.convertExpressionToMetricsSQL(
    ConvertExpressionToMetricsSQLRequest.fromJson(
      stripUndefined({
        instanceId: client.instanceId,
        ...request,
      }) as unknown as JsonValue,
    ),
    { signal: options?.signal },
  );
  return r.toJson({
    emitDefaultValues: true,
  }) as unknown as V1ConvertExpressionToMetricsSQLResponse;
}

export function getQueryServiceConvertExpressionToMetricsSQLQueryKey(
  instanceId: string,
  request?: Omit<
    PartialMessage<ConvertExpressionToMetricsSQLRequest>,
    "instanceId"
  >,
): QueryKey {
  return [
    "QueryService",
    "convertExpressionToMetricsSQL",
    instanceId,
    request ?? {},
  ] as const;
}

export function getQueryServiceConvertExpressionToMetricsSQLQueryOptions<
  TData = V1ConvertExpressionToMetricsSQLResponse,
>(
  client: RuntimeClient,
  request: Omit<
    PartialMessage<ConvertExpressionToMetricsSQLRequest>,
    "instanceId"
  >,
  options?: {
    query?: Partial<
      CreateQueryOptions<V1ConvertExpressionToMetricsSQLResponse, Error, TData>
    >;
  },
): CreateQueryOptions<V1ConvertExpressionToMetricsSQLResponse, Error, TData> & {
  queryKey: QueryKey;
} {
  const queryKey = getQueryServiceConvertExpressionToMetricsSQLQueryKey(
    client.instanceId,
    request,
  );
  const queryFn: QueryFunction<V1ConvertExpressionToMetricsSQLResponse> = ({
    signal,
  }) => queryServiceConvertExpressionToMetricsSQL(client, request, { signal });
  return {
    queryKey,
    queryFn,
    enabled: !!client.instanceId,
    ...options?.query,
  } as CreateQueryOptions<
    V1ConvertExpressionToMetricsSQLResponse,
    Error,
    TData
  > & { queryKey: QueryKey };
}

export function createQueryServiceConvertExpressionToMetricsSQL<
  TData = V1ConvertExpressionToMetricsSQLResponse,
>(
  client: RuntimeClient,
  request: Omit<
    PartialMessage<ConvertExpressionToMetricsSQLRequest>,
    "instanceId"
  >,
  options?: {
    query?: Partial<
      CreateQueryOptions<V1ConvertExpressionToMetricsSQLResponse, Error, TData>
    >;
  },
  queryClient?: QueryClient,
): CreateQueryResult<TData, Error> {
  const queryOptions = getQueryServiceConvertExpressionToMetricsSQLQueryOptions(
    client,
    request,
    options,
  );
  return createQuery(queryOptions, queryClient);
}

/**
 * Raw RPC call: QueryService.ResolveCanvas
 */
export async function queryServiceResolveCanvas(
  client: RuntimeClient,
  request: Omit<PartialMessage<ResolveCanvasRequest>, "instanceId">,
  options?: { signal?: AbortSignal },
): Promise<V1ResolveCanvasResponse> {
  const r = await client.queryService.resolveCanvas(
    ResolveCanvasRequest.fromJson(
      stripUndefined({
        instanceId: client.instanceId,
        ...request,
      }) as unknown as JsonValue,
    ),
    { signal: options?.signal },
  );
  return r.toJson({
    emitDefaultValues: true,
  }) as unknown as V1ResolveCanvasResponse;
}

export function getQueryServiceResolveCanvasQueryKey(
  instanceId: string,
  request?: Omit<PartialMessage<ResolveCanvasRequest>, "instanceId">,
): QueryKey {
  return ["QueryService", "resolveCanvas", instanceId, request ?? {}] as const;
}

export function getQueryServiceResolveCanvasQueryOptions<
  TData = V1ResolveCanvasResponse,
>(
  client: RuntimeClient,
  request: Omit<PartialMessage<ResolveCanvasRequest>, "instanceId">,
  options?: {
    query?: Partial<CreateQueryOptions<V1ResolveCanvasResponse, Error, TData>>;
  },
): CreateQueryOptions<V1ResolveCanvasResponse, Error, TData> & {
  queryKey: QueryKey;
} {
  const queryKey = getQueryServiceResolveCanvasQueryKey(
    client.instanceId,
    request,
  );
  const queryFn: QueryFunction<V1ResolveCanvasResponse> = ({ signal }) =>
    queryServiceResolveCanvas(client, request, { signal });
  return {
    queryKey,
    queryFn,
    enabled: !!client.instanceId,
    ...options?.query,
  } as CreateQueryOptions<V1ResolveCanvasResponse, Error, TData> & {
    queryKey: QueryKey;
  };
}

export function createQueryServiceResolveCanvas<
  TData = V1ResolveCanvasResponse,
>(
  client: RuntimeClient,
  request: Omit<PartialMessage<ResolveCanvasRequest>, "instanceId">,
  options?: {
    query?: Partial<CreateQueryOptions<V1ResolveCanvasResponse, Error, TData>>;
  },
  queryClient?: QueryClient,
): CreateQueryResult<TData, Error> {
  const queryOptions = getQueryServiceResolveCanvasQueryOptions(
    client,
    request,
    options,
  );
  return createQuery(queryOptions, queryClient);
}

/**
 * Raw RPC call: QueryService.ResolveComponent
 */
export async function queryServiceResolveComponent(
  client: RuntimeClient,
  request: Omit<PartialMessage<ResolveComponentRequest>, "instanceId">,
  options?: { signal?: AbortSignal },
): Promise<V1ResolveComponentResponse> {
  const r = await client.queryService.resolveComponent(
    ResolveComponentRequest.fromJson(
      stripUndefined({
        instanceId: client.instanceId,
        ...request,
      }) as unknown as JsonValue,
    ),
    { signal: options?.signal },
  );
  return r.toJson({
    emitDefaultValues: true,
  }) as unknown as V1ResolveComponentResponse;
}

export function getQueryServiceResolveComponentQueryKey(
  instanceId: string,
  request?: Omit<PartialMessage<ResolveComponentRequest>, "instanceId">,
): QueryKey {
  return [
    "QueryService",
    "resolveComponent",
    instanceId,
    request ?? {},
  ] as const;
}

export function getQueryServiceResolveComponentQueryOptions<
  TData = V1ResolveComponentResponse,
>(
  client: RuntimeClient,
  request: Omit<PartialMessage<ResolveComponentRequest>, "instanceId">,
  options?: {
    query?: Partial<
      CreateQueryOptions<V1ResolveComponentResponse, Error, TData>
    >;
  },
): CreateQueryOptions<V1ResolveComponentResponse, Error, TData> & {
  queryKey: QueryKey;
} {
  const queryKey = getQueryServiceResolveComponentQueryKey(
    client.instanceId,
    request,
  );
  const queryFn: QueryFunction<V1ResolveComponentResponse> = ({ signal }) =>
    queryServiceResolveComponent(client, request, { signal });
  return {
    queryKey,
    queryFn,
    enabled: !!client.instanceId,
    ...options?.query,
  } as CreateQueryOptions<V1ResolveComponentResponse, Error, TData> & {
    queryKey: QueryKey;
  };
}

export function createQueryServiceResolveComponent<
  TData = V1ResolveComponentResponse,
>(
  client: RuntimeClient,
  request: Omit<PartialMessage<ResolveComponentRequest>, "instanceId">,
  options?: {
    query?: Partial<
      CreateQueryOptions<V1ResolveComponentResponse, Error, TData>
    >;
  },
  queryClient?: QueryClient,
): CreateQueryResult<TData, Error> {
  const queryOptions = getQueryServiceResolveComponentQueryOptions(
    client,
    request,
    options,
  );
  return createQuery(queryOptions, queryClient);
}

/**
 * Raw RPC call: QueryService.ResolveTemplatedString
 */
export async function queryServiceResolveTemplatedString(
  client: RuntimeClient,
  request: Omit<PartialMessage<ResolveTemplatedStringRequest>, "instanceId">,
  options?: { signal?: AbortSignal },
): Promise<V1ResolveTemplatedStringResponse> {
  const r = await client.queryService.resolveTemplatedString(
    ResolveTemplatedStringRequest.fromJson(
      stripUndefined({
        instanceId: client.instanceId,
        ...request,
      }) as unknown as JsonValue,
    ),
    { signal: options?.signal },
  );
  return r.toJson({
    emitDefaultValues: true,
  }) as unknown as V1ResolveTemplatedStringResponse;
}

export function getQueryServiceResolveTemplatedStringQueryKey(
  instanceId: string,
  request?: Omit<PartialMessage<ResolveTemplatedStringRequest>, "instanceId">,
): QueryKey {
  return [
    "QueryService",
    "resolveTemplatedString",
    instanceId,
    request ?? {},
  ] as const;
}

export function getQueryServiceResolveTemplatedStringQueryOptions<
  TData = V1ResolveTemplatedStringResponse,
>(
  client: RuntimeClient,
  request: Omit<PartialMessage<ResolveTemplatedStringRequest>, "instanceId">,
  options?: {
    query?: Partial<
      CreateQueryOptions<V1ResolveTemplatedStringResponse, Error, TData>
    >;
  },
): CreateQueryOptions<V1ResolveTemplatedStringResponse, Error, TData> & {
  queryKey: QueryKey;
} {
  const queryKey = getQueryServiceResolveTemplatedStringQueryKey(
    client.instanceId,
    request,
  );
  const queryFn: QueryFunction<V1ResolveTemplatedStringResponse> = ({
    signal,
  }) => queryServiceResolveTemplatedString(client, request, { signal });
  return {
    queryKey,
    queryFn,
    enabled: !!client.instanceId,
    ...options?.query,
  } as CreateQueryOptions<V1ResolveTemplatedStringResponse, Error, TData> & {
    queryKey: QueryKey;
  };
}

export function createQueryServiceResolveTemplatedString<
  TData = V1ResolveTemplatedStringResponse,
>(
  client: RuntimeClient,
  request: Omit<PartialMessage<ResolveTemplatedStringRequest>, "instanceId">,
  options?: {
    query?: Partial<
      CreateQueryOptions<V1ResolveTemplatedStringResponse, Error, TData>
    >;
  },
  queryClient?: QueryClient,
): CreateQueryResult<TData, Error> {
  const queryOptions = getQueryServiceResolveTemplatedStringQueryOptions(
    client,
    request,
    options,
  );
  return createQuery(queryOptions, queryClient);
}

/**
 * Raw RPC call: QueryService.ColumnRollupInterval
 */
export async function queryServiceColumnRollupInterval(
  client: RuntimeClient,
  request: Omit<V1ColumnRollupIntervalRequest, "instanceId">,
  options?: { signal?: AbortSignal },
): Promise<V1ColumnRollupIntervalResponse> {
  const r = await client.queryService.columnRollupInterval(
    ColumnRollupIntervalRequest.fromJson(
      stripUndefined({
        instanceId: client.instanceId,
        ...request,
      }) as unknown as JsonValue,
    ),
    { signal: options?.signal },
  );
  return r.toJson({
    emitDefaultValues: true,
  }) as unknown as V1ColumnRollupIntervalResponse;
}

export function getQueryServiceColumnRollupIntervalQueryKey(
  instanceId: string,
  request?: Omit<V1ColumnRollupIntervalRequest, "instanceId">,
): QueryKey {
  return [
    "QueryService",
    "columnRollupInterval",
    instanceId,
    request ?? {},
  ] as const;
}

export function getQueryServiceColumnRollupIntervalQueryOptions<
  TData = V1ColumnRollupIntervalResponse,
>(
  client: RuntimeClient,
  request: Omit<V1ColumnRollupIntervalRequest, "instanceId">,
  options?: {
    query?: Partial<
      CreateQueryOptions<V1ColumnRollupIntervalResponse, Error, TData>
    >;
  },
): CreateQueryOptions<V1ColumnRollupIntervalResponse, Error, TData> & {
  queryKey: QueryKey;
} {
  const queryKey = getQueryServiceColumnRollupIntervalQueryKey(
    client.instanceId,
    request,
  );
  const queryFn: QueryFunction<V1ColumnRollupIntervalResponse> = ({ signal }) =>
    queryServiceColumnRollupInterval(client, request, { signal });
  return {
    queryKey,
    queryFn,
    enabled: !!client.instanceId,
    ...options?.query,
  } as CreateQueryOptions<V1ColumnRollupIntervalResponse, Error, TData> & {
    queryKey: QueryKey;
  };
}

export function createQueryServiceColumnRollupInterval<
  TData = V1ColumnRollupIntervalResponse,
>(
  client: RuntimeClient,
  request: Omit<V1ColumnRollupIntervalRequest, "instanceId">,
  options?: {
    query?: Partial<
      CreateQueryOptions<V1ColumnRollupIntervalResponse, Error, TData>
    >;
  },
  queryClient?: QueryClient,
): CreateQueryResult<TData, Error> {
  const queryOptions = getQueryServiceColumnRollupIntervalQueryOptions(
    client,
    request,
    options,
  );
  return createQuery(queryOptions, queryClient);
}

/**
 * Raw RPC call: QueryService.ColumnTopK
 */
export async function queryServiceColumnTopK(
  client: RuntimeClient,
  request: Omit<V1ColumnTopKRequest, "instanceId">,
  options?: { signal?: AbortSignal },
): Promise<V1ColumnTopKResponse> {
  const r = await client.queryService.columnTopK(
    ColumnTopKRequest.fromJson(
      stripUndefined({
        instanceId: client.instanceId,
        ...request,
      }) as unknown as JsonValue,
    ),
    { signal: options?.signal },
  );
  return r.toJson({
    emitDefaultValues: true,
  }) as unknown as V1ColumnTopKResponse;
}

export function getQueryServiceColumnTopKQueryKey(
  instanceId: string,
  request?: Omit<V1ColumnTopKRequest, "instanceId">,
): QueryKey {
  return ["QueryService", "columnTopK", instanceId, request ?? {}] as const;
}

export function getQueryServiceColumnTopKQueryOptions<
  TData = V1ColumnTopKResponse,
>(
  client: RuntimeClient,
  request: Omit<V1ColumnTopKRequest, "instanceId">,
  options?: {
    query?: Partial<CreateQueryOptions<V1ColumnTopKResponse, Error, TData>>;
  },
): CreateQueryOptions<V1ColumnTopKResponse, Error, TData> & {
  queryKey: QueryKey;
} {
  const queryKey = getQueryServiceColumnTopKQueryKey(
    client.instanceId,
    request,
  );
  const queryFn: QueryFunction<V1ColumnTopKResponse> = ({ signal }) =>
    queryServiceColumnTopK(client, request, { signal });
  return {
    queryKey,
    queryFn,
    enabled: !!client.instanceId,
    ...options?.query,
  } as CreateQueryOptions<V1ColumnTopKResponse, Error, TData> & {
    queryKey: QueryKey;
  };
}

export function createQueryServiceColumnTopK<TData = V1ColumnTopKResponse>(
  client: RuntimeClient,
  request: Omit<V1ColumnTopKRequest, "instanceId">,
  options?: {
    query?: Partial<CreateQueryOptions<V1ColumnTopKResponse, Error, TData>>;
  },
  queryClient?: QueryClient,
): CreateQueryResult<TData, Error> {
  const queryOptions = getQueryServiceColumnTopKQueryOptions(
    client,
    request,
    options,
  );
  return createQuery(queryOptions, queryClient);
}

/**
 * Raw RPC call: QueryService.ColumnNullCount
 */
export async function queryServiceColumnNullCount(
  client: RuntimeClient,
  request: Omit<V1ColumnNullCountRequest, "instanceId">,
  options?: { signal?: AbortSignal },
): Promise<V1ColumnNullCountResponse> {
  const r = await client.queryService.columnNullCount(
    ColumnNullCountRequest.fromJson(
      stripUndefined({
        instanceId: client.instanceId,
        ...request,
      }) as unknown as JsonValue,
    ),
    { signal: options?.signal },
  );
  return r.toJson({
    emitDefaultValues: true,
  }) as unknown as V1ColumnNullCountResponse;
}

export function getQueryServiceColumnNullCountQueryKey(
  instanceId: string,
  request?: Omit<V1ColumnNullCountRequest, "instanceId">,
): QueryKey {
  return [
    "QueryService",
    "columnNullCount",
    instanceId,
    request ?? {},
  ] as const;
}

export function getQueryServiceColumnNullCountQueryOptions<
  TData = V1ColumnNullCountResponse,
>(
  client: RuntimeClient,
  request: Omit<V1ColumnNullCountRequest, "instanceId">,
  options?: {
    query?: Partial<
      CreateQueryOptions<V1ColumnNullCountResponse, Error, TData>
    >;
  },
): CreateQueryOptions<V1ColumnNullCountResponse, Error, TData> & {
  queryKey: QueryKey;
} {
  const queryKey = getQueryServiceColumnNullCountQueryKey(
    client.instanceId,
    request,
  );
  const queryFn: QueryFunction<V1ColumnNullCountResponse> = ({ signal }) =>
    queryServiceColumnNullCount(client, request, { signal });
  return {
    queryKey,
    queryFn,
    enabled: !!client.instanceId,
    ...options?.query,
  } as CreateQueryOptions<V1ColumnNullCountResponse, Error, TData> & {
    queryKey: QueryKey;
  };
}

export function createQueryServiceColumnNullCount<
  TData = V1ColumnNullCountResponse,
>(
  client: RuntimeClient,
  request: Omit<V1ColumnNullCountRequest, "instanceId">,
  options?: {
    query?: Partial<
      CreateQueryOptions<V1ColumnNullCountResponse, Error, TData>
    >;
  },
  queryClient?: QueryClient,
): CreateQueryResult<TData, Error> {
  const queryOptions = getQueryServiceColumnNullCountQueryOptions(
    client,
    request,
    options,
  );
  return createQuery(queryOptions, queryClient);
}

/**
 * Raw RPC call: QueryService.ColumnDescriptiveStatistics
 */
export async function queryServiceColumnDescriptiveStatistics(
  client: RuntimeClient,
  request: Omit<V1ColumnDescriptiveStatisticsRequest, "instanceId">,
  options?: { signal?: AbortSignal },
): Promise<V1ColumnDescriptiveStatisticsResponse> {
  const r = await client.queryService.columnDescriptiveStatistics(
    ColumnDescriptiveStatisticsRequest.fromJson(
      stripUndefined({
        instanceId: client.instanceId,
        ...request,
      }) as unknown as JsonValue,
    ),
    { signal: options?.signal },
  );
  return r.toJson({
    emitDefaultValues: true,
  }) as unknown as V1ColumnDescriptiveStatisticsResponse;
}

export function getQueryServiceColumnDescriptiveStatisticsQueryKey(
  instanceId: string,
  request?: Omit<V1ColumnDescriptiveStatisticsRequest, "instanceId">,
): QueryKey {
  return [
    "QueryService",
    "columnDescriptiveStatistics",
    instanceId,
    request ?? {},
  ] as const;
}

export function getQueryServiceColumnDescriptiveStatisticsQueryOptions<
  TData = V1ColumnDescriptiveStatisticsResponse,
>(
  client: RuntimeClient,
  request: Omit<V1ColumnDescriptiveStatisticsRequest, "instanceId">,
  options?: {
    query?: Partial<
      CreateQueryOptions<V1ColumnDescriptiveStatisticsResponse, Error, TData>
    >;
  },
): CreateQueryOptions<V1ColumnDescriptiveStatisticsResponse, Error, TData> & {
  queryKey: QueryKey;
} {
  const queryKey = getQueryServiceColumnDescriptiveStatisticsQueryKey(
    client.instanceId,
    request,
  );
  const queryFn: QueryFunction<V1ColumnDescriptiveStatisticsResponse> = ({
    signal,
  }) => queryServiceColumnDescriptiveStatistics(client, request, { signal });
  return {
    queryKey,
    queryFn,
    enabled: !!client.instanceId,
    ...options?.query,
  } as CreateQueryOptions<
    V1ColumnDescriptiveStatisticsResponse,
    Error,
    TData
  > & { queryKey: QueryKey };
}

export function createQueryServiceColumnDescriptiveStatistics<
  TData = V1ColumnDescriptiveStatisticsResponse,
>(
  client: RuntimeClient,
  request: Omit<V1ColumnDescriptiveStatisticsRequest, "instanceId">,
  options?: {
    query?: Partial<
      CreateQueryOptions<V1ColumnDescriptiveStatisticsResponse, Error, TData>
    >;
  },
  queryClient?: QueryClient,
): CreateQueryResult<TData, Error> {
  const queryOptions = getQueryServiceColumnDescriptiveStatisticsQueryOptions(
    client,
    request,
    options,
  );
  return createQuery(queryOptions, queryClient);
}

/**
 * Raw RPC call: QueryService.ColumnTimeGrain
 */
export async function queryServiceColumnTimeGrain(
  client: RuntimeClient,
  request: Omit<V1ColumnTimeGrainRequest, "instanceId">,
  options?: { signal?: AbortSignal },
): Promise<V1ColumnTimeGrainResponse> {
  const r = await client.queryService.columnTimeGrain(
    ColumnTimeGrainRequest.fromJson(
      stripUndefined({
        instanceId: client.instanceId,
        ...request,
      }) as unknown as JsonValue,
    ),
    { signal: options?.signal },
  );
  return r.toJson({
    emitDefaultValues: true,
  }) as unknown as V1ColumnTimeGrainResponse;
}

export function getQueryServiceColumnTimeGrainQueryKey(
  instanceId: string,
  request?: Omit<V1ColumnTimeGrainRequest, "instanceId">,
): QueryKey {
  return [
    "QueryService",
    "columnTimeGrain",
    instanceId,
    request ?? {},
  ] as const;
}

export function getQueryServiceColumnTimeGrainQueryOptions<
  TData = V1ColumnTimeGrainResponse,
>(
  client: RuntimeClient,
  request: Omit<V1ColumnTimeGrainRequest, "instanceId">,
  options?: {
    query?: Partial<
      CreateQueryOptions<V1ColumnTimeGrainResponse, Error, TData>
    >;
  },
): CreateQueryOptions<V1ColumnTimeGrainResponse, Error, TData> & {
  queryKey: QueryKey;
} {
  const queryKey = getQueryServiceColumnTimeGrainQueryKey(
    client.instanceId,
    request,
  );
  const queryFn: QueryFunction<V1ColumnTimeGrainResponse> = ({ signal }) =>
    queryServiceColumnTimeGrain(client, request, { signal });
  return {
    queryKey,
    queryFn,
    enabled: !!client.instanceId,
    ...options?.query,
  } as CreateQueryOptions<V1ColumnTimeGrainResponse, Error, TData> & {
    queryKey: QueryKey;
  };
}

export function createQueryServiceColumnTimeGrain<
  TData = V1ColumnTimeGrainResponse,
>(
  client: RuntimeClient,
  request: Omit<V1ColumnTimeGrainRequest, "instanceId">,
  options?: {
    query?: Partial<
      CreateQueryOptions<V1ColumnTimeGrainResponse, Error, TData>
    >;
  },
  queryClient?: QueryClient,
): CreateQueryResult<TData, Error> {
  const queryOptions = getQueryServiceColumnTimeGrainQueryOptions(
    client,
    request,
    options,
  );
  return createQuery(queryOptions, queryClient);
}

/**
 * Raw RPC call: QueryService.ColumnNumericHistogram
 */
export async function queryServiceColumnNumericHistogram(
  client: RuntimeClient,
  request: Omit<V1ColumnNumericHistogramRequest, "instanceId">,
  options?: { signal?: AbortSignal },
): Promise<V1ColumnNumericHistogramResponse> {
  const r = await client.queryService.columnNumericHistogram(
    ColumnNumericHistogramRequest.fromJson(
      stripUndefined({
        instanceId: client.instanceId,
        ...request,
      }) as unknown as JsonValue,
    ),
    { signal: options?.signal },
  );
  return r.toJson({
    emitDefaultValues: true,
  }) as unknown as V1ColumnNumericHistogramResponse;
}

export function getQueryServiceColumnNumericHistogramQueryKey(
  instanceId: string,
  request?: Omit<V1ColumnNumericHistogramRequest, "instanceId">,
): QueryKey {
  return [
    "QueryService",
    "columnNumericHistogram",
    instanceId,
    request ?? {},
  ] as const;
}

export function getQueryServiceColumnNumericHistogramQueryOptions<
  TData = V1ColumnNumericHistogramResponse,
>(
  client: RuntimeClient,
  request: Omit<V1ColumnNumericHistogramRequest, "instanceId">,
  options?: {
    query?: Partial<
      CreateQueryOptions<V1ColumnNumericHistogramResponse, Error, TData>
    >;
  },
): CreateQueryOptions<V1ColumnNumericHistogramResponse, Error, TData> & {
  queryKey: QueryKey;
} {
  const queryKey = getQueryServiceColumnNumericHistogramQueryKey(
    client.instanceId,
    request,
  );
  const queryFn: QueryFunction<V1ColumnNumericHistogramResponse> = ({
    signal,
  }) => queryServiceColumnNumericHistogram(client, request, { signal });
  return {
    queryKey,
    queryFn,
    enabled: !!client.instanceId,
    ...options?.query,
  } as CreateQueryOptions<V1ColumnNumericHistogramResponse, Error, TData> & {
    queryKey: QueryKey;
  };
}

export function createQueryServiceColumnNumericHistogram<
  TData = V1ColumnNumericHistogramResponse,
>(
  client: RuntimeClient,
  request: Omit<V1ColumnNumericHistogramRequest, "instanceId">,
  options?: {
    query?: Partial<
      CreateQueryOptions<V1ColumnNumericHistogramResponse, Error, TData>
    >;
  },
  queryClient?: QueryClient,
): CreateQueryResult<TData, Error> {
  const queryOptions = getQueryServiceColumnNumericHistogramQueryOptions(
    client,
    request,
    options,
  );
  return createQuery(queryOptions, queryClient);
}

/**
 * Raw RPC call: QueryService.ColumnRugHistogram
 */
export async function queryServiceColumnRugHistogram(
  client: RuntimeClient,
  request: Omit<V1ColumnRugHistogramRequest, "instanceId">,
  options?: { signal?: AbortSignal },
): Promise<V1ColumnRugHistogramResponse> {
  const r = await client.queryService.columnRugHistogram(
    ColumnRugHistogramRequest.fromJson(
      stripUndefined({
        instanceId: client.instanceId,
        ...request,
      }) as unknown as JsonValue,
    ),
    { signal: options?.signal },
  );
  return r.toJson({
    emitDefaultValues: true,
  }) as unknown as V1ColumnRugHistogramResponse;
}

export function getQueryServiceColumnRugHistogramQueryKey(
  instanceId: string,
  request?: Omit<V1ColumnRugHistogramRequest, "instanceId">,
): QueryKey {
  return [
    "QueryService",
    "columnRugHistogram",
    instanceId,
    request ?? {},
  ] as const;
}

export function getQueryServiceColumnRugHistogramQueryOptions<
  TData = V1ColumnRugHistogramResponse,
>(
  client: RuntimeClient,
  request: Omit<V1ColumnRugHistogramRequest, "instanceId">,
  options?: {
    query?: Partial<
      CreateQueryOptions<V1ColumnRugHistogramResponse, Error, TData>
    >;
  },
): CreateQueryOptions<V1ColumnRugHistogramResponse, Error, TData> & {
  queryKey: QueryKey;
} {
  const queryKey = getQueryServiceColumnRugHistogramQueryKey(
    client.instanceId,
    request,
  );
  const queryFn: QueryFunction<V1ColumnRugHistogramResponse> = ({ signal }) =>
    queryServiceColumnRugHistogram(client, request, { signal });
  return {
    queryKey,
    queryFn,
    enabled: !!client.instanceId,
    ...options?.query,
  } as CreateQueryOptions<V1ColumnRugHistogramResponse, Error, TData> & {
    queryKey: QueryKey;
  };
}

export function createQueryServiceColumnRugHistogram<
  TData = V1ColumnRugHistogramResponse,
>(
  client: RuntimeClient,
  request: Omit<V1ColumnRugHistogramRequest, "instanceId">,
  options?: {
    query?: Partial<
      CreateQueryOptions<V1ColumnRugHistogramResponse, Error, TData>
    >;
  },
  queryClient?: QueryClient,
): CreateQueryResult<TData, Error> {
  const queryOptions = getQueryServiceColumnRugHistogramQueryOptions(
    client,
    request,
    options,
  );
  return createQuery(queryOptions, queryClient);
}

/**
 * Raw RPC call: QueryService.ColumnTimeRange
 */
export async function queryServiceColumnTimeRange(
  client: RuntimeClient,
  request: Omit<V1ColumnTimeRangeRequest, "instanceId">,
  options?: { signal?: AbortSignal },
): Promise<V1ColumnTimeRangeResponse> {
  const r = await client.queryService.columnTimeRange(
    ColumnTimeRangeRequest.fromJson(
      stripUndefined({
        instanceId: client.instanceId,
        ...request,
      }) as unknown as JsonValue,
    ),
    { signal: options?.signal },
  );
  return r.toJson({
    emitDefaultValues: true,
  }) as unknown as V1ColumnTimeRangeResponse;
}

export function getQueryServiceColumnTimeRangeQueryKey(
  instanceId: string,
  request?: Omit<V1ColumnTimeRangeRequest, "instanceId">,
): QueryKey {
  return [
    "QueryService",
    "columnTimeRange",
    instanceId,
    request ?? {},
  ] as const;
}

export function getQueryServiceColumnTimeRangeQueryOptions<
  TData = V1ColumnTimeRangeResponse,
>(
  client: RuntimeClient,
  request: Omit<V1ColumnTimeRangeRequest, "instanceId">,
  options?: {
    query?: Partial<
      CreateQueryOptions<V1ColumnTimeRangeResponse, Error, TData>
    >;
  },
): CreateQueryOptions<V1ColumnTimeRangeResponse, Error, TData> & {
  queryKey: QueryKey;
} {
  const queryKey = getQueryServiceColumnTimeRangeQueryKey(
    client.instanceId,
    request,
  );
  const queryFn: QueryFunction<V1ColumnTimeRangeResponse> = ({ signal }) =>
    queryServiceColumnTimeRange(client, request, { signal });
  return {
    queryKey,
    queryFn,
    enabled: !!client.instanceId,
    ...options?.query,
  } as CreateQueryOptions<V1ColumnTimeRangeResponse, Error, TData> & {
    queryKey: QueryKey;
  };
}

export function createQueryServiceColumnTimeRange<
  TData = V1ColumnTimeRangeResponse,
>(
  client: RuntimeClient,
  request: Omit<V1ColumnTimeRangeRequest, "instanceId">,
  options?: {
    query?: Partial<
      CreateQueryOptions<V1ColumnTimeRangeResponse, Error, TData>
    >;
  },
  queryClient?: QueryClient,
): CreateQueryResult<TData, Error> {
  const queryOptions = getQueryServiceColumnTimeRangeQueryOptions(
    client,
    request,
    options,
  );
  return createQuery(queryOptions, queryClient);
}

/**
 * Raw RPC call: QueryService.ColumnCardinality
 */
export async function queryServiceColumnCardinality(
  client: RuntimeClient,
  request: Omit<V1ColumnCardinalityRequest, "instanceId">,
  options?: { signal?: AbortSignal },
): Promise<V1ColumnCardinalityResponse> {
  const r = await client.queryService.columnCardinality(
    ColumnCardinalityRequest.fromJson(
      stripUndefined({
        instanceId: client.instanceId,
        ...request,
      }) as unknown as JsonValue,
    ),
    { signal: options?.signal },
  );
  return r.toJson({
    emitDefaultValues: true,
  }) as unknown as V1ColumnCardinalityResponse;
}

export function getQueryServiceColumnCardinalityQueryKey(
  instanceId: string,
  request?: Omit<V1ColumnCardinalityRequest, "instanceId">,
): QueryKey {
  return [
    "QueryService",
    "columnCardinality",
    instanceId,
    request ?? {},
  ] as const;
}

export function getQueryServiceColumnCardinalityQueryOptions<
  TData = V1ColumnCardinalityResponse,
>(
  client: RuntimeClient,
  request: Omit<V1ColumnCardinalityRequest, "instanceId">,
  options?: {
    query?: Partial<
      CreateQueryOptions<V1ColumnCardinalityResponse, Error, TData>
    >;
  },
): CreateQueryOptions<V1ColumnCardinalityResponse, Error, TData> & {
  queryKey: QueryKey;
} {
  const queryKey = getQueryServiceColumnCardinalityQueryKey(
    client.instanceId,
    request,
  );
  const queryFn: QueryFunction<V1ColumnCardinalityResponse> = ({ signal }) =>
    queryServiceColumnCardinality(client, request, { signal });
  return {
    queryKey,
    queryFn,
    enabled: !!client.instanceId,
    ...options?.query,
  } as CreateQueryOptions<V1ColumnCardinalityResponse, Error, TData> & {
    queryKey: QueryKey;
  };
}

export function createQueryServiceColumnCardinality<
  TData = V1ColumnCardinalityResponse,
>(
  client: RuntimeClient,
  request: Omit<V1ColumnCardinalityRequest, "instanceId">,
  options?: {
    query?: Partial<
      CreateQueryOptions<V1ColumnCardinalityResponse, Error, TData>
    >;
  },
  queryClient?: QueryClient,
): CreateQueryResult<TData, Error> {
  const queryOptions = getQueryServiceColumnCardinalityQueryOptions(
    client,
    request,
    options,
  );
  return createQuery(queryOptions, queryClient);
}

/**
 * Raw RPC call: QueryService.ColumnTimeSeries
 */
export async function queryServiceColumnTimeSeries(
  client: RuntimeClient,
  request: Omit<V1ColumnTimeSeriesRequest, "instanceId">,
  options?: { signal?: AbortSignal },
): Promise<V1ColumnTimeSeriesResponse> {
  const r = await client.queryService.columnTimeSeries(
    ColumnTimeSeriesRequest.fromJson(
      stripUndefined({
        instanceId: client.instanceId,
        ...request,
      }) as unknown as JsonValue,
    ),
    { signal: options?.signal },
  );
  return r.toJson({
    emitDefaultValues: true,
  }) as unknown as V1ColumnTimeSeriesResponse;
}

export function getQueryServiceColumnTimeSeriesQueryKey(
  instanceId: string,
  request?: Omit<V1ColumnTimeSeriesRequest, "instanceId">,
): QueryKey {
  return [
    "QueryService",
    "columnTimeSeries",
    instanceId,
    request ?? {},
  ] as const;
}

export function getQueryServiceColumnTimeSeriesQueryOptions<
  TData = V1ColumnTimeSeriesResponse,
>(
  client: RuntimeClient,
  request: Omit<V1ColumnTimeSeriesRequest, "instanceId">,
  options?: {
    query?: Partial<
      CreateQueryOptions<V1ColumnTimeSeriesResponse, Error, TData>
    >;
  },
): CreateQueryOptions<V1ColumnTimeSeriesResponse, Error, TData> & {
  queryKey: QueryKey;
} {
  const queryKey = getQueryServiceColumnTimeSeriesQueryKey(
    client.instanceId,
    request,
  );
  const queryFn: QueryFunction<V1ColumnTimeSeriesResponse> = ({ signal }) =>
    queryServiceColumnTimeSeries(client, request, { signal });
  return {
    queryKey,
    queryFn,
    enabled: !!client.instanceId,
    ...options?.query,
  } as CreateQueryOptions<V1ColumnTimeSeriesResponse, Error, TData> & {
    queryKey: QueryKey;
  };
}

export function createQueryServiceColumnTimeSeries<
  TData = V1ColumnTimeSeriesResponse,
>(
  client: RuntimeClient,
  request: Omit<V1ColumnTimeSeriesRequest, "instanceId">,
  options?: {
    query?: Partial<
      CreateQueryOptions<V1ColumnTimeSeriesResponse, Error, TData>
    >;
  },
  queryClient?: QueryClient,
): CreateQueryResult<TData, Error> {
  const queryOptions = getQueryServiceColumnTimeSeriesQueryOptions(
    client,
    request,
    options,
  );
  return createQuery(queryOptions, queryClient);
}

/**
 * Raw RPC call: QueryService.TableCardinality
 */
export async function queryServiceTableCardinality(
  client: RuntimeClient,
  request: Omit<V1TableCardinalityRequest, "instanceId">,
  options?: { signal?: AbortSignal },
): Promise<V1TableCardinalityResponse> {
  const r = await client.queryService.tableCardinality(
    TableCardinalityRequest.fromJson(
      stripUndefined({
        instanceId: client.instanceId,
        ...request,
      }) as unknown as JsonValue,
    ),
    { signal: options?.signal },
  );
  return r.toJson({
    emitDefaultValues: true,
  }) as unknown as V1TableCardinalityResponse;
}

export function getQueryServiceTableCardinalityQueryKey(
  instanceId: string,
  request?: Omit<V1TableCardinalityRequest, "instanceId">,
): QueryKey {
  return [
    "QueryService",
    "tableCardinality",
    instanceId,
    request ?? {},
  ] as const;
}

export function getQueryServiceTableCardinalityQueryOptions<
  TData = V1TableCardinalityResponse,
>(
  client: RuntimeClient,
  request: Omit<V1TableCardinalityRequest, "instanceId">,
  options?: {
    query?: Partial<
      CreateQueryOptions<V1TableCardinalityResponse, Error, TData>
    >;
  },
): CreateQueryOptions<V1TableCardinalityResponse, Error, TData> & {
  queryKey: QueryKey;
} {
  const queryKey = getQueryServiceTableCardinalityQueryKey(
    client.instanceId,
    request,
  );
  const queryFn: QueryFunction<V1TableCardinalityResponse> = ({ signal }) =>
    queryServiceTableCardinality(client, request, { signal });
  return {
    queryKey,
    queryFn,
    enabled: !!client.instanceId,
    ...options?.query,
  } as CreateQueryOptions<V1TableCardinalityResponse, Error, TData> & {
    queryKey: QueryKey;
  };
}

export function createQueryServiceTableCardinality<
  TData = V1TableCardinalityResponse,
>(
  client: RuntimeClient,
  request: Omit<V1TableCardinalityRequest, "instanceId">,
  options?: {
    query?: Partial<
      CreateQueryOptions<V1TableCardinalityResponse, Error, TData>
    >;
  },
  queryClient?: QueryClient,
): CreateQueryResult<TData, Error> {
  const queryOptions = getQueryServiceTableCardinalityQueryOptions(
    client,
    request,
    options,
  );
  return createQuery(queryOptions, queryClient);
}

/**
 * Raw RPC call: QueryService.TableColumns
 */
export async function queryServiceTableColumns(
  client: RuntimeClient,
  request: Omit<V1TableColumnsRequest, "instanceId">,
  options?: { signal?: AbortSignal },
): Promise<V1TableColumnsResponse> {
  const r = await client.queryService.tableColumns(
    TableColumnsRequest.fromJson(
      stripUndefined({
        instanceId: client.instanceId,
        ...request,
      }) as unknown as JsonValue,
    ),
    { signal: options?.signal },
  );
  return r.toJson({
    emitDefaultValues: true,
  }) as unknown as V1TableColumnsResponse;
}

export function getQueryServiceTableColumnsQueryKey(
  instanceId: string,
  request?: Omit<V1TableColumnsRequest, "instanceId">,
): QueryKey {
  return ["QueryService", "tableColumns", instanceId, request ?? {}] as const;
}

export function getQueryServiceTableColumnsQueryOptions<
  TData = V1TableColumnsResponse,
>(
  client: RuntimeClient,
  request: Omit<V1TableColumnsRequest, "instanceId">,
  options?: {
    query?: Partial<CreateQueryOptions<V1TableColumnsResponse, Error, TData>>;
  },
): CreateQueryOptions<V1TableColumnsResponse, Error, TData> & {
  queryKey: QueryKey;
} {
  const queryKey = getQueryServiceTableColumnsQueryKey(
    client.instanceId,
    request,
  );
  const queryFn: QueryFunction<V1TableColumnsResponse> = ({ signal }) =>
    queryServiceTableColumns(client, request, { signal });
  return {
    queryKey,
    queryFn,
    enabled: !!client.instanceId,
    ...options?.query,
  } as CreateQueryOptions<V1TableColumnsResponse, Error, TData> & {
    queryKey: QueryKey;
  };
}

export function createQueryServiceTableColumns<TData = V1TableColumnsResponse>(
  client: RuntimeClient,
  request: Omit<V1TableColumnsRequest, "instanceId">,
  options?: {
    query?: Partial<CreateQueryOptions<V1TableColumnsResponse, Error, TData>>;
  },
  queryClient?: QueryClient,
): CreateQueryResult<TData, Error> {
  const queryOptions = getQueryServiceTableColumnsQueryOptions(
    client,
    request,
    options,
  );
  return createQuery(queryOptions, queryClient);
}

/**
 * Raw RPC call: QueryService.TableRows
 */
export async function queryServiceTableRows(
  client: RuntimeClient,
  request: Omit<V1TableRowsRequest, "instanceId">,
  options?: { signal?: AbortSignal },
): Promise<V1TableRowsResponse> {
  const r = await client.queryService.tableRows(
    TableRowsRequest.fromJson(
      stripUndefined({
        instanceId: client.instanceId,
        ...request,
      }) as unknown as JsonValue,
    ),
    { signal: options?.signal },
  );
  return r.toJson({
    emitDefaultValues: true,
  }) as unknown as V1TableRowsResponse;
}

export function getQueryServiceTableRowsQueryKey(
  instanceId: string,
  request?: Omit<V1TableRowsRequest, "instanceId">,
): QueryKey {
  return ["QueryService", "tableRows", instanceId, request ?? {}] as const;
}

export function getQueryServiceTableRowsQueryOptions<
  TData = V1TableRowsResponse,
>(
  client: RuntimeClient,
  request: Omit<V1TableRowsRequest, "instanceId">,
  options?: {
    query?: Partial<CreateQueryOptions<V1TableRowsResponse, Error, TData>>;
  },
): CreateQueryOptions<V1TableRowsResponse, Error, TData> & {
  queryKey: QueryKey;
} {
  const queryKey = getQueryServiceTableRowsQueryKey(client.instanceId, request);
  const queryFn: QueryFunction<V1TableRowsResponse> = ({ signal }) =>
    queryServiceTableRows(client, request, { signal });
  return {
    queryKey,
    queryFn,
    enabled: !!client.instanceId,
    ...options?.query,
  } as CreateQueryOptions<V1TableRowsResponse, Error, TData> & {
    queryKey: QueryKey;
  };
}

export function createQueryServiceTableRows<TData = V1TableRowsResponse>(
  client: RuntimeClient,
  request: Omit<V1TableRowsRequest, "instanceId">,
  options?: {
    query?: Partial<CreateQueryOptions<V1TableRowsResponse, Error, TData>>;
  },
  queryClient?: QueryClient,
): CreateQueryResult<TData, Error> {
  const queryOptions = getQueryServiceTableRowsQueryOptions(
    client,
    request,
    options,
  );
  return createQuery(queryOptions, queryClient);
}

/**
 * Raw RPC call (mutation): QueryService.Query
 */
export async function queryServiceQuery(
  client: RuntimeClient,
  request: Omit<PartialMessage<QueryRequest>, "instanceId">,
): Promise<V1QueryResponse> {
  const r = await client.queryService.query(
    QueryRequest.fromJson(
      stripUndefined({
        instanceId: client.instanceId,
        ...request,
      }) as unknown as JsonValue,
    ),
  );
  return r.toJson({ emitDefaultValues: true }) as unknown as V1QueryResponse;
}

export function getQueryServiceQueryMutationOptions(
  client: RuntimeClient,
  options?: Partial<
    CreateMutationOptions<
      V1QueryResponse,
      unknown,
      Omit<PartialMessage<QueryRequest>, "instanceId">
    >
  >,
): CreateMutationOptions<
  V1QueryResponse,
  unknown,
  Omit<PartialMessage<QueryRequest>, "instanceId">
> {
  return {
    mutationFn: (request) => queryServiceQuery(client, request),
    ...options,
  };
}

export function createQueryServiceQueryMutation(
  client: RuntimeClient,
  options?: Partial<
    CreateMutationOptions<
      V1QueryResponse,
      unknown,
      Omit<PartialMessage<QueryRequest>, "instanceId">
    >
  >,
  queryClient?: QueryClient,
): CreateMutationResult<
  V1QueryResponse,
  unknown,
  Omit<PartialMessage<QueryRequest>, "instanceId">
> {
  const mutationOptions = getQueryServiceQueryMutationOptions(client, options);
  return createMutation(mutationOptions, queryClient);
}

/**
 * Raw RPC call (mutation): QueryService.Export
 */
export async function queryServiceExport(
  client: RuntimeClient,
  request: Omit<PartialMessage<ExportRequest>, "instanceId">,
): Promise<V1ExportResponse> {
  const r = await client.queryService.export(
    ExportRequest.fromJson(
      stripUndefined({
        instanceId: client.instanceId,
        ...request,
      }) as unknown as JsonValue,
    ),
  );
  return r.toJson({ emitDefaultValues: true }) as unknown as V1ExportResponse;
}

export function getQueryServiceExportMutationOptions(
  client: RuntimeClient,
  options?: Partial<
    CreateMutationOptions<
      V1ExportResponse,
      unknown,
      Omit<PartialMessage<ExportRequest>, "instanceId">
    >
  >,
): CreateMutationOptions<
  V1ExportResponse,
  unknown,
  Omit<PartialMessage<ExportRequest>, "instanceId">
> {
  return {
    mutationFn: (request) => queryServiceExport(client, request),
    ...options,
  };
}

export function createQueryServiceExportMutation(
  client: RuntimeClient,
  options?: Partial<
    CreateMutationOptions<
      V1ExportResponse,
      unknown,
      Omit<PartialMessage<ExportRequest>, "instanceId">
    >
  >,
  queryClient?: QueryClient,
): CreateMutationResult<
  V1ExportResponse,
  unknown,
  Omit<PartialMessage<ExportRequest>, "instanceId">
> {
  const mutationOptions = getQueryServiceExportMutationOptions(client, options);
  return createMutation(mutationOptions, queryClient);
}

/**
 * Raw RPC call (mutation): QueryService.ExportReport
 */
export async function queryServiceExportReport(
  client: RuntimeClient,
  request: Omit<PartialMessage<ExportReportRequest>, "instanceId">,
): Promise<V1ExportReportResponse> {
  const r = await client.queryService.exportReport(
    ExportReportRequest.fromJson(
      stripUndefined({
        instanceId: client.instanceId,
        ...request,
      }) as unknown as JsonValue,
    ),
  );
  return r.toJson({
    emitDefaultValues: true,
  }) as unknown as V1ExportReportResponse;
}

export function getQueryServiceExportReportMutationOptions(
  client: RuntimeClient,
  options?: Partial<
    CreateMutationOptions<
      V1ExportReportResponse,
      unknown,
      Omit<PartialMessage<ExportReportRequest>, "instanceId">
    >
  >,
): CreateMutationOptions<
  V1ExportReportResponse,
  unknown,
  Omit<PartialMessage<ExportReportRequest>, "instanceId">
> {
  return {
    mutationFn: (request) => queryServiceExportReport(client, request),
    ...options,
  };
}

export function createQueryServiceExportReportMutation(
  client: RuntimeClient,
  options?: Partial<
    CreateMutationOptions<
      V1ExportReportResponse,
      unknown,
      Omit<PartialMessage<ExportReportRequest>, "instanceId">
    >
  >,
  queryClient?: QueryClient,
): CreateMutationResult<
  V1ExportReportResponse,
  unknown,
  Omit<PartialMessage<ExportReportRequest>, "instanceId">
> {
  const mutationOptions = getQueryServiceExportReportMutationOptions(
    client,
    options,
  );
  return createMutation(mutationOptions, queryClient);
}

// Generated by generate-query-hooks.ts — DO NOT EDIT

import type { RuntimeClient } from "../runtime-client";
import type { PartialMessage, JsonValue } from "@bufbuild/protobuf";
import {
  createQuery,
  createMutation,
  type CreateQueryOptions,
  type CreateQueryResult,
  type QueryClient,
  type QueryFunction,
  type QueryKey,
  type CreateMutationOptions,
  type CreateMutationResult,
} from "@tanstack/svelte-query";
import type {
  V1AnalyzeConnectorsResponse,
  V1AnalyzeVariablesResponse,
  V1CompleteResponse,
  V1CreateDirectoryResponse,
  V1CreateInstanceRequest,
  V1CreateInstanceResponse,
  V1CreateTriggerResponse,
  V1DeleteFileResponse,
  V1DeleteInstanceResponse,
  V1EditInstanceResponse,
  V1ForkConversationResponse,
  V1GenerateCanvasFileResponse,
  V1GenerateMetricsViewFileResponse,
  V1GenerateRendererResponse,
  V1GenerateResolverResponse,
  V1GetConversationResponse,
  V1GetExploreResponse,
  V1GetFileResponse,
  V1GetInstanceResponse,
  V1GetLogsResponse,
  V1GetModelPartitionsResponse,
  V1GetResourceResponse,
  V1GitCommitResponse,
  V1GitMergeToBranchResponse,
  V1GitPullResponse,
  V1GitPushResponse,
  V1GitStatusResponse,
  V1GitSwitchBranchResponse,
  V1HealthResponse,
  V1InstanceHealthResponse,
  V1IssueDevJWTRequest,
  V1IssueDevJWTResponse,
  V1ListConnectorDriversResponse,
  V1ListConversationsResponse,
  V1ListExamplesResponse,
  V1ListFilesResponse,
  V1ListGitBranchesResponse,
  V1ListGitCommitsResponse,
  V1ListInstancesResponse,
  V1ListNotifierConnectorsResponse,
  V1ListResourcesResponse,
  V1ListToolsResponse,
  V1PingResponse,
  V1PutFileResponse,
  V1QueryResolverResponse,
  V1ReloadConfigResponse,
  V1RenameFileResponse,
  V1RestoreGitCommitResponse,
  V1ShareConversationResponse,
  V1UnpackEmptyResponse,
  V1UnpackExampleResponse,
} from "../../gen/index.schemas";
import {
  AnalyzeConnectorsRequest,
  AnalyzeVariablesRequest,
  CompleteRequest,
  CreateDirectoryRequest,
  CreateInstanceRequest,
  CreateTriggerRequest,
  DeleteFileRequest,
  DeleteInstanceRequest,
  EditInstanceRequest,
  ForkConversationRequest,
  GenerateCanvasFileRequest,
  GenerateMetricsViewFileRequest,
  GenerateRendererRequest,
  GenerateResolverRequest,
  GetConversationRequest,
  GetExploreRequest,
  GetFileRequest,
  GetInstanceRequest,
  GetLogsRequest,
  GetModelPartitionsRequest,
  GetResourceRequest,
  GitCommitRequest,
  GitMergeToBranchRequest,
  GitPullRequest,
  GitPushRequest,
  GitStatusRequest,
  GitSwitchBranchRequest,
  HealthRequest,
  InstanceHealthRequest,
  IssueDevJWTRequest,
  ListConnectorDriversRequest,
  ListConversationsRequest,
  ListExamplesRequest,
  ListFilesRequest,
  ListGitBranchesRequest,
  ListGitCommitsRequest,
  ListInstancesRequest,
  ListNotifierConnectorsRequest,
  ListResourcesRequest,
  ListToolsRequest,
  PingRequest,
  PutFileRequest,
  QueryResolverRequest,
  ReloadConfigRequest,
  RenameFileRequest,
  RestoreGitCommitRequest,
  ShareConversationRequest,
  UnpackEmptyRequest,
  UnpackExampleRequest,
} from "../../../proto/gen/rill/runtime/v1/api_pb";

/** Deep-strip undefined values — proto fromJson rejects them */
// eslint-disable-next-line @typescript-eslint/no-explicit-any
function stripUndefined(obj: Record<string, any>): Record<string, unknown> {
  const result: Record<string, unknown> = {};
  for (const [key, value] of Object.entries(obj)) {
    if (value === undefined) continue;
    if (Array.isArray(value)) {
      result[key] = value.map((item) =>
        item && typeof item === "object" && !Array.isArray(item)
          ? stripUndefined(item)
          : item,
      );
    } else if (value && typeof value === "object" && !(value instanceof Date)) {
      result[key] = stripUndefined(value);
    } else {
      result[key] = value;
    }
  }
  return result;
}

/**
 * Raw RPC call: RuntimeService.Ping
 */
export function runtimeServicePing(
  client: RuntimeClient,
  request: PartialMessage<PingRequest>,
  options?: { signal?: AbortSignal },
): Promise<V1PingResponse> {
  return client.runtimeService
    .ping(
      PingRequest.fromJson(stripUndefined(request) as unknown as JsonValue),
      { signal: options?.signal },
    )
    .then(
      (r) => r.toJson({ emitDefaultValues: true }) as unknown as V1PingResponse,
    );
}

export function getRuntimeServicePingQueryKey(
  instanceId: string,
  request?: PartialMessage<PingRequest>,
): QueryKey {
  return ["RuntimeService", "ping", instanceId, request ?? {}] as const;
}

export function getRuntimeServicePingQueryOptions<TData = V1PingResponse>(
  client: RuntimeClient,
  request: PartialMessage<PingRequest>,
  options?: {
    query?: Partial<CreateQueryOptions<V1PingResponse, Error, TData>>;
  },
): CreateQueryOptions<V1PingResponse, Error, TData> & { queryKey: QueryKey } {
  const queryKey = getRuntimeServicePingQueryKey(client.instanceId, request);
  const queryFn: QueryFunction<V1PingResponse> = ({ signal }) =>
    runtimeServicePing(client, request, { signal });
  return {
    queryKey,
    queryFn,
    enabled: !!client.instanceId,
    ...options?.query,
  } as CreateQueryOptions<V1PingResponse, Error, TData> & {
    queryKey: QueryKey;
  };
}

export function createRuntimeServicePing<TData = V1PingResponse>(
  client: RuntimeClient,
  request: PartialMessage<PingRequest>,
  options?: {
    query?: Partial<CreateQueryOptions<V1PingResponse, Error, TData>>;
  },
  queryClient?: QueryClient,
): CreateQueryResult<TData, Error> {
  const queryOptions = getRuntimeServicePingQueryOptions(
    client,
    request,
    options,
  );
  return createQuery(queryOptions, queryClient);
}

/**
 * Raw RPC call: RuntimeService.Health
 */
export function runtimeServiceHealth(
  client: RuntimeClient,
  request: PartialMessage<HealthRequest>,
  options?: { signal?: AbortSignal },
): Promise<V1HealthResponse> {
  return client.runtimeService
    .health(
      HealthRequest.fromJson(stripUndefined(request) as unknown as JsonValue),
      { signal: options?.signal },
    )
    .then(
      (r) =>
        r.toJson({ emitDefaultValues: true }) as unknown as V1HealthResponse,
    );
}

export function getRuntimeServiceHealthQueryKey(
  instanceId: string,
  request?: PartialMessage<HealthRequest>,
): QueryKey {
  return ["RuntimeService", "health", instanceId, request ?? {}] as const;
}

export function getRuntimeServiceHealthQueryOptions<TData = V1HealthResponse>(
  client: RuntimeClient,
  request: PartialMessage<HealthRequest>,
  options?: {
    query?: Partial<CreateQueryOptions<V1HealthResponse, Error, TData>>;
  },
): CreateQueryOptions<V1HealthResponse, Error, TData> & { queryKey: QueryKey } {
  const queryKey = getRuntimeServiceHealthQueryKey(client.instanceId, request);
  const queryFn: QueryFunction<V1HealthResponse> = ({ signal }) =>
    runtimeServiceHealth(client, request, { signal });
  return {
    queryKey,
    queryFn,
    enabled: !!client.instanceId,
    ...options?.query,
  } as CreateQueryOptions<V1HealthResponse, Error, TData> & {
    queryKey: QueryKey;
  };
}

export function createRuntimeServiceHealth<TData = V1HealthResponse>(
  client: RuntimeClient,
  request: PartialMessage<HealthRequest>,
  options?: {
    query?: Partial<CreateQueryOptions<V1HealthResponse, Error, TData>>;
  },
  queryClient?: QueryClient,
): CreateQueryResult<TData, Error> {
  const queryOptions = getRuntimeServiceHealthQueryOptions(
    client,
    request,
    options,
  );
  return createQuery(queryOptions, queryClient);
}

/**
 * Raw RPC call: RuntimeService.InstanceHealth
 */
export function runtimeServiceInstanceHealth(
  client: RuntimeClient,
  request: Omit<PartialMessage<InstanceHealthRequest>, "instanceId">,
  options?: { signal?: AbortSignal },
): Promise<V1InstanceHealthResponse> {
  return client.runtimeService
    .instanceHealth(
      InstanceHealthRequest.fromJson(
        stripUndefined({
          instanceId: client.instanceId,
          ...request,
        }) as unknown as JsonValue,
      ),
      { signal: options?.signal },
    )
    .then(
      (r) =>
        r.toJson({
          emitDefaultValues: true,
        }) as unknown as V1InstanceHealthResponse,
    );
}

export function getRuntimeServiceInstanceHealthQueryKey(
  instanceId: string,
  request?: Omit<PartialMessage<InstanceHealthRequest>, "instanceId">,
): QueryKey {
  return [
    "RuntimeService",
    "instanceHealth",
    instanceId,
    request ?? {},
  ] as const;
}

export function getRuntimeServiceInstanceHealthQueryOptions<
  TData = V1InstanceHealthResponse,
>(
  client: RuntimeClient,
  request: Omit<PartialMessage<InstanceHealthRequest>, "instanceId">,
  options?: {
    query?: Partial<CreateQueryOptions<V1InstanceHealthResponse, Error, TData>>;
  },
): CreateQueryOptions<V1InstanceHealthResponse, Error, TData> & {
  queryKey: QueryKey;
} {
  const queryKey = getRuntimeServiceInstanceHealthQueryKey(
    client.instanceId,
    request,
  );
  const queryFn: QueryFunction<V1InstanceHealthResponse> = ({ signal }) =>
    runtimeServiceInstanceHealth(client, request, { signal });
  return {
    queryKey,
    queryFn,
    enabled: !!client.instanceId,
    ...options?.query,
  } as CreateQueryOptions<V1InstanceHealthResponse, Error, TData> & {
    queryKey: QueryKey;
  };
}

export function createRuntimeServiceInstanceHealth<
  TData = V1InstanceHealthResponse,
>(
  client: RuntimeClient,
  request: Omit<PartialMessage<InstanceHealthRequest>, "instanceId">,
  options?: {
    query?: Partial<CreateQueryOptions<V1InstanceHealthResponse, Error, TData>>;
  },
  queryClient?: QueryClient,
): CreateQueryResult<TData, Error> {
  const queryOptions = getRuntimeServiceInstanceHealthQueryOptions(
    client,
    request,
    options,
  );
  return createQuery(queryOptions, queryClient);
}

/**
 * Raw RPC call: RuntimeService.ListInstances
 */
export function runtimeServiceListInstances(
  client: RuntimeClient,
  request: PartialMessage<ListInstancesRequest>,
  options?: { signal?: AbortSignal },
): Promise<V1ListInstancesResponse> {
  return client.runtimeService
    .listInstances(
      ListInstancesRequest.fromJson(
        stripUndefined(request) as unknown as JsonValue,
      ),
      { signal: options?.signal },
    )
    .then(
      (r) =>
        r.toJson({
          emitDefaultValues: true,
        }) as unknown as V1ListInstancesResponse,
    );
}

export function getRuntimeServiceListInstancesQueryKey(
  instanceId: string,
  request?: PartialMessage<ListInstancesRequest>,
): QueryKey {
  return [
    "RuntimeService",
    "listInstances",
    instanceId,
    request ?? {},
  ] as const;
}

export function getRuntimeServiceListInstancesQueryOptions<
  TData = V1ListInstancesResponse,
>(
  client: RuntimeClient,
  request: PartialMessage<ListInstancesRequest>,
  options?: {
    query?: Partial<CreateQueryOptions<V1ListInstancesResponse, Error, TData>>;
  },
): CreateQueryOptions<V1ListInstancesResponse, Error, TData> & {
  queryKey: QueryKey;
} {
  const queryKey = getRuntimeServiceListInstancesQueryKey(
    client.instanceId,
    request,
  );
  const queryFn: QueryFunction<V1ListInstancesResponse> = ({ signal }) =>
    runtimeServiceListInstances(client, request, { signal });
  return {
    queryKey,
    queryFn,
    enabled: !!client.instanceId,
    ...options?.query,
  } as CreateQueryOptions<V1ListInstancesResponse, Error, TData> & {
    queryKey: QueryKey;
  };
}

export function createRuntimeServiceListInstances<
  TData = V1ListInstancesResponse,
>(
  client: RuntimeClient,
  request: PartialMessage<ListInstancesRequest>,
  options?: {
    query?: Partial<CreateQueryOptions<V1ListInstancesResponse, Error, TData>>;
  },
  queryClient?: QueryClient,
): CreateQueryResult<TData, Error> {
  const queryOptions = getRuntimeServiceListInstancesQueryOptions(
    client,
    request,
    options,
  );
  return createQuery(queryOptions, queryClient);
}

/**
 * Raw RPC call: RuntimeService.GetInstance
 */
export function runtimeServiceGetInstance(
  client: RuntimeClient,
  request: Omit<PartialMessage<GetInstanceRequest>, "instanceId">,
  options?: { signal?: AbortSignal },
): Promise<V1GetInstanceResponse> {
  return client.runtimeService
    .getInstance(
      GetInstanceRequest.fromJson(
        stripUndefined({
          instanceId: client.instanceId,
          ...request,
        }) as unknown as JsonValue,
      ),
      { signal: options?.signal },
    )
    .then(
      (r) =>
        r.toJson({
          emitDefaultValues: true,
        }) as unknown as V1GetInstanceResponse,
    );
}

export function getRuntimeServiceGetInstanceQueryKey(
  instanceId: string,
  request?: Omit<PartialMessage<GetInstanceRequest>, "instanceId">,
): QueryKey {
  return ["RuntimeService", "getInstance", instanceId, request ?? {}] as const;
}

export function getRuntimeServiceGetInstanceQueryOptions<
  TData = V1GetInstanceResponse,
>(
  client: RuntimeClient,
  request: Omit<PartialMessage<GetInstanceRequest>, "instanceId">,
  options?: {
    query?: Partial<CreateQueryOptions<V1GetInstanceResponse, Error, TData>>;
  },
): CreateQueryOptions<V1GetInstanceResponse, Error, TData> & {
  queryKey: QueryKey;
} {
  const queryKey = getRuntimeServiceGetInstanceQueryKey(
    client.instanceId,
    request,
  );
  const queryFn: QueryFunction<V1GetInstanceResponse> = ({ signal }) =>
    runtimeServiceGetInstance(client, request, { signal });
  return {
    queryKey,
    queryFn,
    enabled: !!client.instanceId,
    ...options?.query,
  } as CreateQueryOptions<V1GetInstanceResponse, Error, TData> & {
    queryKey: QueryKey;
  };
}

export function createRuntimeServiceGetInstance<TData = V1GetInstanceResponse>(
  client: RuntimeClient,
  request: Omit<PartialMessage<GetInstanceRequest>, "instanceId">,
  options?: {
    query?: Partial<CreateQueryOptions<V1GetInstanceResponse, Error, TData>>;
  },
  queryClient?: QueryClient,
): CreateQueryResult<TData, Error> {
  const queryOptions = getRuntimeServiceGetInstanceQueryOptions(
    client,
    request,
    options,
  );
  return createQuery(queryOptions, queryClient);
}

/**
 * Raw RPC call: RuntimeService.ListFiles
 */
export function runtimeServiceListFiles(
  client: RuntimeClient,
  request: Omit<PartialMessage<ListFilesRequest>, "instanceId">,
  options?: { signal?: AbortSignal },
): Promise<V1ListFilesResponse> {
  return client.runtimeService
    .listFiles(
      ListFilesRequest.fromJson(
        stripUndefined({
          instanceId: client.instanceId,
          ...request,
        }) as unknown as JsonValue,
      ),
      { signal: options?.signal },
    )
    .then(
      (r) =>
        r.toJson({ emitDefaultValues: true }) as unknown as V1ListFilesResponse,
    );
}

export function getRuntimeServiceListFilesQueryKey(
  instanceId: string,
  request?: Omit<PartialMessage<ListFilesRequest>, "instanceId">,
): QueryKey {
  return ["RuntimeService", "listFiles", instanceId, request ?? {}] as const;
}

export function getRuntimeServiceListFilesQueryOptions<
  TData = V1ListFilesResponse,
>(
  client: RuntimeClient,
  request: Omit<PartialMessage<ListFilesRequest>, "instanceId">,
  options?: {
    query?: Partial<CreateQueryOptions<V1ListFilesResponse, Error, TData>>;
  },
): CreateQueryOptions<V1ListFilesResponse, Error, TData> & {
  queryKey: QueryKey;
} {
  const queryKey = getRuntimeServiceListFilesQueryKey(
    client.instanceId,
    request,
  );
  const queryFn: QueryFunction<V1ListFilesResponse> = ({ signal }) =>
    runtimeServiceListFiles(client, request, { signal });
  return {
    queryKey,
    queryFn,
    enabled: !!client.instanceId,
    ...options?.query,
  } as CreateQueryOptions<V1ListFilesResponse, Error, TData> & {
    queryKey: QueryKey;
  };
}

export function createRuntimeServiceListFiles<TData = V1ListFilesResponse>(
  client: RuntimeClient,
  request: Omit<PartialMessage<ListFilesRequest>, "instanceId">,
  options?: {
    query?: Partial<CreateQueryOptions<V1ListFilesResponse, Error, TData>>;
  },
  queryClient?: QueryClient,
): CreateQueryResult<TData, Error> {
  const queryOptions = getRuntimeServiceListFilesQueryOptions(
    client,
    request,
    options,
  );
  return createQuery(queryOptions, queryClient);
}

/**
 * Raw RPC call: RuntimeService.GetFile
 */
export function runtimeServiceGetFile(
  client: RuntimeClient,
  request: Omit<PartialMessage<GetFileRequest>, "instanceId">,
  options?: { signal?: AbortSignal },
): Promise<V1GetFileResponse> {
  return client.runtimeService
    .getFile(
      GetFileRequest.fromJson(
        stripUndefined({
          instanceId: client.instanceId,
          ...request,
        }) as unknown as JsonValue,
      ),
      { signal: options?.signal },
    )
    .then(
      (r) =>
        r.toJson({ emitDefaultValues: true }) as unknown as V1GetFileResponse,
    );
}

export function getRuntimeServiceGetFileQueryKey(
  instanceId: string,
  request?: Omit<PartialMessage<GetFileRequest>, "instanceId">,
): QueryKey {
  return ["RuntimeService", "getFile", instanceId, request ?? {}] as const;
}

export function getRuntimeServiceGetFileQueryOptions<TData = V1GetFileResponse>(
  client: RuntimeClient,
  request: Omit<PartialMessage<GetFileRequest>, "instanceId">,
  options?: {
    query?: Partial<CreateQueryOptions<V1GetFileResponse, Error, TData>>;
  },
): CreateQueryOptions<V1GetFileResponse, Error, TData> & {
  queryKey: QueryKey;
} {
  const queryKey = getRuntimeServiceGetFileQueryKey(client.instanceId, request);
  const queryFn: QueryFunction<V1GetFileResponse> = ({ signal }) =>
    runtimeServiceGetFile(client, request, { signal });
  return {
    queryKey,
    queryFn,
    enabled: !!client.instanceId,
    ...options?.query,
  } as CreateQueryOptions<V1GetFileResponse, Error, TData> & {
    queryKey: QueryKey;
  };
}

export function createRuntimeServiceGetFile<TData = V1GetFileResponse>(
  client: RuntimeClient,
  request: Omit<PartialMessage<GetFileRequest>, "instanceId">,
  options?: {
    query?: Partial<CreateQueryOptions<V1GetFileResponse, Error, TData>>;
  },
  queryClient?: QueryClient,
): CreateQueryResult<TData, Error> {
  const queryOptions = getRuntimeServiceGetFileQueryOptions(
    client,
    request,
    options,
  );
  return createQuery(queryOptions, queryClient);
}

/**
 * Raw RPC call: RuntimeService.ListExamples
 */
export function runtimeServiceListExamples(
  client: RuntimeClient,
  request: PartialMessage<ListExamplesRequest>,
  options?: { signal?: AbortSignal },
): Promise<V1ListExamplesResponse> {
  return client.runtimeService
    .listExamples(
      ListExamplesRequest.fromJson(
        stripUndefined(request) as unknown as JsonValue,
      ),
      { signal: options?.signal },
    )
    .then(
      (r) =>
        r.toJson({
          emitDefaultValues: true,
        }) as unknown as V1ListExamplesResponse,
    );
}

export function getRuntimeServiceListExamplesQueryKey(
  instanceId: string,
  request?: PartialMessage<ListExamplesRequest>,
): QueryKey {
  return ["RuntimeService", "listExamples", instanceId, request ?? {}] as const;
}

export function getRuntimeServiceListExamplesQueryOptions<
  TData = V1ListExamplesResponse,
>(
  client: RuntimeClient,
  request: PartialMessage<ListExamplesRequest>,
  options?: {
    query?: Partial<CreateQueryOptions<V1ListExamplesResponse, Error, TData>>;
  },
): CreateQueryOptions<V1ListExamplesResponse, Error, TData> & {
  queryKey: QueryKey;
} {
  const queryKey = getRuntimeServiceListExamplesQueryKey(
    client.instanceId,
    request,
  );
  const queryFn: QueryFunction<V1ListExamplesResponse> = ({ signal }) =>
    runtimeServiceListExamples(client, request, { signal });
  return {
    queryKey,
    queryFn,
    enabled: !!client.instanceId,
    ...options?.query,
  } as CreateQueryOptions<V1ListExamplesResponse, Error, TData> & {
    queryKey: QueryKey;
  };
}

export function createRuntimeServiceListExamples<
  TData = V1ListExamplesResponse,
>(
  client: RuntimeClient,
  request: PartialMessage<ListExamplesRequest>,
  options?: {
    query?: Partial<CreateQueryOptions<V1ListExamplesResponse, Error, TData>>;
  },
  queryClient?: QueryClient,
): CreateQueryResult<TData, Error> {
  const queryOptions = getRuntimeServiceListExamplesQueryOptions(
    client,
    request,
    options,
  );
  return createQuery(queryOptions, queryClient);
}

/**
 * Raw RPC call: RuntimeService.QueryResolver
 */
export function runtimeServiceQueryResolver(
  client: RuntimeClient,
  request: Omit<PartialMessage<QueryResolverRequest>, "instanceId">,
  options?: { signal?: AbortSignal },
): Promise<V1QueryResolverResponse> {
  return client.runtimeService
    .queryResolver(
      QueryResolverRequest.fromJson(
        stripUndefined({
          instanceId: client.instanceId,
          ...request,
        }) as unknown as JsonValue,
      ),
      { signal: options?.signal },
    )
    .then(
      (r) =>
        r.toJson({
          emitDefaultValues: true,
        }) as unknown as V1QueryResolverResponse,
    );
}

export function getRuntimeServiceQueryResolverQueryKey(
  instanceId: string,
  request?: Omit<PartialMessage<QueryResolverRequest>, "instanceId">,
): QueryKey {
  return [
    "RuntimeService",
    "queryResolver",
    instanceId,
    request ?? {},
  ] as const;
}

export function getRuntimeServiceQueryResolverQueryOptions<
  TData = V1QueryResolverResponse,
>(
  client: RuntimeClient,
  request: Omit<PartialMessage<QueryResolverRequest>, "instanceId">,
  options?: {
    query?: Partial<CreateQueryOptions<V1QueryResolverResponse, Error, TData>>;
  },
): CreateQueryOptions<V1QueryResolverResponse, Error, TData> & {
  queryKey: QueryKey;
} {
  const queryKey = getRuntimeServiceQueryResolverQueryKey(
    client.instanceId,
    request,
  );
  const queryFn: QueryFunction<V1QueryResolverResponse> = ({ signal }) =>
    runtimeServiceQueryResolver(client, request, { signal });
  return {
    queryKey,
    queryFn,
    enabled: !!client.instanceId,
    ...options?.query,
  } as CreateQueryOptions<V1QueryResolverResponse, Error, TData> & {
    queryKey: QueryKey;
  };
}

export function createRuntimeServiceQueryResolver<
  TData = V1QueryResolverResponse,
>(
  client: RuntimeClient,
  request: Omit<PartialMessage<QueryResolverRequest>, "instanceId">,
  options?: {
    query?: Partial<CreateQueryOptions<V1QueryResolverResponse, Error, TData>>;
  },
  queryClient?: QueryClient,
): CreateQueryResult<TData, Error> {
  const queryOptions = getRuntimeServiceQueryResolverQueryOptions(
    client,
    request,
    options,
  );
  return createQuery(queryOptions, queryClient);
}

/**
 * Raw RPC call: RuntimeService.GetLogs
 */
export function runtimeServiceGetLogs(
  client: RuntimeClient,
  request: Omit<PartialMessage<GetLogsRequest>, "instanceId">,
  options?: { signal?: AbortSignal },
): Promise<V1GetLogsResponse> {
  return client.runtimeService
    .getLogs(
      GetLogsRequest.fromJson(
        stripUndefined({
          instanceId: client.instanceId,
          ...request,
        }) as unknown as JsonValue,
      ),
      { signal: options?.signal },
    )
    .then(
      (r) =>
        r.toJson({ emitDefaultValues: true }) as unknown as V1GetLogsResponse,
    );
}

export function getRuntimeServiceGetLogsQueryKey(
  instanceId: string,
  request?: Omit<PartialMessage<GetLogsRequest>, "instanceId">,
): QueryKey {
  return ["RuntimeService", "getLogs", instanceId, request ?? {}] as const;
}

export function getRuntimeServiceGetLogsQueryOptions<TData = V1GetLogsResponse>(
  client: RuntimeClient,
  request: Omit<PartialMessage<GetLogsRequest>, "instanceId">,
  options?: {
    query?: Partial<CreateQueryOptions<V1GetLogsResponse, Error, TData>>;
  },
): CreateQueryOptions<V1GetLogsResponse, Error, TData> & {
  queryKey: QueryKey;
} {
  const queryKey = getRuntimeServiceGetLogsQueryKey(client.instanceId, request);
  const queryFn: QueryFunction<V1GetLogsResponse> = ({ signal }) =>
    runtimeServiceGetLogs(client, request, { signal });
  return {
    queryKey,
    queryFn,
    enabled: !!client.instanceId,
    ...options?.query,
  } as CreateQueryOptions<V1GetLogsResponse, Error, TData> & {
    queryKey: QueryKey;
  };
}

export function createRuntimeServiceGetLogs<TData = V1GetLogsResponse>(
  client: RuntimeClient,
  request: Omit<PartialMessage<GetLogsRequest>, "instanceId">,
  options?: {
    query?: Partial<CreateQueryOptions<V1GetLogsResponse, Error, TData>>;
  },
  queryClient?: QueryClient,
): CreateQueryResult<TData, Error> {
  const queryOptions = getRuntimeServiceGetLogsQueryOptions(
    client,
    request,
    options,
  );
  return createQuery(queryOptions, queryClient);
}

/**
 * Raw RPC call: RuntimeService.ListResources
 */
export function runtimeServiceListResources(
  client: RuntimeClient,
  request: Omit<PartialMessage<ListResourcesRequest>, "instanceId">,
  options?: { signal?: AbortSignal },
): Promise<V1ListResourcesResponse> {
  return client.runtimeService
    .listResources(
      ListResourcesRequest.fromJson(
        stripUndefined({
          instanceId: client.instanceId,
          ...request,
        }) as unknown as JsonValue,
      ),
      { signal: options?.signal },
    )
    .then(
      (r) =>
        r.toJson({
          emitDefaultValues: true,
        }) as unknown as V1ListResourcesResponse,
    );
}

export function getRuntimeServiceListResourcesQueryKey(
  instanceId: string,
  request?: Omit<PartialMessage<ListResourcesRequest>, "instanceId">,
): QueryKey {
  return [
    "RuntimeService",
    "listResources",
    instanceId,
    request ?? {},
  ] as const;
}

export function getRuntimeServiceListResourcesQueryOptions<
  TData = V1ListResourcesResponse,
>(
  client: RuntimeClient,
  request: Omit<PartialMessage<ListResourcesRequest>, "instanceId">,
  options?: {
    query?: Partial<CreateQueryOptions<V1ListResourcesResponse, Error, TData>>;
  },
): CreateQueryOptions<V1ListResourcesResponse, Error, TData> & {
  queryKey: QueryKey;
} {
  const queryKey = getRuntimeServiceListResourcesQueryKey(
    client.instanceId,
    request,
  );
  const queryFn: QueryFunction<V1ListResourcesResponse> = ({ signal }) =>
    runtimeServiceListResources(client, request, { signal });
  return {
    queryKey,
    queryFn,
    enabled: !!client.instanceId,
    ...options?.query,
  } as CreateQueryOptions<V1ListResourcesResponse, Error, TData> & {
    queryKey: QueryKey;
  };
}

export function createRuntimeServiceListResources<
  TData = V1ListResourcesResponse,
>(
  client: RuntimeClient,
  request: Omit<PartialMessage<ListResourcesRequest>, "instanceId">,
  options?: {
    query?: Partial<CreateQueryOptions<V1ListResourcesResponse, Error, TData>>;
  },
  queryClient?: QueryClient,
): CreateQueryResult<TData, Error> {
  const queryOptions = getRuntimeServiceListResourcesQueryOptions(
    client,
    request,
    options,
  );
  return createQuery(queryOptions, queryClient);
}

/**
 * Raw RPC call: RuntimeService.GetResource
 */
export function runtimeServiceGetResource(
  client: RuntimeClient,
  request: Omit<PartialMessage<GetResourceRequest>, "instanceId">,
  options?: { signal?: AbortSignal },
): Promise<V1GetResourceResponse> {
  return client.runtimeService
    .getResource(
      GetResourceRequest.fromJson(
        stripUndefined({
          instanceId: client.instanceId,
          ...request,
        }) as unknown as JsonValue,
      ),
      { signal: options?.signal },
    )
    .then(
      (r) =>
        r.toJson({
          emitDefaultValues: true,
        }) as unknown as V1GetResourceResponse,
    );
}

export function getRuntimeServiceGetResourceQueryKey(
  instanceId: string,
  request?: Omit<PartialMessage<GetResourceRequest>, "instanceId">,
): QueryKey {
  return ["RuntimeService", "getResource", instanceId, request ?? {}] as const;
}

export function getRuntimeServiceGetResourceQueryOptions<
  TData = V1GetResourceResponse,
>(
  client: RuntimeClient,
  request: Omit<PartialMessage<GetResourceRequest>, "instanceId">,
  options?: {
    query?: Partial<CreateQueryOptions<V1GetResourceResponse, Error, TData>>;
  },
): CreateQueryOptions<V1GetResourceResponse, Error, TData> & {
  queryKey: QueryKey;
} {
  const queryKey = getRuntimeServiceGetResourceQueryKey(
    client.instanceId,
    request,
  );
  const queryFn: QueryFunction<V1GetResourceResponse> = ({ signal }) =>
    runtimeServiceGetResource(client, request, { signal });
  return {
    queryKey,
    queryFn,
    enabled: !!client.instanceId,
    ...options?.query,
  } as CreateQueryOptions<V1GetResourceResponse, Error, TData> & {
    queryKey: QueryKey;
  };
}

export function createRuntimeServiceGetResource<TData = V1GetResourceResponse>(
  client: RuntimeClient,
  request: Omit<PartialMessage<GetResourceRequest>, "instanceId">,
  options?: {
    query?: Partial<CreateQueryOptions<V1GetResourceResponse, Error, TData>>;
  },
  queryClient?: QueryClient,
): CreateQueryResult<TData, Error> {
  const queryOptions = getRuntimeServiceGetResourceQueryOptions(
    client,
    request,
    options,
  );
  return createQuery(queryOptions, queryClient);
}

/**
 * Raw RPC call: RuntimeService.GetExplore
 */
export function runtimeServiceGetExplore(
  client: RuntimeClient,
  request: Omit<PartialMessage<GetExploreRequest>, "instanceId">,
  options?: { signal?: AbortSignal },
): Promise<V1GetExploreResponse> {
  return client.runtimeService
    .getExplore(
      GetExploreRequest.fromJson(
        stripUndefined({
          instanceId: client.instanceId,
          ...request,
        }) as unknown as JsonValue,
      ),
      { signal: options?.signal },
    )
    .then(
      (r) =>
        r.toJson({
          emitDefaultValues: true,
        }) as unknown as V1GetExploreResponse,
    );
}

export function getRuntimeServiceGetExploreQueryKey(
  instanceId: string,
  request?: Omit<PartialMessage<GetExploreRequest>, "instanceId">,
): QueryKey {
  return ["RuntimeService", "getExplore", instanceId, request ?? {}] as const;
}

export function getRuntimeServiceGetExploreQueryOptions<
  TData = V1GetExploreResponse,
>(
  client: RuntimeClient,
  request: Omit<PartialMessage<GetExploreRequest>, "instanceId">,
  options?: {
    query?: Partial<CreateQueryOptions<V1GetExploreResponse, Error, TData>>;
  },
): CreateQueryOptions<V1GetExploreResponse, Error, TData> & {
  queryKey: QueryKey;
} {
  const queryKey = getRuntimeServiceGetExploreQueryKey(
    client.instanceId,
    request,
  );
  const queryFn: QueryFunction<V1GetExploreResponse> = ({ signal }) =>
    runtimeServiceGetExplore(client, request, { signal });
  return {
    queryKey,
    queryFn,
    enabled: !!client.instanceId,
    ...options?.query,
  } as CreateQueryOptions<V1GetExploreResponse, Error, TData> & {
    queryKey: QueryKey;
  };
}

export function createRuntimeServiceGetExplore<TData = V1GetExploreResponse>(
  client: RuntimeClient,
  request: Omit<PartialMessage<GetExploreRequest>, "instanceId">,
  options?: {
    query?: Partial<CreateQueryOptions<V1GetExploreResponse, Error, TData>>;
  },
  queryClient?: QueryClient,
): CreateQueryResult<TData, Error> {
  const queryOptions = getRuntimeServiceGetExploreQueryOptions(
    client,
    request,
    options,
  );
  return createQuery(queryOptions, queryClient);
}

/**
 * Raw RPC call: RuntimeService.GetModelPartitions
 */
export function runtimeServiceGetModelPartitions(
  client: RuntimeClient,
  request: Omit<PartialMessage<GetModelPartitionsRequest>, "instanceId">,
  options?: { signal?: AbortSignal },
): Promise<V1GetModelPartitionsResponse> {
  return client.runtimeService
    .getModelPartitions(
      GetModelPartitionsRequest.fromJson(
        stripUndefined({
          instanceId: client.instanceId,
          ...request,
        }) as unknown as JsonValue,
      ),
      { signal: options?.signal },
    )
    .then(
      (r) =>
        r.toJson({
          emitDefaultValues: true,
        }) as unknown as V1GetModelPartitionsResponse,
    );
}

export function getRuntimeServiceGetModelPartitionsQueryKey(
  instanceId: string,
  request?: Omit<PartialMessage<GetModelPartitionsRequest>, "instanceId">,
): QueryKey {
  return [
    "RuntimeService",
    "getModelPartitions",
    instanceId,
    request ?? {},
  ] as const;
}

export function getRuntimeServiceGetModelPartitionsQueryOptions<
  TData = V1GetModelPartitionsResponse,
>(
  client: RuntimeClient,
  request: Omit<PartialMessage<GetModelPartitionsRequest>, "instanceId">,
  options?: {
    query?: Partial<
      CreateQueryOptions<V1GetModelPartitionsResponse, Error, TData>
    >;
  },
): CreateQueryOptions<V1GetModelPartitionsResponse, Error, TData> & {
  queryKey: QueryKey;
} {
  const queryKey = getRuntimeServiceGetModelPartitionsQueryKey(
    client.instanceId,
    request,
  );
  const queryFn: QueryFunction<V1GetModelPartitionsResponse> = ({ signal }) =>
    runtimeServiceGetModelPartitions(client, request, { signal });
  return {
    queryKey,
    queryFn,
    enabled: !!client.instanceId,
    ...options?.query,
  } as CreateQueryOptions<V1GetModelPartitionsResponse, Error, TData> & {
    queryKey: QueryKey;
  };
}

export function createRuntimeServiceGetModelPartitions<
  TData = V1GetModelPartitionsResponse,
>(
  client: RuntimeClient,
  request: Omit<PartialMessage<GetModelPartitionsRequest>, "instanceId">,
  options?: {
    query?: Partial<
      CreateQueryOptions<V1GetModelPartitionsResponse, Error, TData>
    >;
  },
  queryClient?: QueryClient,
): CreateQueryResult<TData, Error> {
  const queryOptions = getRuntimeServiceGetModelPartitionsQueryOptions(
    client,
    request,
    options,
  );
  return createQuery(queryOptions, queryClient);
}

/**
 * Raw RPC call: RuntimeService.ListConnectorDrivers
 */
export function runtimeServiceListConnectorDrivers(
  client: RuntimeClient,
  request: PartialMessage<ListConnectorDriversRequest>,
  options?: { signal?: AbortSignal },
): Promise<V1ListConnectorDriversResponse> {
  return client.runtimeService
    .listConnectorDrivers(
      ListConnectorDriversRequest.fromJson(
        stripUndefined(request) as unknown as JsonValue,
      ),
      { signal: options?.signal },
    )
    .then(
      (r) =>
        r.toJson({
          emitDefaultValues: true,
        }) as unknown as V1ListConnectorDriversResponse,
    );
}

export function getRuntimeServiceListConnectorDriversQueryKey(
  instanceId: string,
  request?: PartialMessage<ListConnectorDriversRequest>,
): QueryKey {
  return [
    "RuntimeService",
    "listConnectorDrivers",
    instanceId,
    request ?? {},
  ] as const;
}

export function getRuntimeServiceListConnectorDriversQueryOptions<
  TData = V1ListConnectorDriversResponse,
>(
  client: RuntimeClient,
  request: PartialMessage<ListConnectorDriversRequest>,
  options?: {
    query?: Partial<
      CreateQueryOptions<V1ListConnectorDriversResponse, Error, TData>
    >;
  },
): CreateQueryOptions<V1ListConnectorDriversResponse, Error, TData> & {
  queryKey: QueryKey;
} {
  const queryKey = getRuntimeServiceListConnectorDriversQueryKey(
    client.instanceId,
    request,
  );
  const queryFn: QueryFunction<V1ListConnectorDriversResponse> = ({ signal }) =>
    runtimeServiceListConnectorDrivers(client, request, { signal });
  return {
    queryKey,
    queryFn,
    enabled: !!client.instanceId,
    ...options?.query,
  } as CreateQueryOptions<V1ListConnectorDriversResponse, Error, TData> & {
    queryKey: QueryKey;
  };
}

export function createRuntimeServiceListConnectorDrivers<
  TData = V1ListConnectorDriversResponse,
>(
  client: RuntimeClient,
  request: PartialMessage<ListConnectorDriversRequest>,
  options?: {
    query?: Partial<
      CreateQueryOptions<V1ListConnectorDriversResponse, Error, TData>
    >;
  },
  queryClient?: QueryClient,
): CreateQueryResult<TData, Error> {
  const queryOptions = getRuntimeServiceListConnectorDriversQueryOptions(
    client,
    request,
    options,
  );
  return createQuery(queryOptions, queryClient);
}

/**
 * Raw RPC call: RuntimeService.AnalyzeConnectors
 */
export function runtimeServiceAnalyzeConnectors(
  client: RuntimeClient,
  request: Omit<PartialMessage<AnalyzeConnectorsRequest>, "instanceId">,
  options?: { signal?: AbortSignal },
): Promise<V1AnalyzeConnectorsResponse> {
  return client.runtimeService
    .analyzeConnectors(
      AnalyzeConnectorsRequest.fromJson(
        stripUndefined({
          instanceId: client.instanceId,
          ...request,
        }) as unknown as JsonValue,
      ),
      { signal: options?.signal },
    )
    .then(
      (r) =>
        r.toJson({
          emitDefaultValues: true,
        }) as unknown as V1AnalyzeConnectorsResponse,
    );
}

export function getRuntimeServiceAnalyzeConnectorsQueryKey(
  instanceId: string,
  request?: Omit<PartialMessage<AnalyzeConnectorsRequest>, "instanceId">,
): QueryKey {
  return [
    "RuntimeService",
    "analyzeConnectors",
    instanceId,
    request ?? {},
  ] as const;
}

export function getRuntimeServiceAnalyzeConnectorsQueryOptions<
  TData = V1AnalyzeConnectorsResponse,
>(
  client: RuntimeClient,
  request: Omit<PartialMessage<AnalyzeConnectorsRequest>, "instanceId">,
  options?: {
    query?: Partial<
      CreateQueryOptions<V1AnalyzeConnectorsResponse, Error, TData>
    >;
  },
): CreateQueryOptions<V1AnalyzeConnectorsResponse, Error, TData> & {
  queryKey: QueryKey;
} {
  const queryKey = getRuntimeServiceAnalyzeConnectorsQueryKey(
    client.instanceId,
    request,
  );
  const queryFn: QueryFunction<V1AnalyzeConnectorsResponse> = ({ signal }) =>
    runtimeServiceAnalyzeConnectors(client, request, { signal });
  return {
    queryKey,
    queryFn,
    enabled: !!client.instanceId,
    ...options?.query,
  } as CreateQueryOptions<V1AnalyzeConnectorsResponse, Error, TData> & {
    queryKey: QueryKey;
  };
}

export function createRuntimeServiceAnalyzeConnectors<
  TData = V1AnalyzeConnectorsResponse,
>(
  client: RuntimeClient,
  request: Omit<PartialMessage<AnalyzeConnectorsRequest>, "instanceId">,
  options?: {
    query?: Partial<
      CreateQueryOptions<V1AnalyzeConnectorsResponse, Error, TData>
    >;
  },
  queryClient?: QueryClient,
): CreateQueryResult<TData, Error> {
  const queryOptions = getRuntimeServiceAnalyzeConnectorsQueryOptions(
    client,
    request,
    options,
  );
  return createQuery(queryOptions, queryClient);
}

/**
 * Raw RPC call: RuntimeService.ListNotifierConnectors
 */
export function runtimeServiceListNotifierConnectors(
  client: RuntimeClient,
  request: Omit<PartialMessage<ListNotifierConnectorsRequest>, "instanceId">,
  options?: { signal?: AbortSignal },
): Promise<V1ListNotifierConnectorsResponse> {
  return client.runtimeService
    .listNotifierConnectors(
      ListNotifierConnectorsRequest.fromJson(
        stripUndefined({
          instanceId: client.instanceId,
          ...request,
        }) as unknown as JsonValue,
      ),
      { signal: options?.signal },
    )
    .then(
      (r) =>
        r.toJson({
          emitDefaultValues: true,
        }) as unknown as V1ListNotifierConnectorsResponse,
    );
}

export function getRuntimeServiceListNotifierConnectorsQueryKey(
  instanceId: string,
  request?: Omit<PartialMessage<ListNotifierConnectorsRequest>, "instanceId">,
): QueryKey {
  return [
    "RuntimeService",
    "listNotifierConnectors",
    instanceId,
    request ?? {},
  ] as const;
}

export function getRuntimeServiceListNotifierConnectorsQueryOptions<
  TData = V1ListNotifierConnectorsResponse,
>(
  client: RuntimeClient,
  request: Omit<PartialMessage<ListNotifierConnectorsRequest>, "instanceId">,
  options?: {
    query?: Partial<
      CreateQueryOptions<V1ListNotifierConnectorsResponse, Error, TData>
    >;
  },
): CreateQueryOptions<V1ListNotifierConnectorsResponse, Error, TData> & {
  queryKey: QueryKey;
} {
  const queryKey = getRuntimeServiceListNotifierConnectorsQueryKey(
    client.instanceId,
    request,
  );
  const queryFn: QueryFunction<V1ListNotifierConnectorsResponse> = ({
    signal,
  }) => runtimeServiceListNotifierConnectors(client, request, { signal });
  return {
    queryKey,
    queryFn,
    enabled: !!client.instanceId,
    ...options?.query,
  } as CreateQueryOptions<V1ListNotifierConnectorsResponse, Error, TData> & {
    queryKey: QueryKey;
  };
}

export function createRuntimeServiceListNotifierConnectors<
  TData = V1ListNotifierConnectorsResponse,
>(
  client: RuntimeClient,
  request: Omit<PartialMessage<ListNotifierConnectorsRequest>, "instanceId">,
  options?: {
    query?: Partial<
      CreateQueryOptions<V1ListNotifierConnectorsResponse, Error, TData>
    >;
  },
  queryClient?: QueryClient,
): CreateQueryResult<TData, Error> {
  const queryOptions = getRuntimeServiceListNotifierConnectorsQueryOptions(
    client,
    request,
    options,
  );
  return createQuery(queryOptions, queryClient);
}

/**
 * Raw RPC call: RuntimeService.ListConversations
 */
export function runtimeServiceListConversations(
  client: RuntimeClient,
  request: Omit<PartialMessage<ListConversationsRequest>, "instanceId">,
  options?: { signal?: AbortSignal },
): Promise<V1ListConversationsResponse> {
  return client.runtimeService
    .listConversations(
      ListConversationsRequest.fromJson(
        stripUndefined({
          instanceId: client.instanceId,
          ...request,
        }) as unknown as JsonValue,
      ),
      { signal: options?.signal },
    )
    .then(
      (r) =>
        r.toJson({
          emitDefaultValues: true,
        }) as unknown as V1ListConversationsResponse,
    );
}

export function getRuntimeServiceListConversationsQueryKey(
  instanceId: string,
  request?: Omit<PartialMessage<ListConversationsRequest>, "instanceId">,
): QueryKey {
  return [
    "RuntimeService",
    "listConversations",
    instanceId,
    request ?? {},
  ] as const;
}

export function getRuntimeServiceListConversationsQueryOptions<
  TData = V1ListConversationsResponse,
>(
  client: RuntimeClient,
  request: Omit<PartialMessage<ListConversationsRequest>, "instanceId">,
  options?: {
    query?: Partial<
      CreateQueryOptions<V1ListConversationsResponse, Error, TData>
    >;
  },
): CreateQueryOptions<V1ListConversationsResponse, Error, TData> & {
  queryKey: QueryKey;
} {
  const queryKey = getRuntimeServiceListConversationsQueryKey(
    client.instanceId,
    request,
  );
  const queryFn: QueryFunction<V1ListConversationsResponse> = ({ signal }) =>
    runtimeServiceListConversations(client, request, { signal });
  return {
    queryKey,
    queryFn,
    enabled: !!client.instanceId,
    ...options?.query,
  } as CreateQueryOptions<V1ListConversationsResponse, Error, TData> & {
    queryKey: QueryKey;
  };
}

export function createRuntimeServiceListConversations<
  TData = V1ListConversationsResponse,
>(
  client: RuntimeClient,
  request: Omit<PartialMessage<ListConversationsRequest>, "instanceId">,
  options?: {
    query?: Partial<
      CreateQueryOptions<V1ListConversationsResponse, Error, TData>
    >;
  },
  queryClient?: QueryClient,
): CreateQueryResult<TData, Error> {
  const queryOptions = getRuntimeServiceListConversationsQueryOptions(
    client,
    request,
    options,
  );
  return createQuery(queryOptions, queryClient);
}

/**
 * Raw RPC call: RuntimeService.GetConversation
 */
export function runtimeServiceGetConversation(
  client: RuntimeClient,
  request: Omit<PartialMessage<GetConversationRequest>, "instanceId">,
  options?: { signal?: AbortSignal },
): Promise<V1GetConversationResponse> {
  return client.runtimeService
    .getConversation(
      GetConversationRequest.fromJson(
        stripUndefined({
          instanceId: client.instanceId,
          ...request,
        }) as unknown as JsonValue,
      ),
      { signal: options?.signal },
    )
    .then(
      (r) =>
        r.toJson({
          emitDefaultValues: true,
        }) as unknown as V1GetConversationResponse,
    );
}

export function getRuntimeServiceGetConversationQueryKey(
  instanceId: string,
  request?: Omit<PartialMessage<GetConversationRequest>, "instanceId">,
): QueryKey {
  return [
    "RuntimeService",
    "getConversation",
    instanceId,
    request ?? {},
  ] as const;
}

export function getRuntimeServiceGetConversationQueryOptions<
  TData = V1GetConversationResponse,
>(
  client: RuntimeClient,
  request: Omit<PartialMessage<GetConversationRequest>, "instanceId">,
  options?: {
    query?: Partial<
      CreateQueryOptions<V1GetConversationResponse, Error, TData>
    >;
  },
): CreateQueryOptions<V1GetConversationResponse, Error, TData> & {
  queryKey: QueryKey;
} {
  const queryKey = getRuntimeServiceGetConversationQueryKey(
    client.instanceId,
    request,
  );
  const queryFn: QueryFunction<V1GetConversationResponse> = ({ signal }) =>
    runtimeServiceGetConversation(client, request, { signal });
  return {
    queryKey,
    queryFn,
    enabled: !!client.instanceId,
    ...options?.query,
  } as CreateQueryOptions<V1GetConversationResponse, Error, TData> & {
    queryKey: QueryKey;
  };
}

export function createRuntimeServiceGetConversation<
  TData = V1GetConversationResponse,
>(
  client: RuntimeClient,
  request: Omit<PartialMessage<GetConversationRequest>, "instanceId">,
  options?: {
    query?: Partial<
      CreateQueryOptions<V1GetConversationResponse, Error, TData>
    >;
  },
  queryClient?: QueryClient,
): CreateQueryResult<TData, Error> {
  const queryOptions = getRuntimeServiceGetConversationQueryOptions(
    client,
    request,
    options,
  );
  return createQuery(queryOptions, queryClient);
}

/**
 * Raw RPC call: RuntimeService.ListTools
 */
export function runtimeServiceListTools(
  client: RuntimeClient,
  request: Omit<PartialMessage<ListToolsRequest>, "instanceId">,
  options?: { signal?: AbortSignal },
): Promise<V1ListToolsResponse> {
  return client.runtimeService
    .listTools(
      ListToolsRequest.fromJson(
        stripUndefined({
          instanceId: client.instanceId,
          ...request,
        }) as unknown as JsonValue,
      ),
      { signal: options?.signal },
    )
    .then(
      (r) =>
        r.toJson({ emitDefaultValues: true }) as unknown as V1ListToolsResponse,
    );
}

export function getRuntimeServiceListToolsQueryKey(
  instanceId: string,
  request?: Omit<PartialMessage<ListToolsRequest>, "instanceId">,
): QueryKey {
  return ["RuntimeService", "listTools", instanceId, request ?? {}] as const;
}

export function getRuntimeServiceListToolsQueryOptions<
  TData = V1ListToolsResponse,
>(
  client: RuntimeClient,
  request: Omit<PartialMessage<ListToolsRequest>, "instanceId">,
  options?: {
    query?: Partial<CreateQueryOptions<V1ListToolsResponse, Error, TData>>;
  },
): CreateQueryOptions<V1ListToolsResponse, Error, TData> & {
  queryKey: QueryKey;
} {
  const queryKey = getRuntimeServiceListToolsQueryKey(
    client.instanceId,
    request,
  );
  const queryFn: QueryFunction<V1ListToolsResponse> = ({ signal }) =>
    runtimeServiceListTools(client, request, { signal });
  return {
    queryKey,
    queryFn,
    enabled: !!client.instanceId,
    ...options?.query,
  } as CreateQueryOptions<V1ListToolsResponse, Error, TData> & {
    queryKey: QueryKey;
  };
}

export function createRuntimeServiceListTools<TData = V1ListToolsResponse>(
  client: RuntimeClient,
  request: Omit<PartialMessage<ListToolsRequest>, "instanceId">,
  options?: {
    query?: Partial<CreateQueryOptions<V1ListToolsResponse, Error, TData>>;
  },
  queryClient?: QueryClient,
): CreateQueryResult<TData, Error> {
  const queryOptions = getRuntimeServiceListToolsQueryOptions(
    client,
    request,
    options,
  );
  return createQuery(queryOptions, queryClient);
}

/**
 * Raw RPC call: RuntimeService.IssueDevJWT
 */
export function runtimeServiceIssueDevJWT(
  client: RuntimeClient,
  request: V1IssueDevJWTRequest,
  options?: { signal?: AbortSignal },
): Promise<V1IssueDevJWTResponse> {
  return client.runtimeService
    .issueDevJWT(
      IssueDevJWTRequest.fromJson(
        stripUndefined(request) as unknown as JsonValue,
      ),
      { signal: options?.signal },
    )
    .then(
      (r) =>
        r.toJson({
          emitDefaultValues: true,
        }) as unknown as V1IssueDevJWTResponse,
    );
}

export function getRuntimeServiceIssueDevJWTQueryKey(
  instanceId: string,
  request?: V1IssueDevJWTRequest,
): QueryKey {
  return ["RuntimeService", "issueDevJWT", instanceId, request ?? {}] as const;
}

export function getRuntimeServiceIssueDevJWTQueryOptions<
  TData = V1IssueDevJWTResponse,
>(
  client: RuntimeClient,
  request: V1IssueDevJWTRequest,
  options?: {
    query?: Partial<CreateQueryOptions<V1IssueDevJWTResponse, Error, TData>>;
  },
): CreateQueryOptions<V1IssueDevJWTResponse, Error, TData> & {
  queryKey: QueryKey;
} {
  const queryKey = getRuntimeServiceIssueDevJWTQueryKey(
    client.instanceId,
    request,
  );
  const queryFn: QueryFunction<V1IssueDevJWTResponse> = ({ signal }) =>
    runtimeServiceIssueDevJWT(client, request, { signal });
  return {
    queryKey,
    queryFn,
    enabled: !!client.instanceId,
    ...options?.query,
  } as CreateQueryOptions<V1IssueDevJWTResponse, Error, TData> & {
    queryKey: QueryKey;
  };
}

export function createRuntimeServiceIssueDevJWT<TData = V1IssueDevJWTResponse>(
  client: RuntimeClient,
  request: V1IssueDevJWTRequest,
  options?: {
    query?: Partial<CreateQueryOptions<V1IssueDevJWTResponse, Error, TData>>;
  },
  queryClient?: QueryClient,
): CreateQueryResult<TData, Error> {
  const queryOptions = getRuntimeServiceIssueDevJWTQueryOptions(
    client,
    request,
    options,
  );
  return createQuery(queryOptions, queryClient);
}

/**
 * Raw RPC call: RuntimeService.AnalyzeVariables
 */
export function runtimeServiceAnalyzeVariables(
  client: RuntimeClient,
  request: Omit<PartialMessage<AnalyzeVariablesRequest>, "instanceId">,
  options?: { signal?: AbortSignal },
): Promise<V1AnalyzeVariablesResponse> {
  return client.runtimeService
    .analyzeVariables(
      AnalyzeVariablesRequest.fromJson(
        stripUndefined({
          instanceId: client.instanceId,
          ...request,
        }) as unknown as JsonValue,
      ),
      { signal: options?.signal },
    )
    .then(
      (r) =>
        r.toJson({
          emitDefaultValues: true,
        }) as unknown as V1AnalyzeVariablesResponse,
    );
}

export function getRuntimeServiceAnalyzeVariablesQueryKey(
  instanceId: string,
  request?: Omit<PartialMessage<AnalyzeVariablesRequest>, "instanceId">,
): QueryKey {
  return [
    "RuntimeService",
    "analyzeVariables",
    instanceId,
    request ?? {},
  ] as const;
}

export function getRuntimeServiceAnalyzeVariablesQueryOptions<
  TData = V1AnalyzeVariablesResponse,
>(
  client: RuntimeClient,
  request: Omit<PartialMessage<AnalyzeVariablesRequest>, "instanceId">,
  options?: {
    query?: Partial<
      CreateQueryOptions<V1AnalyzeVariablesResponse, Error, TData>
    >;
  },
): CreateQueryOptions<V1AnalyzeVariablesResponse, Error, TData> & {
  queryKey: QueryKey;
} {
  const queryKey = getRuntimeServiceAnalyzeVariablesQueryKey(
    client.instanceId,
    request,
  );
  const queryFn: QueryFunction<V1AnalyzeVariablesResponse> = ({ signal }) =>
    runtimeServiceAnalyzeVariables(client, request, { signal });
  return {
    queryKey,
    queryFn,
    enabled: !!client.instanceId,
    ...options?.query,
  } as CreateQueryOptions<V1AnalyzeVariablesResponse, Error, TData> & {
    queryKey: QueryKey;
  };
}

export function createRuntimeServiceAnalyzeVariables<
  TData = V1AnalyzeVariablesResponse,
>(
  client: RuntimeClient,
  request: Omit<PartialMessage<AnalyzeVariablesRequest>, "instanceId">,
  options?: {
    query?: Partial<
      CreateQueryOptions<V1AnalyzeVariablesResponse, Error, TData>
    >;
  },
  queryClient?: QueryClient,
): CreateQueryResult<TData, Error> {
  const queryOptions = getRuntimeServiceAnalyzeVariablesQueryOptions(
    client,
    request,
    options,
  );
  return createQuery(queryOptions, queryClient);
}

/**
 * Raw RPC call: RuntimeService.ListGitCommits
 */
export function runtimeServiceListGitCommits(
  client: RuntimeClient,
  request: Omit<PartialMessage<ListGitCommitsRequest>, "instanceId">,
  options?: { signal?: AbortSignal },
): Promise<V1ListGitCommitsResponse> {
  return client.runtimeService
    .listGitCommits(
      ListGitCommitsRequest.fromJson(
        stripUndefined({
          instanceId: client.instanceId,
          ...request,
        }) as unknown as JsonValue,
      ),
      { signal: options?.signal },
    )
    .then(
      (r) =>
        r.toJson({
          emitDefaultValues: true,
        }) as unknown as V1ListGitCommitsResponse,
    );
}

export function getRuntimeServiceListGitCommitsQueryKey(
  instanceId: string,
  request?: Omit<PartialMessage<ListGitCommitsRequest>, "instanceId">,
): QueryKey {
  return [
    "RuntimeService",
    "listGitCommits",
    instanceId,
    request ?? {},
  ] as const;
}

export function getRuntimeServiceListGitCommitsQueryOptions<
  TData = V1ListGitCommitsResponse,
>(
  client: RuntimeClient,
  request: Omit<PartialMessage<ListGitCommitsRequest>, "instanceId">,
  options?: {
    query?: Partial<CreateQueryOptions<V1ListGitCommitsResponse, Error, TData>>;
  },
): CreateQueryOptions<V1ListGitCommitsResponse, Error, TData> & {
  queryKey: QueryKey;
} {
  const queryKey = getRuntimeServiceListGitCommitsQueryKey(
    client.instanceId,
    request,
  );
  const queryFn: QueryFunction<V1ListGitCommitsResponse> = ({ signal }) =>
    runtimeServiceListGitCommits(client, request, { signal });
  return {
    queryKey,
    queryFn,
    enabled: !!client.instanceId,
    ...options?.query,
  } as CreateQueryOptions<V1ListGitCommitsResponse, Error, TData> & {
    queryKey: QueryKey;
  };
}

export function createRuntimeServiceListGitCommits<
  TData = V1ListGitCommitsResponse,
>(
  client: RuntimeClient,
  request: Omit<PartialMessage<ListGitCommitsRequest>, "instanceId">,
  options?: {
    query?: Partial<CreateQueryOptions<V1ListGitCommitsResponse, Error, TData>>;
  },
  queryClient?: QueryClient,
): CreateQueryResult<TData, Error> {
  const queryOptions = getRuntimeServiceListGitCommitsQueryOptions(
    client,
    request,
    options,
  );
  return createQuery(queryOptions, queryClient);
}

/**
 * Raw RPC call: RuntimeService.ListGitBranches
 */
export function runtimeServiceListGitBranches(
  client: RuntimeClient,
  request: Omit<PartialMessage<ListGitBranchesRequest>, "instanceId">,
  options?: { signal?: AbortSignal },
): Promise<V1ListGitBranchesResponse> {
  return client.runtimeService
    .listGitBranches(
      ListGitBranchesRequest.fromJson(
        stripUndefined({
          instanceId: client.instanceId,
          ...request,
        }) as unknown as JsonValue,
      ),
      { signal: options?.signal },
    )
    .then(
      (r) =>
        r.toJson({
          emitDefaultValues: true,
        }) as unknown as V1ListGitBranchesResponse,
    );
}

export function getRuntimeServiceListGitBranchesQueryKey(
  instanceId: string,
  request?: Omit<PartialMessage<ListGitBranchesRequest>, "instanceId">,
): QueryKey {
  return [
    "RuntimeService",
    "listGitBranches",
    instanceId,
    request ?? {},
  ] as const;
}

export function getRuntimeServiceListGitBranchesQueryOptions<
  TData = V1ListGitBranchesResponse,
>(
  client: RuntimeClient,
  request: Omit<PartialMessage<ListGitBranchesRequest>, "instanceId">,
  options?: {
    query?: Partial<
      CreateQueryOptions<V1ListGitBranchesResponse, Error, TData>
    >;
  },
): CreateQueryOptions<V1ListGitBranchesResponse, Error, TData> & {
  queryKey: QueryKey;
} {
  const queryKey = getRuntimeServiceListGitBranchesQueryKey(
    client.instanceId,
    request,
  );
  const queryFn: QueryFunction<V1ListGitBranchesResponse> = ({ signal }) =>
    runtimeServiceListGitBranches(client, request, { signal });
  return {
    queryKey,
    queryFn,
    enabled: !!client.instanceId,
    ...options?.query,
  } as CreateQueryOptions<V1ListGitBranchesResponse, Error, TData> & {
    queryKey: QueryKey;
  };
}

export function createRuntimeServiceListGitBranches<
  TData = V1ListGitBranchesResponse,
>(
  client: RuntimeClient,
  request: Omit<PartialMessage<ListGitBranchesRequest>, "instanceId">,
  options?: {
    query?: Partial<
      CreateQueryOptions<V1ListGitBranchesResponse, Error, TData>
    >;
  },
  queryClient?: QueryClient,
): CreateQueryResult<TData, Error> {
  const queryOptions = getRuntimeServiceListGitBranchesQueryOptions(
    client,
    request,
    options,
  );
  return createQuery(queryOptions, queryClient);
}

/**
 * Raw RPC call (mutation): RuntimeService.CreateInstance
 */
export function runtimeServiceCreateInstance(
  client: RuntimeClient,
  request: Omit<V1CreateInstanceRequest, "instanceId">,
): Promise<V1CreateInstanceResponse> {
  return client.runtimeService
    .createInstance(
      CreateInstanceRequest.fromJson(
        stripUndefined({
          instanceId: client.instanceId,
          ...request,
        }) as unknown as JsonValue,
      ),
    )
    .then(
      (r) =>
        r.toJson({
          emitDefaultValues: true,
        }) as unknown as V1CreateInstanceResponse,
    );
}

export function getRuntimeServiceCreateInstanceMutationOptions(
  client: RuntimeClient,
  options?: Partial<
    CreateMutationOptions<
      V1CreateInstanceResponse,
      unknown,
      Omit<V1CreateInstanceRequest, "instanceId">
    >
  >,
): CreateMutationOptions<
  V1CreateInstanceResponse,
  unknown,
  Omit<V1CreateInstanceRequest, "instanceId">
> {
  return {
    mutationFn: (request) => runtimeServiceCreateInstance(client, request),
    ...options,
  };
}

export function createRuntimeServiceCreateInstanceMutation(
  client: RuntimeClient,
  options?: Partial<
    CreateMutationOptions<
      V1CreateInstanceResponse,
      unknown,
      Omit<V1CreateInstanceRequest, "instanceId">
    >
  >,
  queryClient?: QueryClient,
): CreateMutationResult<
  V1CreateInstanceResponse,
  unknown,
  Omit<V1CreateInstanceRequest, "instanceId">
> {
  const mutationOptions = getRuntimeServiceCreateInstanceMutationOptions(
    client,
    options,
  );
  return createMutation(mutationOptions, queryClient);
}

/**
 * Raw RPC call (mutation): RuntimeService.EditInstance
 */
export function runtimeServiceEditInstance(
  client: RuntimeClient,
  request: Omit<PartialMessage<EditInstanceRequest>, "instanceId">,
): Promise<V1EditInstanceResponse> {
  return client.runtimeService
    .editInstance(
      EditInstanceRequest.fromJson(
        stripUndefined({
          instanceId: client.instanceId,
          ...request,
        }) as unknown as JsonValue,
      ),
    )
    .then(
      (r) =>
        r.toJson({
          emitDefaultValues: true,
        }) as unknown as V1EditInstanceResponse,
    );
}

export function getRuntimeServiceEditInstanceMutationOptions(
  client: RuntimeClient,
  options?: Partial<
    CreateMutationOptions<
      V1EditInstanceResponse,
      unknown,
      Omit<PartialMessage<EditInstanceRequest>, "instanceId">
    >
  >,
): CreateMutationOptions<
  V1EditInstanceResponse,
  unknown,
  Omit<PartialMessage<EditInstanceRequest>, "instanceId">
> {
  return {
    mutationFn: (request) => runtimeServiceEditInstance(client, request),
    ...options,
  };
}

export function createRuntimeServiceEditInstanceMutation(
  client: RuntimeClient,
  options?: Partial<
    CreateMutationOptions<
      V1EditInstanceResponse,
      unknown,
      Omit<PartialMessage<EditInstanceRequest>, "instanceId">
    >
  >,
  queryClient?: QueryClient,
): CreateMutationResult<
  V1EditInstanceResponse,
  unknown,
  Omit<PartialMessage<EditInstanceRequest>, "instanceId">
> {
  const mutationOptions = getRuntimeServiceEditInstanceMutationOptions(
    client,
    options,
  );
  return createMutation(mutationOptions, queryClient);
}

/**
 * Raw RPC call (mutation): RuntimeService.DeleteInstance
 */
export function runtimeServiceDeleteInstance(
  client: RuntimeClient,
  request: Omit<PartialMessage<DeleteInstanceRequest>, "instanceId">,
): Promise<V1DeleteInstanceResponse> {
  return client.runtimeService
    .deleteInstance(
      DeleteInstanceRequest.fromJson(
        stripUndefined({
          instanceId: client.instanceId,
          ...request,
        }) as unknown as JsonValue,
      ),
    )
    .then(
      (r) =>
        r.toJson({
          emitDefaultValues: true,
        }) as unknown as V1DeleteInstanceResponse,
    );
}

export function getRuntimeServiceDeleteInstanceMutationOptions(
  client: RuntimeClient,
  options?: Partial<
    CreateMutationOptions<
      V1DeleteInstanceResponse,
      unknown,
      Omit<PartialMessage<DeleteInstanceRequest>, "instanceId">
    >
  >,
): CreateMutationOptions<
  V1DeleteInstanceResponse,
  unknown,
  Omit<PartialMessage<DeleteInstanceRequest>, "instanceId">
> {
  return {
    mutationFn: (request) => runtimeServiceDeleteInstance(client, request),
    ...options,
  };
}

export function createRuntimeServiceDeleteInstanceMutation(
  client: RuntimeClient,
  options?: Partial<
    CreateMutationOptions<
      V1DeleteInstanceResponse,
      unknown,
      Omit<PartialMessage<DeleteInstanceRequest>, "instanceId">
    >
  >,
  queryClient?: QueryClient,
): CreateMutationResult<
  V1DeleteInstanceResponse,
  unknown,
  Omit<PartialMessage<DeleteInstanceRequest>, "instanceId">
> {
  const mutationOptions = getRuntimeServiceDeleteInstanceMutationOptions(
    client,
    options,
  );
  return createMutation(mutationOptions, queryClient);
}

/**
 * Raw RPC call (mutation): RuntimeService.ReloadConfig
 */
export function runtimeServiceReloadConfig(
  client: RuntimeClient,
  request: Omit<PartialMessage<ReloadConfigRequest>, "instanceId">,
): Promise<V1ReloadConfigResponse> {
  return client.runtimeService
    .reloadConfig(
      ReloadConfigRequest.fromJson(
        stripUndefined({
          instanceId: client.instanceId,
          ...request,
        }) as unknown as JsonValue,
      ),
    )
    .then(
      (r) =>
        r.toJson({
          emitDefaultValues: true,
        }) as unknown as V1ReloadConfigResponse,
    );
}

export function getRuntimeServiceReloadConfigMutationOptions(
  client: RuntimeClient,
  options?: Partial<
    CreateMutationOptions<
      V1ReloadConfigResponse,
      unknown,
      Omit<PartialMessage<ReloadConfigRequest>, "instanceId">
    >
  >,
): CreateMutationOptions<
  V1ReloadConfigResponse,
  unknown,
  Omit<PartialMessage<ReloadConfigRequest>, "instanceId">
> {
  return {
    mutationFn: (request) => runtimeServiceReloadConfig(client, request),
    ...options,
  };
}

export function createRuntimeServiceReloadConfigMutation(
  client: RuntimeClient,
  options?: Partial<
    CreateMutationOptions<
      V1ReloadConfigResponse,
      unknown,
      Omit<PartialMessage<ReloadConfigRequest>, "instanceId">
    >
  >,
  queryClient?: QueryClient,
): CreateMutationResult<
  V1ReloadConfigResponse,
  unknown,
  Omit<PartialMessage<ReloadConfigRequest>, "instanceId">
> {
  const mutationOptions = getRuntimeServiceReloadConfigMutationOptions(
    client,
    options,
  );
  return createMutation(mutationOptions, queryClient);
}

/**
 * Raw RPC call (mutation): RuntimeService.PutFile
 */
export function runtimeServicePutFile(
  client: RuntimeClient,
  request: Omit<PartialMessage<PutFileRequest>, "instanceId">,
): Promise<V1PutFileResponse> {
  return client.runtimeService
    .putFile(
      PutFileRequest.fromJson(
        stripUndefined({
          instanceId: client.instanceId,
          ...request,
        }) as unknown as JsonValue,
      ),
    )
    .then(
      (r) =>
        r.toJson({ emitDefaultValues: true }) as unknown as V1PutFileResponse,
    );
}

export function getRuntimeServicePutFileMutationOptions(
  client: RuntimeClient,
  options?: Partial<
    CreateMutationOptions<
      V1PutFileResponse,
      unknown,
      Omit<PartialMessage<PutFileRequest>, "instanceId">
    >
  >,
): CreateMutationOptions<
  V1PutFileResponse,
  unknown,
  Omit<PartialMessage<PutFileRequest>, "instanceId">
> {
  return {
    mutationFn: (request) => runtimeServicePutFile(client, request),
    ...options,
  };
}

export function createRuntimeServicePutFileMutation(
  client: RuntimeClient,
  options?: Partial<
    CreateMutationOptions<
      V1PutFileResponse,
      unknown,
      Omit<PartialMessage<PutFileRequest>, "instanceId">
    >
  >,
  queryClient?: QueryClient,
): CreateMutationResult<
  V1PutFileResponse,
  unknown,
  Omit<PartialMessage<PutFileRequest>, "instanceId">
> {
  const mutationOptions = getRuntimeServicePutFileMutationOptions(
    client,
    options,
  );
  return createMutation(mutationOptions, queryClient);
}

/**
 * Raw RPC call (mutation): RuntimeService.CreateDirectory
 */
export function runtimeServiceCreateDirectory(
  client: RuntimeClient,
  request: Omit<PartialMessage<CreateDirectoryRequest>, "instanceId">,
): Promise<V1CreateDirectoryResponse> {
  return client.runtimeService
    .createDirectory(
      CreateDirectoryRequest.fromJson(
        stripUndefined({
          instanceId: client.instanceId,
          ...request,
        }) as unknown as JsonValue,
      ),
    )
    .then(
      (r) =>
        r.toJson({
          emitDefaultValues: true,
        }) as unknown as V1CreateDirectoryResponse,
    );
}

export function getRuntimeServiceCreateDirectoryMutationOptions(
  client: RuntimeClient,
  options?: Partial<
    CreateMutationOptions<
      V1CreateDirectoryResponse,
      unknown,
      Omit<PartialMessage<CreateDirectoryRequest>, "instanceId">
    >
  >,
): CreateMutationOptions<
  V1CreateDirectoryResponse,
  unknown,
  Omit<PartialMessage<CreateDirectoryRequest>, "instanceId">
> {
  return {
    mutationFn: (request) => runtimeServiceCreateDirectory(client, request),
    ...options,
  };
}

export function createRuntimeServiceCreateDirectoryMutation(
  client: RuntimeClient,
  options?: Partial<
    CreateMutationOptions<
      V1CreateDirectoryResponse,
      unknown,
      Omit<PartialMessage<CreateDirectoryRequest>, "instanceId">
    >
  >,
  queryClient?: QueryClient,
): CreateMutationResult<
  V1CreateDirectoryResponse,
  unknown,
  Omit<PartialMessage<CreateDirectoryRequest>, "instanceId">
> {
  const mutationOptions = getRuntimeServiceCreateDirectoryMutationOptions(
    client,
    options,
  );
  return createMutation(mutationOptions, queryClient);
}

/**
 * Raw RPC call (mutation): RuntimeService.DeleteFile
 */
export function runtimeServiceDeleteFile(
  client: RuntimeClient,
  request: Omit<PartialMessage<DeleteFileRequest>, "instanceId">,
): Promise<V1DeleteFileResponse> {
  return client.runtimeService
    .deleteFile(
      DeleteFileRequest.fromJson(
        stripUndefined({
          instanceId: client.instanceId,
          ...request,
        }) as unknown as JsonValue,
      ),
    )
    .then(
      (r) =>
        r.toJson({
          emitDefaultValues: true,
        }) as unknown as V1DeleteFileResponse,
    );
}

export function getRuntimeServiceDeleteFileMutationOptions(
  client: RuntimeClient,
  options?: Partial<
    CreateMutationOptions<
      V1DeleteFileResponse,
      unknown,
      Omit<PartialMessage<DeleteFileRequest>, "instanceId">
    >
  >,
): CreateMutationOptions<
  V1DeleteFileResponse,
  unknown,
  Omit<PartialMessage<DeleteFileRequest>, "instanceId">
> {
  return {
    mutationFn: (request) => runtimeServiceDeleteFile(client, request),
    ...options,
  };
}

export function createRuntimeServiceDeleteFileMutation(
  client: RuntimeClient,
  options?: Partial<
    CreateMutationOptions<
      V1DeleteFileResponse,
      unknown,
      Omit<PartialMessage<DeleteFileRequest>, "instanceId">
    >
  >,
  queryClient?: QueryClient,
): CreateMutationResult<
  V1DeleteFileResponse,
  unknown,
  Omit<PartialMessage<DeleteFileRequest>, "instanceId">
> {
  const mutationOptions = getRuntimeServiceDeleteFileMutationOptions(
    client,
    options,
  );
  return createMutation(mutationOptions, queryClient);
}

/**
 * Raw RPC call (mutation): RuntimeService.RenameFile
 */
export function runtimeServiceRenameFile(
  client: RuntimeClient,
  request: Omit<PartialMessage<RenameFileRequest>, "instanceId">,
): Promise<V1RenameFileResponse> {
  return client.runtimeService
    .renameFile(
      RenameFileRequest.fromJson(
        stripUndefined({
          instanceId: client.instanceId,
          ...request,
        }) as unknown as JsonValue,
      ),
    )
    .then(
      (r) =>
        r.toJson({
          emitDefaultValues: true,
        }) as unknown as V1RenameFileResponse,
    );
}

export function getRuntimeServiceRenameFileMutationOptions(
  client: RuntimeClient,
  options?: Partial<
    CreateMutationOptions<
      V1RenameFileResponse,
      unknown,
      Omit<PartialMessage<RenameFileRequest>, "instanceId">
    >
  >,
): CreateMutationOptions<
  V1RenameFileResponse,
  unknown,
  Omit<PartialMessage<RenameFileRequest>, "instanceId">
> {
  return {
    mutationFn: (request) => runtimeServiceRenameFile(client, request),
    ...options,
  };
}

export function createRuntimeServiceRenameFileMutation(
  client: RuntimeClient,
  options?: Partial<
    CreateMutationOptions<
      V1RenameFileResponse,
      unknown,
      Omit<PartialMessage<RenameFileRequest>, "instanceId">
    >
  >,
  queryClient?: QueryClient,
): CreateMutationResult<
  V1RenameFileResponse,
  unknown,
  Omit<PartialMessage<RenameFileRequest>, "instanceId">
> {
  const mutationOptions = getRuntimeServiceRenameFileMutationOptions(
    client,
    options,
  );
  return createMutation(mutationOptions, queryClient);
}

/**
 * Raw RPC call (mutation): RuntimeService.UnpackExample
 */
export function runtimeServiceUnpackExample(
  client: RuntimeClient,
  request: Omit<PartialMessage<UnpackExampleRequest>, "instanceId">,
): Promise<V1UnpackExampleResponse> {
  return client.runtimeService
    .unpackExample(
      UnpackExampleRequest.fromJson(
        stripUndefined({
          instanceId: client.instanceId,
          ...request,
        }) as unknown as JsonValue,
      ),
    )
    .then(
      (r) =>
        r.toJson({
          emitDefaultValues: true,
        }) as unknown as V1UnpackExampleResponse,
    );
}

export function getRuntimeServiceUnpackExampleMutationOptions(
  client: RuntimeClient,
  options?: Partial<
    CreateMutationOptions<
      V1UnpackExampleResponse,
      unknown,
      Omit<PartialMessage<UnpackExampleRequest>, "instanceId">
    >
  >,
): CreateMutationOptions<
  V1UnpackExampleResponse,
  unknown,
  Omit<PartialMessage<UnpackExampleRequest>, "instanceId">
> {
  return {
    mutationFn: (request) => runtimeServiceUnpackExample(client, request),
    ...options,
  };
}

export function createRuntimeServiceUnpackExampleMutation(
  client: RuntimeClient,
  options?: Partial<
    CreateMutationOptions<
      V1UnpackExampleResponse,
      unknown,
      Omit<PartialMessage<UnpackExampleRequest>, "instanceId">
    >
  >,
  queryClient?: QueryClient,
): CreateMutationResult<
  V1UnpackExampleResponse,
  unknown,
  Omit<PartialMessage<UnpackExampleRequest>, "instanceId">
> {
  const mutationOptions = getRuntimeServiceUnpackExampleMutationOptions(
    client,
    options,
  );
  return createMutation(mutationOptions, queryClient);
}

/**
 * Raw RPC call (mutation): RuntimeService.UnpackEmpty
 */
export function runtimeServiceUnpackEmpty(
  client: RuntimeClient,
  request: Omit<PartialMessage<UnpackEmptyRequest>, "instanceId">,
): Promise<V1UnpackEmptyResponse> {
  return client.runtimeService
    .unpackEmpty(
      UnpackEmptyRequest.fromJson(
        stripUndefined({
          instanceId: client.instanceId,
          ...request,
        }) as unknown as JsonValue,
      ),
    )
    .then(
      (r) =>
        r.toJson({
          emitDefaultValues: true,
        }) as unknown as V1UnpackEmptyResponse,
    );
}

export function getRuntimeServiceUnpackEmptyMutationOptions(
  client: RuntimeClient,
  options?: Partial<
    CreateMutationOptions<
      V1UnpackEmptyResponse,
      unknown,
      Omit<PartialMessage<UnpackEmptyRequest>, "instanceId">
    >
  >,
): CreateMutationOptions<
  V1UnpackEmptyResponse,
  unknown,
  Omit<PartialMessage<UnpackEmptyRequest>, "instanceId">
> {
  return {
    mutationFn: (request) => runtimeServiceUnpackEmpty(client, request),
    ...options,
  };
}

export function createRuntimeServiceUnpackEmptyMutation(
  client: RuntimeClient,
  options?: Partial<
    CreateMutationOptions<
      V1UnpackEmptyResponse,
      unknown,
      Omit<PartialMessage<UnpackEmptyRequest>, "instanceId">
    >
  >,
  queryClient?: QueryClient,
): CreateMutationResult<
  V1UnpackEmptyResponse,
  unknown,
  Omit<PartialMessage<UnpackEmptyRequest>, "instanceId">
> {
  const mutationOptions = getRuntimeServiceUnpackEmptyMutationOptions(
    client,
    options,
  );
  return createMutation(mutationOptions, queryClient);
}

/**
 * Raw RPC call (mutation): RuntimeService.GenerateMetricsViewFile
 */
export function runtimeServiceGenerateMetricsViewFile(
  client: RuntimeClient,
  request: Omit<PartialMessage<GenerateMetricsViewFileRequest>, "instanceId">,
): Promise<V1GenerateMetricsViewFileResponse> {
  return client.runtimeService
    .generateMetricsViewFile(
      GenerateMetricsViewFileRequest.fromJson(
        stripUndefined({
          instanceId: client.instanceId,
          ...request,
        }) as unknown as JsonValue,
      ),
    )
    .then(
      (r) =>
        r.toJson({
          emitDefaultValues: true,
        }) as unknown as V1GenerateMetricsViewFileResponse,
    );
}

export function getRuntimeServiceGenerateMetricsViewFileMutationOptions(
  client: RuntimeClient,
  options?: Partial<
    CreateMutationOptions<
      V1GenerateMetricsViewFileResponse,
      unknown,
      Omit<PartialMessage<GenerateMetricsViewFileRequest>, "instanceId">
    >
  >,
): CreateMutationOptions<
  V1GenerateMetricsViewFileResponse,
  unknown,
  Omit<PartialMessage<GenerateMetricsViewFileRequest>, "instanceId">
> {
  return {
    mutationFn: (request) =>
      runtimeServiceGenerateMetricsViewFile(client, request),
    ...options,
  };
}

export function createRuntimeServiceGenerateMetricsViewFileMutation(
  client: RuntimeClient,
  options?: Partial<
    CreateMutationOptions<
      V1GenerateMetricsViewFileResponse,
      unknown,
      Omit<PartialMessage<GenerateMetricsViewFileRequest>, "instanceId">
    >
  >,
  queryClient?: QueryClient,
): CreateMutationResult<
  V1GenerateMetricsViewFileResponse,
  unknown,
  Omit<PartialMessage<GenerateMetricsViewFileRequest>, "instanceId">
> {
  const mutationOptions =
    getRuntimeServiceGenerateMetricsViewFileMutationOptions(client, options);
  return createMutation(mutationOptions, queryClient);
}

/**
 * Raw RPC call (mutation): RuntimeService.GenerateCanvasFile
 */
export function runtimeServiceGenerateCanvasFile(
  client: RuntimeClient,
  request: Omit<PartialMessage<GenerateCanvasFileRequest>, "instanceId">,
): Promise<V1GenerateCanvasFileResponse> {
  return client.runtimeService
    .generateCanvasFile(
      GenerateCanvasFileRequest.fromJson(
        stripUndefined({
          instanceId: client.instanceId,
          ...request,
        }) as unknown as JsonValue,
      ),
    )
    .then(
      (r) =>
        r.toJson({
          emitDefaultValues: true,
        }) as unknown as V1GenerateCanvasFileResponse,
    );
}

export function getRuntimeServiceGenerateCanvasFileMutationOptions(
  client: RuntimeClient,
  options?: Partial<
    CreateMutationOptions<
      V1GenerateCanvasFileResponse,
      unknown,
      Omit<PartialMessage<GenerateCanvasFileRequest>, "instanceId">
    >
  >,
): CreateMutationOptions<
  V1GenerateCanvasFileResponse,
  unknown,
  Omit<PartialMessage<GenerateCanvasFileRequest>, "instanceId">
> {
  return {
    mutationFn: (request) => runtimeServiceGenerateCanvasFile(client, request),
    ...options,
  };
}

export function createRuntimeServiceGenerateCanvasFileMutation(
  client: RuntimeClient,
  options?: Partial<
    CreateMutationOptions<
      V1GenerateCanvasFileResponse,
      unknown,
      Omit<PartialMessage<GenerateCanvasFileRequest>, "instanceId">
    >
  >,
  queryClient?: QueryClient,
): CreateMutationResult<
  V1GenerateCanvasFileResponse,
  unknown,
  Omit<PartialMessage<GenerateCanvasFileRequest>, "instanceId">
> {
  const mutationOptions = getRuntimeServiceGenerateCanvasFileMutationOptions(
    client,
    options,
  );
  return createMutation(mutationOptions, queryClient);
}

/**
 * Raw RPC call (mutation): RuntimeService.GenerateResolver
 */
export function runtimeServiceGenerateResolver(
  client: RuntimeClient,
  request: Omit<PartialMessage<GenerateResolverRequest>, "instanceId">,
): Promise<V1GenerateResolverResponse> {
  return client.runtimeService
    .generateResolver(
      GenerateResolverRequest.fromJson(
        stripUndefined({
          instanceId: client.instanceId,
          ...request,
        }) as unknown as JsonValue,
      ),
    )
    .then(
      (r) =>
        r.toJson({
          emitDefaultValues: true,
        }) as unknown as V1GenerateResolverResponse,
    );
}

export function getRuntimeServiceGenerateResolverMutationOptions(
  client: RuntimeClient,
  options?: Partial<
    CreateMutationOptions<
      V1GenerateResolverResponse,
      unknown,
      Omit<PartialMessage<GenerateResolverRequest>, "instanceId">
    >
  >,
): CreateMutationOptions<
  V1GenerateResolverResponse,
  unknown,
  Omit<PartialMessage<GenerateResolverRequest>, "instanceId">
> {
  return {
    mutationFn: (request) => runtimeServiceGenerateResolver(client, request),
    ...options,
  };
}

export function createRuntimeServiceGenerateResolverMutation(
  client: RuntimeClient,
  options?: Partial<
    CreateMutationOptions<
      V1GenerateResolverResponse,
      unknown,
      Omit<PartialMessage<GenerateResolverRequest>, "instanceId">
    >
  >,
  queryClient?: QueryClient,
): CreateMutationResult<
  V1GenerateResolverResponse,
  unknown,
  Omit<PartialMessage<GenerateResolverRequest>, "instanceId">
> {
  const mutationOptions = getRuntimeServiceGenerateResolverMutationOptions(
    client,
    options,
  );
  return createMutation(mutationOptions, queryClient);
}

/**
 * Raw RPC call (mutation): RuntimeService.GenerateRenderer
 */
export function runtimeServiceGenerateRenderer(
  client: RuntimeClient,
  request: Omit<PartialMessage<GenerateRendererRequest>, "instanceId">,
): Promise<V1GenerateRendererResponse> {
  return client.runtimeService
    .generateRenderer(
      GenerateRendererRequest.fromJson(
        stripUndefined({
          instanceId: client.instanceId,
          ...request,
        }) as unknown as JsonValue,
      ),
    )
    .then(
      (r) =>
        r.toJson({
          emitDefaultValues: true,
        }) as unknown as V1GenerateRendererResponse,
    );
}

export function getRuntimeServiceGenerateRendererMutationOptions(
  client: RuntimeClient,
  options?: Partial<
    CreateMutationOptions<
      V1GenerateRendererResponse,
      unknown,
      Omit<PartialMessage<GenerateRendererRequest>, "instanceId">
    >
  >,
): CreateMutationOptions<
  V1GenerateRendererResponse,
  unknown,
  Omit<PartialMessage<GenerateRendererRequest>, "instanceId">
> {
  return {
    mutationFn: (request) => runtimeServiceGenerateRenderer(client, request),
    ...options,
  };
}

export function createRuntimeServiceGenerateRendererMutation(
  client: RuntimeClient,
  options?: Partial<
    CreateMutationOptions<
      V1GenerateRendererResponse,
      unknown,
      Omit<PartialMessage<GenerateRendererRequest>, "instanceId">
    >
  >,
  queryClient?: QueryClient,
): CreateMutationResult<
  V1GenerateRendererResponse,
  unknown,
  Omit<PartialMessage<GenerateRendererRequest>, "instanceId">
> {
  const mutationOptions = getRuntimeServiceGenerateRendererMutationOptions(
    client,
    options,
  );
  return createMutation(mutationOptions, queryClient);
}

/**
 * Raw RPC call (mutation): RuntimeService.CreateTrigger
 */
export function runtimeServiceCreateTrigger(
  client: RuntimeClient,
  request: Omit<PartialMessage<CreateTriggerRequest>, "instanceId">,
): Promise<V1CreateTriggerResponse> {
  return client.runtimeService
    .createTrigger(
      CreateTriggerRequest.fromJson(
        stripUndefined({
          instanceId: client.instanceId,
          ...request,
        }) as unknown as JsonValue,
      ),
    )
    .then(
      (r) =>
        r.toJson({
          emitDefaultValues: true,
        }) as unknown as V1CreateTriggerResponse,
    );
}

export function getRuntimeServiceCreateTriggerMutationOptions(
  client: RuntimeClient,
  options?: Partial<
    CreateMutationOptions<
      V1CreateTriggerResponse,
      unknown,
      Omit<PartialMessage<CreateTriggerRequest>, "instanceId">
    >
  >,
): CreateMutationOptions<
  V1CreateTriggerResponse,
  unknown,
  Omit<PartialMessage<CreateTriggerRequest>, "instanceId">
> {
  return {
    mutationFn: (request) => runtimeServiceCreateTrigger(client, request),
    ...options,
  };
}

export function createRuntimeServiceCreateTriggerMutation(
  client: RuntimeClient,
  options?: Partial<
    CreateMutationOptions<
      V1CreateTriggerResponse,
      unknown,
      Omit<PartialMessage<CreateTriggerRequest>, "instanceId">
    >
  >,
  queryClient?: QueryClient,
): CreateMutationResult<
  V1CreateTriggerResponse,
  unknown,
  Omit<PartialMessage<CreateTriggerRequest>, "instanceId">
> {
  const mutationOptions = getRuntimeServiceCreateTriggerMutationOptions(
    client,
    options,
  );
  return createMutation(mutationOptions, queryClient);
}

/**
 * Raw RPC call (mutation): RuntimeService.ShareConversation
 */
export function runtimeServiceShareConversation(
  client: RuntimeClient,
  request: Omit<PartialMessage<ShareConversationRequest>, "instanceId">,
): Promise<V1ShareConversationResponse> {
  return client.runtimeService
    .shareConversation(
      ShareConversationRequest.fromJson(
        stripUndefined({
          instanceId: client.instanceId,
          ...request,
        }) as unknown as JsonValue,
      ),
    )
    .then(
      (r) =>
        r.toJson({
          emitDefaultValues: true,
        }) as unknown as V1ShareConversationResponse,
    );
}

export function getRuntimeServiceShareConversationMutationOptions(
  client: RuntimeClient,
  options?: Partial<
    CreateMutationOptions<
      V1ShareConversationResponse,
      unknown,
      Omit<PartialMessage<ShareConversationRequest>, "instanceId">
    >
  >,
): CreateMutationOptions<
  V1ShareConversationResponse,
  unknown,
  Omit<PartialMessage<ShareConversationRequest>, "instanceId">
> {
  return {
    mutationFn: (request) => runtimeServiceShareConversation(client, request),
    ...options,
  };
}

export function createRuntimeServiceShareConversationMutation(
  client: RuntimeClient,
  options?: Partial<
    CreateMutationOptions<
      V1ShareConversationResponse,
      unknown,
      Omit<PartialMessage<ShareConversationRequest>, "instanceId">
    >
  >,
  queryClient?: QueryClient,
): CreateMutationResult<
  V1ShareConversationResponse,
  unknown,
  Omit<PartialMessage<ShareConversationRequest>, "instanceId">
> {
  const mutationOptions = getRuntimeServiceShareConversationMutationOptions(
    client,
    options,
  );
  return createMutation(mutationOptions, queryClient);
}

/**
 * Raw RPC call (mutation): RuntimeService.ForkConversation
 */
export function runtimeServiceForkConversation(
  client: RuntimeClient,
  request: Omit<PartialMessage<ForkConversationRequest>, "instanceId">,
): Promise<V1ForkConversationResponse> {
  return client.runtimeService
    .forkConversation(
      ForkConversationRequest.fromJson(
        stripUndefined({
          instanceId: client.instanceId,
          ...request,
        }) as unknown as JsonValue,
      ),
    )
    .then(
      (r) =>
        r.toJson({
          emitDefaultValues: true,
        }) as unknown as V1ForkConversationResponse,
    );
}

export function getRuntimeServiceForkConversationMutationOptions(
  client: RuntimeClient,
  options?: Partial<
    CreateMutationOptions<
      V1ForkConversationResponse,
      unknown,
      Omit<PartialMessage<ForkConversationRequest>, "instanceId">
    >
  >,
): CreateMutationOptions<
  V1ForkConversationResponse,
  unknown,
  Omit<PartialMessage<ForkConversationRequest>, "instanceId">
> {
  return {
    mutationFn: (request) => runtimeServiceForkConversation(client, request),
    ...options,
  };
}

export function createRuntimeServiceForkConversationMutation(
  client: RuntimeClient,
  options?: Partial<
    CreateMutationOptions<
      V1ForkConversationResponse,
      unknown,
      Omit<PartialMessage<ForkConversationRequest>, "instanceId">
    >
  >,
  queryClient?: QueryClient,
): CreateMutationResult<
  V1ForkConversationResponse,
  unknown,
  Omit<PartialMessage<ForkConversationRequest>, "instanceId">
> {
  const mutationOptions = getRuntimeServiceForkConversationMutationOptions(
    client,
    options,
  );
  return createMutation(mutationOptions, queryClient);
}

/**
 * Raw RPC call (mutation): RuntimeService.Complete
 */
export function runtimeServiceComplete(
  client: RuntimeClient,
  request: Omit<PartialMessage<CompleteRequest>, "instanceId">,
): Promise<V1CompleteResponse> {
  return client.runtimeService
    .complete(
      CompleteRequest.fromJson(
        stripUndefined({
          instanceId: client.instanceId,
          ...request,
        }) as unknown as JsonValue,
      ),
    )
    .then(
      (r) =>
        r.toJson({ emitDefaultValues: true }) as unknown as V1CompleteResponse,
    );
}

export function getRuntimeServiceCompleteMutationOptions(
  client: RuntimeClient,
  options?: Partial<
    CreateMutationOptions<
      V1CompleteResponse,
      unknown,
      Omit<PartialMessage<CompleteRequest>, "instanceId">
    >
  >,
): CreateMutationOptions<
  V1CompleteResponse,
  unknown,
  Omit<PartialMessage<CompleteRequest>, "instanceId">
> {
  return {
    mutationFn: (request) => runtimeServiceComplete(client, request),
    ...options,
  };
}

export function createRuntimeServiceCompleteMutation(
  client: RuntimeClient,
  options?: Partial<
    CreateMutationOptions<
      V1CompleteResponse,
      unknown,
      Omit<PartialMessage<CompleteRequest>, "instanceId">
    >
  >,
  queryClient?: QueryClient,
): CreateMutationResult<
  V1CompleteResponse,
  unknown,
  Omit<PartialMessage<CompleteRequest>, "instanceId">
> {
  const mutationOptions = getRuntimeServiceCompleteMutationOptions(
    client,
    options,
  );
  return createMutation(mutationOptions, queryClient);
}

/**
 * Raw RPC call (mutation): RuntimeService.GitStatus
 */
export function runtimeServiceGitStatus(
  client: RuntimeClient,
  request: Omit<PartialMessage<GitStatusRequest>, "instanceId">,
): Promise<V1GitStatusResponse> {
  return client.runtimeService
    .gitStatus(
      GitStatusRequest.fromJson(
        stripUndefined({
          instanceId: client.instanceId,
          ...request,
        }) as unknown as JsonValue,
      ),
    )
    .then(
      (r) =>
        r.toJson({ emitDefaultValues: true }) as unknown as V1GitStatusResponse,
    );
}

export function getRuntimeServiceGitStatusMutationOptions(
  client: RuntimeClient,
  options?: Partial<
    CreateMutationOptions<
      V1GitStatusResponse,
      unknown,
      Omit<PartialMessage<GitStatusRequest>, "instanceId">
    >
  >,
): CreateMutationOptions<
  V1GitStatusResponse,
  unknown,
  Omit<PartialMessage<GitStatusRequest>, "instanceId">
> {
  return {
    mutationFn: (request) => runtimeServiceGitStatus(client, request),
    ...options,
  };
}

export function createRuntimeServiceGitStatusMutation(
  client: RuntimeClient,
  options?: Partial<
    CreateMutationOptions<
      V1GitStatusResponse,
      unknown,
      Omit<PartialMessage<GitStatusRequest>, "instanceId">
    >
  >,
  queryClient?: QueryClient,
): CreateMutationResult<
  V1GitStatusResponse,
  unknown,
  Omit<PartialMessage<GitStatusRequest>, "instanceId">
> {
  const mutationOptions = getRuntimeServiceGitStatusMutationOptions(
    client,
    options,
  );
  return createMutation(mutationOptions, queryClient);
}

/**
 * Raw RPC call (mutation): RuntimeService.GitCommit
 */
export function runtimeServiceGitCommit(
  client: RuntimeClient,
  request: Omit<PartialMessage<GitCommitRequest>, "instanceId">,
): Promise<V1GitCommitResponse> {
  return client.runtimeService
    .gitCommit(
      GitCommitRequest.fromJson(
        stripUndefined({
          instanceId: client.instanceId,
          ...request,
        }) as unknown as JsonValue,
      ),
    )
    .then(
      (r) =>
        r.toJson({ emitDefaultValues: true }) as unknown as V1GitCommitResponse,
    );
}

export function getRuntimeServiceGitCommitMutationOptions(
  client: RuntimeClient,
  options?: Partial<
    CreateMutationOptions<
      V1GitCommitResponse,
      unknown,
      Omit<PartialMessage<GitCommitRequest>, "instanceId">
    >
  >,
): CreateMutationOptions<
  V1GitCommitResponse,
  unknown,
  Omit<PartialMessage<GitCommitRequest>, "instanceId">
> {
  return {
    mutationFn: (request) => runtimeServiceGitCommit(client, request),
    ...options,
  };
}

export function createRuntimeServiceGitCommitMutation(
  client: RuntimeClient,
  options?: Partial<
    CreateMutationOptions<
      V1GitCommitResponse,
      unknown,
      Omit<PartialMessage<GitCommitRequest>, "instanceId">
    >
  >,
  queryClient?: QueryClient,
): CreateMutationResult<
  V1GitCommitResponse,
  unknown,
  Omit<PartialMessage<GitCommitRequest>, "instanceId">
> {
  const mutationOptions = getRuntimeServiceGitCommitMutationOptions(
    client,
    options,
  );
  return createMutation(mutationOptions, queryClient);
}

/**
 * Raw RPC call (mutation): RuntimeService.RestoreGitCommit
 */
export function runtimeServiceRestoreGitCommit(
  client: RuntimeClient,
  request: Omit<PartialMessage<RestoreGitCommitRequest>, "instanceId">,
): Promise<V1RestoreGitCommitResponse> {
  return client.runtimeService
    .restoreGitCommit(
      RestoreGitCommitRequest.fromJson(
        stripUndefined({
          instanceId: client.instanceId,
          ...request,
        }) as unknown as JsonValue,
      ),
    )
    .then(
      (r) =>
        r.toJson({
          emitDefaultValues: true,
        }) as unknown as V1RestoreGitCommitResponse,
    );
}

export function getRuntimeServiceRestoreGitCommitMutationOptions(
  client: RuntimeClient,
  options?: Partial<
    CreateMutationOptions<
      V1RestoreGitCommitResponse,
      unknown,
      Omit<PartialMessage<RestoreGitCommitRequest>, "instanceId">
    >
  >,
): CreateMutationOptions<
  V1RestoreGitCommitResponse,
  unknown,
  Omit<PartialMessage<RestoreGitCommitRequest>, "instanceId">
> {
  return {
    mutationFn: (request) => runtimeServiceRestoreGitCommit(client, request),
    ...options,
  };
}

export function createRuntimeServiceRestoreGitCommitMutation(
  client: RuntimeClient,
  options?: Partial<
    CreateMutationOptions<
      V1RestoreGitCommitResponse,
      unknown,
      Omit<PartialMessage<RestoreGitCommitRequest>, "instanceId">
    >
  >,
  queryClient?: QueryClient,
): CreateMutationResult<
  V1RestoreGitCommitResponse,
  unknown,
  Omit<PartialMessage<RestoreGitCommitRequest>, "instanceId">
> {
  const mutationOptions = getRuntimeServiceRestoreGitCommitMutationOptions(
    client,
    options,
  );
  return createMutation(mutationOptions, queryClient);
}

/**
 * Raw RPC call (mutation): RuntimeService.GitMergeToBranch
 */
export function runtimeServiceGitMergeToBranch(
  client: RuntimeClient,
  request: Omit<PartialMessage<GitMergeToBranchRequest>, "instanceId">,
): Promise<V1GitMergeToBranchResponse> {
  return client.runtimeService
    .gitMergeToBranch(
      GitMergeToBranchRequest.fromJson(
        stripUndefined({
          instanceId: client.instanceId,
          ...request,
        }) as unknown as JsonValue,
      ),
    )
    .then(
      (r) =>
        r.toJson({
          emitDefaultValues: true,
        }) as unknown as V1GitMergeToBranchResponse,
    );
}

export function getRuntimeServiceGitMergeToBranchMutationOptions(
  client: RuntimeClient,
  options?: Partial<
    CreateMutationOptions<
      V1GitMergeToBranchResponse,
      unknown,
      Omit<PartialMessage<GitMergeToBranchRequest>, "instanceId">
    >
  >,
): CreateMutationOptions<
  V1GitMergeToBranchResponse,
  unknown,
  Omit<PartialMessage<GitMergeToBranchRequest>, "instanceId">
> {
  return {
    mutationFn: (request) => runtimeServiceGitMergeToBranch(client, request),
    ...options,
  };
}

export function createRuntimeServiceGitMergeToBranchMutation(
  client: RuntimeClient,
  options?: Partial<
    CreateMutationOptions<
      V1GitMergeToBranchResponse,
      unknown,
      Omit<PartialMessage<GitMergeToBranchRequest>, "instanceId">
    >
  >,
  queryClient?: QueryClient,
): CreateMutationResult<
  V1GitMergeToBranchResponse,
  unknown,
  Omit<PartialMessage<GitMergeToBranchRequest>, "instanceId">
> {
  const mutationOptions = getRuntimeServiceGitMergeToBranchMutationOptions(
    client,
    options,
  );
  return createMutation(mutationOptions, queryClient);
}

/**
 * Raw RPC call (mutation): RuntimeService.GitSwitchBranch
 */
export function runtimeServiceGitSwitchBranch(
  client: RuntimeClient,
  request: Omit<PartialMessage<GitSwitchBranchRequest>, "instanceId">,
): Promise<V1GitSwitchBranchResponse> {
  return client.runtimeService
    .gitSwitchBranch(
      GitSwitchBranchRequest.fromJson(
        stripUndefined({
          instanceId: client.instanceId,
          ...request,
        }) as unknown as JsonValue,
      ),
    )
    .then(
      (r) =>
        r.toJson({
          emitDefaultValues: true,
        }) as unknown as V1GitSwitchBranchResponse,
    );
}

export function getRuntimeServiceGitSwitchBranchMutationOptions(
  client: RuntimeClient,
  options?: Partial<
    CreateMutationOptions<
      V1GitSwitchBranchResponse,
      unknown,
      Omit<PartialMessage<GitSwitchBranchRequest>, "instanceId">
    >
  >,
): CreateMutationOptions<
  V1GitSwitchBranchResponse,
  unknown,
  Omit<PartialMessage<GitSwitchBranchRequest>, "instanceId">
> {
  return {
    mutationFn: (request) => runtimeServiceGitSwitchBranch(client, request),
    ...options,
  };
}

export function createRuntimeServiceGitSwitchBranchMutation(
  client: RuntimeClient,
  options?: Partial<
    CreateMutationOptions<
      V1GitSwitchBranchResponse,
      unknown,
      Omit<PartialMessage<GitSwitchBranchRequest>, "instanceId">
    >
  >,
  queryClient?: QueryClient,
): CreateMutationResult<
  V1GitSwitchBranchResponse,
  unknown,
  Omit<PartialMessage<GitSwitchBranchRequest>, "instanceId">
> {
  const mutationOptions = getRuntimeServiceGitSwitchBranchMutationOptions(
    client,
    options,
  );
  return createMutation(mutationOptions, queryClient);
}

/**
 * Raw RPC call (mutation): RuntimeService.GitPull
 */
export function runtimeServiceGitPull(
  client: RuntimeClient,
  request: Omit<PartialMessage<GitPullRequest>, "instanceId">,
): Promise<V1GitPullResponse> {
  return client.runtimeService
    .gitPull(
      GitPullRequest.fromJson(
        stripUndefined({
          instanceId: client.instanceId,
          ...request,
        }) as unknown as JsonValue,
      ),
    )
    .then(
      (r) =>
        r.toJson({ emitDefaultValues: true }) as unknown as V1GitPullResponse,
    );
}

export function getRuntimeServiceGitPullMutationOptions(
  client: RuntimeClient,
  options?: Partial<
    CreateMutationOptions<
      V1GitPullResponse,
      unknown,
      Omit<PartialMessage<GitPullRequest>, "instanceId">
    >
  >,
): CreateMutationOptions<
  V1GitPullResponse,
  unknown,
  Omit<PartialMessage<GitPullRequest>, "instanceId">
> {
  return {
    mutationFn: (request) => runtimeServiceGitPull(client, request),
    ...options,
  };
}

export function createRuntimeServiceGitPullMutation(
  client: RuntimeClient,
  options?: Partial<
    CreateMutationOptions<
      V1GitPullResponse,
      unknown,
      Omit<PartialMessage<GitPullRequest>, "instanceId">
    >
  >,
  queryClient?: QueryClient,
): CreateMutationResult<
  V1GitPullResponse,
  unknown,
  Omit<PartialMessage<GitPullRequest>, "instanceId">
> {
  const mutationOptions = getRuntimeServiceGitPullMutationOptions(
    client,
    options,
  );
  return createMutation(mutationOptions, queryClient);
}

/**
 * Raw RPC call (mutation): RuntimeService.GitPush
 */
export function runtimeServiceGitPush(
  client: RuntimeClient,
  request: Omit<PartialMessage<GitPushRequest>, "instanceId">,
): Promise<V1GitPushResponse> {
  return client.runtimeService
    .gitPush(
      GitPushRequest.fromJson(
        stripUndefined({
          instanceId: client.instanceId,
          ...request,
        }) as unknown as JsonValue,
      ),
    )
    .then(
      (r) =>
        r.toJson({ emitDefaultValues: true }) as unknown as V1GitPushResponse,
    );
}

export function getRuntimeServiceGitPushMutationOptions(
  client: RuntimeClient,
  options?: Partial<
    CreateMutationOptions<
      V1GitPushResponse,
      unknown,
      Omit<PartialMessage<GitPushRequest>, "instanceId">
    >
  >,
): CreateMutationOptions<
  V1GitPushResponse,
  unknown,
  Omit<PartialMessage<GitPushRequest>, "instanceId">
> {
  return {
    mutationFn: (request) => runtimeServiceGitPush(client, request),
    ...options,
  };
}

export function createRuntimeServiceGitPushMutation(
  client: RuntimeClient,
  options?: Partial<
    CreateMutationOptions<
      V1GitPushResponse,
      unknown,
      Omit<PartialMessage<GitPushRequest>, "instanceId">
    >
  >,
  queryClient?: QueryClient,
): CreateMutationResult<
  V1GitPushResponse,
  unknown,
  Omit<PartialMessage<GitPushRequest>, "instanceId">
> {
  const mutationOptions = getRuntimeServiceGitPushMutationOptions(
    client,
    options,
  );
  return createMutation(mutationOptions, queryClient);
}

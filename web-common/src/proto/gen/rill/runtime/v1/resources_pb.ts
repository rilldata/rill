// @generated by protoc-gen-es v1.10.0 with parameter "target=ts"
// @generated from file rill/runtime/v1/resources.proto (package rill.runtime.v1, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3, protoInt64, Struct, Timestamp, Value } from "@bufbuild/protobuf";
import { StructType, Type } from "./schema_pb.js";
import { TimeGrain } from "./time_grain_pb.js";
import { Expression } from "./expression_pb.js";
import { ExportFormat } from "./export_format_pb.js";
import { Color } from "./color_pb.js";

/**
 * @generated from enum rill.runtime.v1.ReconcileStatus
 */
export enum ReconcileStatus {
  /**
   * @generated from enum value: RECONCILE_STATUS_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * @generated from enum value: RECONCILE_STATUS_IDLE = 1;
   */
  IDLE = 1,

  /**
   * @generated from enum value: RECONCILE_STATUS_PENDING = 2;
   */
  PENDING = 2,

  /**
   * @generated from enum value: RECONCILE_STATUS_RUNNING = 3;
   */
  RUNNING = 3,
}
// Retrieve enum metadata with: proto3.getEnumType(ReconcileStatus)
proto3.util.setEnumType(ReconcileStatus, "rill.runtime.v1.ReconcileStatus", [
  { no: 0, name: "RECONCILE_STATUS_UNSPECIFIED" },
  { no: 1, name: "RECONCILE_STATUS_IDLE" },
  { no: 2, name: "RECONCILE_STATUS_PENDING" },
  { no: 3, name: "RECONCILE_STATUS_RUNNING" },
]);

/**
 * @generated from enum rill.runtime.v1.ModelChangeMode
 */
export enum ModelChangeMode {
  /**
   * @generated from enum value: MODEL_CHANGE_MODE_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * @generated from enum value: MODEL_CHANGE_MODE_RESET = 1;
   */
  RESET = 1,

  /**
   * @generated from enum value: MODEL_CHANGE_MODE_MANUAL = 2;
   */
  MANUAL = 2,

  /**
   * @generated from enum value: MODEL_CHANGE_MODE_PATCH = 3;
   */
  PATCH = 3,
}
// Retrieve enum metadata with: proto3.getEnumType(ModelChangeMode)
proto3.util.setEnumType(ModelChangeMode, "rill.runtime.v1.ModelChangeMode", [
  { no: 0, name: "MODEL_CHANGE_MODE_UNSPECIFIED" },
  { no: 1, name: "MODEL_CHANGE_MODE_RESET" },
  { no: 2, name: "MODEL_CHANGE_MODE_MANUAL" },
  { no: 3, name: "MODEL_CHANGE_MODE_PATCH" },
]);

/**
 * @generated from enum rill.runtime.v1.ExploreComparisonMode
 */
export enum ExploreComparisonMode {
  /**
   * @generated from enum value: EXPLORE_COMPARISON_MODE_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * @generated from enum value: EXPLORE_COMPARISON_MODE_NONE = 1;
   */
  NONE = 1,

  /**
   * @generated from enum value: EXPLORE_COMPARISON_MODE_TIME = 2;
   */
  TIME = 2,

  /**
   * @generated from enum value: EXPLORE_COMPARISON_MODE_DIMENSION = 3;
   */
  DIMENSION = 3,
}
// Retrieve enum metadata with: proto3.getEnumType(ExploreComparisonMode)
proto3.util.setEnumType(ExploreComparisonMode, "rill.runtime.v1.ExploreComparisonMode", [
  { no: 0, name: "EXPLORE_COMPARISON_MODE_UNSPECIFIED" },
  { no: 1, name: "EXPLORE_COMPARISON_MODE_NONE" },
  { no: 2, name: "EXPLORE_COMPARISON_MODE_TIME" },
  { no: 3, name: "EXPLORE_COMPARISON_MODE_DIMENSION" },
]);

/**
 * @generated from enum rill.runtime.v1.ExploreWebView
 */
export enum ExploreWebView {
  /**
   * @generated from enum value: EXPLORE_WEB_VIEW_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * @generated from enum value: EXPLORE_WEB_VIEW_EXPLORE = 1;
   */
  EXPLORE = 1,

  /**
   * @generated from enum value: EXPLORE_WEB_VIEW_TIME_DIMENSION = 2;
   */
  TIME_DIMENSION = 2,

  /**
   * @generated from enum value: EXPLORE_WEB_VIEW_PIVOT = 3;
   */
  PIVOT = 3,

  /**
   * @generated from enum value: EXPLORE_WEB_VIEW_CANVAS = 4;
   */
  CANVAS = 4,
}
// Retrieve enum metadata with: proto3.getEnumType(ExploreWebView)
proto3.util.setEnumType(ExploreWebView, "rill.runtime.v1.ExploreWebView", [
  { no: 0, name: "EXPLORE_WEB_VIEW_UNSPECIFIED" },
  { no: 1, name: "EXPLORE_WEB_VIEW_EXPLORE" },
  { no: 2, name: "EXPLORE_WEB_VIEW_TIME_DIMENSION" },
  { no: 3, name: "EXPLORE_WEB_VIEW_PIVOT" },
  { no: 4, name: "EXPLORE_WEB_VIEW_CANVAS" },
]);

/**
 * @generated from enum rill.runtime.v1.ExploreSortType
 */
export enum ExploreSortType {
  /**
   * @generated from enum value: EXPLORE_SORT_TYPE_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * @generated from enum value: EXPLORE_SORT_TYPE_VALUE = 1;
   */
  VALUE = 1,

  /**
   * @generated from enum value: EXPLORE_SORT_TYPE_PERCENT = 2;
   */
  PERCENT = 2,

  /**
   * @generated from enum value: EXPLORE_SORT_TYPE_DELTA_PERCENT = 3;
   */
  DELTA_PERCENT = 3,

  /**
   * @generated from enum value: EXPLORE_SORT_TYPE_DELTA_ABSOLUTE = 4;
   */
  DELTA_ABSOLUTE = 4,

  /**
   * @generated from enum value: EXPLORE_SORT_TYPE_DIMENSION = 5;
   */
  DIMENSION = 5,
}
// Retrieve enum metadata with: proto3.getEnumType(ExploreSortType)
proto3.util.setEnumType(ExploreSortType, "rill.runtime.v1.ExploreSortType", [
  { no: 0, name: "EXPLORE_SORT_TYPE_UNSPECIFIED" },
  { no: 1, name: "EXPLORE_SORT_TYPE_VALUE" },
  { no: 2, name: "EXPLORE_SORT_TYPE_PERCENT" },
  { no: 3, name: "EXPLORE_SORT_TYPE_DELTA_PERCENT" },
  { no: 4, name: "EXPLORE_SORT_TYPE_DELTA_ABSOLUTE" },
  { no: 5, name: "EXPLORE_SORT_TYPE_DIMENSION" },
]);

/**
 * @generated from enum rill.runtime.v1.AssertionStatus
 */
export enum AssertionStatus {
  /**
   * @generated from enum value: ASSERTION_STATUS_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * @generated from enum value: ASSERTION_STATUS_PASS = 1;
   */
  PASS = 1,

  /**
   * @generated from enum value: ASSERTION_STATUS_FAIL = 2;
   */
  FAIL = 2,

  /**
   * @generated from enum value: ASSERTION_STATUS_ERROR = 3;
   */
  ERROR = 3,
}
// Retrieve enum metadata with: proto3.getEnumType(AssertionStatus)
proto3.util.setEnumType(AssertionStatus, "rill.runtime.v1.AssertionStatus", [
  { no: 0, name: "ASSERTION_STATUS_UNSPECIFIED" },
  { no: 1, name: "ASSERTION_STATUS_PASS" },
  { no: 2, name: "ASSERTION_STATUS_FAIL" },
  { no: 3, name: "ASSERTION_STATUS_ERROR" },
]);

/**
 * @generated from message rill.runtime.v1.Resource
 */
export class Resource extends Message<Resource> {
  /**
   * @generated from field: rill.runtime.v1.ResourceMeta meta = 1;
   */
  meta?: ResourceMeta;

  /**
   * @generated from oneof rill.runtime.v1.Resource.resource
   */
  resource: {
    /**
     * Well-known types only, for now. If required, we can add support for a google.protobuf.Any later.
     *
     * @generated from field: rill.runtime.v1.ProjectParser project_parser = 2;
     */
    value: ProjectParser;
    case: "projectParser";
  } | {
    /**
     * @generated from field: rill.runtime.v1.Source source = 3;
     */
    value: Source;
    case: "source";
  } | {
    /**
     * @generated from field: rill.runtime.v1.Model model = 4;
     */
    value: Model;
    case: "model";
  } | {
    /**
     * @generated from field: rill.runtime.v1.MetricsView metrics_view = 5;
     */
    value: MetricsView;
    case: "metricsView";
  } | {
    /**
     * @generated from field: rill.runtime.v1.Explore explore = 17;
     */
    value: Explore;
    case: "explore";
  } | {
    /**
     * @generated from field: rill.runtime.v1.Migration migration = 9;
     */
    value: Migration;
    case: "migration";
  } | {
    /**
     * @generated from field: rill.runtime.v1.Report report = 10;
     */
    value: Report;
    case: "report";
  } | {
    /**
     * @generated from field: rill.runtime.v1.Alert alert = 12;
     */
    value: Alert;
    case: "alert";
  } | {
    /**
     * @generated from field: rill.runtime.v1.RefreshTrigger refresh_trigger = 7;
     */
    value: RefreshTrigger;
    case: "refreshTrigger";
  } | {
    /**
     * @generated from field: rill.runtime.v1.Theme theme = 11;
     */
    value: Theme;
    case: "theme";
  } | {
    /**
     * @generated from field: rill.runtime.v1.Component component = 13;
     */
    value: Component;
    case: "component";
  } | {
    /**
     * @generated from field: rill.runtime.v1.Canvas canvas = 14;
     */
    value: Canvas;
    case: "canvas";
  } | {
    /**
     * @generated from field: rill.runtime.v1.API api = 15;
     */
    value: API;
    case: "api";
  } | {
    /**
     * @generated from field: rill.runtime.v1.ConnectorV2 connector = 16;
     */
    value: ConnectorV2;
    case: "connector";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<Resource>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "rill.runtime.v1.Resource";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "meta", kind: "message", T: ResourceMeta },
    { no: 2, name: "project_parser", kind: "message", T: ProjectParser, oneof: "resource" },
    { no: 3, name: "source", kind: "message", T: Source, oneof: "resource" },
    { no: 4, name: "model", kind: "message", T: Model, oneof: "resource" },
    { no: 5, name: "metrics_view", kind: "message", T: MetricsView, oneof: "resource" },
    { no: 17, name: "explore", kind: "message", T: Explore, oneof: "resource" },
    { no: 9, name: "migration", kind: "message", T: Migration, oneof: "resource" },
    { no: 10, name: "report", kind: "message", T: Report, oneof: "resource" },
    { no: 12, name: "alert", kind: "message", T: Alert, oneof: "resource" },
    { no: 7, name: "refresh_trigger", kind: "message", T: RefreshTrigger, oneof: "resource" },
    { no: 11, name: "theme", kind: "message", T: Theme, oneof: "resource" },
    { no: 13, name: "component", kind: "message", T: Component, oneof: "resource" },
    { no: 14, name: "canvas", kind: "message", T: Canvas, oneof: "resource" },
    { no: 15, name: "api", kind: "message", T: API, oneof: "resource" },
    { no: 16, name: "connector", kind: "message", T: ConnectorV2, oneof: "resource" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Resource {
    return new Resource().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Resource {
    return new Resource().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Resource {
    return new Resource().fromJsonString(jsonString, options);
  }

  static equals(a: Resource | PlainMessage<Resource> | undefined, b: Resource | PlainMessage<Resource> | undefined): boolean {
    return proto3.util.equals(Resource, a, b);
  }
}

/**
 * @generated from message rill.runtime.v1.ResourceMeta
 */
export class ResourceMeta extends Message<ResourceMeta> {
  /**
   * @generated from field: rill.runtime.v1.ResourceName name = 1;
   */
  name?: ResourceName;

  /**
   * @generated from field: repeated rill.runtime.v1.ResourceName refs = 2;
   */
  refs: ResourceName[] = [];

  /**
   * @generated from field: optional rill.runtime.v1.ResourceName owner = 3;
   */
  owner?: ResourceName;

  /**
   * @generated from field: repeated string file_paths = 4;
   */
  filePaths: string[] = [];

  /**
   * @generated from field: bool hidden = 7;
   */
  hidden = false;

  /**
   * @generated from field: int64 version = 15;
   */
  version = protoInt64.zero;

  /**
   * @generated from field: int64 spec_version = 5;
   */
  specVersion = protoInt64.zero;

  /**
   * @generated from field: int64 state_version = 6;
   */
  stateVersion = protoInt64.zero;

  /**
   * @generated from field: google.protobuf.Timestamp created_on = 9;
   */
  createdOn?: Timestamp;

  /**
   * @generated from field: google.protobuf.Timestamp spec_updated_on = 10;
   */
  specUpdatedOn?: Timestamp;

  /**
   * @generated from field: google.protobuf.Timestamp state_updated_on = 11;
   */
  stateUpdatedOn?: Timestamp;

  /**
   * @generated from field: optional google.protobuf.Timestamp deleted_on = 12;
   */
  deletedOn?: Timestamp;

  /**
   * @generated from field: rill.runtime.v1.ReconcileStatus reconcile_status = 16;
   */
  reconcileStatus = ReconcileStatus.UNSPECIFIED;

  /**
   * @generated from field: string reconcile_error = 8;
   */
  reconcileError = "";

  /**
   * @generated from field: google.protobuf.Timestamp reconcile_on = 17;
   */
  reconcileOn?: Timestamp;

  /**
   * @generated from field: optional rill.runtime.v1.ResourceName renamed_from = 13;
   */
  renamedFrom?: ResourceName;

  constructor(data?: PartialMessage<ResourceMeta>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "rill.runtime.v1.ResourceMeta";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "name", kind: "message", T: ResourceName },
    { no: 2, name: "refs", kind: "message", T: ResourceName, repeated: true },
    { no: 3, name: "owner", kind: "message", T: ResourceName, opt: true },
    { no: 4, name: "file_paths", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 7, name: "hidden", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 15, name: "version", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 5, name: "spec_version", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 6, name: "state_version", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 9, name: "created_on", kind: "message", T: Timestamp },
    { no: 10, name: "spec_updated_on", kind: "message", T: Timestamp },
    { no: 11, name: "state_updated_on", kind: "message", T: Timestamp },
    { no: 12, name: "deleted_on", kind: "message", T: Timestamp, opt: true },
    { no: 16, name: "reconcile_status", kind: "enum", T: proto3.getEnumType(ReconcileStatus) },
    { no: 8, name: "reconcile_error", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 17, name: "reconcile_on", kind: "message", T: Timestamp },
    { no: 13, name: "renamed_from", kind: "message", T: ResourceName, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ResourceMeta {
    return new ResourceMeta().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ResourceMeta {
    return new ResourceMeta().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ResourceMeta {
    return new ResourceMeta().fromJsonString(jsonString, options);
  }

  static equals(a: ResourceMeta | PlainMessage<ResourceMeta> | undefined, b: ResourceMeta | PlainMessage<ResourceMeta> | undefined): boolean {
    return proto3.util.equals(ResourceMeta, a, b);
  }
}

/**
 * @generated from message rill.runtime.v1.ResourceName
 */
export class ResourceName extends Message<ResourceName> {
  /**
   * @generated from field: string kind = 1;
   */
  kind = "";

  /**
   * @generated from field: string name = 2;
   */
  name = "";

  constructor(data?: PartialMessage<ResourceName>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "rill.runtime.v1.ResourceName";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "kind", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ResourceName {
    return new ResourceName().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ResourceName {
    return new ResourceName().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ResourceName {
    return new ResourceName().fromJsonString(jsonString, options);
  }

  static equals(a: ResourceName | PlainMessage<ResourceName> | undefined, b: ResourceName | PlainMessage<ResourceName> | undefined): boolean {
    return proto3.util.equals(ResourceName, a, b);
  }
}

/**
 * @generated from message rill.runtime.v1.ProjectParser
 */
export class ProjectParser extends Message<ProjectParser> {
  /**
   * @generated from field: rill.runtime.v1.ProjectParserSpec spec = 1;
   */
  spec?: ProjectParserSpec;

  /**
   * @generated from field: rill.runtime.v1.ProjectParserState state = 2;
   */
  state?: ProjectParserState;

  constructor(data?: PartialMessage<ProjectParser>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "rill.runtime.v1.ProjectParser";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "spec", kind: "message", T: ProjectParserSpec },
    { no: 2, name: "state", kind: "message", T: ProjectParserState },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ProjectParser {
    return new ProjectParser().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ProjectParser {
    return new ProjectParser().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ProjectParser {
    return new ProjectParser().fromJsonString(jsonString, options);
  }

  static equals(a: ProjectParser | PlainMessage<ProjectParser> | undefined, b: ProjectParser | PlainMessage<ProjectParser> | undefined): boolean {
    return proto3.util.equals(ProjectParser, a, b);
  }
}

/**
 * @generated from message rill.runtime.v1.ProjectParserSpec
 */
export class ProjectParserSpec extends Message<ProjectParserSpec> {
  constructor(data?: PartialMessage<ProjectParserSpec>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "rill.runtime.v1.ProjectParserSpec";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ProjectParserSpec {
    return new ProjectParserSpec().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ProjectParserSpec {
    return new ProjectParserSpec().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ProjectParserSpec {
    return new ProjectParserSpec().fromJsonString(jsonString, options);
  }

  static equals(a: ProjectParserSpec | PlainMessage<ProjectParserSpec> | undefined, b: ProjectParserSpec | PlainMessage<ProjectParserSpec> | undefined): boolean {
    return proto3.util.equals(ProjectParserSpec, a, b);
  }
}

/**
 * @generated from message rill.runtime.v1.ProjectParserState
 */
export class ProjectParserState extends Message<ProjectParserState> {
  /**
   * @generated from field: repeated rill.runtime.v1.ParseError parse_errors = 1;
   */
  parseErrors: ParseError[] = [];

  /**
   * @generated from field: string current_commit_sha = 2;
   */
  currentCommitSha = "";

  /**
   * @generated from field: google.protobuf.Timestamp current_commit_on = 4;
   */
  currentCommitOn?: Timestamp;

  /**
   * @generated from field: bool watching = 3;
   */
  watching = false;

  constructor(data?: PartialMessage<ProjectParserState>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "rill.runtime.v1.ProjectParserState";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "parse_errors", kind: "message", T: ParseError, repeated: true },
    { no: 2, name: "current_commit_sha", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "current_commit_on", kind: "message", T: Timestamp },
    { no: 3, name: "watching", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ProjectParserState {
    return new ProjectParserState().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ProjectParserState {
    return new ProjectParserState().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ProjectParserState {
    return new ProjectParserState().fromJsonString(jsonString, options);
  }

  static equals(a: ProjectParserState | PlainMessage<ProjectParserState> | undefined, b: ProjectParserState | PlainMessage<ProjectParserState> | undefined): boolean {
    return proto3.util.equals(ProjectParserState, a, b);
  }
}

/**
 * @generated from message rill.runtime.v1.Source
 */
export class Source extends Message<Source> {
  /**
   * @generated from field: rill.runtime.v1.SourceSpec spec = 1;
   */
  spec?: SourceSpec;

  /**
   * @generated from field: rill.runtime.v1.SourceState state = 2;
   */
  state?: SourceState;

  constructor(data?: PartialMessage<Source>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "rill.runtime.v1.Source";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "spec", kind: "message", T: SourceSpec },
    { no: 2, name: "state", kind: "message", T: SourceState },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Source {
    return new Source().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Source {
    return new Source().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Source {
    return new Source().fromJsonString(jsonString, options);
  }

  static equals(a: Source | PlainMessage<Source> | undefined, b: Source | PlainMessage<Source> | undefined): boolean {
    return proto3.util.equals(Source, a, b);
  }
}

/**
 * @generated from message rill.runtime.v1.SourceSpec
 */
export class SourceSpec extends Message<SourceSpec> {
  /**
   * @generated from field: string source_connector = 1;
   */
  sourceConnector = "";

  /**
   * @generated from field: string sink_connector = 2;
   */
  sinkConnector = "";

  /**
   * @generated from field: google.protobuf.Struct properties = 3;
   */
  properties?: Struct;

  /**
   * @generated from field: rill.runtime.v1.Schedule refresh_schedule = 5;
   */
  refreshSchedule?: Schedule;

  /**
   * @generated from field: uint32 timeout_seconds = 6;
   */
  timeoutSeconds = 0;

  /**
   * Fields not derived from code files
   *
   * @generated from field: bool stage_changes = 7;
   */
  stageChanges = false;

  /**
   * @generated from field: bool stream_ingestion = 8;
   */
  streamIngestion = false;

  /**
   * @generated from field: bool trigger = 9;
   */
  trigger = false;

  constructor(data?: PartialMessage<SourceSpec>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "rill.runtime.v1.SourceSpec";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "source_connector", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "sink_connector", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "properties", kind: "message", T: Struct },
    { no: 5, name: "refresh_schedule", kind: "message", T: Schedule },
    { no: 6, name: "timeout_seconds", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 7, name: "stage_changes", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 8, name: "stream_ingestion", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 9, name: "trigger", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SourceSpec {
    return new SourceSpec().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SourceSpec {
    return new SourceSpec().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SourceSpec {
    return new SourceSpec().fromJsonString(jsonString, options);
  }

  static equals(a: SourceSpec | PlainMessage<SourceSpec> | undefined, b: SourceSpec | PlainMessage<SourceSpec> | undefined): boolean {
    return proto3.util.equals(SourceSpec, a, b);
  }
}

/**
 * @generated from message rill.runtime.v1.SourceState
 */
export class SourceState extends Message<SourceState> {
  /**
   * @generated from field: string connector = 1;
   */
  connector = "";

  /**
   * @generated from field: string table = 2;
   */
  table = "";

  /**
   * @generated from field: string spec_hash = 3;
   */
  specHash = "";

  /**
   * @generated from field: google.protobuf.Timestamp refreshed_on = 4;
   */
  refreshedOn?: Timestamp;

  constructor(data?: PartialMessage<SourceState>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "rill.runtime.v1.SourceState";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "connector", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "table", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "spec_hash", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "refreshed_on", kind: "message", T: Timestamp },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SourceState {
    return new SourceState().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SourceState {
    return new SourceState().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SourceState {
    return new SourceState().fromJsonString(jsonString, options);
  }

  static equals(a: SourceState | PlainMessage<SourceState> | undefined, b: SourceState | PlainMessage<SourceState> | undefined): boolean {
    return proto3.util.equals(SourceState, a, b);
  }
}

/**
 * @generated from message rill.runtime.v1.Model
 */
export class Model extends Message<Model> {
  /**
   * @generated from field: rill.runtime.v1.ModelSpec spec = 1;
   */
  spec?: ModelSpec;

  /**
   * @generated from field: rill.runtime.v1.ModelState state = 2;
   */
  state?: ModelState;

  constructor(data?: PartialMessage<Model>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "rill.runtime.v1.Model";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "spec", kind: "message", T: ModelSpec },
    { no: 2, name: "state", kind: "message", T: ModelState },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Model {
    return new Model().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Model {
    return new Model().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Model {
    return new Model().fromJsonString(jsonString, options);
  }

  static equals(a: Model | PlainMessage<Model> | undefined, b: Model | PlainMessage<Model> | undefined): boolean {
    return proto3.util.equals(Model, a, b);
  }
}

/**
 * @generated from message rill.runtime.v1.ModelSpec
 */
export class ModelSpec extends Message<ModelSpec> {
  /**
   * @generated from field: rill.runtime.v1.Schedule refresh_schedule = 4;
   */
  refreshSchedule?: Schedule;

  /**
   * @generated from field: uint32 timeout_seconds = 5;
   */
  timeoutSeconds = 0;

  /**
   * @generated from field: bool incremental = 13;
   */
  incremental = false;

  /**
   * @generated from field: string incremental_state_resolver = 14;
   */
  incrementalStateResolver = "";

  /**
   * @generated from field: google.protobuf.Struct incremental_state_resolver_properties = 15;
   */
  incrementalStateResolverProperties?: Struct;

  /**
   * @generated from field: string partitions_resolver = 18;
   */
  partitionsResolver = "";

  /**
   * @generated from field: google.protobuf.Struct partitions_resolver_properties = 19;
   */
  partitionsResolverProperties?: Struct;

  /**
   * @generated from field: string partitions_watermark_field = 20;
   */
  partitionsWatermarkField = "";

  /**
   * @generated from field: uint32 partitions_concurrency_limit = 21;
   */
  partitionsConcurrencyLimit = 0;

  /**
   * @generated from field: string input_connector = 10;
   */
  inputConnector = "";

  /**
   * @generated from field: google.protobuf.Struct input_properties = 11;
   */
  inputProperties?: Struct;

  /**
   * stage_connector is optional.
   *
   * @generated from field: string stage_connector = 16;
   */
  stageConnector = "";

  /**
   * @generated from field: google.protobuf.Struct stage_properties = 17;
   */
  stageProperties?: Struct;

  /**
   * @generated from field: string output_connector = 1;
   */
  outputConnector = "";

  /**
   * @generated from field: google.protobuf.Struct output_properties = 12;
   */
  outputProperties?: Struct;

  /**
   * @generated from field: optional uint32 retry_attempts = 26;
   */
  retryAttempts?: number;

  /**
   * @generated from field: optional uint32 retry_delay_seconds = 27;
   */
  retryDelaySeconds?: number;

  /**
   * @generated from field: optional bool retry_exponential_backoff = 28;
   */
  retryExponentialBackoff?: boolean;

  /**
   * @generated from field: repeated string retry_if_error_matches = 29;
   */
  retryIfErrorMatches: string[] = [];

  /**
   * change_mode is the mode of change detection to use for the model.
   *
   * @generated from field: rill.runtime.v1.ModelChangeMode change_mode = 24;
   */
  changeMode = ModelChangeMode.UNSPECIFIED;

  /**
   * @generated from field: repeated rill.runtime.v1.ModelTest tests = 25;
   */
  tests: ModelTest[] = [];

  /**
   * trigger indicates a normal refresh (incremental or full depending on the model type).
   *
   * @generated from field: bool trigger = 9;
   */
  trigger = false;

  /**
   * trigger_full indicates a full refresh regardless of the model type.
   *
   * @generated from field: bool trigger_full = 22;
   */
  triggerFull = false;

  /**
   * trigger_partitions indicates a refresh of existing partitions marked pending (won't sync new partitions). Only valid for incremental, partitioned models.
   *
   * @generated from field: bool trigger_partitions = 30;
   */
  triggerPartitions = false;

  /**
   * defined_as_source is true if it was defined by user as a source but converted internally to a model.
   *
   * @generated from field: bool defined_as_source = 23;
   */
  definedAsSource = false;

  constructor(data?: PartialMessage<ModelSpec>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "rill.runtime.v1.ModelSpec";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 4, name: "refresh_schedule", kind: "message", T: Schedule },
    { no: 5, name: "timeout_seconds", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 13, name: "incremental", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 14, name: "incremental_state_resolver", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 15, name: "incremental_state_resolver_properties", kind: "message", T: Struct },
    { no: 18, name: "partitions_resolver", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 19, name: "partitions_resolver_properties", kind: "message", T: Struct },
    { no: 20, name: "partitions_watermark_field", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 21, name: "partitions_concurrency_limit", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 10, name: "input_connector", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 11, name: "input_properties", kind: "message", T: Struct },
    { no: 16, name: "stage_connector", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 17, name: "stage_properties", kind: "message", T: Struct },
    { no: 1, name: "output_connector", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 12, name: "output_properties", kind: "message", T: Struct },
    { no: 26, name: "retry_attempts", kind: "scalar", T: 13 /* ScalarType.UINT32 */, opt: true },
    { no: 27, name: "retry_delay_seconds", kind: "scalar", T: 13 /* ScalarType.UINT32 */, opt: true },
    { no: 28, name: "retry_exponential_backoff", kind: "scalar", T: 8 /* ScalarType.BOOL */, opt: true },
    { no: 29, name: "retry_if_error_matches", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 24, name: "change_mode", kind: "enum", T: proto3.getEnumType(ModelChangeMode) },
    { no: 25, name: "tests", kind: "message", T: ModelTest, repeated: true },
    { no: 9, name: "trigger", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 22, name: "trigger_full", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 30, name: "trigger_partitions", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 23, name: "defined_as_source", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ModelSpec {
    return new ModelSpec().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ModelSpec {
    return new ModelSpec().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ModelSpec {
    return new ModelSpec().fromJsonString(jsonString, options);
  }

  static equals(a: ModelSpec | PlainMessage<ModelSpec> | undefined, b: ModelSpec | PlainMessage<ModelSpec> | undefined): boolean {
    return proto3.util.equals(ModelSpec, a, b);
  }
}

/**
 * @generated from message rill.runtime.v1.ModelState
 */
export class ModelState extends Message<ModelState> {
  /**
   * executor_connector is the ModelExecutor that produced the model's result.
   *
   * @generated from field: string executor_connector = 6;
   */
  executorConnector = "";

  /**
   * result_connector is the connector where the model's result is stored.
   *
   * @generated from field: string result_connector = 1;
   */
  resultConnector = "";

  /**
   * result_properties are returned by the executor and contains metadata about the result.
   *
   * @generated from field: google.protobuf.Struct result_properties = 5;
   */
  resultProperties?: Struct;

  /**
   * result_table contains the model's result table for SQL models. It is a convenience field that can also be derived from result_properties.
   *
   * @generated from field: string result_table = 2;
   */
  resultTable = "";

  /**
   * spec_hash is a hash of those parts of the spec that affect the model's result.
   *
   * @generated from field: string spec_hash = 3;
   */
  specHash = "";

  /**
   * refs_hash is a hash of the model's refs current state. It is used to determine if the model's refs have changed.
   *
   * @generated from field: string refs_hash = 9;
   */
  refsHash = "";

  /**
   * test_hash is a hash of the model's tests current state. It is used to determine if the model's tests have changed.
   *
   * @generated from field: string test_hash = 27;
   */
  testHash = "";

  /**
   * test_errors contains the results of the model's tests.
   *
   * @generated from field: repeated string test_errors = 28;
   */
  testErrors: string[] = [];

  /**
   * refreshed_on is the time the model was last executed.
   *
   * @generated from field: google.protobuf.Timestamp refreshed_on = 4;
   */
  refreshedOn?: Timestamp;

  /**
   * incremental_state contains the result of the most recent invocation of the model's incremental state resolver.
   *
   * @generated from field: google.protobuf.Struct incremental_state = 7;
   */
  incrementalState?: Struct;

  /**
   * incremental_state_schema contains a schema for the data in incremental_state.
   *
   * @generated from field: rill.runtime.v1.StructType incremental_state_schema = 8;
   */
  incrementalStateSchema?: StructType;

  /**
   * partitions_model_id is a randomly generated ID used to store the model's partitions in the CatalogStore.
   *
   * @generated from field: string partitions_model_id = 10;
   */
  partitionsModelId = "";

  /**
   * partitions_have_errors is true if one or more partitions failed to execute.
   *
   * @generated from field: bool partitions_have_errors = 11;
   */
  partitionsHaveErrors = false;

  /**
   * total_execution_duration_ms is the time user queries took to execute while refreshing the model.
   * In case of incremental models it is the sum of all successful executions so far.
   * This is not the time it took to refresh the model which also includes other stuff like taking a write lock.
   *
   * @generated from field: int64 total_execution_duration_ms = 12;
   */
  totalExecutionDurationMs = protoInt64.zero;

  /**
   * latest_execution_duration_ms is the time user queries took to execute in the last successful refresh.
   *
   * @generated from field: int64 latest_execution_duration_ms = 13;
   */
  latestExecutionDurationMs = protoInt64.zero;

  constructor(data?: PartialMessage<ModelState>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "rill.runtime.v1.ModelState";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 6, name: "executor_connector", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 1, name: "result_connector", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "result_properties", kind: "message", T: Struct },
    { no: 2, name: "result_table", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "spec_hash", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 9, name: "refs_hash", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 27, name: "test_hash", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 28, name: "test_errors", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 4, name: "refreshed_on", kind: "message", T: Timestamp },
    { no: 7, name: "incremental_state", kind: "message", T: Struct },
    { no: 8, name: "incremental_state_schema", kind: "message", T: StructType },
    { no: 10, name: "partitions_model_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 11, name: "partitions_have_errors", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 12, name: "total_execution_duration_ms", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 13, name: "latest_execution_duration_ms", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ModelState {
    return new ModelState().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ModelState {
    return new ModelState().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ModelState {
    return new ModelState().fromJsonString(jsonString, options);
  }

  static equals(a: ModelState | PlainMessage<ModelState> | undefined, b: ModelState | PlainMessage<ModelState> | undefined): boolean {
    return proto3.util.equals(ModelState, a, b);
  }
}

/**
 * @generated from message rill.runtime.v1.ModelTest
 */
export class ModelTest extends Message<ModelTest> {
  /**
   * @generated from field: string name = 1;
   */
  name = "";

  /**
   * @generated from field: string resolver = 2;
   */
  resolver = "";

  /**
   * @generated from field: google.protobuf.Struct resolver_properties = 3;
   */
  resolverProperties?: Struct;

  constructor(data?: PartialMessage<ModelTest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "rill.runtime.v1.ModelTest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "resolver", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "resolver_properties", kind: "message", T: Struct },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ModelTest {
    return new ModelTest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ModelTest {
    return new ModelTest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ModelTest {
    return new ModelTest().fromJsonString(jsonString, options);
  }

  static equals(a: ModelTest | PlainMessage<ModelTest> | undefined, b: ModelTest | PlainMessage<ModelTest> | undefined): boolean {
    return proto3.util.equals(ModelTest, a, b);
  }
}

/**
 * @generated from message rill.runtime.v1.MetricsView
 */
export class MetricsView extends Message<MetricsView> {
  /**
   * @generated from field: rill.runtime.v1.MetricsViewSpec spec = 1;
   */
  spec?: MetricsViewSpec;

  /**
   * @generated from field: rill.runtime.v1.MetricsViewState state = 2;
   */
  state?: MetricsViewState;

  constructor(data?: PartialMessage<MetricsView>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "rill.runtime.v1.MetricsView";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "spec", kind: "message", T: MetricsViewSpec },
    { no: 2, name: "state", kind: "message", T: MetricsViewState },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MetricsView {
    return new MetricsView().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MetricsView {
    return new MetricsView().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MetricsView {
    return new MetricsView().fromJsonString(jsonString, options);
  }

  static equals(a: MetricsView | PlainMessage<MetricsView> | undefined, b: MetricsView | PlainMessage<MetricsView> | undefined): boolean {
    return proto3.util.equals(MetricsView, a, b);
  }
}

/**
 * @generated from message rill.runtime.v1.MetricsViewSpec
 */
export class MetricsViewSpec extends Message<MetricsViewSpec> {
  /**
   * name of parent metrics view, if this is a derived metrics view. If this is set then certain fields like table, connector, database*, model, dimensions, and measures will only be set in `state.valid_spec`.
   *
   * @generated from field: string parent = 30;
   */
  parent = "";

  /**
   * Connector containing the table
   *
   * @generated from field: string connector = 1;
   */
  connector = "";

  /**
   * Name of the database where table is located (optional)
   *
   * @generated from field: string database = 21;
   */
  database = "";

  /**
   * Name of the database schema where table is located (optional)
   *
   * @generated from field: string database_schema = 22;
   */
  databaseSchema = "";

  /**
   * Name of the table the metrics view is based on
   *
   * @generated from field: string table = 2;
   */
  table = "";

  /**
   * Name of the model the metrics view is based on. Either table or model should be set.
   *
   * @generated from field: string model = 24;
   */
  model = "";

  /**
   * User-facing name
   *
   * @generated from field: string display_name = 3;
   */
  displayName = "";

  /**
   * User-facing description
   *
   * @generated from field: string description = 4;
   */
  description = "";

  /**
   * Extra context for LLM/AI features. Used to guide natural language question answering and routing.
   *
   * @generated from field: string ai_instructions = 28;
   */
  aiInstructions = "";

  /**
   * Name of the primary time dimension, used for rendering time series
   *
   * @generated from field: string time_dimension = 5;
   */
  timeDimension = "";

  /**
   * The smallest time grain that can be queried for.
   * This can be useful to set if the time_dimension is not available below a certain granularity.
   *
   * @generated from field: rill.runtime.v1.TimeGrain smallest_time_grain = 8;
   */
  smallestTimeGrain = TimeGrain.UNSPECIFIED;

  /**
   * Expression to evaluate a watermark for the metrics view. If not set, the watermark defaults to max(time_dimension).
   *
   * @generated from field: string watermark_expression = 20;
   */
  watermarkExpression = "";

  /**
   * Dimensions in the metrics view
   *
   * @generated from field: repeated rill.runtime.v1.MetricsViewSpec.Dimension dimensions = 6;
   */
  dimensions: MetricsViewSpec_Dimension[] = [];

  /**
   * Measures in the metrics view
   *
   * @generated from field: repeated rill.runtime.v1.MetricsViewSpec.Measure measures = 7;
   */
  measures: MetricsViewSpec_Measure[] = [];

  /**
   * Dynamic selector for dimensions from parent metrics view. Will be processed during validation, so it will always be empty in `state.valid_spec`. Can only be used if parent is set.
   *
   * @generated from field: rill.runtime.v1.FieldSelector parent_dimensions = 31;
   */
  parentDimensions?: FieldSelector;

  /**
   * Dynamic selector for measures from parent metrics view. Will be processed during validation, so it will always be empty in `state.valid_spec`. Can only be used if parent is set.
   *
   * @generated from field: rill.runtime.v1.FieldSelector parent_measures = 32;
   */
  parentMeasures?: FieldSelector;

  /**
   * Annotations in the metrics view
   *
   * @generated from field: repeated rill.runtime.v1.MetricsViewSpec.Annotation annotations = 29;
   */
  annotations: MetricsViewSpec_Annotation[] = [];

  /**
   * Security for the metrics view
   *
   * @generated from field: repeated rill.runtime.v1.SecurityRule security_rules = 23;
   */
  securityRules: SecurityRule[] = [];

  /**
   * ISO 8601 weekday number to use as the base for time aggregations by week. Defaults to 1 (Monday).
   *
   * @generated from field: uint32 first_day_of_week = 12;
   */
  firstDayOfWeek = 0;

  /**
   * Month number to use as the base for time aggregations by year. Defaults to 1 (January).
   *
   * @generated from field: uint32 first_month_of_year = 13;
   */
  firstMonthOfYear = 0;

  /**
   * Cache controls for the metrics view.
   *
   * @generated from field: optional bool cache_enabled = 25;
   */
  cacheEnabled?: boolean;

  /**
   * @generated from field: string cache_key_sql = 26;
   */
  cacheKeySql = "";

  /**
   * @generated from field: int64 cache_key_ttl_seconds = 27;
   */
  cacheKeyTtlSeconds = protoInt64.zero;

  constructor(data?: PartialMessage<MetricsViewSpec>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "rill.runtime.v1.MetricsViewSpec";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 30, name: "parent", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 1, name: "connector", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 21, name: "database", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 22, name: "database_schema", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "table", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 24, name: "model", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "display_name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "description", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 28, name: "ai_instructions", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "time_dimension", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 8, name: "smallest_time_grain", kind: "enum", T: proto3.getEnumType(TimeGrain) },
    { no: 20, name: "watermark_expression", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 6, name: "dimensions", kind: "message", T: MetricsViewSpec_Dimension, repeated: true },
    { no: 7, name: "measures", kind: "message", T: MetricsViewSpec_Measure, repeated: true },
    { no: 31, name: "parent_dimensions", kind: "message", T: FieldSelector },
    { no: 32, name: "parent_measures", kind: "message", T: FieldSelector },
    { no: 29, name: "annotations", kind: "message", T: MetricsViewSpec_Annotation, repeated: true },
    { no: 23, name: "security_rules", kind: "message", T: SecurityRule, repeated: true },
    { no: 12, name: "first_day_of_week", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 13, name: "first_month_of_year", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 25, name: "cache_enabled", kind: "scalar", T: 8 /* ScalarType.BOOL */, opt: true },
    { no: 26, name: "cache_key_sql", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 27, name: "cache_key_ttl_seconds", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MetricsViewSpec {
    return new MetricsViewSpec().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MetricsViewSpec {
    return new MetricsViewSpec().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MetricsViewSpec {
    return new MetricsViewSpec().fromJsonString(jsonString, options);
  }

  static equals(a: MetricsViewSpec | PlainMessage<MetricsViewSpec> | undefined, b: MetricsViewSpec | PlainMessage<MetricsViewSpec> | undefined): boolean {
    return proto3.util.equals(MetricsViewSpec, a, b);
  }
}

/**
 * @generated from enum rill.runtime.v1.MetricsViewSpec.DimensionType
 */
export enum MetricsViewSpec_DimensionType {
  /**
   * @generated from enum value: DIMENSION_TYPE_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * @generated from enum value: DIMENSION_TYPE_CATEGORICAL = 1;
   */
  CATEGORICAL = 1,

  /**
   * @generated from enum value: DIMENSION_TYPE_TIME = 2;
   */
  TIME = 2,
}
// Retrieve enum metadata with: proto3.getEnumType(MetricsViewSpec_DimensionType)
proto3.util.setEnumType(MetricsViewSpec_DimensionType, "rill.runtime.v1.MetricsViewSpec.DimensionType", [
  { no: 0, name: "DIMENSION_TYPE_UNSPECIFIED" },
  { no: 1, name: "DIMENSION_TYPE_CATEGORICAL" },
  { no: 2, name: "DIMENSION_TYPE_TIME" },
]);

/**
 * Type of measure query to generate
 *
 * @generated from enum rill.runtime.v1.MetricsViewSpec.MeasureType
 */
export enum MetricsViewSpec_MeasureType {
  /**
   * @generated from enum value: MEASURE_TYPE_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * @generated from enum value: MEASURE_TYPE_SIMPLE = 1;
   */
  SIMPLE = 1,

  /**
   * @generated from enum value: MEASURE_TYPE_DERIVED = 2;
   */
  DERIVED = 2,

  /**
   * @generated from enum value: MEASURE_TYPE_TIME_COMPARISON = 3;
   */
  TIME_COMPARISON = 3,
}
// Retrieve enum metadata with: proto3.getEnumType(MetricsViewSpec_MeasureType)
proto3.util.setEnumType(MetricsViewSpec_MeasureType, "rill.runtime.v1.MetricsViewSpec.MeasureType", [
  { no: 0, name: "MEASURE_TYPE_UNSPECIFIED" },
  { no: 1, name: "MEASURE_TYPE_SIMPLE" },
  { no: 2, name: "MEASURE_TYPE_DERIVED" },
  { no: 3, name: "MEASURE_TYPE_TIME_COMPARISON" },
]);

/**
 * Dimensions are columns to filter and group by
 *
 * @generated from message rill.runtime.v1.MetricsViewSpec.Dimension
 */
export class MetricsViewSpec_Dimension extends Message<MetricsViewSpec_Dimension> {
  /**
   * @generated from field: string name = 1;
   */
  name = "";

  /**
   * The dimension type. Only populated in ValidSpec.
   *
   * @generated from field: rill.runtime.v1.MetricsViewSpec.DimensionType type = 14;
   */
  type = MetricsViewSpec_DimensionType.UNSPECIFIED;

  /**
   * @generated from field: string display_name = 3;
   */
  displayName = "";

  /**
   * @generated from field: string description = 4;
   */
  description = "";

  /**
   * @generated from field: string column = 2;
   */
  column = "";

  /**
   * @generated from field: string expression = 6;
   */
  expression = "";

  /**
   * @generated from field: bool unnest = 5;
   */
  unnest = false;

  /**
   * @generated from field: string uri = 7;
   */
  uri = "";

  /**
   * Lookup fields for the dimension
   *
   * @generated from field: string lookup_table = 8;
   */
  lookupTable = "";

  /**
   * @generated from field: string lookup_key_column = 9;
   */
  lookupKeyColumn = "";

  /**
   * @generated from field: string lookup_value_column = 10;
   */
  lookupValueColumn = "";

  /**
   * @generated from field: string lookup_default_expression = 11;
   */
  lookupDefaultExpression = "";

  /**
   * The smallest time grain for the dimension. Only populated for time dimensions.
   *
   * @generated from field: rill.runtime.v1.TimeGrain smallest_time_grain = 13;
   */
  smallestTimeGrain = TimeGrain.UNSPECIFIED;

  /**
   * The data type of the dimension. Only populated in ValidSpec.
   *
   * @generated from field: rill.runtime.v1.Type data_type = 12;
   */
  dataType?: Type;

  constructor(data?: PartialMessage<MetricsViewSpec_Dimension>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "rill.runtime.v1.MetricsViewSpec.Dimension";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 14, name: "type", kind: "enum", T: proto3.getEnumType(MetricsViewSpec_DimensionType) },
    { no: 3, name: "display_name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "description", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "column", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 6, name: "expression", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "unnest", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 7, name: "uri", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 8, name: "lookup_table", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 9, name: "lookup_key_column", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 10, name: "lookup_value_column", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 11, name: "lookup_default_expression", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 13, name: "smallest_time_grain", kind: "enum", T: proto3.getEnumType(TimeGrain) },
    { no: 12, name: "data_type", kind: "message", T: Type },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MetricsViewSpec_Dimension {
    return new MetricsViewSpec_Dimension().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MetricsViewSpec_Dimension {
    return new MetricsViewSpec_Dimension().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MetricsViewSpec_Dimension {
    return new MetricsViewSpec_Dimension().fromJsonString(jsonString, options);
  }

  static equals(a: MetricsViewSpec_Dimension | PlainMessage<MetricsViewSpec_Dimension> | undefined, b: MetricsViewSpec_Dimension | PlainMessage<MetricsViewSpec_Dimension> | undefined): boolean {
    return proto3.util.equals(MetricsViewSpec_Dimension, a, b);
  }
}

/**
 * Selector for a dimension
 *
 * @generated from message rill.runtime.v1.MetricsViewSpec.DimensionSelector
 */
export class MetricsViewSpec_DimensionSelector extends Message<MetricsViewSpec_DimensionSelector> {
  /**
   * @generated from field: string name = 1;
   */
  name = "";

  /**
   * Only for time dimensions (optional)
   *
   * @generated from field: rill.runtime.v1.TimeGrain time_grain = 2;
   */
  timeGrain = TimeGrain.UNSPECIFIED;

  /**
   * Only for when ordering (optional)
   *
   * @generated from field: bool desc = 3;
   */
  desc = false;

  constructor(data?: PartialMessage<MetricsViewSpec_DimensionSelector>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "rill.runtime.v1.MetricsViewSpec.DimensionSelector";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "time_grain", kind: "enum", T: proto3.getEnumType(TimeGrain) },
    { no: 3, name: "desc", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MetricsViewSpec_DimensionSelector {
    return new MetricsViewSpec_DimensionSelector().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MetricsViewSpec_DimensionSelector {
    return new MetricsViewSpec_DimensionSelector().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MetricsViewSpec_DimensionSelector {
    return new MetricsViewSpec_DimensionSelector().fromJsonString(jsonString, options);
  }

  static equals(a: MetricsViewSpec_DimensionSelector | PlainMessage<MetricsViewSpec_DimensionSelector> | undefined, b: MetricsViewSpec_DimensionSelector | PlainMessage<MetricsViewSpec_DimensionSelector> | undefined): boolean {
    return proto3.util.equals(MetricsViewSpec_DimensionSelector, a, b);
  }
}

/**
 * Window to apply to the measure calculation
 *
 * @generated from message rill.runtime.v1.MetricsViewSpec.MeasureWindow
 */
export class MetricsViewSpec_MeasureWindow extends Message<MetricsViewSpec_MeasureWindow> {
  /**
   * If true, partitions the window by all present dimensions except those in order_by
   *
   * @generated from field: bool partition = 1;
   */
  partition = false;

  /**
   * Dimensions to order the window by. Must be present in required_dimensions.
   *
   * @generated from field: repeated rill.runtime.v1.MetricsViewSpec.DimensionSelector order_by = 3;
   */
  orderBy: MetricsViewSpec_DimensionSelector[] = [];

  /**
   * Raw SQL expression to use as the frame (starting with "ROWS ...")
   *
   * @generated from field: string frame_expression = 2;
   */
  frameExpression = "";

  constructor(data?: PartialMessage<MetricsViewSpec_MeasureWindow>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "rill.runtime.v1.MetricsViewSpec.MeasureWindow";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "partition", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 3, name: "order_by", kind: "message", T: MetricsViewSpec_DimensionSelector, repeated: true },
    { no: 2, name: "frame_expression", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MetricsViewSpec_MeasureWindow {
    return new MetricsViewSpec_MeasureWindow().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MetricsViewSpec_MeasureWindow {
    return new MetricsViewSpec_MeasureWindow().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MetricsViewSpec_MeasureWindow {
    return new MetricsViewSpec_MeasureWindow().fromJsonString(jsonString, options);
  }

  static equals(a: MetricsViewSpec_MeasureWindow | PlainMessage<MetricsViewSpec_MeasureWindow> | undefined, b: MetricsViewSpec_MeasureWindow | PlainMessage<MetricsViewSpec_MeasureWindow> | undefined): boolean {
    return proto3.util.equals(MetricsViewSpec_MeasureWindow, a, b);
  }
}

/**
 * Measures are aggregated computed values
 *
 * @generated from message rill.runtime.v1.MetricsViewSpec.Measure
 */
export class MetricsViewSpec_Measure extends Message<MetricsViewSpec_Measure> {
  /**
   * @generated from field: string name = 1;
   */
  name = "";

  /**
   * @generated from field: string display_name = 3;
   */
  displayName = "";

  /**
   * @generated from field: string description = 4;
   */
  description = "";

  /**
   * @generated from field: string expression = 2;
   */
  expression = "";

  /**
   * @generated from field: rill.runtime.v1.MetricsViewSpec.MeasureType type = 8;
   */
  type = MetricsViewSpec_MeasureType.UNSPECIFIED;

  /**
   * @generated from field: rill.runtime.v1.MetricsViewSpec.MeasureWindow window = 9;
   */
  window?: MetricsViewSpec_MeasureWindow;

  /**
   * @generated from field: repeated rill.runtime.v1.MetricsViewSpec.DimensionSelector per_dimensions = 10;
   */
  perDimensions: MetricsViewSpec_DimensionSelector[] = [];

  /**
   * @generated from field: repeated rill.runtime.v1.MetricsViewSpec.DimensionSelector required_dimensions = 11;
   */
  requiredDimensions: MetricsViewSpec_DimensionSelector[] = [];

  /**
   * @generated from field: repeated string referenced_measures = 12;
   */
  referencedMeasures: string[] = [];

  /**
   * @generated from field: string format_preset = 5;
   */
  formatPreset = "";

  /**
   * @generated from field: string format_d3 = 7;
   */
  formatD3 = "";

  /**
   * @generated from field: google.protobuf.Struct format_d3_locale = 13;
   */
  formatD3Locale?: Struct;

  /**
   * @generated from field: bool valid_percent_of_total = 6;
   */
  validPercentOfTotal = false;

  /**
   * @generated from field: string treat_nulls_as = 14;
   */
  treatNullsAs = "";

  /**
   * The data type of the measure. Only populated in ValidSpec.
   *
   * @generated from field: rill.runtime.v1.Type data_type = 15;
   */
  dataType?: Type;

  constructor(data?: PartialMessage<MetricsViewSpec_Measure>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "rill.runtime.v1.MetricsViewSpec.Measure";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "display_name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "description", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "expression", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 8, name: "type", kind: "enum", T: proto3.getEnumType(MetricsViewSpec_MeasureType) },
    { no: 9, name: "window", kind: "message", T: MetricsViewSpec_MeasureWindow },
    { no: 10, name: "per_dimensions", kind: "message", T: MetricsViewSpec_DimensionSelector, repeated: true },
    { no: 11, name: "required_dimensions", kind: "message", T: MetricsViewSpec_DimensionSelector, repeated: true },
    { no: 12, name: "referenced_measures", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 5, name: "format_preset", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 7, name: "format_d3", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 13, name: "format_d3_locale", kind: "message", T: Struct },
    { no: 6, name: "valid_percent_of_total", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 14, name: "treat_nulls_as", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 15, name: "data_type", kind: "message", T: Type },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MetricsViewSpec_Measure {
    return new MetricsViewSpec_Measure().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MetricsViewSpec_Measure {
    return new MetricsViewSpec_Measure().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MetricsViewSpec_Measure {
    return new MetricsViewSpec_Measure().fromJsonString(jsonString, options);
  }

  static equals(a: MetricsViewSpec_Measure | PlainMessage<MetricsViewSpec_Measure> | undefined, b: MetricsViewSpec_Measure | PlainMessage<MetricsViewSpec_Measure> | undefined): boolean {
    return proto3.util.equals(MetricsViewSpec_Measure, a, b);
  }
}

/**
 * Annotations that can be applied to measures. Each annotation needs to have a model or a table defined.
 * 1. The underlying model/table has to have a `time` and `description` columns.
 * 2. Can additionally have `time_end` column to convert the annotation to range type annotation.
 * 3. Can additionally have `duration` column, this is used to not query for annotations greater than selected grain in dashboard. Also forces `time` and `time_end` in UI to be truncated to selected grain.
 *
 * @generated from message rill.runtime.v1.MetricsViewSpec.Annotation
 */
export class MetricsViewSpec_Annotation extends Message<MetricsViewSpec_Annotation> {
  /**
   * @generated from field: string name = 1;
   */
  name = "";

  /**
   * Connector containing the table
   *
   * @generated from field: string connector = 2;
   */
  connector = "";

  /**
   * Name of the database where table is located (optional)
   *
   * @generated from field: string database = 3;
   */
  database = "";

  /**
   * Name of the database schema where table is located (optional)
   *
   * @generated from field: string database_schema = 4;
   */
  databaseSchema = "";

  /**
   * Name of the model that source of annotation
   *
   * @generated from field: string table = 5;
   */
  table = "";

  /**
   * Name of the model that source of annotation. Either table or model should be set.
   *
   * @generated from field: string model = 6;
   */
  model = "";

  /**
   * Measures to apply the annotation to. If `measures_selector` is set, this will only be set in `state.valid_spec`.
   *
   * @generated from field: repeated string measures = 7;
   */
  measures: string[] = [];

  /**
   * Dynamic selector for `measures`. Will be processed during validation, so it will always be empty in `state.valid_spec`.
   *
   * @generated from field: rill.runtime.v1.FieldSelector measures_selector = 8;
   */
  measuresSelector?: FieldSelector;

  /**
   * Signifies that the underlying table has `time_end` column. Will be used while querying to add additional filter.
   *
   * @generated from field: bool has_time_end = 10;
   */
  hasTimeEnd = false;

  /**
   * Signifies that the underlying table has `duration` column. Will be used while querying to add additional filter.
   *
   * @generated from field: bool has_duration = 11;
   */
  hasDuration = false;

  constructor(data?: PartialMessage<MetricsViewSpec_Annotation>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "rill.runtime.v1.MetricsViewSpec.Annotation";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "connector", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "database", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "database_schema", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "table", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 6, name: "model", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 7, name: "measures", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 8, name: "measures_selector", kind: "message", T: FieldSelector },
    { no: 10, name: "has_time_end", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 11, name: "has_duration", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MetricsViewSpec_Annotation {
    return new MetricsViewSpec_Annotation().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MetricsViewSpec_Annotation {
    return new MetricsViewSpec_Annotation().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MetricsViewSpec_Annotation {
    return new MetricsViewSpec_Annotation().fromJsonString(jsonString, options);
  }

  static equals(a: MetricsViewSpec_Annotation | PlainMessage<MetricsViewSpec_Annotation> | undefined, b: MetricsViewSpec_Annotation | PlainMessage<MetricsViewSpec_Annotation> | undefined): boolean {
    return proto3.util.equals(MetricsViewSpec_Annotation, a, b);
  }
}

/**
 * @generated from message rill.runtime.v1.SecurityRule
 */
export class SecurityRule extends Message<SecurityRule> {
  /**
   * @generated from oneof rill.runtime.v1.SecurityRule.rule
   */
  rule: {
    /**
     * @generated from field: rill.runtime.v1.SecurityRuleAccess access = 1;
     */
    value: SecurityRuleAccess;
    case: "access";
  } | {
    /**
     * @generated from field: rill.runtime.v1.SecurityRuleFieldAccess field_access = 2;
     */
    value: SecurityRuleFieldAccess;
    case: "fieldAccess";
  } | {
    /**
     * @generated from field: rill.runtime.v1.SecurityRuleRowFilter row_filter = 3;
     */
    value: SecurityRuleRowFilter;
    case: "rowFilter";
  } | {
    /**
     * @generated from field: rill.runtime.v1.SecurityRuleTransitiveAccess transitive_access = 4;
     */
    value: SecurityRuleTransitiveAccess;
    case: "transitiveAccess";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<SecurityRule>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "rill.runtime.v1.SecurityRule";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "access", kind: "message", T: SecurityRuleAccess, oneof: "rule" },
    { no: 2, name: "field_access", kind: "message", T: SecurityRuleFieldAccess, oneof: "rule" },
    { no: 3, name: "row_filter", kind: "message", T: SecurityRuleRowFilter, oneof: "rule" },
    { no: 4, name: "transitive_access", kind: "message", T: SecurityRuleTransitiveAccess, oneof: "rule" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SecurityRule {
    return new SecurityRule().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SecurityRule {
    return new SecurityRule().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SecurityRule {
    return new SecurityRule().fromJsonString(jsonString, options);
  }

  static equals(a: SecurityRule | PlainMessage<SecurityRule> | undefined, b: SecurityRule | PlainMessage<SecurityRule> | undefined): boolean {
    return proto3.util.equals(SecurityRule, a, b);
  }
}

/**
 * @generated from message rill.runtime.v1.SecurityRuleAccess
 */
export class SecurityRuleAccess extends Message<SecurityRuleAccess> {
  /**
   * The condition under which this rule applies.
   * It is ANDed together with the condition_kinds and condition_resources.
   *
   * @generated from field: string condition_expression = 1;
   */
  conditionExpression = "";

  /**
   * The resource kinds the rule applies to. If empty, it defaults to all resource kinds.
   *
   * @generated from field: repeated string condition_kinds = 3;
   */
  conditionKinds: string[] = [];

  /**
   * The resources the rule applies to. If empty, it defaults to all resources in scope covered by `resource_kinds`.
   * It is ORed together with the condition_kinds.
   *
   * @generated from field: repeated rill.runtime.v1.ResourceName condition_resources = 4;
   */
  conditionResources: ResourceName[] = [];

  /**
   * Whether to allow or deny access to the resources covered by the conditions.
   *
   * @generated from field: bool allow = 2;
   */
  allow = false;

  /**
   * If true, any resource not covered by the conditions will explicitly get the opposite permission (e.g. will be denied if `allow` is true).
   *
   * @generated from field: bool exclusive = 5;
   */
  exclusive = false;

  constructor(data?: PartialMessage<SecurityRuleAccess>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "rill.runtime.v1.SecurityRuleAccess";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "condition_expression", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "condition_kinds", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 4, name: "condition_resources", kind: "message", T: ResourceName, repeated: true },
    { no: 2, name: "allow", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 5, name: "exclusive", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SecurityRuleAccess {
    return new SecurityRuleAccess().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SecurityRuleAccess {
    return new SecurityRuleAccess().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SecurityRuleAccess {
    return new SecurityRuleAccess().fromJsonString(jsonString, options);
  }

  static equals(a: SecurityRuleAccess | PlainMessage<SecurityRuleAccess> | undefined, b: SecurityRuleAccess | PlainMessage<SecurityRuleAccess> | undefined): boolean {
    return proto3.util.equals(SecurityRuleAccess, a, b);
  }
}

/**
 * @generated from message rill.runtime.v1.SecurityRuleFieldAccess
 */
export class SecurityRuleFieldAccess extends Message<SecurityRuleFieldAccess> {
  /**
   * The condition under which this rule applies.
   * It is ANDed together with the condition_kinds and condition_resources.
   *
   * @generated from field: string condition_expression = 1;
   */
  conditionExpression = "";

  /**
   * The resource kinds the rule applies to. If empty, it defaults to all resource kinds.
   *
   * @generated from field: repeated string condition_kinds = 5;
   */
  conditionKinds: string[] = [];

  /**
   * The resources the rule applies to. If empty, it defaults to all resources in scope covered by `resource_kinds`.
   * It is ORed together with the condition_kinds.
   *
   * @generated from field: repeated rill.runtime.v1.ResourceName condition_resources = 6;
   */
  conditionResources: ResourceName[] = [];

  /**
   * @generated from field: bool allow = 2;
   */
  allow = false;

  /**
   * If true, all other fields not explicitly listed will get the opposite permission (e.g. will be denied if `allow` is true).
   *
   * @generated from field: bool exclusive = 7;
   */
  exclusive = false;

  /**
   * @generated from field: repeated string fields = 3;
   */
  fields: string[] = [];

  /**
   * @generated from field: bool all_fields = 4;
   */
  allFields = false;

  constructor(data?: PartialMessage<SecurityRuleFieldAccess>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "rill.runtime.v1.SecurityRuleFieldAccess";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "condition_expression", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "condition_kinds", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 6, name: "condition_resources", kind: "message", T: ResourceName, repeated: true },
    { no: 2, name: "allow", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 7, name: "exclusive", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 3, name: "fields", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 4, name: "all_fields", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SecurityRuleFieldAccess {
    return new SecurityRuleFieldAccess().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SecurityRuleFieldAccess {
    return new SecurityRuleFieldAccess().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SecurityRuleFieldAccess {
    return new SecurityRuleFieldAccess().fromJsonString(jsonString, options);
  }

  static equals(a: SecurityRuleFieldAccess | PlainMessage<SecurityRuleFieldAccess> | undefined, b: SecurityRuleFieldAccess | PlainMessage<SecurityRuleFieldAccess> | undefined): boolean {
    return proto3.util.equals(SecurityRuleFieldAccess, a, b);
  }
}

/**
 * @generated from message rill.runtime.v1.SecurityRuleRowFilter
 */
export class SecurityRuleRowFilter extends Message<SecurityRuleRowFilter> {
  /**
   * The condition under which this rule applies.
   * It is ANDed together with the condition_kinds and condition_resources.
   *
   * @generated from field: string condition_expression = 1;
   */
  conditionExpression = "";

  /**
   * The resource kinds the rule applies to. If empty, it defaults to all resource kinds.
   *
   * @generated from field: repeated string condition_kinds = 4;
   */
  conditionKinds: string[] = [];

  /**
   * The resources the rule applies to. If empty, it defaults to all resources in scope covered by `resource_kinds`.
   * It is ORed together with the condition_kinds.
   *
   * @generated from field: repeated rill.runtime.v1.ResourceName condition_resources = 5;
   */
  conditionResources: ResourceName[] = [];

  /**
   * Raw SQL expression to apply to the underlying table
   *
   * @generated from field: string sql = 2;
   */
  sql = "";

  /**
   * Regular query expression referencing dimension names
   *
   * @generated from field: rill.runtime.v1.Expression expression = 3;
   */
  expression?: Expression;

  constructor(data?: PartialMessage<SecurityRuleRowFilter>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "rill.runtime.v1.SecurityRuleRowFilter";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "condition_expression", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "condition_kinds", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 5, name: "condition_resources", kind: "message", T: ResourceName, repeated: true },
    { no: 2, name: "sql", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "expression", kind: "message", T: Expression },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SecurityRuleRowFilter {
    return new SecurityRuleRowFilter().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SecurityRuleRowFilter {
    return new SecurityRuleRowFilter().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SecurityRuleRowFilter {
    return new SecurityRuleRowFilter().fromJsonString(jsonString, options);
  }

  static equals(a: SecurityRuleRowFilter | PlainMessage<SecurityRuleRowFilter> | undefined, b: SecurityRuleRowFilter | PlainMessage<SecurityRuleRowFilter> | undefined): boolean {
    return proto3.util.equals(SecurityRuleRowFilter, a, b);
  }
}

/**
 * @generated from message rill.runtime.v1.SecurityRuleTransitiveAccess
 */
export class SecurityRuleTransitiveAccess extends Message<SecurityRuleTransitiveAccess> {
  /**
   * this rules resolves to rules that provides access to whatever is needed to access this resource.
   *
   * @generated from field: rill.runtime.v1.ResourceName resource = 1;
   */
  resource?: ResourceName;

  constructor(data?: PartialMessage<SecurityRuleTransitiveAccess>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "rill.runtime.v1.SecurityRuleTransitiveAccess";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "resource", kind: "message", T: ResourceName },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SecurityRuleTransitiveAccess {
    return new SecurityRuleTransitiveAccess().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SecurityRuleTransitiveAccess {
    return new SecurityRuleTransitiveAccess().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SecurityRuleTransitiveAccess {
    return new SecurityRuleTransitiveAccess().fromJsonString(jsonString, options);
  }

  static equals(a: SecurityRuleTransitiveAccess | PlainMessage<SecurityRuleTransitiveAccess> | undefined, b: SecurityRuleTransitiveAccess | PlainMessage<SecurityRuleTransitiveAccess> | undefined): boolean {
    return proto3.util.equals(SecurityRuleTransitiveAccess, a, b);
  }
}

/**
 * @generated from message rill.runtime.v1.MetricsViewState
 */
export class MetricsViewState extends Message<MetricsViewState> {
  /**
   * Valid spec is a (potentially previous) version of the spec that is known to currently be valid.
   *
   * @generated from field: rill.runtime.v1.MetricsViewSpec valid_spec = 1;
   */
  validSpec?: MetricsViewSpec;

  /**
   * Streaming is true if the underlying data may change without the metrics view's spec/state version changing.
   * It's set to true if the metrics view is based on an externally managed table.
   *
   * @generated from field: bool streaming = 2;
   */
  streaming = false;

  /**
   * The last time the metrics view's underlying data was refreshed.
   * This may be empty if the metrics view is based on an externally managed table.
   *
   * @generated from field: google.protobuf.Timestamp data_refreshed_on = 3;
   */
  dataRefreshedOn?: Timestamp;

  constructor(data?: PartialMessage<MetricsViewState>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "rill.runtime.v1.MetricsViewState";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "valid_spec", kind: "message", T: MetricsViewSpec },
    { no: 2, name: "streaming", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 3, name: "data_refreshed_on", kind: "message", T: Timestamp },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MetricsViewState {
    return new MetricsViewState().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MetricsViewState {
    return new MetricsViewState().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MetricsViewState {
    return new MetricsViewState().fromJsonString(jsonString, options);
  }

  static equals(a: MetricsViewState | PlainMessage<MetricsViewState> | undefined, b: MetricsViewState | PlainMessage<MetricsViewState> | undefined): boolean {
    return proto3.util.equals(MetricsViewState, a, b);
  }
}

/**
 * @generated from message rill.runtime.v1.Explore
 */
export class Explore extends Message<Explore> {
  /**
   * @generated from field: rill.runtime.v1.ExploreSpec spec = 1;
   */
  spec?: ExploreSpec;

  /**
   * @generated from field: rill.runtime.v1.ExploreState state = 2;
   */
  state?: ExploreState;

  constructor(data?: PartialMessage<Explore>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "rill.runtime.v1.Explore";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "spec", kind: "message", T: ExploreSpec },
    { no: 2, name: "state", kind: "message", T: ExploreState },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Explore {
    return new Explore().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Explore {
    return new Explore().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Explore {
    return new Explore().fromJsonString(jsonString, options);
  }

  static equals(a: Explore | PlainMessage<Explore> | undefined, b: Explore | PlainMessage<Explore> | undefined): boolean {
    return proto3.util.equals(Explore, a, b);
  }
}

/**
 * @generated from message rill.runtime.v1.ExploreSpec
 */
export class ExploreSpec extends Message<ExploreSpec> {
  /**
   * User-facing name
   *
   * @generated from field: string display_name = 1;
   */
  displayName = "";

  /**
   * User-facing description
   *
   * @generated from field: string description = 2;
   */
  description = "";

  /**
   * The metrics view the explore is based on
   *
   * @generated from field: string metrics_view = 3;
   */
  metricsView = "";

  /**
   * Dimensions to show. If `dimensions_selector` is set, this will only be set in `state.valid_spec`.
   *
   * @generated from field: repeated string dimensions = 4;
   */
  dimensions: string[] = [];

  /**
   * Dynamic selector for `dimensions`. Will be processed during validation, so it will always be empty in `state.valid_spec`.
   *
   * @generated from field: rill.runtime.v1.FieldSelector dimensions_selector = 13;
   */
  dimensionsSelector?: FieldSelector;

  /**
   * Measures to show. If `measures_selector` is set, this will only be set in `state.valid_spec`.
   *
   * @generated from field: repeated string measures = 6;
   */
  measures: string[] = [];

  /**
   * Dynamic selector for `measures`. Will be processed during validation, so it will always be empty in `state.valid_spec`.
   *
   * @generated from field: rill.runtime.v1.FieldSelector measures_selector = 14;
   */
  measuresSelector?: FieldSelector;

  /**
   * Theme to use
   *
   * @generated from field: string theme = 8;
   */
  theme = "";

  /**
   * @generated from field: rill.runtime.v1.ThemeSpec embedded_theme = 17;
   */
  embeddedTheme?: ThemeSpec;

  /**
   * List of selectable time ranges with comparison time ranges.
   * If the list is empty, a default list should be shown.
   *
   * @generated from field: repeated rill.runtime.v1.ExploreTimeRange time_ranges = 9;
   */
  timeRanges: ExploreTimeRange[] = [];

  /**
   * List of selectable time zones.
   * If the list is empty, a default list should be shown.
   * The values should be valid IANA location identifiers.
   *
   * @generated from field: repeated string time_zones = 10;
   */
  timeZones: string[] = [];

  /**
   * Preset UI state to show by default.
   *
   * @generated from field: rill.runtime.v1.ExplorePreset default_preset = 15;
   */
  defaultPreset?: ExplorePreset;

  /**
   * If true, the pivot tab will be hidden when the explore is embedded.
   *
   * @generated from field: bool embeds_hide_pivot = 16;
   */
  embedsHidePivot = false;

  /**
   * Security for the explore dashboard.
   * These are not currently parsed from YAML, but will be derived from the parent metrics view.
   *
   * @generated from field: repeated rill.runtime.v1.SecurityRule security_rules = 12;
   */
  securityRules: SecurityRule[] = [];

  /**
   * Banner text that can be displayed in Rill Cloud.
   *
   * @generated from field: string banner = 18;
   */
  banner = "";

  /**
   * When set to true, dashboard will be locked to the first time zone in the time_zones key (or UTC)
   *
   * @generated from field: bool lock_time_zone = 19;
   */
  lockTimeZone = false;

  /**
   * Allow custom time range
   *
   * @generated from field: bool allow_custom_time_range = 20;
   */
  allowCustomTimeRange = false;

  /**
   * When true, it indicates that the explore was defined in a metrics view either explicitly or emitted because version was not set.
   *
   * @generated from field: bool defined_in_metrics_view = 21;
   */
  definedInMetricsView = false;

  constructor(data?: PartialMessage<ExploreSpec>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "rill.runtime.v1.ExploreSpec";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "display_name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "description", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "metrics_view", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "dimensions", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 13, name: "dimensions_selector", kind: "message", T: FieldSelector },
    { no: 6, name: "measures", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 14, name: "measures_selector", kind: "message", T: FieldSelector },
    { no: 8, name: "theme", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 17, name: "embedded_theme", kind: "message", T: ThemeSpec },
    { no: 9, name: "time_ranges", kind: "message", T: ExploreTimeRange, repeated: true },
    { no: 10, name: "time_zones", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 15, name: "default_preset", kind: "message", T: ExplorePreset },
    { no: 16, name: "embeds_hide_pivot", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 12, name: "security_rules", kind: "message", T: SecurityRule, repeated: true },
    { no: 18, name: "banner", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 19, name: "lock_time_zone", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 20, name: "allow_custom_time_range", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 21, name: "defined_in_metrics_view", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ExploreSpec {
    return new ExploreSpec().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ExploreSpec {
    return new ExploreSpec().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ExploreSpec {
    return new ExploreSpec().fromJsonString(jsonString, options);
  }

  static equals(a: ExploreSpec | PlainMessage<ExploreSpec> | undefined, b: ExploreSpec | PlainMessage<ExploreSpec> | undefined): boolean {
    return proto3.util.equals(ExploreSpec, a, b);
  }
}

/**
 * @generated from message rill.runtime.v1.ExploreState
 */
export class ExploreState extends Message<ExploreState> {
  /**
   * Valid spec is a (potentially previous) version of the spec that is known to be valid.
   * It is also guaranteed to have concrete dimensions and measures, i.e. if the spec has a `dimensions_selector` or `measures_selector`, they will be resolved to concrete fields.
   *
   * @generated from field: rill.runtime.v1.ExploreSpec valid_spec = 1;
   */
  validSpec?: ExploreSpec;

  /**
   * The last time the underlying metrics view's data was refreshed.
   * This may be empty if the data refresh time is not known, e.g. if the metrics view is based on an externally managed table.
   *
   * @generated from field: google.protobuf.Timestamp data_refreshed_on = 2;
   */
  dataRefreshedOn?: Timestamp;

  constructor(data?: PartialMessage<ExploreState>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "rill.runtime.v1.ExploreState";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "valid_spec", kind: "message", T: ExploreSpec },
    { no: 2, name: "data_refreshed_on", kind: "message", T: Timestamp },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ExploreState {
    return new ExploreState().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ExploreState {
    return new ExploreState().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ExploreState {
    return new ExploreState().fromJsonString(jsonString, options);
  }

  static equals(a: ExploreState | PlainMessage<ExploreState> | undefined, b: ExploreState | PlainMessage<ExploreState> | undefined): boolean {
    return proto3.util.equals(ExploreState, a, b);
  }
}

/**
 * @generated from message rill.runtime.v1.ExploreTimeRange
 */
export class ExploreTimeRange extends Message<ExploreTimeRange> {
  /**
   * ISO 8601 duration string for the time range
   *
   * @generated from field: string range = 1;
   */
  range = "";

  /**
   * Comparison time ranges available for this time range
   *
   * @generated from field: repeated rill.runtime.v1.ExploreComparisonTimeRange comparison_time_ranges = 2;
   */
  comparisonTimeRanges: ExploreComparisonTimeRange[] = [];

  constructor(data?: PartialMessage<ExploreTimeRange>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "rill.runtime.v1.ExploreTimeRange";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "range", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "comparison_time_ranges", kind: "message", T: ExploreComparisonTimeRange, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ExploreTimeRange {
    return new ExploreTimeRange().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ExploreTimeRange {
    return new ExploreTimeRange().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ExploreTimeRange {
    return new ExploreTimeRange().fromJsonString(jsonString, options);
  }

  static equals(a: ExploreTimeRange | PlainMessage<ExploreTimeRange> | undefined, b: ExploreTimeRange | PlainMessage<ExploreTimeRange> | undefined): boolean {
    return proto3.util.equals(ExploreTimeRange, a, b);
  }
}

/**
 * @generated from message rill.runtime.v1.ExploreComparisonTimeRange
 */
export class ExploreComparisonTimeRange extends Message<ExploreComparisonTimeRange> {
  /**
   * ISO 8601 duration string to use as an offset from the base time range.
   *
   * @generated from field: string offset = 1;
   */
  offset = "";

  /**
   * ISO 8601 duration string for the duration of the comparison time range.
   * If not specified, it should fallback to the range of the base time range.
   *
   * @generated from field: string range = 2;
   */
  range = "";

  constructor(data?: PartialMessage<ExploreComparisonTimeRange>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "rill.runtime.v1.ExploreComparisonTimeRange";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "offset", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "range", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ExploreComparisonTimeRange {
    return new ExploreComparisonTimeRange().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ExploreComparisonTimeRange {
    return new ExploreComparisonTimeRange().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ExploreComparisonTimeRange {
    return new ExploreComparisonTimeRange().fromJsonString(jsonString, options);
  }

  static equals(a: ExploreComparisonTimeRange | PlainMessage<ExploreComparisonTimeRange> | undefined, b: ExploreComparisonTimeRange | PlainMessage<ExploreComparisonTimeRange> | undefined): boolean {
    return proto3.util.equals(ExploreComparisonTimeRange, a, b);
  }
}

/**
 * @generated from message rill.runtime.v1.ExplorePreset
 */
export class ExplorePreset extends Message<ExplorePreset> {
  /**
   * Dimensions to show. If `dimensions_selector` is set, this will only be set in `state.valid_spec`.
   *
   * @generated from field: repeated string dimensions = 2;
   */
  dimensions: string[] = [];

  /**
   * Dynamic selector for `dimensions`. Will be processed during validation, so it will always be empty in `state.valid_spec`.
   *
   * @generated from field: rill.runtime.v1.FieldSelector dimensions_selector = 9;
   */
  dimensionsSelector?: FieldSelector;

  /**
   * Measures to show. If `measures_selector` is set, this will only be set in `state.valid_spec`.
   *
   * @generated from field: repeated string measures = 4;
   */
  measures: string[] = [];

  /**
   * Dynamic selector for `measures`. Will be processed during validation, so it will always be empty in `state.valid_spec`.
   *
   * @generated from field: rill.runtime.v1.FieldSelector measures_selector = 10;
   */
  measuresSelector?: FieldSelector;

  /**
   * @generated from field: optional rill.runtime.v1.Expression where = 11;
   */
  where?: Expression;

  /**
   * Temporary to differentiate between "select" and "in list" modes. Expression will be replaced with UI specific state in the future.
   *
   * @generated from field: repeated string dimensions_with_inlist_filter = 29;
   */
  dimensionsWithInlistFilter: string[] = [];

  /**
   * Time range for the explore.
   * It corresponds to the `range` property of the explore's `time_ranges`.
   * If not found in `time_ranges`, it should be added to the list.
   *
   * @generated from field: optional string time_range = 6;
   */
  timeRange?: string;

  /**
   * @generated from field: optional string timezone = 12;
   */
  timezone?: string;

  /**
   * @generated from field: optional string time_grain = 13;
   */
  timeGrain?: string;

  /**
   * @generated from field: optional string select_time_range = 14;
   */
  selectTimeRange?: string;

  /**
   * Comparison mode.
   *
   * @generated from field: rill.runtime.v1.ExploreComparisonMode comparison_mode = 7;
   */
  comparisonMode = ExploreComparisonMode.UNSPECIFIED;

  /**
   * @generated from field: optional string compare_time_range = 15;
   */
  compareTimeRange?: string;

  /**
   * If comparison_mode is EXPLORE_COMPARISON_MODE_DIMENSION, this indicates the dimension to use.
   *
   * @generated from field: optional string comparison_dimension = 8;
   */
  comparisonDimension?: string;

  /**
   * @generated from field: optional rill.runtime.v1.ExploreWebView view = 16;
   */
  view?: ExploreWebView;

  /**
   * @generated from field: optional string explore_sort_by = 17;
   */
  exploreSortBy?: string;

  /**
   * @generated from field: optional bool explore_sort_asc = 18;
   */
  exploreSortAsc?: boolean;

  /**
   * @generated from field: optional rill.runtime.v1.ExploreSortType explore_sort_type = 19;
   */
  exploreSortType?: ExploreSortType;

  /**
   * @generated from field: optional string explore_expanded_dimension = 20;
   */
  exploreExpandedDimension?: string;

  /**
   * Deprecated
   *
   * @generated from field: optional uint32 explore_leaderboard_measure_count = 30;
   */
  exploreLeaderboardMeasureCount?: number;

  /**
   * @generated from field: repeated string explore_leaderboard_measures = 31;
   */
  exploreLeaderboardMeasures: string[] = [];

  /**
   * @generated from field: optional bool explore_leaderboard_show_context_for_all_measures = 32;
   */
  exploreLeaderboardShowContextForAllMeasures?: boolean;

  /**
   * @generated from field: optional string time_dimension_measure = 21;
   */
  timeDimensionMeasure?: string;

  /**
   * @generated from field: optional string time_dimension_chart_type = 22;
   */
  timeDimensionChartType?: string;

  /**
   * @generated from field: optional bool time_dimension_pin = 23;
   */
  timeDimensionPin?: boolean;

  /**
   * @generated from field: repeated string pivot_rows = 24;
   */
  pivotRows: string[] = [];

  /**
   * @generated from field: repeated string pivot_cols = 25;
   */
  pivotCols: string[] = [];

  /**
   * @generated from field: optional string pivot_sort_by = 26;
   */
  pivotSortBy?: string;

  /**
   * @generated from field: optional bool pivot_sort_asc = 27;
   */
  pivotSortAsc?: boolean;

  /**
   * @generated from field: optional string pivot_table_mode = 28;
   */
  pivotTableMode?: string;

  constructor(data?: PartialMessage<ExplorePreset>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "rill.runtime.v1.ExplorePreset";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 2, name: "dimensions", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 9, name: "dimensions_selector", kind: "message", T: FieldSelector },
    { no: 4, name: "measures", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 10, name: "measures_selector", kind: "message", T: FieldSelector },
    { no: 11, name: "where", kind: "message", T: Expression, opt: true },
    { no: 29, name: "dimensions_with_inlist_filter", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 6, name: "time_range", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 12, name: "timezone", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 13, name: "time_grain", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 14, name: "select_time_range", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 7, name: "comparison_mode", kind: "enum", T: proto3.getEnumType(ExploreComparisonMode) },
    { no: 15, name: "compare_time_range", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 8, name: "comparison_dimension", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 16, name: "view", kind: "enum", T: proto3.getEnumType(ExploreWebView), opt: true },
    { no: 17, name: "explore_sort_by", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 18, name: "explore_sort_asc", kind: "scalar", T: 8 /* ScalarType.BOOL */, opt: true },
    { no: 19, name: "explore_sort_type", kind: "enum", T: proto3.getEnumType(ExploreSortType), opt: true },
    { no: 20, name: "explore_expanded_dimension", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 30, name: "explore_leaderboard_measure_count", kind: "scalar", T: 13 /* ScalarType.UINT32 */, opt: true },
    { no: 31, name: "explore_leaderboard_measures", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 32, name: "explore_leaderboard_show_context_for_all_measures", kind: "scalar", T: 8 /* ScalarType.BOOL */, opt: true },
    { no: 21, name: "time_dimension_measure", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 22, name: "time_dimension_chart_type", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 23, name: "time_dimension_pin", kind: "scalar", T: 8 /* ScalarType.BOOL */, opt: true },
    { no: 24, name: "pivot_rows", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 25, name: "pivot_cols", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 26, name: "pivot_sort_by", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 27, name: "pivot_sort_asc", kind: "scalar", T: 8 /* ScalarType.BOOL */, opt: true },
    { no: 28, name: "pivot_table_mode", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ExplorePreset {
    return new ExplorePreset().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ExplorePreset {
    return new ExplorePreset().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ExplorePreset {
    return new ExplorePreset().fromJsonString(jsonString, options);
  }

  static equals(a: ExplorePreset | PlainMessage<ExplorePreset> | undefined, b: ExplorePreset | PlainMessage<ExplorePreset> | undefined): boolean {
    return proto3.util.equals(ExplorePreset, a, b);
  }
}

/**
 * FieldSelector describes logic for selecting a list of fields.
 * It is useful for dynamically evaluating fields when the list of potential fields is not known at parse time.
 *
 * @generated from message rill.runtime.v1.FieldSelector
 */
export class FieldSelector extends Message<FieldSelector> {
  /**
   * Invert the result such that all fields *except* the selected fields are returned.
   *
   * @generated from field: bool invert = 1;
   */
  invert = false;

  /**
   * @generated from oneof rill.runtime.v1.FieldSelector.selector
   */
  selector: {
    /**
     * Select all fields.
     *
     * @generated from field: bool all = 2;
     */
    value: boolean;
    case: "all";
  } | {
    /**
     * Select specific fields by name.
     *
     * @generated from field: rill.runtime.v1.StringListValue fields = 3;
     */
    value: StringListValue;
    case: "fields";
  } | {
    /**
     * Select fields by a regular expression.
     *
     * @generated from field: string regex = 4;
     */
    value: string;
    case: "regex";
  } | {
    /**
     * Select fields by a DuckDB SQL SELECT expression. For example "* EXCLUDE (city)".
     *
     * @generated from field: string duckdb_expression = 5;
     */
    value: string;
    case: "duckdbExpression";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<FieldSelector>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "rill.runtime.v1.FieldSelector";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "invert", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 2, name: "all", kind: "scalar", T: 8 /* ScalarType.BOOL */, oneof: "selector" },
    { no: 3, name: "fields", kind: "message", T: StringListValue, oneof: "selector" },
    { no: 4, name: "regex", kind: "scalar", T: 9 /* ScalarType.STRING */, oneof: "selector" },
    { no: 5, name: "duckdb_expression", kind: "scalar", T: 9 /* ScalarType.STRING */, oneof: "selector" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): FieldSelector {
    return new FieldSelector().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): FieldSelector {
    return new FieldSelector().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): FieldSelector {
    return new FieldSelector().fromJsonString(jsonString, options);
  }

  static equals(a: FieldSelector | PlainMessage<FieldSelector> | undefined, b: FieldSelector | PlainMessage<FieldSelector> | undefined): boolean {
    return proto3.util.equals(FieldSelector, a, b);
  }
}

/**
 * @generated from message rill.runtime.v1.StringListValue
 */
export class StringListValue extends Message<StringListValue> {
  /**
   * @generated from field: repeated string values = 1;
   */
  values: string[] = [];

  constructor(data?: PartialMessage<StringListValue>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "rill.runtime.v1.StringListValue";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "values", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): StringListValue {
    return new StringListValue().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): StringListValue {
    return new StringListValue().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): StringListValue {
    return new StringListValue().fromJsonString(jsonString, options);
  }

  static equals(a: StringListValue | PlainMessage<StringListValue> | undefined, b: StringListValue | PlainMessage<StringListValue> | undefined): boolean {
    return proto3.util.equals(StringListValue, a, b);
  }
}

/**
 * @generated from message rill.runtime.v1.Migration
 */
export class Migration extends Message<Migration> {
  /**
   * @generated from field: rill.runtime.v1.MigrationSpec spec = 1;
   */
  spec?: MigrationSpec;

  /**
   * @generated from field: rill.runtime.v1.MigrationState state = 2;
   */
  state?: MigrationState;

  constructor(data?: PartialMessage<Migration>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "rill.runtime.v1.Migration";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "spec", kind: "message", T: MigrationSpec },
    { no: 2, name: "state", kind: "message", T: MigrationState },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Migration {
    return new Migration().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Migration {
    return new Migration().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Migration {
    return new Migration().fromJsonString(jsonString, options);
  }

  static equals(a: Migration | PlainMessage<Migration> | undefined, b: Migration | PlainMessage<Migration> | undefined): boolean {
    return proto3.util.equals(Migration, a, b);
  }
}

/**
 * @generated from message rill.runtime.v1.MigrationSpec
 */
export class MigrationSpec extends Message<MigrationSpec> {
  /**
   * @generated from field: string connector = 1;
   */
  connector = "";

  /**
   * @generated from field: string sql = 2;
   */
  sql = "";

  /**
   * @generated from field: uint32 version = 3;
   */
  version = 0;

  constructor(data?: PartialMessage<MigrationSpec>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "rill.runtime.v1.MigrationSpec";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "connector", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "sql", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "version", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MigrationSpec {
    return new MigrationSpec().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MigrationSpec {
    return new MigrationSpec().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MigrationSpec {
    return new MigrationSpec().fromJsonString(jsonString, options);
  }

  static equals(a: MigrationSpec | PlainMessage<MigrationSpec> | undefined, b: MigrationSpec | PlainMessage<MigrationSpec> | undefined): boolean {
    return proto3.util.equals(MigrationSpec, a, b);
  }
}

/**
 * @generated from message rill.runtime.v1.MigrationState
 */
export class MigrationState extends Message<MigrationState> {
  /**
   * @generated from field: uint32 version = 1;
   */
  version = 0;

  constructor(data?: PartialMessage<MigrationState>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "rill.runtime.v1.MigrationState";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "version", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MigrationState {
    return new MigrationState().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MigrationState {
    return new MigrationState().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MigrationState {
    return new MigrationState().fromJsonString(jsonString, options);
  }

  static equals(a: MigrationState | PlainMessage<MigrationState> | undefined, b: MigrationState | PlainMessage<MigrationState> | undefined): boolean {
    return proto3.util.equals(MigrationState, a, b);
  }
}

/**
 * @generated from message rill.runtime.v1.Report
 */
export class Report extends Message<Report> {
  /**
   * @generated from field: rill.runtime.v1.ReportSpec spec = 1;
   */
  spec?: ReportSpec;

  /**
   * @generated from field: rill.runtime.v1.ReportState state = 2;
   */
  state?: ReportState;

  constructor(data?: PartialMessage<Report>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "rill.runtime.v1.Report";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "spec", kind: "message", T: ReportSpec },
    { no: 2, name: "state", kind: "message", T: ReportState },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Report {
    return new Report().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Report {
    return new Report().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Report {
    return new Report().fromJsonString(jsonString, options);
  }

  static equals(a: Report | PlainMessage<Report> | undefined, b: Report | PlainMessage<Report> | undefined): boolean {
    return proto3.util.equals(Report, a, b);
  }
}

/**
 * @generated from message rill.runtime.v1.ReportSpec
 */
export class ReportSpec extends Message<ReportSpec> {
  /**
   * @generated from field: string display_name = 2;
   */
  displayName = "";

  /**
   * @generated from field: bool trigger = 1;
   */
  trigger = false;

  /**
   * @generated from field: rill.runtime.v1.Schedule refresh_schedule = 3;
   */
  refreshSchedule?: Schedule;

  /**
   * @generated from field: uint32 timeout_seconds = 4;
   */
  timeoutSeconds = 0;

  /**
   * @generated from field: string query_name = 5;
   */
  queryName = "";

  /**
   * @generated from field: string query_args_json = 6;
   */
  queryArgsJson = "";

  /**
   * @generated from field: uint64 export_limit = 7;
   */
  exportLimit = protoInt64.zero;

  /**
   * @generated from field: rill.runtime.v1.ExportFormat export_format = 8;
   */
  exportFormat = ExportFormat.UNSPECIFIED;

  /**
   * @generated from field: bool export_include_header = 16;
   */
  exportIncludeHeader = false;

  /**
   * @generated from field: repeated rill.runtime.v1.Notifier notifiers = 11;
   */
  notifiers: Notifier[] = [];

  /**
   * @generated from field: map<string, string> annotations = 10;
   */
  annotations: { [key: string]: string } = {};

  /**
   * If true, will use the lowest watermark of its refs instead of the trigger time.
   *
   * @generated from field: bool watermark_inherit = 12;
   */
  watermarkInherit = false;

  /**
   * @generated from field: string intervals_iso_duration = 13;
   */
  intervalsIsoDuration = "";

  /**
   * @generated from field: int32 intervals_limit = 14;
   */
  intervalsLimit = 0;

  /**
   * @generated from field: bool intervals_check_unclosed = 15;
   */
  intervalsCheckUnclosed = false;

  constructor(data?: PartialMessage<ReportSpec>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "rill.runtime.v1.ReportSpec";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 2, name: "display_name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 1, name: "trigger", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 3, name: "refresh_schedule", kind: "message", T: Schedule },
    { no: 4, name: "timeout_seconds", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 5, name: "query_name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 6, name: "query_args_json", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 7, name: "export_limit", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 8, name: "export_format", kind: "enum", T: proto3.getEnumType(ExportFormat) },
    { no: 16, name: "export_include_header", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 11, name: "notifiers", kind: "message", T: Notifier, repeated: true },
    { no: 10, name: "annotations", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "scalar", T: 9 /* ScalarType.STRING */} },
    { no: 12, name: "watermark_inherit", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 13, name: "intervals_iso_duration", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 14, name: "intervals_limit", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 15, name: "intervals_check_unclosed", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ReportSpec {
    return new ReportSpec().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ReportSpec {
    return new ReportSpec().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ReportSpec {
    return new ReportSpec().fromJsonString(jsonString, options);
  }

  static equals(a: ReportSpec | PlainMessage<ReportSpec> | undefined, b: ReportSpec | PlainMessage<ReportSpec> | undefined): boolean {
    return proto3.util.equals(ReportSpec, a, b);
  }
}

/**
 * @generated from message rill.runtime.v1.ReportState
 */
export class ReportState extends Message<ReportState> {
  /**
   * @generated from field: google.protobuf.Timestamp next_run_on = 1;
   */
  nextRunOn?: Timestamp;

  /**
   * @generated from field: rill.runtime.v1.ReportExecution current_execution = 2;
   */
  currentExecution?: ReportExecution;

  /**
   * @generated from field: repeated rill.runtime.v1.ReportExecution execution_history = 3;
   */
  executionHistory: ReportExecution[] = [];

  /**
   * @generated from field: uint32 execution_count = 4;
   */
  executionCount = 0;

  constructor(data?: PartialMessage<ReportState>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "rill.runtime.v1.ReportState";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "next_run_on", kind: "message", T: Timestamp },
    { no: 2, name: "current_execution", kind: "message", T: ReportExecution },
    { no: 3, name: "execution_history", kind: "message", T: ReportExecution, repeated: true },
    { no: 4, name: "execution_count", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ReportState {
    return new ReportState().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ReportState {
    return new ReportState().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ReportState {
    return new ReportState().fromJsonString(jsonString, options);
  }

  static equals(a: ReportState | PlainMessage<ReportState> | undefined, b: ReportState | PlainMessage<ReportState> | undefined): boolean {
    return proto3.util.equals(ReportState, a, b);
  }
}

/**
 * @generated from message rill.runtime.v1.ReportExecution
 */
export class ReportExecution extends Message<ReportExecution> {
  /**
   * @generated from field: bool adhoc = 1;
   */
  adhoc = false;

  /**
   * @generated from field: string error_message = 2;
   */
  errorMessage = "";

  /**
   * @generated from field: google.protobuf.Timestamp report_time = 3;
   */
  reportTime?: Timestamp;

  /**
   * @generated from field: google.protobuf.Timestamp started_on = 4;
   */
  startedOn?: Timestamp;

  /**
   * @generated from field: google.protobuf.Timestamp finished_on = 5;
   */
  finishedOn?: Timestamp;

  constructor(data?: PartialMessage<ReportExecution>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "rill.runtime.v1.ReportExecution";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "adhoc", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 2, name: "error_message", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "report_time", kind: "message", T: Timestamp },
    { no: 4, name: "started_on", kind: "message", T: Timestamp },
    { no: 5, name: "finished_on", kind: "message", T: Timestamp },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ReportExecution {
    return new ReportExecution().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ReportExecution {
    return new ReportExecution().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ReportExecution {
    return new ReportExecution().fromJsonString(jsonString, options);
  }

  static equals(a: ReportExecution | PlainMessage<ReportExecution> | undefined, b: ReportExecution | PlainMessage<ReportExecution> | undefined): boolean {
    return proto3.util.equals(ReportExecution, a, b);
  }
}

/**
 * @generated from message rill.runtime.v1.Alert
 */
export class Alert extends Message<Alert> {
  /**
   * @generated from field: rill.runtime.v1.AlertSpec spec = 1;
   */
  spec?: AlertSpec;

  /**
   * @generated from field: rill.runtime.v1.AlertState state = 2;
   */
  state?: AlertState;

  constructor(data?: PartialMessage<Alert>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "rill.runtime.v1.Alert";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "spec", kind: "message", T: AlertSpec },
    { no: 2, name: "state", kind: "message", T: AlertState },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Alert {
    return new Alert().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Alert {
    return new Alert().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Alert {
    return new Alert().fromJsonString(jsonString, options);
  }

  static equals(a: Alert | PlainMessage<Alert> | undefined, b: Alert | PlainMessage<Alert> | undefined): boolean {
    return proto3.util.equals(Alert, a, b);
  }
}

/**
 * @generated from message rill.runtime.v1.AlertSpec
 */
export class AlertSpec extends Message<AlertSpec> {
  /**
   * @generated from field: string display_name = 2;
   */
  displayName = "";

  /**
   * @generated from field: bool trigger = 1;
   */
  trigger = false;

  /**
   * @generated from field: rill.runtime.v1.Schedule refresh_schedule = 3;
   */
  refreshSchedule?: Schedule;

  /**
   * If true, will use the lowest watermark of its refs instead of the trigger time.
   *
   * @generated from field: bool watermark_inherit = 4;
   */
  watermarkInherit = false;

  /**
   * @generated from field: string intervals_iso_duration = 5;
   */
  intervalsIsoDuration = "";

  /**
   * @generated from field: int32 intervals_limit = 6;
   */
  intervalsLimit = 0;

  /**
   * @generated from field: bool intervals_check_unclosed = 7;
   */
  intervalsCheckUnclosed = false;

  /**
   * @generated from field: uint32 timeout_seconds = 8;
   */
  timeoutSeconds = 0;

  /**
   * for alerts that have not been edited since resolver and resolver_properties have been added
   *
   * @generated from field: string query_name = 9;
   */
  queryName = "";

  /**
   * @generated from field: string query_args_json = 10;
   */
  queryArgsJson = "";

  /**
   * @generated from field: string resolver = 22;
   */
  resolver = "";

  /**
   * @generated from field: google.protobuf.Struct resolver_properties = 23;
   */
  resolverProperties?: Struct;

  /**
   * @generated from oneof rill.runtime.v1.AlertSpec.query_for
   */
  queryFor: {
    /**
     * @generated from field: string query_for_user_id = 11;
     */
    value: string;
    case: "queryForUserId";
  } | {
    /**
     * @generated from field: string query_for_user_email = 12;
     */
    value: string;
    case: "queryForUserEmail";
  } | {
    /**
     * @generated from field: google.protobuf.Struct query_for_attributes = 13;
     */
    value: Struct;
    case: "queryForAttributes";
  } | { case: undefined; value?: undefined } = { case: undefined };

  /**
   * @generated from field: bool notify_on_recover = 15;
   */
  notifyOnRecover = false;

  /**
   * @generated from field: bool notify_on_fail = 16;
   */
  notifyOnFail = false;

  /**
   * @generated from field: bool notify_on_error = 17;
   */
  notifyOnError = false;

  /**
   * @generated from field: bool renotify = 18;
   */
  renotify = false;

  /**
   * @generated from field: uint32 renotify_after_seconds = 19;
   */
  renotifyAfterSeconds = 0;

  /**
   * @generated from field: repeated rill.runtime.v1.Notifier notifiers = 21;
   */
  notifiers: Notifier[] = [];

  /**
   * @generated from field: map<string, string> annotations = 20;
   */
  annotations: { [key: string]: string } = {};

  constructor(data?: PartialMessage<AlertSpec>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "rill.runtime.v1.AlertSpec";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 2, name: "display_name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 1, name: "trigger", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 3, name: "refresh_schedule", kind: "message", T: Schedule },
    { no: 4, name: "watermark_inherit", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 5, name: "intervals_iso_duration", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 6, name: "intervals_limit", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 7, name: "intervals_check_unclosed", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 8, name: "timeout_seconds", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 9, name: "query_name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 10, name: "query_args_json", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 22, name: "resolver", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 23, name: "resolver_properties", kind: "message", T: Struct },
    { no: 11, name: "query_for_user_id", kind: "scalar", T: 9 /* ScalarType.STRING */, oneof: "query_for" },
    { no: 12, name: "query_for_user_email", kind: "scalar", T: 9 /* ScalarType.STRING */, oneof: "query_for" },
    { no: 13, name: "query_for_attributes", kind: "message", T: Struct, oneof: "query_for" },
    { no: 15, name: "notify_on_recover", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 16, name: "notify_on_fail", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 17, name: "notify_on_error", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 18, name: "renotify", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 19, name: "renotify_after_seconds", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 21, name: "notifiers", kind: "message", T: Notifier, repeated: true },
    { no: 20, name: "annotations", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "scalar", T: 9 /* ScalarType.STRING */} },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AlertSpec {
    return new AlertSpec().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AlertSpec {
    return new AlertSpec().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AlertSpec {
    return new AlertSpec().fromJsonString(jsonString, options);
  }

  static equals(a: AlertSpec | PlainMessage<AlertSpec> | undefined, b: AlertSpec | PlainMessage<AlertSpec> | undefined): boolean {
    return proto3.util.equals(AlertSpec, a, b);
  }
}

/**
 * @generated from message rill.runtime.v1.Notifier
 */
export class Notifier extends Message<Notifier> {
  /**
   * @generated from field: string connector = 1;
   */
  connector = "";

  /**
   * @generated from field: google.protobuf.Struct properties = 2;
   */
  properties?: Struct;

  constructor(data?: PartialMessage<Notifier>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "rill.runtime.v1.Notifier";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "connector", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "properties", kind: "message", T: Struct },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Notifier {
    return new Notifier().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Notifier {
    return new Notifier().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Notifier {
    return new Notifier().fromJsonString(jsonString, options);
  }

  static equals(a: Notifier | PlainMessage<Notifier> | undefined, b: Notifier | PlainMessage<Notifier> | undefined): boolean {
    return proto3.util.equals(Notifier, a, b);
  }
}

/**
 * @generated from message rill.runtime.v1.AlertState
 */
export class AlertState extends Message<AlertState> {
  /**
   * @generated from field: string spec_hash = 1;
   */
  specHash = "";

  /**
   * @generated from field: string refs_hash = 2;
   */
  refsHash = "";

  /**
   * @generated from field: google.protobuf.Timestamp next_run_on = 3;
   */
  nextRunOn?: Timestamp;

  /**
   * @generated from field: rill.runtime.v1.AlertExecution current_execution = 4;
   */
  currentExecution?: AlertExecution;

  /**
   * @generated from field: repeated rill.runtime.v1.AlertExecution execution_history = 5;
   */
  executionHistory: AlertExecution[] = [];

  /**
   * @generated from field: uint32 execution_count = 6;
   */
  executionCount = 0;

  constructor(data?: PartialMessage<AlertState>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "rill.runtime.v1.AlertState";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "spec_hash", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "refs_hash", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "next_run_on", kind: "message", T: Timestamp },
    { no: 4, name: "current_execution", kind: "message", T: AlertExecution },
    { no: 5, name: "execution_history", kind: "message", T: AlertExecution, repeated: true },
    { no: 6, name: "execution_count", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AlertState {
    return new AlertState().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AlertState {
    return new AlertState().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AlertState {
    return new AlertState().fromJsonString(jsonString, options);
  }

  static equals(a: AlertState | PlainMessage<AlertState> | undefined, b: AlertState | PlainMessage<AlertState> | undefined): boolean {
    return proto3.util.equals(AlertState, a, b);
  }
}

/**
 * @generated from message rill.runtime.v1.AlertExecution
 */
export class AlertExecution extends Message<AlertExecution> {
  /**
   * @generated from field: bool adhoc = 1;
   */
  adhoc = false;

  /**
   * @generated from field: rill.runtime.v1.AssertionResult result = 2;
   */
  result?: AssertionResult;

  /**
   * @generated from field: bool sent_notifications = 3;
   */
  sentNotifications = false;

  /**
   * @generated from field: google.protobuf.Timestamp execution_time = 4;
   */
  executionTime?: Timestamp;

  /**
   * @generated from field: google.protobuf.Timestamp started_on = 5;
   */
  startedOn?: Timestamp;

  /**
   * @generated from field: google.protobuf.Timestamp finished_on = 6;
   */
  finishedOn?: Timestamp;

  /**
   * Stores the last notification time in suppressed alerts
   *
   * @generated from field: google.protobuf.Timestamp suppressed_since = 7;
   */
  suppressedSince?: Timestamp;

  constructor(data?: PartialMessage<AlertExecution>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "rill.runtime.v1.AlertExecution";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "adhoc", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 2, name: "result", kind: "message", T: AssertionResult },
    { no: 3, name: "sent_notifications", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 4, name: "execution_time", kind: "message", T: Timestamp },
    { no: 5, name: "started_on", kind: "message", T: Timestamp },
    { no: 6, name: "finished_on", kind: "message", T: Timestamp },
    { no: 7, name: "suppressed_since", kind: "message", T: Timestamp },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AlertExecution {
    return new AlertExecution().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AlertExecution {
    return new AlertExecution().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AlertExecution {
    return new AlertExecution().fromJsonString(jsonString, options);
  }

  static equals(a: AlertExecution | PlainMessage<AlertExecution> | undefined, b: AlertExecution | PlainMessage<AlertExecution> | undefined): boolean {
    return proto3.util.equals(AlertExecution, a, b);
  }
}

/**
 * @generated from message rill.runtime.v1.AssertionResult
 */
export class AssertionResult extends Message<AssertionResult> {
  /**
   * @generated from field: rill.runtime.v1.AssertionStatus status = 1;
   */
  status = AssertionStatus.UNSPECIFIED;

  /**
   * @generated from field: google.protobuf.Struct fail_row = 2;
   */
  failRow?: Struct;

  /**
   * @generated from field: string error_message = 3;
   */
  errorMessage = "";

  constructor(data?: PartialMessage<AssertionResult>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "rill.runtime.v1.AssertionResult";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "status", kind: "enum", T: proto3.getEnumType(AssertionStatus) },
    { no: 2, name: "fail_row", kind: "message", T: Struct },
    { no: 3, name: "error_message", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AssertionResult {
    return new AssertionResult().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AssertionResult {
    return new AssertionResult().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AssertionResult {
    return new AssertionResult().fromJsonString(jsonString, options);
  }

  static equals(a: AssertionResult | PlainMessage<AssertionResult> | undefined, b: AssertionResult | PlainMessage<AssertionResult> | undefined): boolean {
    return proto3.util.equals(AssertionResult, a, b);
  }
}

/**
 * @generated from message rill.runtime.v1.RefreshTrigger
 */
export class RefreshTrigger extends Message<RefreshTrigger> {
  /**
   * @generated from field: rill.runtime.v1.RefreshTriggerSpec spec = 1;
   */
  spec?: RefreshTriggerSpec;

  /**
   * @generated from field: rill.runtime.v1.RefreshTriggerState state = 2;
   */
  state?: RefreshTriggerState;

  constructor(data?: PartialMessage<RefreshTrigger>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "rill.runtime.v1.RefreshTrigger";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "spec", kind: "message", T: RefreshTriggerSpec },
    { no: 2, name: "state", kind: "message", T: RefreshTriggerState },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RefreshTrigger {
    return new RefreshTrigger().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RefreshTrigger {
    return new RefreshTrigger().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RefreshTrigger {
    return new RefreshTrigger().fromJsonString(jsonString, options);
  }

  static equals(a: RefreshTrigger | PlainMessage<RefreshTrigger> | undefined, b: RefreshTrigger | PlainMessage<RefreshTrigger> | undefined): boolean {
    return proto3.util.equals(RefreshTrigger, a, b);
  }
}

/**
 * @generated from message rill.runtime.v1.RefreshTriggerSpec
 */
export class RefreshTriggerSpec extends Message<RefreshTriggerSpec> {
  /**
   * Resources to refresh. The refreshable types are sources, models, alerts, reports, and the project parser.
   * If a model is specified, a normal incremental refresh is triggered. Use the "models" field to trigger other kinds of model refreshes.
   *
   * @generated from field: repeated rill.runtime.v1.ResourceName resources = 1;
   */
  resources: ResourceName[] = [];

  /**
   * Models to refresh. These are specified separately to enable more fine-grained configuration.
   *
   * @generated from field: repeated rill.runtime.v1.RefreshModelTrigger models = 2;
   */
  models: RefreshModelTrigger[] = [];

  constructor(data?: PartialMessage<RefreshTriggerSpec>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "rill.runtime.v1.RefreshTriggerSpec";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "resources", kind: "message", T: ResourceName, repeated: true },
    { no: 2, name: "models", kind: "message", T: RefreshModelTrigger, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RefreshTriggerSpec {
    return new RefreshTriggerSpec().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RefreshTriggerSpec {
    return new RefreshTriggerSpec().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RefreshTriggerSpec {
    return new RefreshTriggerSpec().fromJsonString(jsonString, options);
  }

  static equals(a: RefreshTriggerSpec | PlainMessage<RefreshTriggerSpec> | undefined, b: RefreshTriggerSpec | PlainMessage<RefreshTriggerSpec> | undefined): boolean {
    return proto3.util.equals(RefreshTriggerSpec, a, b);
  }
}

/**
 * @generated from message rill.runtime.v1.RefreshTriggerState
 */
export class RefreshTriggerState extends Message<RefreshTriggerState> {
  constructor(data?: PartialMessage<RefreshTriggerState>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "rill.runtime.v1.RefreshTriggerState";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RefreshTriggerState {
    return new RefreshTriggerState().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RefreshTriggerState {
    return new RefreshTriggerState().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RefreshTriggerState {
    return new RefreshTriggerState().fromJsonString(jsonString, options);
  }

  static equals(a: RefreshTriggerState | PlainMessage<RefreshTriggerState> | undefined, b: RefreshTriggerState | PlainMessage<RefreshTriggerState> | undefined): boolean {
    return proto3.util.equals(RefreshTriggerState, a, b);
  }
}

/**
 * @generated from message rill.runtime.v1.RefreshModelTrigger
 */
export class RefreshModelTrigger extends Message<RefreshModelTrigger> {
  /**
   * The model to refresh.
   *
   * @generated from field: string model = 1;
   */
  model = "";

  /**
   * If true, the current table and state will be dropped before refreshing.
   * For non-incremental models, this is equivalent to a normal refresh.
   *
   * @generated from field: bool full = 2;
   */
  full = false;

  /**
   * Keys of specific partitions to refresh.
   *
   * @generated from field: repeated string partitions = 3;
   */
  partitions: string[] = [];

  /**
   * If true, it will refresh all partitions that errored on their last execution.
   *
   * @generated from field: bool all_errored_partitions = 4;
   */
  allErroredPartitions = false;

  constructor(data?: PartialMessage<RefreshModelTrigger>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "rill.runtime.v1.RefreshModelTrigger";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "model", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "full", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 3, name: "partitions", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 4, name: "all_errored_partitions", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RefreshModelTrigger {
    return new RefreshModelTrigger().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RefreshModelTrigger {
    return new RefreshModelTrigger().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RefreshModelTrigger {
    return new RefreshModelTrigger().fromJsonString(jsonString, options);
  }

  static equals(a: RefreshModelTrigger | PlainMessage<RefreshModelTrigger> | undefined, b: RefreshModelTrigger | PlainMessage<RefreshModelTrigger> | undefined): boolean {
    return proto3.util.equals(RefreshModelTrigger, a, b);
  }
}

/**
 * @generated from message rill.runtime.v1.Theme
 */
export class Theme extends Message<Theme> {
  /**
   * @generated from field: rill.runtime.v1.ThemeSpec spec = 1;
   */
  spec?: ThemeSpec;

  /**
   * @generated from field: rill.runtime.v1.ThemeState state = 2;
   */
  state?: ThemeState;

  constructor(data?: PartialMessage<Theme>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "rill.runtime.v1.Theme";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "spec", kind: "message", T: ThemeSpec },
    { no: 2, name: "state", kind: "message", T: ThemeState },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Theme {
    return new Theme().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Theme {
    return new Theme().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Theme {
    return new Theme().fromJsonString(jsonString, options);
  }

  static equals(a: Theme | PlainMessage<Theme> | undefined, b: Theme | PlainMessage<Theme> | undefined): boolean {
    return proto3.util.equals(Theme, a, b);
  }
}

/**
 * @generated from message rill.runtime.v1.ThemeSpec
 */
export class ThemeSpec extends Message<ThemeSpec> {
  /**
   * @generated from field: optional rill.runtime.v1.Color primary_color = 1;
   */
  primaryColor?: Color;

  /**
   * @generated from field: optional rill.runtime.v1.Color secondary_color = 2;
   */
  secondaryColor?: Color;

  /**
   * @generated from field: string primary_color_raw = 3;
   */
  primaryColorRaw = "";

  /**
   * @generated from field: string secondary_color_raw = 4;
   */
  secondaryColorRaw = "";

  /**
   * @generated from field: optional rill.runtime.v1.ThemeColors light = 5;
   */
  light?: ThemeColors;

  /**
   * @generated from field: optional rill.runtime.v1.ThemeColors dark = 6;
   */
  dark?: ThemeColors;

  constructor(data?: PartialMessage<ThemeSpec>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "rill.runtime.v1.ThemeSpec";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "primary_color", kind: "message", T: Color, opt: true },
    { no: 2, name: "secondary_color", kind: "message", T: Color, opt: true },
    { no: 3, name: "primary_color_raw", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "secondary_color_raw", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "light", kind: "message", T: ThemeColors, opt: true },
    { no: 6, name: "dark", kind: "message", T: ThemeColors, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ThemeSpec {
    return new ThemeSpec().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ThemeSpec {
    return new ThemeSpec().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ThemeSpec {
    return new ThemeSpec().fromJsonString(jsonString, options);
  }

  static equals(a: ThemeSpec | PlainMessage<ThemeSpec> | undefined, b: ThemeSpec | PlainMessage<ThemeSpec> | undefined): boolean {
    return proto3.util.equals(ThemeSpec, a, b);
  }
}

/**
 * @generated from message rill.runtime.v1.ThemeState
 */
export class ThemeState extends Message<ThemeState> {
  constructor(data?: PartialMessage<ThemeState>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "rill.runtime.v1.ThemeState";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ThemeState {
    return new ThemeState().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ThemeState {
    return new ThemeState().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ThemeState {
    return new ThemeState().fromJsonString(jsonString, options);
  }

  static equals(a: ThemeState | PlainMessage<ThemeState> | undefined, b: ThemeState | PlainMessage<ThemeState> | undefined): boolean {
    return proto3.util.equals(ThemeState, a, b);
  }
}

/**
 * @generated from message rill.runtime.v1.ThemeColors
 */
export class ThemeColors extends Message<ThemeColors> {
  /**
   * @generated from field: string primary = 1;
   */
  primary = "";

  /**
   * @generated from field: string secondary = 2;
   */
  secondary = "";

  /**
   * @generated from field: map<string, string> variables = 3;
   */
  variables: { [key: string]: string } = {};

  constructor(data?: PartialMessage<ThemeColors>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "rill.runtime.v1.ThemeColors";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "primary", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "secondary", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "variables", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "scalar", T: 9 /* ScalarType.STRING */} },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ThemeColors {
    return new ThemeColors().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ThemeColors {
    return new ThemeColors().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ThemeColors {
    return new ThemeColors().fromJsonString(jsonString, options);
  }

  static equals(a: ThemeColors | PlainMessage<ThemeColors> | undefined, b: ThemeColors | PlainMessage<ThemeColors> | undefined): boolean {
    return proto3.util.equals(ThemeColors, a, b);
  }
}

/**
 * @generated from message rill.runtime.v1.Component
 */
export class Component extends Message<Component> {
  /**
   * @generated from field: rill.runtime.v1.ComponentSpec spec = 1;
   */
  spec?: ComponentSpec;

  /**
   * @generated from field: rill.runtime.v1.ComponentState state = 2;
   */
  state?: ComponentState;

  constructor(data?: PartialMessage<Component>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "rill.runtime.v1.Component";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "spec", kind: "message", T: ComponentSpec },
    { no: 2, name: "state", kind: "message", T: ComponentState },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Component {
    return new Component().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Component {
    return new Component().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Component {
    return new Component().fromJsonString(jsonString, options);
  }

  static equals(a: Component | PlainMessage<Component> | undefined, b: Component | PlainMessage<Component> | undefined): boolean {
    return proto3.util.equals(Component, a, b);
  }
}

/**
 * @generated from message rill.runtime.v1.ComponentSpec
 */
export class ComponentSpec extends Message<ComponentSpec> {
  /**
   * @generated from field: string display_name = 1;
   */
  displayName = "";

  /**
   * @generated from field: string description = 7;
   */
  description = "";

  /**
   * @generated from field: string renderer = 4;
   */
  renderer = "";

  /**
   * @generated from field: google.protobuf.Struct renderer_properties = 5;
   */
  rendererProperties?: Struct;

  /**
   * @generated from field: repeated rill.runtime.v1.ComponentVariable input = 8;
   */
  input: ComponentVariable[] = [];

  /**
   * @generated from field: rill.runtime.v1.ComponentVariable output = 9;
   */
  output?: ComponentVariable;

  /**
   * @generated from field: bool defined_in_canvas = 6;
   */
  definedInCanvas = false;

  constructor(data?: PartialMessage<ComponentSpec>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "rill.runtime.v1.ComponentSpec";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "display_name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 7, name: "description", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "renderer", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "renderer_properties", kind: "message", T: Struct },
    { no: 8, name: "input", kind: "message", T: ComponentVariable, repeated: true },
    { no: 9, name: "output", kind: "message", T: ComponentVariable },
    { no: 6, name: "defined_in_canvas", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ComponentSpec {
    return new ComponentSpec().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ComponentSpec {
    return new ComponentSpec().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ComponentSpec {
    return new ComponentSpec().fromJsonString(jsonString, options);
  }

  static equals(a: ComponentSpec | PlainMessage<ComponentSpec> | undefined, b: ComponentSpec | PlainMessage<ComponentSpec> | undefined): boolean {
    return proto3.util.equals(ComponentSpec, a, b);
  }
}

/**
 * @generated from message rill.runtime.v1.ComponentState
 */
export class ComponentState extends Message<ComponentState> {
  /**
   * Valid spec is a (potentially previous) version of the component's spec that is known to be valid.
   *
   * @generated from field: rill.runtime.v1.ComponentSpec valid_spec = 1;
   */
  validSpec?: ComponentSpec;

  /**
   * The last time any underlying metrics view(s)'s data was refreshed.
   * This may be empty if the data refresh time is not known, e.g. if the metrics view is based on an externally managed table.
   *
   * @generated from field: google.protobuf.Timestamp data_refreshed_on = 2;
   */
  dataRefreshedOn?: Timestamp;

  constructor(data?: PartialMessage<ComponentState>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "rill.runtime.v1.ComponentState";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "valid_spec", kind: "message", T: ComponentSpec },
    { no: 2, name: "data_refreshed_on", kind: "message", T: Timestamp },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ComponentState {
    return new ComponentState().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ComponentState {
    return new ComponentState().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ComponentState {
    return new ComponentState().fromJsonString(jsonString, options);
  }

  static equals(a: ComponentState | PlainMessage<ComponentState> | undefined, b: ComponentState | PlainMessage<ComponentState> | undefined): boolean {
    return proto3.util.equals(ComponentState, a, b);
  }
}

/**
 * @generated from message rill.runtime.v1.ComponentVariable
 */
export class ComponentVariable extends Message<ComponentVariable> {
  /**
   * @generated from field: string name = 1;
   */
  name = "";

  /**
   * @generated from field: string type = 2;
   */
  type = "";

  /**
   * @generated from field: google.protobuf.Value default_value = 3;
   */
  defaultValue?: Value;

  constructor(data?: PartialMessage<ComponentVariable>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "rill.runtime.v1.ComponentVariable";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "type", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "default_value", kind: "message", T: Value },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ComponentVariable {
    return new ComponentVariable().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ComponentVariable {
    return new ComponentVariable().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ComponentVariable {
    return new ComponentVariable().fromJsonString(jsonString, options);
  }

  static equals(a: ComponentVariable | PlainMessage<ComponentVariable> | undefined, b: ComponentVariable | PlainMessage<ComponentVariable> | undefined): boolean {
    return proto3.util.equals(ComponentVariable, a, b);
  }
}

/**
 * @generated from message rill.runtime.v1.Canvas
 */
export class Canvas extends Message<Canvas> {
  /**
   * @generated from field: rill.runtime.v1.CanvasSpec spec = 1;
   */
  spec?: CanvasSpec;

  /**
   * @generated from field: rill.runtime.v1.CanvasState state = 2;
   */
  state?: CanvasState;

  constructor(data?: PartialMessage<Canvas>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "rill.runtime.v1.Canvas";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "spec", kind: "message", T: CanvasSpec },
    { no: 2, name: "state", kind: "message", T: CanvasState },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Canvas {
    return new Canvas().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Canvas {
    return new Canvas().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Canvas {
    return new Canvas().fromJsonString(jsonString, options);
  }

  static equals(a: Canvas | PlainMessage<Canvas> | undefined, b: Canvas | PlainMessage<Canvas> | undefined): boolean {
    return proto3.util.equals(Canvas, a, b);
  }
}

/**
 * @generated from message rill.runtime.v1.CanvasSpec
 */
export class CanvasSpec extends Message<CanvasSpec> {
  /**
   * Display name for the canvas.
   *
   * @generated from field: string display_name = 1;
   */
  displayName = "";

  /**
   * Banner text that can be displayed in Rill Cloud.
   *
   * @generated from field: string banner = 17;
   */
  banner = "";

  /**
   * Max width in pixels of the canvas.
   *
   * @generated from field: uint32 max_width = 2;
   */
  maxWidth = 0;

  /**
   * Horizontal gap in pixels of the canvas.
   *
   * @generated from field: uint32 gap_x = 9;
   */
  gapX = 0;

  /**
   * Vertical gap in pixels of the canvas.
   *
   * @generated from field: uint32 gap_y = 10;
   */
  gapY = 0;

  /**
   * Name of the theme to use. Only one of theme and embedded_theme can be set.
   *
   * @generated from field: string theme = 7;
   */
  theme = "";

  /**
   * Theme to use, provided inline. Only one of theme and embedded_theme can be set.
   *
   * @generated from field: rill.runtime.v1.ThemeSpec embedded_theme = 8;
   */
  embeddedTheme?: ThemeSpec;

  /**
   * List of selectable time ranges with comparison time ranges.
   * If the list is empty, a default list should be shown.
   * TODO: Once the canvas APIs have stabilized, rename ExploreTimeRange to a non-explore-specific name.
   *
   * @generated from field: repeated rill.runtime.v1.ExploreTimeRange time_ranges = 11;
   */
  timeRanges: ExploreTimeRange[] = [];

  /**
   * Toggle custom time range
   *
   * @generated from field: bool allow_custom_time_range = 14;
   */
  allowCustomTimeRange = false;

  /**
   * List of selectable time zones.
   * If the list is empty, a default list should be shown.
   * The values should be valid IANA location identifiers.
   *
   * @generated from field: repeated string time_zones = 12;
   */
  timeZones: string[] = [];

  /**
   * Indicates if filters should be enabled for the canvas.
   *
   * @generated from field: bool filters_enabled = 13;
   */
  filtersEnabled = false;

  /**
   * Preset UI state to show by default.
   *
   * @generated from field: rill.runtime.v1.CanvasPreset default_preset = 15;
   */
  defaultPreset?: CanvasPreset;

  /**
   * Variables that can be used in the canvas.
   *
   * @generated from field: repeated rill.runtime.v1.ComponentVariable variables = 5;
   */
  variables: ComponentVariable[] = [];

  /**
   * Rows to render on the canvas
   *
   * @generated from field: repeated rill.runtime.v1.CanvasRow rows = 18;
   */
  rows: CanvasRow[] = [];

  /**
   * Security rules to apply for access to the canvas.
   *
   * @generated from field: repeated rill.runtime.v1.SecurityRule security_rules = 6;
   */
  securityRules: SecurityRule[] = [];

  constructor(data?: PartialMessage<CanvasSpec>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "rill.runtime.v1.CanvasSpec";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "display_name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 17, name: "banner", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "max_width", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 9, name: "gap_x", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 10, name: "gap_y", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 7, name: "theme", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 8, name: "embedded_theme", kind: "message", T: ThemeSpec },
    { no: 11, name: "time_ranges", kind: "message", T: ExploreTimeRange, repeated: true },
    { no: 14, name: "allow_custom_time_range", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 12, name: "time_zones", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 13, name: "filters_enabled", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 15, name: "default_preset", kind: "message", T: CanvasPreset },
    { no: 5, name: "variables", kind: "message", T: ComponentVariable, repeated: true },
    { no: 18, name: "rows", kind: "message", T: CanvasRow, repeated: true },
    { no: 6, name: "security_rules", kind: "message", T: SecurityRule, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CanvasSpec {
    return new CanvasSpec().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CanvasSpec {
    return new CanvasSpec().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CanvasSpec {
    return new CanvasSpec().fromJsonString(jsonString, options);
  }

  static equals(a: CanvasSpec | PlainMessage<CanvasSpec> | undefined, b: CanvasSpec | PlainMessage<CanvasSpec> | undefined): boolean {
    return proto3.util.equals(CanvasSpec, a, b);
  }
}

/**
 * @generated from message rill.runtime.v1.CanvasState
 */
export class CanvasState extends Message<CanvasState> {
  /**
   * Valid spec is a (potentially previous) version of the canvas's spec that is known to be valid.
   *
   * @generated from field: rill.runtime.v1.CanvasSpec valid_spec = 1;
   */
  validSpec?: CanvasSpec;

  /**
   * The last time any underlying metrics view(s)'s data was refreshed.
   * This may be empty if the data refresh time is not known, e.g. if the metrics view is based on an externally managed table.
   *
   * @generated from field: google.protobuf.Timestamp data_refreshed_on = 2;
   */
  dataRefreshedOn?: Timestamp;

  constructor(data?: PartialMessage<CanvasState>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "rill.runtime.v1.CanvasState";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "valid_spec", kind: "message", T: CanvasSpec },
    { no: 2, name: "data_refreshed_on", kind: "message", T: Timestamp },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CanvasState {
    return new CanvasState().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CanvasState {
    return new CanvasState().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CanvasState {
    return new CanvasState().fromJsonString(jsonString, options);
  }

  static equals(a: CanvasState | PlainMessage<CanvasState> | undefined, b: CanvasState | PlainMessage<CanvasState> | undefined): boolean {
    return proto3.util.equals(CanvasState, a, b);
  }
}

/**
 * @generated from message rill.runtime.v1.CanvasRow
 */
export class CanvasRow extends Message<CanvasRow> {
  /**
   * Height of the row. The unit is given in height_unit.
   *
   * @generated from field: optional uint32 height = 1;
   */
  height?: number;

  /**
   * Unit of the height. Current possible values: "px", empty string.
   *
   * @generated from field: string height_unit = 2;
   */
  heightUnit = "";

  /**
   * Items to render in the row.
   *
   * @generated from field: repeated rill.runtime.v1.CanvasItem items = 3;
   */
  items: CanvasItem[] = [];

  constructor(data?: PartialMessage<CanvasRow>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "rill.runtime.v1.CanvasRow";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "height", kind: "scalar", T: 13 /* ScalarType.UINT32 */, opt: true },
    { no: 2, name: "height_unit", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "items", kind: "message", T: CanvasItem, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CanvasRow {
    return new CanvasRow().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CanvasRow {
    return new CanvasRow().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CanvasRow {
    return new CanvasRow().fromJsonString(jsonString, options);
  }

  static equals(a: CanvasRow | PlainMessage<CanvasRow> | undefined, b: CanvasRow | PlainMessage<CanvasRow> | undefined): boolean {
    return proto3.util.equals(CanvasRow, a, b);
  }
}

/**
 * @generated from message rill.runtime.v1.CanvasItem
 */
export class CanvasItem extends Message<CanvasItem> {
  /**
   * Name of the component to render.
   *
   * @generated from field: string component = 1;
   */
  component = "";

  /**
   * Indicates if the component was defined inline as part of the canvas YAML.
   *
   * @generated from field: bool defined_in_canvas = 8;
   */
  definedInCanvas = false;

  /**
   * Width of the item. The unit is given in width_unit.
   *
   * @generated from field: optional uint32 width = 9;
   */
  width?: number;

  /**
   * Unit of the width. Current possible values: empty string.
   *
   * @generated from field: string width_unit = 10;
   */
  widthUnit = "";

  constructor(data?: PartialMessage<CanvasItem>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "rill.runtime.v1.CanvasItem";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "component", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 8, name: "defined_in_canvas", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 9, name: "width", kind: "scalar", T: 13 /* ScalarType.UINT32 */, opt: true },
    { no: 10, name: "width_unit", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CanvasItem {
    return new CanvasItem().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CanvasItem {
    return new CanvasItem().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CanvasItem {
    return new CanvasItem().fromJsonString(jsonString, options);
  }

  static equals(a: CanvasItem | PlainMessage<CanvasItem> | undefined, b: CanvasItem | PlainMessage<CanvasItem> | undefined): boolean {
    return proto3.util.equals(CanvasItem, a, b);
  }
}

/**
 * @generated from message rill.runtime.v1.CanvasPreset
 */
export class CanvasPreset extends Message<CanvasPreset> {
  /**
   * Time range for the explore.
   * It corresponds to the `range` property of the explore's `time_ranges`.
   * If not found in `time_ranges`, it should be added to the list.
   *
   * @generated from field: optional string time_range = 1;
   */
  timeRange?: string;

  /**
   * Comparison mode.
   * TODO: Once the canvas APIs have stabilized, rename ExploreComparisonMode to a non-explore-specific name.
   *
   * @generated from field: rill.runtime.v1.ExploreComparisonMode comparison_mode = 2;
   */
  comparisonMode = ExploreComparisonMode.UNSPECIFIED;

  /**
   * If comparison_mode is EXPLORE_COMPARISON_MODE_DIMENSION, this indicates the dimension to use.
   *
   * @generated from field: optional string comparison_dimension = 8;
   */
  comparisonDimension?: string;

  constructor(data?: PartialMessage<CanvasPreset>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "rill.runtime.v1.CanvasPreset";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "time_range", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 2, name: "comparison_mode", kind: "enum", T: proto3.getEnumType(ExploreComparisonMode) },
    { no: 8, name: "comparison_dimension", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CanvasPreset {
    return new CanvasPreset().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CanvasPreset {
    return new CanvasPreset().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CanvasPreset {
    return new CanvasPreset().fromJsonString(jsonString, options);
  }

  static equals(a: CanvasPreset | PlainMessage<CanvasPreset> | undefined, b: CanvasPreset | PlainMessage<CanvasPreset> | undefined): boolean {
    return proto3.util.equals(CanvasPreset, a, b);
  }
}

/**
 * API defines a custom operation for querying data stored in Rill.
 *
 * @generated from message rill.runtime.v1.API
 */
export class API extends Message<API> {
  /**
   * @generated from field: rill.runtime.v1.APISpec spec = 1;
   */
  spec?: APISpec;

  /**
   * @generated from field: rill.runtime.v1.APIState state = 2;
   */
  state?: APIState;

  constructor(data?: PartialMessage<API>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "rill.runtime.v1.API";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "spec", kind: "message", T: APISpec },
    { no: 2, name: "state", kind: "message", T: APIState },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): API {
    return new API().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): API {
    return new API().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): API {
    return new API().fromJsonString(jsonString, options);
  }

  static equals(a: API | PlainMessage<API> | undefined, b: API | PlainMessage<API> | undefined): boolean {
    return proto3.util.equals(API, a, b);
  }
}

/**
 * @generated from message rill.runtime.v1.APISpec
 */
export class APISpec extends Message<APISpec> {
  /**
   * @generated from field: string resolver = 1;
   */
  resolver = "";

  /**
   * @generated from field: google.protobuf.Struct resolver_properties = 2;
   */
  resolverProperties?: Struct;

  /**
   * @generated from field: string openapi_summary = 3;
   */
  openapiSummary = "";

  /**
   * @generated from field: string openapi_parameters_json = 8;
   */
  openapiParametersJson = "";

  /**
   * @generated from field: string openapi_request_schema_json = 9;
   */
  openapiRequestSchemaJson = "";

  /**
   * @generated from field: string openapi_response_schema_json = 10;
   */
  openapiResponseSchemaJson = "";

  /**
   * @generated from field: string openapi_defs_prefix = 11;
   */
  openapiDefsPrefix = "";

  /**
   * @generated from field: repeated rill.runtime.v1.SecurityRule security_rules = 6;
   */
  securityRules: SecurityRule[] = [];

  /**
   * @generated from field: bool skip_nested_security = 7;
   */
  skipNestedSecurity = false;

  constructor(data?: PartialMessage<APISpec>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "rill.runtime.v1.APISpec";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "resolver", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "resolver_properties", kind: "message", T: Struct },
    { no: 3, name: "openapi_summary", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 8, name: "openapi_parameters_json", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 9, name: "openapi_request_schema_json", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 10, name: "openapi_response_schema_json", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 11, name: "openapi_defs_prefix", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 6, name: "security_rules", kind: "message", T: SecurityRule, repeated: true },
    { no: 7, name: "skip_nested_security", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): APISpec {
    return new APISpec().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): APISpec {
    return new APISpec().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): APISpec {
    return new APISpec().fromJsonString(jsonString, options);
  }

  static equals(a: APISpec | PlainMessage<APISpec> | undefined, b: APISpec | PlainMessage<APISpec> | undefined): boolean {
    return proto3.util.equals(APISpec, a, b);
  }
}

/**
 * @generated from message rill.runtime.v1.APIState
 */
export class APIState extends Message<APIState> {
  constructor(data?: PartialMessage<APIState>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "rill.runtime.v1.APIState";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): APIState {
    return new APIState().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): APIState {
    return new APIState().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): APIState {
    return new APIState().fromJsonString(jsonString, options);
  }

  static equals(a: APIState | PlainMessage<APIState> | undefined, b: APIState | PlainMessage<APIState> | undefined): boolean {
    return proto3.util.equals(APIState, a, b);
  }
}

/**
 * @generated from message rill.runtime.v1.Schedule
 */
export class Schedule extends Message<Schedule> {
  /**
   * @generated from field: bool ref_update = 4;
   */
  refUpdate = false;

  /**
   * @generated from field: bool disable = 5;
   */
  disable = false;

  /**
   * @generated from field: string cron = 1;
   */
  cron = "";

  /**
   * @generated from field: uint32 ticker_seconds = 2;
   */
  tickerSeconds = 0;

  /**
   * @generated from field: string time_zone = 3;
   */
  timeZone = "";

  constructor(data?: PartialMessage<Schedule>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "rill.runtime.v1.Schedule";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 4, name: "ref_update", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 5, name: "disable", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 1, name: "cron", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "ticker_seconds", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 3, name: "time_zone", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Schedule {
    return new Schedule().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Schedule {
    return new Schedule().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Schedule {
    return new Schedule().fromJsonString(jsonString, options);
  }

  static equals(a: Schedule | PlainMessage<Schedule> | undefined, b: Schedule | PlainMessage<Schedule> | undefined): boolean {
    return proto3.util.equals(Schedule, a, b);
  }
}

/**
 * @generated from message rill.runtime.v1.ParseError
 */
export class ParseError extends Message<ParseError> {
  /**
   * @generated from field: string message = 1;
   */
  message = "";

  /**
   * @generated from field: string file_path = 2;
   */
  filePath = "";

  /**
   * @generated from field: rill.runtime.v1.CharLocation start_location = 3;
   */
  startLocation?: CharLocation;

  /**
   * @generated from field: bool external = 4;
   */
  external = false;

  constructor(data?: PartialMessage<ParseError>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "rill.runtime.v1.ParseError";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "message", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "file_path", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "start_location", kind: "message", T: CharLocation },
    { no: 4, name: "external", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ParseError {
    return new ParseError().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ParseError {
    return new ParseError().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ParseError {
    return new ParseError().fromJsonString(jsonString, options);
  }

  static equals(a: ParseError | PlainMessage<ParseError> | undefined, b: ParseError | PlainMessage<ParseError> | undefined): boolean {
    return proto3.util.equals(ParseError, a, b);
  }
}

/**
 * @generated from message rill.runtime.v1.ValidationError
 */
export class ValidationError extends Message<ValidationError> {
  /**
   * @generated from field: string message = 1;
   */
  message = "";

  /**
   * @generated from field: repeated string property_path = 2;
   */
  propertyPath: string[] = [];

  constructor(data?: PartialMessage<ValidationError>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "rill.runtime.v1.ValidationError";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "message", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "property_path", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ValidationError {
    return new ValidationError().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ValidationError {
    return new ValidationError().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ValidationError {
    return new ValidationError().fromJsonString(jsonString, options);
  }

  static equals(a: ValidationError | PlainMessage<ValidationError> | undefined, b: ValidationError | PlainMessage<ValidationError> | undefined): boolean {
    return proto3.util.equals(ValidationError, a, b);
  }
}

/**
 * @generated from message rill.runtime.v1.DependencyError
 */
export class DependencyError extends Message<DependencyError> {
  /**
   * @generated from field: string message = 1;
   */
  message = "";

  /**
   * @generated from field: string dependency = 2;
   */
  dependency = "";

  constructor(data?: PartialMessage<DependencyError>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "rill.runtime.v1.DependencyError";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "message", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "dependency", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DependencyError {
    return new DependencyError().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DependencyError {
    return new DependencyError().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DependencyError {
    return new DependencyError().fromJsonString(jsonString, options);
  }

  static equals(a: DependencyError | PlainMessage<DependencyError> | undefined, b: DependencyError | PlainMessage<DependencyError> | undefined): boolean {
    return proto3.util.equals(DependencyError, a, b);
  }
}

/**
 * @generated from message rill.runtime.v1.ExecutionError
 */
export class ExecutionError extends Message<ExecutionError> {
  /**
   * @generated from field: string message = 1;
   */
  message = "";

  constructor(data?: PartialMessage<ExecutionError>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "rill.runtime.v1.ExecutionError";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "message", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ExecutionError {
    return new ExecutionError().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ExecutionError {
    return new ExecutionError().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ExecutionError {
    return new ExecutionError().fromJsonString(jsonString, options);
  }

  static equals(a: ExecutionError | PlainMessage<ExecutionError> | undefined, b: ExecutionError | PlainMessage<ExecutionError> | undefined): boolean {
    return proto3.util.equals(ExecutionError, a, b);
  }
}

/**
 * @generated from message rill.runtime.v1.CharLocation
 */
export class CharLocation extends Message<CharLocation> {
  /**
   * @generated from field: uint32 line = 1;
   */
  line = 0;

  constructor(data?: PartialMessage<CharLocation>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "rill.runtime.v1.CharLocation";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "line", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CharLocation {
    return new CharLocation().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CharLocation {
    return new CharLocation().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CharLocation {
    return new CharLocation().fromJsonString(jsonString, options);
  }

  static equals(a: CharLocation | PlainMessage<CharLocation> | undefined, b: CharLocation | PlainMessage<CharLocation> | undefined): boolean {
    return proto3.util.equals(CharLocation, a, b);
  }
}

/**
 * @generated from message rill.runtime.v1.ConnectorV2
 */
export class ConnectorV2 extends Message<ConnectorV2> {
  /**
   * @generated from field: rill.runtime.v1.ConnectorSpec spec = 1;
   */
  spec?: ConnectorSpec;

  /**
   * @generated from field: rill.runtime.v1.ConnectorState state = 2;
   */
  state?: ConnectorState;

  constructor(data?: PartialMessage<ConnectorV2>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "rill.runtime.v1.ConnectorV2";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "spec", kind: "message", T: ConnectorSpec },
    { no: 2, name: "state", kind: "message", T: ConnectorState },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ConnectorV2 {
    return new ConnectorV2().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ConnectorV2 {
    return new ConnectorV2().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ConnectorV2 {
    return new ConnectorV2().fromJsonString(jsonString, options);
  }

  static equals(a: ConnectorV2 | PlainMessage<ConnectorV2> | undefined, b: ConnectorV2 | PlainMessage<ConnectorV2> | undefined): boolean {
    return proto3.util.equals(ConnectorV2, a, b);
  }
}

/**
 * @generated from message rill.runtime.v1.ConnectorSpec
 */
export class ConnectorSpec extends Message<ConnectorSpec> {
  /**
   * @generated from field: string driver = 1;
   */
  driver = "";

  /**
   * @generated from field: google.protobuf.Struct properties = 7;
   */
  properties?: Struct;

  /**
   * @generated from field: repeated string templated_properties = 4;
   */
  templatedProperties: string[] = [];

  /**
   * @generated from field: bool provision = 5;
   */
  provision = false;

  /**
   * @generated from field: google.protobuf.Struct provision_args = 6;
   */
  provisionArgs?: Struct;

  constructor(data?: PartialMessage<ConnectorSpec>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "rill.runtime.v1.ConnectorSpec";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "driver", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 7, name: "properties", kind: "message", T: Struct },
    { no: 4, name: "templated_properties", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 5, name: "provision", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 6, name: "provision_args", kind: "message", T: Struct },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ConnectorSpec {
    return new ConnectorSpec().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ConnectorSpec {
    return new ConnectorSpec().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ConnectorSpec {
    return new ConnectorSpec().fromJsonString(jsonString, options);
  }

  static equals(a: ConnectorSpec | PlainMessage<ConnectorSpec> | undefined, b: ConnectorSpec | PlainMessage<ConnectorSpec> | undefined): boolean {
    return proto3.util.equals(ConnectorSpec, a, b);
  }
}

/**
 * @generated from message rill.runtime.v1.ConnectorState
 */
export class ConnectorState extends Message<ConnectorState> {
  /**
   * @generated from field: string spec_hash = 1;
   */
  specHash = "";

  constructor(data?: PartialMessage<ConnectorState>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "rill.runtime.v1.ConnectorState";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "spec_hash", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ConnectorState {
    return new ConnectorState().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ConnectorState {
    return new ConnectorState().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ConnectorState {
    return new ConnectorState().fromJsonString(jsonString, options);
  }

  static equals(a: ConnectorState | PlainMessage<ConnectorState> | undefined, b: ConnectorState | PlainMessage<ConnectorState> | undefined): boolean {
    return proto3.util.equals(ConnectorState, a, b);
  }
}


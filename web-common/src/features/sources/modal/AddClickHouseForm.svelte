<script lang="ts">
  import { Button } from "@rilldata/web-common/components/button";
  import InformationalField from "@rilldata/web-common/components/forms/InformationalField.svelte";
  import Input from "@rilldata/web-common/components/forms/Input.svelte";
  import { queryClient } from "@rilldata/web-common/lib/svelte-query/globalQueryClient";
  import {
    ConnectorDriverPropertyType,
    type V1ConnectorDriver,
  } from "@rilldata/web-common/runtime-client";
  import { createEventDispatcher } from "svelte";
  import {
    defaults,
    superForm,
    type SuperValidated,
  } from "sveltekit-superforms";
  import { yup } from "sveltekit-superforms/adapters";
  import { ButtonGroup, SubButton } from "../../../components/button-group";
  import { inferSourceName } from "../sourceUtils";
  import { humanReadableErrorMessage } from "../errors/errors";
  import {
    submitAddOLAPConnectorForm,
    submitAddSourceForm,
  } from "./submitAddDataForm";
  import type { AddDataFormType } from "./types";
  import { dsnSchema, getYupSchema } from "./yupSchemas";
  import Checkbox from "@rilldata/web-common/components/forms/Checkbox.svelte";

  const dispatch = createEventDispatcher();

  export let connector: V1ConnectorDriver;
  export let formType: AddDataFormType;
  export let onBack: () => void;
  export let onClose: () => void;
  export let setError: (
    error: string | null,
    details?: string,
  ) => void = () => {};

  // Always include 'managed' in the schema for ClickHouse
  const clickhouseSchema = yup(getYupSchema["clickhouse"]);
  const paramsFormId = `add-clickhouse-data-${connector.name}-form`;
  const {
    form: paramsForm,
    errors: paramsErrors,
    enhance: paramsEnhance,
    tainted: paramsTainted,
    submit: paramsSubmit,
    submitting: paramsSubmitting,
  } = superForm(defaults(clickhouseSchema), {
    SPA: true,
    validators: clickhouseSchema,
    onUpdate: handleOnUpdate,
    resetForm: false,
  });
  let paramsError: string | null = null;
  let paramsErrorDetails: string | undefined = undefined;

  // DSN form
  let useDsn = false;

  const dsnFormId = `add-clickhouse-data-${connector.name}-dsn-form`;
  const dsnProperties =
    connector.configProperties?.filter((property) => property.key === "dsn") ??
    [];
  const dsnYupSchema = yup(dsnSchema);
  const {
    form: dsnForm,
    errors: dsnErrors,
    enhance: dsnEnhance,
    tainted: dsnTainted,
    submit: dsnSubmit,
    submitting: dsnSubmitting,
  } = superForm(defaults(dsnYupSchema), {
    SPA: true,
    validators: dsnYupSchema,
    onUpdate: handleOnUpdate,
    resetForm: false,
  });
  let dsnError: string | null = null;
  let dsnErrorDetails: string | undefined = undefined;

  // Managed toggle
  $: submitting = useDsn ? $dsnSubmitting : $paramsSubmitting;
  $: formId = useDsn ? dsnFormId : paramsFormId;

  // Reset useDsn if switching to Rill-managed
  $: if ($paramsForm.managed) {
    useDsn = false;
  }

  // Reset errors when form is modified
  $: if (useDsn) {
    if ($dsnTainted) dsnError = null;
  } else {
    if ($paramsTainted) paramsError = null;
  }

  // Emit the submitting state to the parent
  $: dispatch("submitting", { submitting });

  function handleConnectionTypeChange(e: CustomEvent<any>): void {
    useDsn = e.detail === "dsn";
  }

  function onStringInputChange(event: Event) {
    const target = event.target as HTMLInputElement;
    const { name, value } = target;
    if (name === "path") {
      if ($paramsTainted?.name) return;
      const nameVal = inferSourceName(connector, value);
      if (nameVal)
        paramsForm.update(
          ($form) => {
            $form.name = nameVal;
            return $form;
          },
          { taint: false },
        );
    }
  }

  async function handleOnUpdate<
    T extends Record<string, unknown>,
    M = any,
    In extends Record<string, unknown> = T,
  >(event: {
    form: SuperValidated<T, M, In>;
    formEl: HTMLFormElement;
    cancel: () => void;
    result: Extract<
      import("@sveltejs/kit").ActionResult,
      { type: "success" | "failure" }
    >;
  }) {
    if (!event.form.valid) return;
    const values = event.form.data;
    try {
      if (formType === "source") {
        await submitAddSourceForm(queryClient, connector, values);
      } else {
        await submitAddOLAPConnectorForm(queryClient, connector, values);
      }
      onClose();
    } catch (e) {
      let error: string;
      let details: string | undefined = undefined;
      if (e instanceof Error) {
        error = e.message;
        details = undefined;
      } else if (e?.message && e?.details) {
        error = e.message;
        details = e.details !== e.message ? e.details : undefined;
      } else if (e?.response?.data) {
        const originalMessage = e.response.data.message;
        const humanReadable = humanReadableErrorMessage(
          connector.name,
          e.response.data.code,
          originalMessage,
        );
        error = humanReadable;
        details =
          humanReadable !== originalMessage ? originalMessage : undefined;
      } else {
        error = "Unknown error";
        details = undefined;
      }
      if (useDsn) {
        dsnError = error;
        dsnErrorDetails = details;
        setError(dsnError, dsnErrorDetails);
      } else {
        paramsError = error;
        paramsErrorDetails = details;
        setError(paramsError, paramsErrorDetails);
      }
    }
  }

  $: properties = $paramsForm.managed
    ? (connector.sourceProperties ?? [])
    : (connector.configProperties?.filter((p) =>
        !useDsn ? p.key !== "dsn" : true,
      ) ?? []);
  $: filteredProperties = properties.filter((property) => !property.noPrompt);

  function isEmpty(val: any) {
    return (
      val === undefined ||
      val === null ||
      val === "" ||
      (typeof val === "string" && val.trim() === "")
    );
  }

  // Compute disabled state for the submit button
  // Refer to `runtime/drivers/clickhouse/clickhouse.go` for the required
  // Account for the managed property and the dsn property can be either true or false
  $: isSubmitDisabled = (() => {
    if ($paramsForm.managed) {
      // Managed form: only check required properties where property.key === 'managed' or property.key is not 'managed'
      for (const property of filteredProperties) {
        if (
          property.required &&
          (property.key === "managed" || property.key !== "managed")
        ) {
          const key = String(property.key);
          const value = $paramsForm[key];
          if (isEmpty(value) || $paramsErrors[key]?.length) return true;
        }
      }
      return false;
    } else if (useDsn) {
      // Self-managed DSN form
      for (const property of dsnProperties) {
        if (property.required) {
          const key = String(property.key);
          const value = $dsnForm[key];
          if (isEmpty(value) || $dsnErrors[key]?.length) return true;
        }
      }
      return false;
    } else {
      // Self-managed parameters form: only check required properties where property.key !== 'managed'
      for (const property of filteredProperties) {
        if (property.required && property.key !== "managed") {
          const key = String(property.key);
          const value = $paramsForm[key];
          if (isEmpty(value) || $paramsErrors[key]?.length) return true;
        }
      }
      return false;
    }
  })();
</script>

<div class="h-full w-full flex flex-col">
  <!-- FIXME: ConnectorTypeSelector -->
  <div>
    <div class="text-sm font-medium mb-2">Connector type</div>
    <select id="managed" bind:value={$paramsForm.managed} class="form-select">
      <option value={true}>Rill-managed ClickHouse</option>
      <option value={false}>Self-managed ClickHouse</option>
    </select>
    {#if $paramsForm.managed}
      <InformationalField
        description="This option uses ClickHouse as an OLAP engine with Rill-managed infrastructure. No additional configuration is required - Rill will handle the setup and management of your ClickHouse instance."
      />
    {/if}
  </div>

  <!-- Connection method selector -->
  {#if !$paramsForm.managed}
    <div class="py-3">
      <div class="text-sm font-medium mb-2">Connection method</div>
      <!-- FIXME: use Tabs, not ButtonGroup -->
      <ButtonGroup
        selected={[useDsn ? "dsn" : "parameters"]}
        on:subbutton-click={handleConnectionTypeChange}
      >
        <SubButton value="parameters" ariaLabel="Enter parameters">
          <span class="px-2">Enter parameters</span>
        </SubButton>
        <SubButton value="dsn" ariaLabel="Use connection string">
          <span class="px-2">Enter connection string</span>
        </SubButton>
      </ButtonGroup>
    </div>
  {/if}

  <!-- Parameters form -->
  {#if !useDsn}
    <!-- Form 1: Individual parameters -->
    <form
      id={paramsFormId}
      class="pb-5 flex-grow overflow-y-auto"
      use:paramsEnhance
      on:submit|preventDefault={paramsSubmit}
    >
      {#each filteredProperties as property (property.key)}
        {@const propertyKey = property.key ?? ""}
        {@const label =
          property.displayName + (property.required ? "" : " (optional)")}
        <div class="py-1.5">
          {#if property.type === ConnectorDriverPropertyType.TYPE_STRING || property.type === ConnectorDriverPropertyType.TYPE_NUMBER}
            <Input
              id={propertyKey}
              label={property.displayName}
              placeholder={property.placeholder}
              optional={!property.required}
              secret={property.secret}
              hint={property.hint}
              errors={$paramsErrors[propertyKey]}
              bind:value={$paramsForm[propertyKey]}
              onInput={(_, e) => onStringInputChange(e)}
              alwaysShowError
            />
          {:else if property.type === ConnectorDriverPropertyType.TYPE_BOOLEAN}
            <Checkbox
              id={propertyKey}
              bind:checked={$paramsForm[propertyKey]}
              {label}
              hint={property.hint}
            />
          {:else if property.type === ConnectorDriverPropertyType.TYPE_INFORMATIONAL}
            <InformationalField
              description={property.description}
              hint={property.hint}
              href={property.docsUrl}
            />
          {/if}
        </div>
      {/each}
    </form>
  {:else}
    <!-- Connection string form -->
    <form
      id={dsnFormId}
      class="pb-5 flex-grow overflow-y-auto"
      use:dsnEnhance
      on:submit|preventDefault={dsnSubmit}
    >
      {#each dsnProperties as property (property.key)}
        {@const propertyKey = property.key ?? ""}
        <div class="py-1.5">
          <Input
            id={propertyKey}
            label={property.displayName}
            placeholder={property.placeholder}
            secret={property.secret}
            hint={property.hint}
            errors={$dsnErrors[propertyKey]}
            bind:value={$dsnForm[propertyKey]}
            alwaysShowError
          />
        </div>
      {/each}
    </form>
  {/if}

  <div class="flex items-center space-x-2 ml-auto">
    <Button onClick={onBack} type="secondary">Back</Button>

    <!-- FIXME: use Connect when managed is true -->
    <Button
      disabled={submitting || isSubmitDisabled}
      form={formId}
      submitForm
      type="primary"
    >
      {#if $paramsForm.managed}
        {#if submitting}
          Connecting...
        {:else}
          Connect
        {/if}
      {:else if submitting}
        Testing connection...
      {:else}
        Test and Connect
      {/if}
    </Button>
  </div>
</div>
